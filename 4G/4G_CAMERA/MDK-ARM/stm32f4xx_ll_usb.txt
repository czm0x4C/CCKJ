; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o4gcamera\stm32f4xx_ll_usb.o --asm_dir=.\ --list_dir=.\ --depend=4gcamera\stm32f4xx_ll_usb.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../USB_DEVICE/App -I../USB_DEVICE/Target -I../Core/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Middlewares/ST/STM32_USB_Device_Library/Core/Inc -I../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 -I../Middlewares/Third_Party/FreeRTOS/Source/portable/RVDS/ARM_CM4F -I../HARDWARE/OV2640 -I../HARDWARE/WS2812B -I../HARDWARE/RING_BUFFER -I../HARDWARE/FLASH -I.\RTE\_4GCAMERA -IC:\Users\czm\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\czm\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=536 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F407xx --omf_browse=4gcamera\stm32f4xx_ll_usb.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_usb.c]
                          THUMB

                          AREA ||i.USB_ActivateDedicatedEndpoint||, CODE, READONLY, ALIGN=2

                  USB_ActivateDedicatedEndpoint PROC
;;;634      */
;;;635    HAL_StatusTypeDef USB_ActivateDedicatedEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
000000  b570              PUSH     {r4-r6,lr}
;;;636    {
000002  4604              MOV      r4,r0
000004  460b              MOV      r3,r1
;;;637      uint32_t USBx_BASE = (uint32_t)USBx;
000006  4622              MOV      r2,r4
;;;638      uint32_t epnum = (uint32_t)ep->num;
000008  7819              LDRB     r1,[r3,#0]
;;;639    
;;;640      /* Read DEPCTLn register */
;;;641      if (ep->is_in == 1U)
00000a  7858              LDRB     r0,[r3,#1]
00000c  2801              CMP      r0,#1
00000e  d12c              BNE      |L1.106|
;;;642      {
;;;643        if (((USBx_INEP(epnum)->DIEPCTL) & USB_OTG_DIEPCTL_USBAEP) == 0U)
000010  f5026010          ADD      r0,r2,#0x900
000014  eb001041          ADD      r0,r0,r1,LSL #5
000018  6800              LDR      r0,[r0,#0]
00001a  f4004000          AND      r0,r0,#0x8000
00001e  b9b0              CBNZ     r0,|L1.78|
;;;644        {
;;;645          USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
000020  8998              LDRH     r0,[r3,#0xc]
000022  f3c0000a          UBFX     r0,r0,#0,#11
000026  791d              LDRB     r5,[r3,#4]
000028  ea404085          ORR      r0,r0,r5,LSL #18
00002c  ea405081          ORR      r0,r0,r1,LSL #22
000030  f0405080          ORR      r0,r0,#0x10000000
000034  f4404000          ORR      r0,r0,#0x8000
000038  f5026510          ADD      r5,r2,#0x900
00003c  eb051541          ADD      r5,r5,r1,LSL #5
000040  682d              LDR      r5,[r5,#0]
000042  4328              ORRS     r0,r0,r5
000044  f5026510          ADD      r5,r2,#0x900
000048  eb051541          ADD      r5,r5,r1,LSL #5
00004c  6028              STR      r0,[r5,#0]
                  |L1.78|
;;;646                                       ((uint32_t)ep->type << 18) | (epnum << 22) |
;;;647                                       USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
;;;648                                       USB_OTG_DIEPCTL_USBAEP;
;;;649        }
;;;650    
;;;651        USBx_DEVICE->DEACHMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
00004e  f640003c          MOV      r0,#0x83c
000052  5880              LDR      r0,[r0,r2]
000054  781d              LDRB     r5,[r3,#0]
000056  f005060f          AND      r6,r5,#0xf
00005a  2501              MOVS     r5,#1
00005c  40b5              LSLS     r5,r5,r6
00005e  b2ad              UXTH     r5,r5
000060  4328              ORRS     r0,r0,r5
000062  f640053c          MOV      r5,#0x83c
000066  50a8              STR      r0,[r5,r2]
000068  e02b              B        |L1.194|
                  |L1.106|
;;;652      }
;;;653      else
;;;654      {
;;;655        if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
00006a  f5026030          ADD      r0,r2,#0xb00
00006e  eb001041          ADD      r0,r0,r1,LSL #5
000072  6800              LDR      r0,[r0,#0]
000074  f4004000          AND      r0,r0,#0x8000
000078  b9a0              CBNZ     r0,|L1.164|
;;;656        {
;;;657          USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
00007a  8998              LDRH     r0,[r3,#0xc]
00007c  f3c0000a          UBFX     r0,r0,#0,#11
000080  791d              LDRB     r5,[r3,#4]
000082  ea404085          ORR      r0,r0,r5,LSL #18
000086  ea405081          ORR      r0,r0,r1,LSL #22
00008a  f4404000          ORR      r0,r0,#0x8000
00008e  f5026530          ADD      r5,r2,#0xb00
000092  eb051541          ADD      r5,r5,r1,LSL #5
000096  682d              LDR      r5,[r5,#0]
000098  4328              ORRS     r0,r0,r5
00009a  f5026530          ADD      r5,r2,#0xb00
00009e  eb051541          ADD      r5,r5,r1,LSL #5
0000a2  6028              STR      r0,[r5,#0]
                  |L1.164|
;;;658                                        ((uint32_t)ep->type << 18) | (epnum << 22) |
;;;659                                        USB_OTG_DOEPCTL_USBAEP;
;;;660        }
;;;661    
;;;662        USBx_DEVICE->DEACHMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16);
0000a4  f640003c          MOV      r0,#0x83c
0000a8  5880              LDR      r0,[r0,r2]
0000aa  781d              LDRB     r5,[r3,#0]
0000ac  f005060f          AND      r6,r5,#0xf
0000b0  2501              MOVS     r5,#1
0000b2  40b5              LSLS     r5,r5,r6
0000b4  4e04              LDR      r6,|L1.200|
0000b6  ea064505          AND      r5,r6,r5,LSL #16
0000ba  4328              ORRS     r0,r0,r5
0000bc  f640053c          MOV      r5,#0x83c
0000c0  50a8              STR      r0,[r5,r2]
                  |L1.194|
;;;663      }
;;;664    
;;;665      return HAL_OK;
0000c2  2000              MOVS     r0,#0
;;;666    }
0000c4  bd70              POP      {r4-r6,pc}
;;;667    
                          ENDP

0000c6  0000              DCW      0x0000
                  |L1.200|
                          DCD      0xffff0000

                          AREA ||i.USB_ActivateEndpoint||, CODE, READONLY, ALIGN=2

                  USB_ActivateEndpoint PROC
;;;596      */
;;;597    HAL_StatusTypeDef USB_ActivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
000000  b570              PUSH     {r4-r6,lr}
;;;598    {
000002  4604              MOV      r4,r0
000004  460b              MOV      r3,r1
;;;599      uint32_t USBx_BASE = (uint32_t)USBx;
000006  4622              MOV      r2,r4
;;;600      uint32_t epnum = (uint32_t)ep->num;
000008  7819              LDRB     r1,[r3,#0]
;;;601    
;;;602      if (ep->is_in == 1U)
00000a  7858              LDRB     r0,[r3,#1]
00000c  2801              CMP      r0,#1
00000e  d12c              BNE      |L2.106|
;;;603      {
;;;604        USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
000010  f640001c          MOV      r0,#0x81c
000014  5880              LDR      r0,[r0,r2]
000016  781d              LDRB     r5,[r3,#0]
000018  f005060f          AND      r6,r5,#0xf
00001c  2501              MOVS     r5,#1
00001e  40b5              LSLS     r5,r5,r6
000020  b2ad              UXTH     r5,r5
000022  4328              ORRS     r0,r0,r5
000024  f640051c          MOV      r5,#0x81c
000028  50a8              STR      r0,[r5,r2]
;;;605    
;;;606        if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
00002a  f5026010          ADD      r0,r2,#0x900
00002e  eb001041          ADD      r0,r0,r1,LSL #5
000032  6800              LDR      r0,[r0,#0]
000034  f4004000          AND      r0,r0,#0x8000
000038  bbf0              CBNZ     r0,|L2.184|
;;;607        {
;;;608          USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
00003a  8998              LDRH     r0,[r3,#0xc]
00003c  f3c0000a          UBFX     r0,r0,#0,#11
000040  791d              LDRB     r5,[r3,#4]
000042  ea404085          ORR      r0,r0,r5,LSL #18
000046  ea405081          ORR      r0,r0,r1,LSL #22
00004a  f0405080          ORR      r0,r0,#0x10000000
00004e  f4404000          ORR      r0,r0,#0x8000
000052  f5026510          ADD      r5,r2,#0x900
000056  eb051541          ADD      r5,r5,r1,LSL #5
00005a  682d              LDR      r5,[r5,#0]
00005c  4328              ORRS     r0,r0,r5
00005e  f5026510          ADD      r5,r2,#0x900
000062  eb051541          ADD      r5,r5,r1,LSL #5
000066  6028              STR      r0,[r5,#0]
000068  e02d              B        |L2.198|
                  |L2.106|
;;;609                                       ((uint32_t)ep->type << 18) | (epnum << 22) |
;;;610                                       USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
;;;611                                       USB_OTG_DIEPCTL_USBAEP;
;;;612        }
;;;613      }
;;;614      else
;;;615      {
;;;616        USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16);
00006a  f640001c          MOV      r0,#0x81c
00006e  5880              LDR      r0,[r0,r2]
000070  781d              LDRB     r5,[r3,#0]
000072  f005060f          AND      r6,r5,#0xf
000076  2501              MOVS     r5,#1
000078  40b5              LSLS     r5,r5,r6
00007a  4e14              LDR      r6,|L2.204|
00007c  ea064505          AND      r5,r6,r5,LSL #16
000080  4328              ORRS     r0,r0,r5
000082  f640051c          MOV      r5,#0x81c
000086  50a8              STR      r0,[r5,r2]
;;;617    
;;;618        if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
000088  f5026030          ADD      r0,r2,#0xb00
00008c  eb001041          ADD      r0,r0,r1,LSL #5
000090  6800              LDR      r0,[r0,#0]
000092  f4004000          AND      r0,r0,#0x8000
000096  b978              CBNZ     r0,|L2.184|
;;;619        {
;;;620          USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
000098  8998              LDRH     r0,[r3,#0xc]
00009a  f3c0000a          UBFX     r0,r0,#0,#11
00009e  791d              LDRB     r5,[r3,#4]
0000a0  ea404085          ORR      r0,r0,r5,LSL #18
0000a4  f0405080          ORR      r0,r0,#0x10000000
0000a8  f4404000          ORR      r0,r0,#0x8000
0000ac  f5026530          ADD      r5,r2,#0xb00
0000b0  eb051541          ADD      r5,r5,r1,LSL #5
0000b4  682d              LDR      r5,[r5,#0]
0000b6  e000              B        |L2.186|
                  |L2.184|
0000b8  e005              B        |L2.198|
                  |L2.186|
0000ba  4328              ORRS     r0,r0,r5
0000bc  f5026530          ADD      r5,r2,#0xb00
0000c0  eb051541          ADD      r5,r5,r1,LSL #5
0000c4  6028              STR      r0,[r5,#0]
                  |L2.198|
;;;621                                        ((uint32_t)ep->type << 18) |
;;;622                                        USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
;;;623                                        USB_OTG_DOEPCTL_USBAEP;
;;;624        }
;;;625      }
;;;626      return HAL_OK;
0000c6  2000              MOVS     r0,#0
;;;627    }
0000c8  bd70              POP      {r4-r6,pc}
;;;628    
                          ENDP

0000ca  0000              DCW      0x0000
                  |L2.204|
                          DCD      0xffff0000

                          AREA ||i.USB_ActivateRemoteWakeup||, CODE, READONLY, ALIGN=1

                  USB_ActivateRemoteWakeup PROC
;;;2181     */
;;;2182   HAL_StatusTypeDef USB_ActivateRemoteWakeup(USB_OTG_GlobalTypeDef *USBx)
000000  4601              MOV      r1,r0
;;;2183   {
;;;2184     uint32_t USBx_BASE = (uint32_t)USBx;
000002  460a              MOV      r2,r1
;;;2185   
;;;2186     if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
000004  f6400008          MOV      r0,#0x808
000008  5880              LDR      r0,[r0,r2]
00000a  f0000001          AND      r0,r0,#1
00000e  b138              CBZ      r0,|L3.32|
;;;2187     {
;;;2188       /* active Remote wakeup signalling */
;;;2189       USBx_DEVICE->DCTL |= USB_OTG_DCTL_RWUSIG;
000010  f6400004          MOV      r0,#0x804
000014  5880              LDR      r0,[r0,r2]
000016  f0400301          ORR      r3,r0,#1
00001a  f6400004          MOV      r0,#0x804
00001e  5083              STR      r3,[r0,r2]
                  |L3.32|
;;;2190     }
;;;2191   
;;;2192     return HAL_OK;
000020  2000              MOVS     r0,#0
;;;2193   }
000022  4770              BX       lr
;;;2194   
                          ENDP


                          AREA ||i.USB_ActivateSetup||, CODE, READONLY, ALIGN=1

                  USB_ActivateSetup PROC
;;;1403     */
;;;1404   HAL_StatusTypeDef  USB_ActivateSetup(USB_OTG_GlobalTypeDef *USBx)
000000  4601              MOV      r1,r0
;;;1405   {
;;;1406     uint32_t USBx_BASE = (uint32_t)USBx;
000002  460a              MOV      r2,r1
;;;1407   
;;;1408     /* Set the MPS of the IN EP0 to 64 bytes */
;;;1409     USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
000004  f44f6010          MOV      r0,#0x900
000008  5880              LDR      r0,[r0,r2]
00000a  0ac3              LSRS     r3,r0,#11
00000c  02db              LSLS     r3,r3,#11
00000e  f44f6010          MOV      r0,#0x900
000012  5083              STR      r3,[r0,r2]
;;;1410   
;;;1411     USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
000014  f6400004          MOV      r0,#0x804
000018  5880              LDR      r0,[r0,r2]
00001a  f4407380          ORR      r3,r0,#0x100
00001e  f6400004          MOV      r0,#0x804
000022  5083              STR      r3,[r0,r2]
;;;1412   
;;;1413     return HAL_OK;
000024  2000              MOVS     r0,#0
;;;1414   }
000026  4770              BX       lr
;;;1415   
                          ENDP


                          AREA ||i.USB_ClearInterrupts||, CODE, READONLY, ALIGN=1

                  USB_ClearInterrupts PROC
;;;1380     */
;;;1381   void  USB_ClearInterrupts(USB_OTG_GlobalTypeDef *USBx, uint32_t interrupt)
000000  6942              LDR      r2,[r0,#0x14]
;;;1382   {
;;;1383     USBx->GINTSTS |= interrupt;
000002  430a              ORRS     r2,r2,r1
000004  6142              STR      r2,[r0,#0x14]
;;;1384   }
000006  4770              BX       lr
;;;1385   
                          ENDP


                          AREA ||i.USB_CoreInit||, CODE, READONLY, ALIGN=2

                  USB_CoreInit PROC
;;;82       */
;;;83     HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
000000  b40f              PUSH     {r0-r3}
;;;84     {
000002  b570              PUSH     {r4-r6,lr}
000004  4604              MOV      r4,r0
;;;85       HAL_StatusTypeDef ret;
;;;86       if (cfg.phy_itface == USB_OTG_ULPI_PHY)
000006  980a              LDR      r0,[sp,#0x28]
000008  2801              CMP      r0,#1
00000a  d117              BNE      |L6.60|
;;;87       {
;;;88         USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
00000c  6ba0              LDR      r0,[r4,#0x38]
00000e  f4203080          BIC      r0,r0,#0x10000
000012  63a0              STR      r0,[r4,#0x38]
;;;89     
;;;90         /* Init The ULPI Interface */
;;;91         USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
000014  68e0              LDR      r0,[r4,#0xc]
000016  491a              LDR      r1,|L6.128|
000018  4008              ANDS     r0,r0,r1
00001a  60e0              STR      r0,[r4,#0xc]
;;;92     
;;;93         /* Select vbus source */
;;;94         USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
00001c  68e0              LDR      r0,[r4,#0xc]
00001e  f4201040          BIC      r0,r0,#0x300000
000022  60e0              STR      r0,[r4,#0xc]
;;;95         if (cfg.use_external_vbus == 1U)
000024  9811              LDR      r0,[sp,#0x44]
000026  2801              CMP      r0,#1
000028  d103              BNE      |L6.50|
;;;96         {
;;;97           USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
00002a  68e0              LDR      r0,[r4,#0xc]
00002c  f4401080          ORR      r0,r0,#0x100000
000030  60e0              STR      r0,[r4,#0xc]
                  |L6.50|
;;;98         }
;;;99     
;;;100        /* Reset after a PHY select */
;;;101        ret = USB_CoreReset(USBx);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       USB_CoreReset
000038  4605              MOV      r5,r0
00003a  e012              B        |L6.98|
                  |L6.60|
;;;102      }
;;;103      else /* FS interface (embedded Phy) */
;;;104      {
;;;105        /* Select FS Embedded PHY */
;;;106        USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
00003c  68e0              LDR      r0,[r4,#0xc]
00003e  f0400040          ORR      r0,r0,#0x40
000042  60e0              STR      r0,[r4,#0xc]
;;;107    
;;;108        /* Reset after a PHY select */
;;;109        ret = USB_CoreReset(USBx);
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       USB_CoreReset
00004a  4605              MOV      r5,r0
;;;110    
;;;111        if (cfg.battery_charging_enable == 0U)
00004c  980e              LDR      r0,[sp,#0x38]
00004e  b920              CBNZ     r0,|L6.90|
;;;112        {
;;;113          /* Activate the USB Transceiver */
;;;114          USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
000050  6ba0              LDR      r0,[r4,#0x38]
000052  f4403080          ORR      r0,r0,#0x10000
000056  63a0              STR      r0,[r4,#0x38]
000058  e003              B        |L6.98|
                  |L6.90|
;;;115        }
;;;116        else
;;;117        {
;;;118          /* Deactivate the USB Transceiver */
;;;119          USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
00005a  6ba0              LDR      r0,[r4,#0x38]
00005c  f4203080          BIC      r0,r0,#0x10000
000060  63a0              STR      r0,[r4,#0x38]
                  |L6.98|
;;;120        }
;;;121      }
;;;122    
;;;123      if (cfg.dma_enable == 1U)
000062  9808              LDR      r0,[sp,#0x20]
000064  2801              CMP      r0,#1
000066  d107              BNE      |L6.120|
;;;124      {
;;;125        USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
000068  68a0              LDR      r0,[r4,#8]
00006a  f0400006          ORR      r0,r0,#6
00006e  60a0              STR      r0,[r4,#8]
;;;126        USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
000070  68a0              LDR      r0,[r4,#8]
000072  f0400020          ORR      r0,r0,#0x20
000076  60a0              STR      r0,[r4,#8]
                  |L6.120|
;;;127      }
;;;128    
;;;129      return ret;
000078  4628              MOV      r0,r5
;;;130    }
00007a  bc70              POP      {r4-r6}
00007c  f85dfb14          LDR      pc,[sp],#0x14
;;;131    
                          ENDP

                  |L6.128|
                          DCD      0xffbdffbf

                          AREA ||i.USB_CoreReset||, CODE, READONLY, ALIGN=2

                  USB_CoreReset PROC
;;;1458     */
;;;1459   static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
000000  b508              PUSH     {r3,lr}
;;;1460   {
000002  4601              MOV      r1,r0
;;;1461     __IO uint32_t count = 0U;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;1462   
;;;1463     /* Wait for AHB master IDLE state. */
;;;1464     do
000008  bf00              NOP      
                  |L7.10|
;;;1465     {
;;;1466       count++;
00000a  9800              LDR      r0,[sp,#0]
00000c  1c40              ADDS     r0,r0,#1
00000e  9000              STR      r0,[sp,#0]
;;;1467   
;;;1468       if (count > 200000U)
000010  4a10              LDR      r2,|L7.84|
000012  9800              LDR      r0,[sp,#0]
000014  4290              CMP      r0,r2
000016  d901              BLS      |L7.28|
;;;1469       {
;;;1470         return HAL_TIMEOUT;
000018  2003              MOVS     r0,#3
                  |L7.26|
;;;1471       }
;;;1472     } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
;;;1473   
;;;1474     /* Core Soft Reset */
;;;1475     count = 0U;
;;;1476     USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
;;;1477   
;;;1478     do
;;;1479     {
;;;1480       count++;
;;;1481   
;;;1482       if (count > 200000U)
;;;1483       {
;;;1484         return HAL_TIMEOUT;
;;;1485       }
;;;1486     } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
;;;1487   
;;;1488     return HAL_OK;
;;;1489   }
00001a  bd08              POP      {r3,pc}
                  |L7.28|
00001c  6908              LDR      r0,[r1,#0x10]         ;1472
00001e  f0004000          AND      r0,r0,#0x80000000     ;1472
000022  2800              CMP      r0,#0                 ;1472
000024  d0f1              BEQ      |L7.10|
000026  2000              MOVS     r0,#0                 ;1475
000028  9000              STR      r0,[sp,#0]            ;1475
00002a  6908              LDR      r0,[r1,#0x10]         ;1476
00002c  f0400001          ORR      r0,r0,#1              ;1476
000030  6108              STR      r0,[r1,#0x10]         ;1476
000032  bf00              NOP                            ;1478
                  |L7.52|
000034  9800              LDR      r0,[sp,#0]            ;1480
000036  1c40              ADDS     r0,r0,#1              ;1480
000038  9000              STR      r0,[sp,#0]            ;1480
00003a  4a06              LDR      r2,|L7.84|
00003c  9800              LDR      r0,[sp,#0]            ;1482
00003e  4290              CMP      r0,r2                 ;1482
000040  d901              BLS      |L7.70|
000042  2003              MOVS     r0,#3                 ;1484
000044  e7e9              B        |L7.26|
                  |L7.70|
000046  6908              LDR      r0,[r1,#0x10]         ;1486
000048  f0000001          AND      r0,r0,#1              ;1486
00004c  2800              CMP      r0,#0                 ;1486
00004e  d1f1              BNE      |L7.52|
000050  bf00              NOP                            ;1488
000052  e7e2              B        |L7.26|
;;;1490   
                          ENDP

                  |L7.84|
                          DCD      0x00030d40

                          AREA ||i.USB_DeActivateRemoteWakeup||, CODE, READONLY, ALIGN=1

                  USB_DeActivateRemoteWakeup PROC
;;;2199     */
;;;2200   HAL_StatusTypeDef USB_DeActivateRemoteWakeup(USB_OTG_GlobalTypeDef *USBx)
000000  4601              MOV      r1,r0
;;;2201   {
;;;2202     uint32_t USBx_BASE = (uint32_t)USBx;
000002  460a              MOV      r2,r1
;;;2203   
;;;2204     /* active Remote wakeup signalling */
;;;2205     USBx_DEVICE->DCTL &= ~(USB_OTG_DCTL_RWUSIG);
000004  f6400004          MOV      r0,#0x804
000008  5880              LDR      r0,[r0,r2]
00000a  f0200301          BIC      r3,r0,#1
00000e  f6400004          MOV      r0,#0x804
000012  5083              STR      r3,[r0,r2]
;;;2206   
;;;2207     return HAL_OK;
000014  2000              MOVS     r0,#0
;;;2208   }
000016  4770              BX       lr
;;;2209   #endif /* defined (USB_OTG_FS) || defined (USB_OTG_HS) */
                          ENDP


                          AREA ||i.USB_DeactivateDedicatedEndpoint||, CODE, READONLY, ALIGN=2

                  USB_DeactivateDedicatedEndpoint PROC
;;;720      */
;;;721    HAL_StatusTypeDef USB_DeactivateDedicatedEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
000000  b570              PUSH     {r4-r6,lr}
;;;722    {
000002  4604              MOV      r4,r0
000004  460b              MOV      r3,r1
;;;723      uint32_t USBx_BASE = (uint32_t)USBx;
000006  4622              MOV      r2,r4
;;;724      uint32_t epnum = (uint32_t)ep->num;
000008  7819              LDRB     r1,[r3,#0]
;;;725    
;;;726      /* Read DEPCTLn register */
;;;727      if (ep->is_in == 1U)
00000a  7858              LDRB     r0,[r3,#1]
00000c  2801              CMP      r0,#1
00000e  d13b              BNE      |L9.136|
;;;728      {
;;;729        if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
000010  f5026010          ADD      r0,r2,#0x900
000014  eb001041          ADD      r0,r0,r1,LSL #5
000018  6800              LDR      r0,[r0,#0]
00001a  f0004000          AND      r0,r0,#0x80000000
00001e  f1b04f00          CMP      r0,#0x80000000
000022  d117              BNE      |L9.84|
;;;730        {
;;;731          USBx_INEP(epnum)->DIEPCTL  |= USB_OTG_DIEPCTL_SNAK;
000024  f5026010          ADD      r0,r2,#0x900
000028  eb001041          ADD      r0,r0,r1,LSL #5
00002c  6800              LDR      r0,[r0,#0]
00002e  f0406500          ORR      r5,r0,#0x8000000
000032  f5026010          ADD      r0,r2,#0x900
000036  eb001041          ADD      r0,r0,r1,LSL #5
00003a  6005              STR      r5,[r0,#0]
;;;732          USBx_INEP(epnum)->DIEPCTL  |= USB_OTG_DIEPCTL_EPDIS;
00003c  f5026010          ADD      r0,r2,#0x900
000040  eb001041          ADD      r0,r0,r1,LSL #5
000044  6800              LDR      r0,[r0,#0]
000046  f0404580          ORR      r5,r0,#0x40000000
00004a  f5026010          ADD      r0,r2,#0x900
00004e  eb001041          ADD      r0,r0,r1,LSL #5
000052  6005              STR      r5,[r0,#0]
                  |L9.84|
;;;733        }
;;;734    
;;;735        USBx_INEP(epnum)->DIEPCTL &= ~ USB_OTG_DIEPCTL_USBAEP;
000054  f5026010          ADD      r0,r2,#0x900
000058  eb001041          ADD      r0,r0,r1,LSL #5
00005c  6800              LDR      r0,[r0,#0]
00005e  f4204500          BIC      r5,r0,#0x8000
000062  f5026010          ADD      r0,r2,#0x900
000066  eb001041          ADD      r0,r0,r1,LSL #5
00006a  6005              STR      r5,[r0,#0]
;;;736        USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
00006c  f640001c          MOV      r0,#0x81c
000070  5880              LDR      r0,[r0,r2]
000072  781d              LDRB     r5,[r3,#0]
000074  f005060f          AND      r6,r5,#0xf
000078  2501              MOVS     r5,#1
00007a  40b5              LSLS     r5,r5,r6
00007c  b2ad              UXTH     r5,r5
00007e  43a8              BICS     r0,r0,r5
000080  f640051c          MOV      r5,#0x81c
000084  50a8              STR      r0,[r5,r2]
000086  e03c              B        |L9.258|
                  |L9.136|
;;;737      }
;;;738      else
;;;739      {
;;;740        if ((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
000088  f5026030          ADD      r0,r2,#0xb00
00008c  eb001041          ADD      r0,r0,r1,LSL #5
000090  6800              LDR      r0,[r0,#0]
000092  f0004000          AND      r0,r0,#0x80000000
000096  f1b04f00          CMP      r0,#0x80000000
00009a  d117              BNE      |L9.204|
;;;741        {
;;;742          USBx_OUTEP(epnum)->DOEPCTL  |= USB_OTG_DOEPCTL_SNAK;
00009c  f5026030          ADD      r0,r2,#0xb00
0000a0  eb001041          ADD      r0,r0,r1,LSL #5
0000a4  6800              LDR      r0,[r0,#0]
0000a6  f0406500          ORR      r5,r0,#0x8000000
0000aa  f5026030          ADD      r0,r2,#0xb00
0000ae  eb001041          ADD      r0,r0,r1,LSL #5
0000b2  6005              STR      r5,[r0,#0]
;;;743          USBx_OUTEP(epnum)->DOEPCTL  |= USB_OTG_DOEPCTL_EPDIS;
0000b4  f5026030          ADD      r0,r2,#0xb00
0000b8  eb001041          ADD      r0,r0,r1,LSL #5
0000bc  6800              LDR      r0,[r0,#0]
0000be  f0404580          ORR      r5,r0,#0x40000000
0000c2  f5026030          ADD      r0,r2,#0xb00
0000c6  eb001041          ADD      r0,r0,r1,LSL #5
0000ca  6005              STR      r5,[r0,#0]
                  |L9.204|
;;;744        }
;;;745    
;;;746        USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_USBAEP;
0000cc  f5026030          ADD      r0,r2,#0xb00
0000d0  eb001041          ADD      r0,r0,r1,LSL #5
0000d4  6800              LDR      r0,[r0,#0]
0000d6  f4204500          BIC      r5,r0,#0x8000
0000da  f5026030          ADD      r0,r2,#0xb00
0000de  eb001041          ADD      r0,r0,r1,LSL #5
0000e2  6005              STR      r5,[r0,#0]
;;;747        USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
0000e4  f640001c          MOV      r0,#0x81c
0000e8  5885              LDR      r5,[r0,r2]
0000ea  7818              LDRB     r0,[r3,#0]
0000ec  f000060f          AND      r6,r0,#0xf
0000f0  2001              MOVS     r0,#1
0000f2  40b0              LSLS     r0,r0,r6
0000f4  4e04              LDR      r6,|L9.264|
0000f6  ea064000          AND      r0,r6,r0,LSL #16
0000fa  4385              BICS     r5,r5,r0
0000fc  f640001c          MOV      r0,#0x81c
000100  5085              STR      r5,[r0,r2]
                  |L9.258|
;;;748      }
;;;749    
;;;750      return HAL_OK;
000102  2000              MOVS     r0,#0
;;;751    }
000104  bd70              POP      {r4-r6,pc}
;;;752    
                          ENDP

000106  0000              DCW      0x0000
                  |L9.264|
                          DCD      0xffff0000

                          AREA ||i.USB_DeactivateEndpoint||, CODE, READONLY, ALIGN=2

                  USB_DeactivateEndpoint PROC
;;;673      */
;;;674    HAL_StatusTypeDef USB_DeactivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
000000  b570              PUSH     {r4-r6,lr}
;;;675    {
000002  4604              MOV      r4,r0
000004  460b              MOV      r3,r1
;;;676      uint32_t USBx_BASE = (uint32_t)USBx;
000006  4622              MOV      r2,r4
;;;677      uint32_t epnum = (uint32_t)ep->num;
000008  7819              LDRB     r1,[r3,#0]
;;;678    
;;;679      /* Read DEPCTLn register */
;;;680      if (ep->is_in == 1U)
00000a  7858              LDRB     r0,[r3,#1]
00000c  2801              CMP      r0,#1
00000e  d148              BNE      |L10.162|
;;;681      {
;;;682        if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
000010  f5026010          ADD      r0,r2,#0x900
000014  eb001041          ADD      r0,r0,r1,LSL #5
000018  6800              LDR      r0,[r0,#0]
00001a  f0004000          AND      r0,r0,#0x80000000
00001e  f1b04f00          CMP      r0,#0x80000000
000022  d117              BNE      |L10.84|
;;;683        {
;;;684          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SNAK;
000024  f5026010          ADD      r0,r2,#0x900
000028  eb001041          ADD      r0,r0,r1,LSL #5
00002c  6800              LDR      r0,[r0,#0]
00002e  f0406500          ORR      r5,r0,#0x8000000
000032  f5026010          ADD      r0,r2,#0x900
000036  eb001041          ADD      r0,r0,r1,LSL #5
00003a  6005              STR      r5,[r0,#0]
;;;685          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_EPDIS;
00003c  f5026010          ADD      r0,r2,#0x900
000040  eb001041          ADD      r0,r0,r1,LSL #5
000044  6800              LDR      r0,[r0,#0]
000046  f0404580          ORR      r5,r0,#0x40000000
00004a  f5026010          ADD      r0,r2,#0x900
00004e  eb001041          ADD      r0,r0,r1,LSL #5
000052  6005              STR      r5,[r0,#0]
                  |L10.84|
;;;686        }
;;;687    
;;;688        USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
000054  f640003c          MOV      r0,#0x83c
000058  5880              LDR      r0,[r0,r2]
00005a  781d              LDRB     r5,[r3,#0]
00005c  f005060f          AND      r6,r5,#0xf
000060  2501              MOVS     r5,#1
000062  40b5              LSLS     r5,r5,r6
000064  b2ad              UXTH     r5,r5
000066  43a8              BICS     r0,r0,r5
000068  f640053c          MOV      r5,#0x83c
00006c  50a8              STR      r0,[r5,r2]
;;;689        USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
00006e  f640001c          MOV      r0,#0x81c
000072  5880              LDR      r0,[r0,r2]
000074  781d              LDRB     r5,[r3,#0]
000076  f005060f          AND      r6,r5,#0xf
00007a  2501              MOVS     r5,#1
00007c  40b5              LSLS     r5,r5,r6
00007e  b2ad              UXTH     r5,r5
000080  43a8              BICS     r0,r0,r5
000082  f640051c          MOV      r5,#0x81c
000086  50a8              STR      r0,[r5,r2]
;;;690        USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |
000088  f5026010          ADD      r0,r2,#0x900
00008c  eb001041          ADD      r0,r0,r1,LSL #5
000090  6800              LDR      r0,[r0,#0]
000092  4d2b              LDR      r5,|L10.320|
000094  4028              ANDS     r0,r0,r5
000096  f5026510          ADD      r5,r2,#0x900
00009a  eb051541          ADD      r5,r5,r1,LSL #5
00009e  6028              STR      r0,[r5,#0]
0000a0  e04b              B        |L10.314|
                  |L10.162|
;;;691                                       USB_OTG_DIEPCTL_MPSIZ |
;;;692                                       USB_OTG_DIEPCTL_TXFNUM |
;;;693                                       USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
;;;694                                       USB_OTG_DIEPCTL_EPTYP);
;;;695      }
;;;696      else
;;;697      {
;;;698        if ((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
0000a2  f5026030          ADD      r0,r2,#0xb00
0000a6  eb001041          ADD      r0,r0,r1,LSL #5
0000aa  6800              LDR      r0,[r0,#0]
0000ac  f0004000          AND      r0,r0,#0x80000000
0000b0  f1b04f00          CMP      r0,#0x80000000
0000b4  d117              BNE      |L10.230|
;;;699        {
;;;700          USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
0000b6  f5026030          ADD      r0,r2,#0xb00
0000ba  eb001041          ADD      r0,r0,r1,LSL #5
0000be  6800              LDR      r0,[r0,#0]
0000c0  f0406500          ORR      r5,r0,#0x8000000
0000c4  f5026030          ADD      r0,r2,#0xb00
0000c8  eb001041          ADD      r0,r0,r1,LSL #5
0000cc  6005              STR      r5,[r0,#0]
;;;701          USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_EPDIS;
0000ce  f5026030          ADD      r0,r2,#0xb00
0000d2  eb001041          ADD      r0,r0,r1,LSL #5
0000d6  6800              LDR      r0,[r0,#0]
0000d8  f0404580          ORR      r5,r0,#0x40000000
0000dc  f5026030          ADD      r0,r2,#0xb00
0000e0  eb001041          ADD      r0,r0,r1,LSL #5
0000e4  6005              STR      r5,[r0,#0]
                  |L10.230|
;;;702        }
;;;703    
;;;704        USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
0000e6  f640003c          MOV      r0,#0x83c
0000ea  5880              LDR      r0,[r0,r2]
0000ec  781d              LDRB     r5,[r3,#0]
0000ee  f005060f          AND      r6,r5,#0xf
0000f2  2501              MOVS     r5,#1
0000f4  40b5              LSLS     r5,r5,r6
0000f6  4e13              LDR      r6,|L10.324|
0000f8  ea064505          AND      r5,r6,r5,LSL #16
0000fc  43a8              BICS     r0,r0,r5
0000fe  f640053c          MOV      r5,#0x83c
000102  50a8              STR      r0,[r5,r2]
;;;705        USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
000104  f640001c          MOV      r0,#0x81c
000108  5885              LDR      r5,[r0,r2]
00010a  7818              LDRB     r0,[r3,#0]
00010c  f000060f          AND      r6,r0,#0xf
000110  2001              MOVS     r0,#1
000112  40b0              LSLS     r0,r0,r6
000114  4e0b              LDR      r6,|L10.324|
000116  ea064000          AND      r0,r6,r0,LSL #16
00011a  4385              BICS     r5,r5,r0
00011c  f640001c          MOV      r0,#0x81c
000120  5085              STR      r5,[r0,r2]
;;;706        USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |
000122  f5026030          ADD      r0,r2,#0xb00
000126  eb001041          ADD      r0,r0,r1,LSL #5
00012a  6800              LDR      r0,[r0,#0]
00012c  4d06              LDR      r5,|L10.328|
00012e  4028              ANDS     r0,r0,r5
000130  f5026530          ADD      r5,r2,#0xb00
000134  eb051541          ADD      r5,r5,r1,LSL #5
000138  6028              STR      r0,[r5,#0]
                  |L10.314|
;;;707                                        USB_OTG_DOEPCTL_MPSIZ |
;;;708                                        USB_OTG_DOEPCTL_SD0PID_SEVNFRM |
;;;709                                        USB_OTG_DOEPCTL_EPTYP);
;;;710      }
;;;711    
;;;712      return HAL_OK;
00013a  2000              MOVS     r0,#0
;;;713    }
00013c  bd70              POP      {r4-r6,pc}
;;;714    
                          ENDP

00013e  0000              DCW      0x0000
                  |L10.320|
                          DCD      0xec337800
                  |L10.324|
                          DCD      0xffff0000
                  |L10.328|
                          DCD      0xeff37800

                          AREA ||i.USB_DevConnect||, CODE, READONLY, ALIGN=1

                  USB_DevConnect PROC
;;;1258     */
;;;1259   HAL_StatusTypeDef  USB_DevConnect(USB_OTG_GlobalTypeDef *USBx)
000000  4601              MOV      r1,r0
;;;1260   {
;;;1261     uint32_t USBx_BASE = (uint32_t)USBx;
000002  460a              MOV      r2,r1
;;;1262   
;;;1263     /* In case phy is stopped, ensure to ungate and restore the phy CLK */
;;;1264     USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
000004  f8d20e00          LDR      r0,[r2,#0xe00]
000008  f0200003          BIC      r0,r0,#3
00000c  f8c20e00          STR      r0,[r2,#0xe00]
;;;1265   
;;;1266     USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS;
000010  f6400004          MOV      r0,#0x804
000014  5880              LDR      r0,[r0,r2]
000016  f0200302          BIC      r3,r0,#2
00001a  f6400004          MOV      r0,#0x804
00001e  5083              STR      r3,[r0,r2]
;;;1267   
;;;1268     return HAL_OK;
000020  2000              MOVS     r0,#0
;;;1269   }
000022  4770              BX       lr
;;;1270   
                          ENDP


                          AREA ||i.USB_DevDisconnect||, CODE, READONLY, ALIGN=1

                  USB_DevDisconnect PROC
;;;1275     */
;;;1276   HAL_StatusTypeDef  USB_DevDisconnect(USB_OTG_GlobalTypeDef *USBx)
000000  4601              MOV      r1,r0
;;;1277   {
;;;1278     uint32_t USBx_BASE = (uint32_t)USBx;
000002  460a              MOV      r2,r1
;;;1279   
;;;1280     /* In case phy is stopped, ensure to ungate and restore the phy CLK */
;;;1281     USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
000004  f8d20e00          LDR      r0,[r2,#0xe00]
000008  f0200003          BIC      r0,r0,#3
00000c  f8c20e00          STR      r0,[r2,#0xe00]
;;;1282   
;;;1283     USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
000010  f6400004          MOV      r0,#0x804
000014  5880              LDR      r0,[r0,r2]
000016  f0400302          ORR      r3,r0,#2
00001a  f6400004          MOV      r0,#0x804
00001e  5083              STR      r3,[r0,r2]
;;;1284   
;;;1285     return HAL_OK;
000020  2000              MOVS     r0,#0
;;;1286   }
000022  4770              BX       lr
;;;1287   
                          ENDP


                          AREA ||i.USB_DevInit||, CODE, READONLY, ALIGN=2

                  USB_DevInit PROC
;;;295      */
;;;296    HAL_StatusTypeDef USB_DevInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
000000  b40f              PUSH     {r0-r3}
;;;297    {
000002  b5f0              PUSH     {r4-r7,lr}
000004  4605              MOV      r5,r0
;;;298      HAL_StatusTypeDef ret = HAL_OK;
000006  2700              MOVS     r7,#0
;;;299      uint32_t USBx_BASE = (uint32_t)USBx;
000008  462e              MOV      r6,r5
;;;300      uint32_t i;
;;;301    
;;;302      for (i = 0U; i < 15U; i++)
00000a  2400              MOVS     r4,#0
00000c  e005              B        |L13.26|
                  |L13.14|
;;;303      {
;;;304        USBx->DIEPTXF[i] = 0U;
00000e  2100              MOVS     r1,#0
000010  f5057082          ADD      r0,r5,#0x104
000014  f8401024          STR      r1,[r0,r4,LSL #2]
000018  1c64              ADDS     r4,r4,#1              ;302
                  |L13.26|
00001a  2c0f              CMP      r4,#0xf               ;302
00001c  d3f7              BCC      |L13.14|
;;;305      }
;;;306    
;;;307    #if defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
;;;308      /* VBUS Sensing setup */
;;;309      if (cfg.vbus_sensing_enable == 0U)
;;;310      {
;;;311        USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
;;;312    
;;;313        /* Deactivate VBUS Sensing B */
;;;314        USBx->GCCFG &= ~USB_OTG_GCCFG_VBDEN;
;;;315    
;;;316        /* B-peripheral session valid override enable */
;;;317        USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
;;;318        USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
;;;319      }
;;;320      else
;;;321      {
;;;322        /* Enable HW VBUS sensing */
;;;323        USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;
;;;324      }
;;;325    #else
;;;326      /* VBUS Sensing setup */
;;;327      if (cfg.vbus_sensing_enable == 0U)
00001e  9810              LDR      r0,[sp,#0x40]
000020  b9a0              CBNZ     r0,|L13.76|
;;;328      {
;;;329        /*
;;;330         * Disable HW VBUS sensing. VBUS is internally considered to be always
;;;331         * at VBUS-Valid level (5V).
;;;332         */
;;;333        USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
000022  f6400004          MOV      r0,#0x804
000026  5980              LDR      r0,[r0,r6]
000028  f0400102          ORR      r1,r0,#2
00002c  f6400004          MOV      r0,#0x804
000030  5181              STR      r1,[r0,r6]
;;;334        USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
000032  6ba8              LDR      r0,[r5,#0x38]
000034  f4401000          ORR      r0,r0,#0x200000
000038  63a8              STR      r0,[r5,#0x38]
;;;335        USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSBSEN;
00003a  6ba8              LDR      r0,[r5,#0x38]
00003c  f4202000          BIC      r0,r0,#0x80000
000040  63a8              STR      r0,[r5,#0x38]
;;;336        USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSASEN;
000042  6ba8              LDR      r0,[r5,#0x38]
000044  f4202080          BIC      r0,r0,#0x40000
000048  63a8              STR      r0,[r5,#0x38]
00004a  e007              B        |L13.92|
                  |L13.76|
;;;337      }
;;;338      else
;;;339      {
;;;340        /* Enable HW VBUS sensing */
;;;341        USBx->GCCFG &= ~USB_OTG_GCCFG_NOVBUSSENS;
00004c  6ba8              LDR      r0,[r5,#0x38]
00004e  f4201000          BIC      r0,r0,#0x200000
000052  63a8              STR      r0,[r5,#0x38]
;;;342        USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
000054  6ba8              LDR      r0,[r5,#0x38]
000056  f4402000          ORR      r0,r0,#0x80000
00005a  63a8              STR      r0,[r5,#0x38]
                  |L13.92|
;;;343      }
;;;344    #endif /* defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx) */
;;;345    
;;;346      /* Restart the Phy Clock */
;;;347      USBx_PCGCCTL = 0U;
00005c  2000              MOVS     r0,#0
00005e  f8c60e00          STR      r0,[r6,#0xe00]
;;;348    
;;;349      /* Device mode configuration */
;;;350      USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
000062  f8d60800          LDR      r0,[r6,#0x800]
000066  f8c60800          STR      r0,[r6,#0x800]
;;;351    
;;;352      if (cfg.phy_itface == USB_OTG_ULPI_PHY)
00006a  980b              LDR      r0,[sp,#0x2c]
00006c  2801              CMP      r0,#1
00006e  d10b              BNE      |L13.136|
;;;353      {
;;;354        if (cfg.speed == USBD_HS_SPEED)
000070  9808              LDR      r0,[sp,#0x20]
000072  b920              CBNZ     r0,|L13.126|
;;;355        {
;;;356          /* Set Core speed to High speed mode */
;;;357          (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH);
000074  2100              MOVS     r1,#0
000076  4628              MOV      r0,r5
000078  f7fffffe          BL       USB_SetDevSpeed
00007c  e008              B        |L13.144|
                  |L13.126|
;;;358        }
;;;359        else
;;;360        {
;;;361          /* Set Core speed to Full speed mode */
;;;362          (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH_IN_FULL);
00007e  2101              MOVS     r1,#1
000080  4628              MOV      r0,r5
000082  f7fffffe          BL       USB_SetDevSpeed
000086  e003              B        |L13.144|
                  |L13.136|
;;;363        }
;;;364      }
;;;365      else
;;;366      {
;;;367        /* Set Core speed to Full speed mode */
;;;368        (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_FULL);
000088  2103              MOVS     r1,#3
00008a  4628              MOV      r0,r5
00008c  f7fffffe          BL       USB_SetDevSpeed
                  |L13.144|
;;;369      }
;;;370    
;;;371      /* Flush the FIFOs */
;;;372      if (USB_FlushTxFifo(USBx, 0x10U) != HAL_OK) /* all Tx FIFOs */
000090  2110              MOVS     r1,#0x10
000092  4628              MOV      r0,r5
000094  f7fffffe          BL       USB_FlushTxFifo
000098  b100              CBZ      r0,|L13.156|
;;;373      {
;;;374        ret = HAL_ERROR;
00009a  2701              MOVS     r7,#1
                  |L13.156|
;;;375      }
;;;376    
;;;377      if (USB_FlushRxFifo(USBx) != HAL_OK)
00009c  4628              MOV      r0,r5
00009e  f7fffffe          BL       USB_FlushRxFifo
0000a2  b100              CBZ      r0,|L13.166|
;;;378      {
;;;379        ret = HAL_ERROR;
0000a4  2701              MOVS     r7,#1
                  |L13.166|
;;;380      }
;;;381    
;;;382      /* Clear all pending Device Interrupts */
;;;383      USBx_DEVICE->DIEPMSK = 0U;
0000a6  2100              MOVS     r1,#0
0000a8  f44f6001          MOV      r0,#0x810
0000ac  5181              STR      r1,[r0,r6]
;;;384      USBx_DEVICE->DOEPMSK = 0U;
0000ae  1d00              ADDS     r0,r0,#4
0000b0  5181              STR      r1,[r0,r6]
;;;385      USBx_DEVICE->DAINTMSK = 0U;
0000b2  f640001c          MOV      r0,#0x81c
0000b6  5181              STR      r1,[r0,r6]
;;;386    
;;;387      for (i = 0U; i < cfg.dev_endpoints; i++)
0000b8  2400              MOVS     r4,#0
0000ba  e02e              B        |L13.282|
                  |L13.188|
;;;388      {
;;;389        if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
0000bc  f5066010          ADD      r0,r6,#0x900
0000c0  eb001044          ADD      r0,r0,r4,LSL #5
0000c4  6800              LDR      r0,[r0,#0]
0000c6  f0004000          AND      r0,r0,#0x80000000
0000ca  f1b04f00          CMP      r0,#0x80000000
0000ce  d110              BNE      |L13.242|
;;;390        {
;;;391          if (i == 0U)
0000d0  b93c              CBNZ     r4,|L13.226|
;;;392          {
;;;393            USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
0000d2  f04f6100          MOV      r1,#0x8000000
0000d6  f5066010          ADD      r0,r6,#0x900
0000da  eb001044          ADD      r0,r0,r4,LSL #5
0000de  6001              STR      r1,[r0,#0]
0000e0  e00d              B        |L13.254|
                  |L13.226|
;;;394          }
;;;395          else
;;;396          {
;;;397            USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;
0000e2  f04f4190          MOV      r1,#0x48000000
0000e6  f5066010          ADD      r0,r6,#0x900
0000ea  eb001044          ADD      r0,r0,r4,LSL #5
0000ee  6001              STR      r1,[r0,#0]
0000f0  e005              B        |L13.254|
                  |L13.242|
;;;398          }
;;;399        }
;;;400        else
;;;401        {
;;;402          USBx_INEP(i)->DIEPCTL = 0U;
0000f2  2100              MOVS     r1,#0
0000f4  f5066010          ADD      r0,r6,#0x900
0000f8  eb001044          ADD      r0,r0,r4,LSL #5
0000fc  6001              STR      r1,[r0,#0]
                  |L13.254|
;;;403        }
;;;404    
;;;405        USBx_INEP(i)->DIEPTSIZ = 0U;
0000fe  2100              MOVS     r1,#0
000100  f5066010          ADD      r0,r6,#0x900
000104  eb001044          ADD      r0,r0,r4,LSL #5
000108  6101              STR      r1,[r0,#0x10]
;;;406        USBx_INEP(i)->DIEPINT  = 0xFB7FU;
00010a  f64f317f          MOV      r1,#0xfb7f
00010e  f5066010          ADD      r0,r6,#0x900
000112  eb001044          ADD      r0,r0,r4,LSL #5
000116  6081              STR      r1,[r0,#8]
000118  1c64              ADDS     r4,r4,#1              ;387
                  |L13.282|
00011a  9806              LDR      r0,[sp,#0x18]         ;387
00011c  42a0              CMP      r0,r4                 ;387
00011e  d8cd              BHI      |L13.188|
;;;407      }
;;;408    
;;;409      for (i = 0U; i < cfg.dev_endpoints; i++)
000120  2400              MOVS     r4,#0
000122  e02e              B        |L13.386|
                  |L13.292|
;;;410      {
;;;411        if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
000124  f5066030          ADD      r0,r6,#0xb00
000128  eb001044          ADD      r0,r0,r4,LSL #5
00012c  6800              LDR      r0,[r0,#0]
00012e  f0004000          AND      r0,r0,#0x80000000
000132  f1b04f00          CMP      r0,#0x80000000
000136  d110              BNE      |L13.346|
;;;412        {
;;;413          if (i == 0U)
000138  b93c              CBNZ     r4,|L13.330|
;;;414          {
;;;415            USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
00013a  f04f6100          MOV      r1,#0x8000000
00013e  f5066030          ADD      r0,r6,#0xb00
000142  eb001044          ADD      r0,r0,r4,LSL #5
000146  6001              STR      r1,[r0,#0]
000148  e00d              B        |L13.358|
                  |L13.330|
;;;416          }
;;;417          else
;;;418          {
;;;419            USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK;
00014a  f04f4190          MOV      r1,#0x48000000
00014e  f5066030          ADD      r0,r6,#0xb00
000152  eb001044          ADD      r0,r0,r4,LSL #5
000156  6001              STR      r1,[r0,#0]
000158  e005              B        |L13.358|
                  |L13.346|
;;;420          }
;;;421        }
;;;422        else
;;;423        {
;;;424          USBx_OUTEP(i)->DOEPCTL = 0U;
00015a  2100              MOVS     r1,#0
00015c  f5066030          ADD      r0,r6,#0xb00
000160  eb001044          ADD      r0,r0,r4,LSL #5
000164  6001              STR      r1,[r0,#0]
                  |L13.358|
;;;425        }
;;;426    
;;;427        USBx_OUTEP(i)->DOEPTSIZ = 0U;
000166  2100              MOVS     r1,#0
000168  f5066030          ADD      r0,r6,#0xb00
00016c  eb001044          ADD      r0,r0,r4,LSL #5
000170  6101              STR      r1,[r0,#0x10]
;;;428        USBx_OUTEP(i)->DOEPINT  = 0xFB7FU;
000172  f64f317f          MOV      r1,#0xfb7f
000176  f5066030          ADD      r0,r6,#0xb00
00017a  eb001044          ADD      r0,r0,r4,LSL #5
00017e  6081              STR      r1,[r0,#8]
000180  1c64              ADDS     r4,r4,#1              ;409
                  |L13.386|
000182  9806              LDR      r0,[sp,#0x18]         ;409
000184  42a0              CMP      r0,r4                 ;409
000186  d8cd              BHI      |L13.292|
;;;429      }
;;;430    
;;;431      USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
000188  f44f6001          MOV      r0,#0x810
00018c  5980              LDR      r0,[r0,r6]
00018e  f4207180          BIC      r1,r0,#0x100
000192  f44f6001          MOV      r0,#0x810
000196  5181              STR      r1,[r0,r6]
;;;432    
;;;433      /* Disable all interrupts. */
;;;434      USBx->GINTMSK = 0U;
000198  2000              MOVS     r0,#0
00019a  61a8              STR      r0,[r5,#0x18]
;;;435    
;;;436      /* Clear any pending interrupts */
;;;437      USBx->GINTSTS = 0xBFFFFFFFU;
00019c  f06f4080          MVN      r0,#0x40000000
0001a0  6168              STR      r0,[r5,#0x14]
;;;438    
;;;439      /* Enable the common interrupts */
;;;440      if (cfg.dma_enable == 0U)
0001a2  9809              LDR      r0,[sp,#0x24]
0001a4  b918              CBNZ     r0,|L13.430|
;;;441      {
;;;442        USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
0001a6  69a8              LDR      r0,[r5,#0x18]
0001a8  f0400010          ORR      r0,r0,#0x10
0001ac  61a8              STR      r0,[r5,#0x18]
                  |L13.430|
;;;443      }
;;;444    
;;;445      /* Enable interrupts matching to the Device mode ONLY */
;;;446      USBx->GINTMSK |= USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |
0001ae  69a8              LDR      r0,[r5,#0x18]
0001b0  4909              LDR      r1,|L13.472|
0001b2  4308              ORRS     r0,r0,r1
0001b4  61a8              STR      r0,[r5,#0x18]
;;;447                       USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |
;;;448                       USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM |
;;;449                       USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM;
;;;450    
;;;451      if (cfg.Sof_enable != 0U)
0001b6  980c              LDR      r0,[sp,#0x30]
0001b8  b118              CBZ      r0,|L13.450|
;;;452      {
;;;453        USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
0001ba  69a8              LDR      r0,[r5,#0x18]
0001bc  f0400008          ORR      r0,r0,#8
0001c0  61a8              STR      r0,[r5,#0x18]
                  |L13.450|
;;;454      }
;;;455    
;;;456      if (cfg.vbus_sensing_enable == 1U)
0001c2  9810              LDR      r0,[sp,#0x40]
0001c4  2801              CMP      r0,#1
0001c6  d103              BNE      |L13.464|
;;;457      {
;;;458        USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT);
0001c8  69a8              LDR      r0,[r5,#0x18]
0001ca  4904              LDR      r1,|L13.476|
0001cc  4308              ORRS     r0,r0,r1
0001ce  61a8              STR      r0,[r5,#0x18]
                  |L13.464|
;;;459      }
;;;460    
;;;461      return ret;
0001d0  4638              MOV      r0,r7
;;;462    }
0001d2  bcf0              POP      {r4-r7}
0001d4  f85dfb14          LDR      pc,[sp],#0x14
;;;463    
                          ENDP

                  |L13.472|
                          DCD      0x803c3800
                  |L13.476|
                          DCD      0x40000004

                          AREA ||i.USB_DisableGlobalInt||, CODE, READONLY, ALIGN=1

                  USB_DisableGlobalInt PROC
;;;233      */
;;;234    HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
000000  4601              MOV      r1,r0
;;;235    {
;;;236      USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
000002  6888              LDR      r0,[r1,#8]
000004  f0200001          BIC      r0,r0,#1
000008  6088              STR      r0,[r1,#8]
;;;237      return HAL_OK;
00000a  2000              MOVS     r0,#0
;;;238    }
00000c  4770              BX       lr
;;;239    
                          ENDP


                          AREA ||i.USB_DoPing||, CODE, READONLY, ALIGN=2

                  USB_DoPing PROC
;;;2092     */
;;;2093   HAL_StatusTypeDef USB_DoPing(USB_OTG_GlobalTypeDef *USBx, uint8_t ch_num)
000000  b5f0              PUSH     {r4-r7,lr}
;;;2094   {
000002  4603              MOV      r3,r0
;;;2095     uint32_t USBx_BASE = (uint32_t)USBx;
000004  461c              MOV      r4,r3
;;;2096     uint32_t chnum = (uint32_t)ch_num;
000006  460a              MOV      r2,r1
;;;2097     uint32_t num_packets = 1U;
000008  2601              MOVS     r6,#1
;;;2098     uint32_t tmpreg;
;;;2099   
;;;2100     USBx_HC(chnum)->HCTSIZ = ((num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
00000a  480d              LDR      r0,|L15.64|
00000c  ea0040c6          AND      r0,r0,r6,LSL #19
000010  f0404700          ORR      r7,r0,#0x80000000
000014  4611              MOV      r1,r2
000016  f50460a0          ADD      r0,r4,#0x500
00001a  eb001041          ADD      r0,r0,r1,LSL #5
00001e  6107              STR      r7,[r0,#0x10]
;;;2101                              USB_OTG_HCTSIZ_DOPING;
;;;2102   
;;;2103     /* Set host channel enable */
;;;2104     tmpreg = USBx_HC(chnum)->HCCHAR;
000020  f50460a0          ADD      r0,r4,#0x500
000024  eb001041          ADD      r0,r0,r1,LSL #5
000028  6805              LDR      r5,[r0,#0]
;;;2105     tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
00002a  f0254580          BIC      r5,r5,#0x40000000
;;;2106     tmpreg |= USB_OTG_HCCHAR_CHENA;
00002e  f0454500          ORR      r5,r5,#0x80000000
;;;2107     USBx_HC(chnum)->HCCHAR = tmpreg;
000032  f50460a0          ADD      r0,r4,#0x500
000036  eb001041          ADD      r0,r0,r1,LSL #5
00003a  6005              STR      r5,[r0,#0]
;;;2108   
;;;2109     return HAL_OK;
00003c  2000              MOVS     r0,#0
;;;2110   }
00003e  bdf0              POP      {r4-r7,pc}
;;;2111   
                          ENDP

                  |L15.64|
                          DCD      0x1ff80000

                          AREA ||i.USB_DriveVbus||, CODE, READONLY, ALIGN=1

                  USB_DriveVbus PROC
;;;1663     */
;;;1664   HAL_StatusTypeDef USB_DriveVbus(USB_OTG_GlobalTypeDef *USBx, uint8_t state)
000000  b508              PUSH     {r3,lr}
;;;1665   {
000002  4602              MOV      r2,r0
;;;1666     uint32_t USBx_BASE = (uint32_t)USBx;
000004  4613              MOV      r3,r2
;;;1667     __IO uint32_t hprt0 = 0U;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;1668   
;;;1669     hprt0 = USBx_HPRT0;
00000a  f8d30440          LDR      r0,[r3,#0x440]
00000e  9000              STR      r0,[sp,#0]
;;;1670   
;;;1671     hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
000010  9800              LDR      r0,[sp,#0]
000012  f020002e          BIC      r0,r0,#0x2e
000016  9000              STR      r0,[sp,#0]
;;;1672                USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);
;;;1673   
;;;1674     if (((hprt0 & USB_OTG_HPRT_PPWR) == 0U) && (state == 1U))
000018  9800              LDR      r0,[sp,#0]
00001a  f4005080          AND      r0,r0,#0x1000
00001e  b930              CBNZ     r0,|L16.46|
000020  2901              CMP      r1,#1
000022  d104              BNE      |L16.46|
;;;1675     {
;;;1676       USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0);
000024  9800              LDR      r0,[sp,#0]
000026  f4405080          ORR      r0,r0,#0x1000
00002a  f8c30440          STR      r0,[r3,#0x440]
                  |L16.46|
;;;1677     }
;;;1678     if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0U))
00002e  9800              LDR      r0,[sp,#0]
000030  f4005080          AND      r0,r0,#0x1000
000034  f5b05f80          CMP      r0,#0x1000
000038  d105              BNE      |L16.70|
00003a  b921              CBNZ     r1,|L16.70|
;;;1679     {
;;;1680       USBx_HPRT0 = ((~USB_OTG_HPRT_PPWR) & hprt0);
00003c  9800              LDR      r0,[sp,#0]
00003e  f4205080          BIC      r0,r0,#0x1000
000042  f8c30440          STR      r0,[r3,#0x440]
                  |L16.70|
;;;1681     }
;;;1682     return HAL_OK;
000046  2000              MOVS     r0,#0
;;;1683   }
000048  bd08              POP      {r3,pc}
;;;1684   
                          ENDP


                          AREA ||i.USB_EP0StartXfer||, CODE, READONLY, ALIGN=2

                  USB_EP0StartXfer PROC
;;;908      */
;;;909    HAL_StatusTypeDef USB_EP0StartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep, uint8_t dma)
000000  b5f0              PUSH     {r4-r7,lr}
;;;910    {
000002  4605              MOV      r5,r0
000004  460b              MOV      r3,r1
000006  4614              MOV      r4,r2
;;;911      uint32_t USBx_BASE = (uint32_t)USBx;
000008  462a              MOV      r2,r5
;;;912      uint32_t epnum = (uint32_t)ep->num;
00000a  7819              LDRB     r1,[r3,#0]
;;;913    
;;;914      /* IN endpoint */
;;;915      if (ep->is_in == 1U)
00000c  7858              LDRB     r0,[r3,#1]
00000e  2801              CMP      r0,#1
000010  d175              BNE      |L17.254|
;;;916      {
;;;917        /* Zero Length Packet? */
;;;918        if (ep->xfer_len == 0U)
000012  6998              LDR      r0,[r3,#0x18]
000014  bb20              CBNZ     r0,|L17.96|
;;;919        {
;;;920          USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
000016  f5026010          ADD      r0,r2,#0x900
00001a  eb001041          ADD      r0,r0,r1,LSL #5
00001e  6900              LDR      r0,[r0,#0x10]
000020  4e6d              LDR      r6,|L17.472|
000022  4030              ANDS     r0,r0,r6
000024  f5026610          ADD      r6,r2,#0x900
000028  eb061641          ADD      r6,r6,r1,LSL #5
00002c  6130              STR      r0,[r6,#0x10]
;;;921          USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
00002e  f5026010          ADD      r0,r2,#0x900
000032  eb001041          ADD      r0,r0,r1,LSL #5
000036  6900              LDR      r0,[r0,#0x10]
000038  f4402600          ORR      r6,r0,#0x80000
00003c  f5026010          ADD      r0,r2,#0x900
000040  eb001041          ADD      r0,r0,r1,LSL #5
000044  6106              STR      r6,[r0,#0x10]
;;;922          USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
000046  f5026010          ADD      r0,r2,#0x900
00004a  eb001041          ADD      r0,r0,r1,LSL #5
00004e  6900              LDR      r0,[r0,#0x10]
000050  0cc6              LSRS     r6,r0,#19
000052  04f6              LSLS     r6,r6,#19
000054  f5026010          ADD      r0,r2,#0x900
000058  eb001041          ADD      r0,r0,r1,LSL #5
00005c  6106              STR      r6,[r0,#0x10]
00005e  e037              B        |L17.208|
                  |L17.96|
;;;923        }
;;;924        else
;;;925        {
;;;926          /* Program the transfer size and packet count
;;;927          * as follows: xfersize = N * maxpacket +
;;;928          * short_packet pktcnt = N + (short_packet
;;;929          * exist ? 1 : 0)
;;;930          */
;;;931          USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
000060  f5026010          ADD      r0,r2,#0x900
000064  eb001041          ADD      r0,r0,r1,LSL #5
000068  6900              LDR      r0,[r0,#0x10]
00006a  0cc6              LSRS     r6,r0,#19
00006c  04f6              LSLS     r6,r6,#19
00006e  f5026010          ADD      r0,r2,#0x900
000072  eb001041          ADD      r0,r0,r1,LSL #5
000076  6106              STR      r6,[r0,#0x10]
;;;932          USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
000078  f5026010          ADD      r0,r2,#0x900
00007c  eb001041          ADD      r0,r0,r1,LSL #5
000080  6900              LDR      r0,[r0,#0x10]
000082  4e55              LDR      r6,|L17.472|
000084  4030              ANDS     r0,r0,r6
000086  f5026610          ADD      r6,r2,#0x900
00008a  eb061641          ADD      r6,r6,r1,LSL #5
00008e  6130              STR      r0,[r6,#0x10]
;;;933    
;;;934          if (ep->xfer_len > ep->maxpacket)
000090  68de              LDR      r6,[r3,#0xc]
000092  6998              LDR      r0,[r3,#0x18]
000094  42b0              CMP      r0,r6
000096  d901              BLS      |L17.156|
;;;935          {
;;;936            ep->xfer_len = ep->maxpacket;
000098  68d8              LDR      r0,[r3,#0xc]
00009a  6198              STR      r0,[r3,#0x18]
                  |L17.156|
;;;937          }
;;;938          USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
00009c  f5026010          ADD      r0,r2,#0x900
0000a0  eb001041          ADD      r0,r0,r1,LSL #5
0000a4  6900              LDR      r0,[r0,#0x10]
0000a6  f4402600          ORR      r6,r0,#0x80000
0000aa  f5026010          ADD      r0,r2,#0x900
0000ae  eb001041          ADD      r0,r0,r1,LSL #5
0000b2  6106              STR      r6,[r0,#0x10]
;;;939          USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
0000b4  f5026010          ADD      r0,r2,#0x900
0000b8  eb001041          ADD      r0,r0,r1,LSL #5
0000bc  6900              LDR      r0,[r0,#0x10]
0000be  699e              LDR      r6,[r3,#0x18]
0000c0  f3c60612          UBFX     r6,r6,#0,#19
0000c4  4330              ORRS     r0,r0,r6
0000c6  f5026610          ADD      r6,r2,#0x900
0000ca  eb061641          ADD      r6,r6,r1,LSL #5
0000ce  6130              STR      r0,[r6,#0x10]
                  |L17.208|
;;;940        }
;;;941    
;;;942        if (dma == 1U)
0000d0  2c01              CMP      r4,#1
0000d2  d115              BNE      |L17.256|
;;;943        {
;;;944          if ((uint32_t)ep->dma_addr != 0U)
0000d4  6958              LDR      r0,[r3,#0x14]
0000d6  b128              CBZ      r0,|L17.228|
;;;945          {
;;;946            USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
0000d8  f5026010          ADD      r0,r2,#0x900
0000dc  eb001041          ADD      r0,r0,r1,LSL #5
0000e0  695e              LDR      r6,[r3,#0x14]
0000e2  6146              STR      r6,[r0,#0x14]
                  |L17.228|
;;;947          }
;;;948    
;;;949          /* EP enable, IN data in FIFO */
;;;950          USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
0000e4  f5026010          ADD      r0,r2,#0x900
0000e8  eb001041          ADD      r0,r0,r1,LSL #5
0000ec  6800              LDR      r0,[r0,#0]
0000ee  f0404604          ORR      r6,r0,#0x84000000
0000f2  f5026010          ADD      r0,r2,#0x900
0000f6  eb001041          ADD      r0,r0,r1,LSL #5
0000fa  6006              STR      r6,[r0,#0]
0000fc  e06a              B        |L17.468|
                  |L17.254|
0000fe  e01b              B        |L17.312|
                  |L17.256|
;;;951        }
;;;952        else
;;;953        {
;;;954          /* EP enable, IN data in FIFO */
;;;955          USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
000100  f5026010          ADD      r0,r2,#0x900
000104  eb001041          ADD      r0,r0,r1,LSL #5
000108  6800              LDR      r0,[r0,#0]
00010a  f0404604          ORR      r6,r0,#0x84000000
00010e  f5026010          ADD      r0,r2,#0x900
000112  eb001041          ADD      r0,r0,r1,LSL #5
000116  6006              STR      r6,[r0,#0]
;;;956    
;;;957          /* Enable the Tx FIFO Empty Interrupt for this EP */
;;;958          if (ep->xfer_len > 0U)
000118  6998              LDR      r0,[r3,#0x18]
00011a  2800              CMP      r0,#0
00011c  d05a              BEQ      |L17.468|
;;;959          {
;;;960            USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
00011e  f6400034          MOV      r0,#0x834
000122  5880              LDR      r0,[r0,r2]
000124  781e              LDRB     r6,[r3,#0]
000126  f006070f          AND      r7,r6,#0xf
00012a  2601              MOVS     r6,#1
00012c  40be              LSLS     r6,r6,r7
00012e  4330              ORRS     r0,r0,r6
000130  f6400634          MOV      r6,#0x834
000134  50b0              STR      r0,[r6,r2]
000136  e04d              B        |L17.468|
                  |L17.312|
;;;961          }
;;;962        }
;;;963      }
;;;964      else /* OUT endpoint */
;;;965      {
;;;966        /* Program the transfer size and packet count as follows:
;;;967        * pktcnt = N
;;;968        * xfersize = N * maxpacket
;;;969        */
;;;970        USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
000138  f5026030          ADD      r0,r2,#0xb00
00013c  eb001041          ADD      r0,r0,r1,LSL #5
000140  6900              LDR      r0,[r0,#0x10]
000142  0cc6              LSRS     r6,r0,#19
000144  04f6              LSLS     r6,r6,#19
000146  f5026030          ADD      r0,r2,#0xb00
00014a  eb001041          ADD      r0,r0,r1,LSL #5
00014e  6106              STR      r6,[r0,#0x10]
;;;971        USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
000150  f5026030          ADD      r0,r2,#0xb00
000154  eb001041          ADD      r0,r0,r1,LSL #5
000158  6900              LDR      r0,[r0,#0x10]
00015a  4e1f              LDR      r6,|L17.472|
00015c  4030              ANDS     r0,r0,r6
00015e  f5026630          ADD      r6,r2,#0xb00
000162  eb061641          ADD      r6,r6,r1,LSL #5
000166  6130              STR      r0,[r6,#0x10]
;;;972    
;;;973        if (ep->xfer_len > 0U)
000168  6998              LDR      r0,[r3,#0x18]
00016a  b108              CBZ      r0,|L17.368|
;;;974        {
;;;975          ep->xfer_len = ep->maxpacket;
00016c  68d8              LDR      r0,[r3,#0xc]
00016e  6198              STR      r0,[r3,#0x18]
                  |L17.368|
;;;976        }
;;;977    
;;;978        /* Store transfer size, for EP0 this is equal to endpoint max packet size */
;;;979        ep->xfer_size = ep->maxpacket;
000170  68d8              LDR      r0,[r3,#0xc]
000172  61d8              STR      r0,[r3,#0x1c]
;;;980    
;;;981        USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
000174  f5026030          ADD      r0,r2,#0xb00
000178  eb001041          ADD      r0,r0,r1,LSL #5
00017c  6900              LDR      r0,[r0,#0x10]
00017e  f4402600          ORR      r6,r0,#0x80000
000182  f5026030          ADD      r0,r2,#0xb00
000186  eb001041          ADD      r0,r0,r1,LSL #5
00018a  6106              STR      r6,[r0,#0x10]
;;;982        USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size);
00018c  f5026030          ADD      r0,r2,#0xb00
000190  eb001041          ADD      r0,r0,r1,LSL #5
000194  6900              LDR      r0,[r0,#0x10]
000196  69de              LDR      r6,[r3,#0x1c]
000198  f3c60612          UBFX     r6,r6,#0,#19
00019c  4330              ORRS     r0,r0,r6
00019e  f5026630          ADD      r6,r2,#0xb00
0001a2  eb061641          ADD      r6,r6,r1,LSL #5
0001a6  6130              STR      r0,[r6,#0x10]
;;;983    
;;;984        if (dma == 1U)
0001a8  2c01              CMP      r4,#1
0001aa  d107              BNE      |L17.444|
;;;985        {
;;;986          if ((uint32_t)ep->xfer_buff != 0U)
0001ac  6918              LDR      r0,[r3,#0x10]
0001ae  b128              CBZ      r0,|L17.444|
;;;987          {
;;;988            USBx_OUTEP(epnum)->DOEPDMA = (uint32_t)(ep->xfer_buff);
0001b0  f5026030          ADD      r0,r2,#0xb00
0001b4  eb001041          ADD      r0,r0,r1,LSL #5
0001b8  691e              LDR      r6,[r3,#0x10]
0001ba  6146              STR      r6,[r0,#0x14]
                  |L17.444|
;;;989          }
;;;990        }
;;;991    
;;;992        /* EP enable */
;;;993        USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
0001bc  f5026030          ADD      r0,r2,#0xb00
0001c0  eb001041          ADD      r0,r0,r1,LSL #5
0001c4  6800              LDR      r0,[r0,#0]
0001c6  f0404604          ORR      r6,r0,#0x84000000
0001ca  f5026030          ADD      r0,r2,#0xb00
0001ce  eb001041          ADD      r0,r0,r1,LSL #5
0001d2  6006              STR      r6,[r0,#0]
                  |L17.468|
;;;994      }
;;;995    
;;;996      return HAL_OK;
0001d4  2000              MOVS     r0,#0
;;;997    }
0001d6  bdf0              POP      {r4-r7,pc}
;;;998    
                          ENDP

                  |L17.472|
                          DCD      0xe007ffff

                          AREA ||i.USB_EP0_OutStart||, CODE, READONLY, ALIGN=2

                  USB_EP0_OutStart PROC
;;;1425     */
;;;1426   HAL_StatusTypeDef USB_EP0_OutStart(USB_OTG_GlobalTypeDef *USBx, uint8_t dma, uint8_t *psetup)
000000  b570              PUSH     {r4-r6,lr}
;;;1427   {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;1428     uint32_t USBx_BASE = (uint32_t)USBx;
000006  4619              MOV      r1,r3
;;;1429     uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
000008  6c1d              LDR      r5,[r3,#0x40]
;;;1430   
;;;1431     if (gSNPSiD > USB_OTG_CORE_ID_300A)
00000a  4818              LDR      r0,|L18.108|
00000c  4285              CMP      r5,r0
00000e  d909              BLS      |L18.36|
;;;1432     {
;;;1433       if ((USBx_OUTEP(0U)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
000010  f44f6030          MOV      r0,#0xb00
000014  5840              LDR      r0,[r0,r1]
000016  f0004000          AND      r0,r0,#0x80000000
00001a  f1b04f00          CMP      r0,#0x80000000
00001e  d101              BNE      |L18.36|
;;;1434       {
;;;1435         return HAL_OK;
000020  2000              MOVS     r0,#0
                  |L18.34|
;;;1436       }
;;;1437     }
;;;1438   
;;;1439     USBx_OUTEP(0U)->DOEPTSIZ = 0U;
;;;1440     USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
;;;1441     USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
;;;1442     USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;
;;;1443   
;;;1444     if (dma == 1U)
;;;1445     {
;;;1446       USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
;;;1447       /* EP enable */
;;;1448       USBx_OUTEP(0U)->DOEPCTL |= USB_OTG_DOEPCTL_EPENA | USB_OTG_DOEPCTL_USBAEP;
;;;1449     }
;;;1450   
;;;1451     return HAL_OK;
;;;1452   }
000022  bd70              POP      {r4-r6,pc}
                  |L18.36|
000024  2600              MOVS     r6,#0                 ;1439
000026  f8c16b10          STR      r6,[r1,#0xb10]        ;1439
00002a  f8d10b10          LDR      r0,[r1,#0xb10]        ;1440
00002e  f4402600          ORR      r6,r0,#0x80000        ;1440
000032  f8c16b10          STR      r6,[r1,#0xb10]        ;1440
000036  f8d10b10          LDR      r0,[r1,#0xb10]        ;1441
00003a  f0400618          ORR      r6,r0,#0x18           ;1441
00003e  f8c16b10          STR      r6,[r1,#0xb10]        ;1441
000042  f8d10b10          LDR      r0,[r1,#0xb10]        ;1442
000046  f04046c0          ORR      r6,r0,#0x60000000     ;1442
00004a  f8c16b10          STR      r6,[r1,#0xb10]        ;1442
00004e  2c01              CMP      r4,#1                 ;1444
000050  d109              BNE      |L18.102|
000052  f8c12b14          STR      r2,[r1,#0xb14]        ;1446
000056  f44f6030          MOV      r0,#0xb00             ;1448
00005a  5840              LDR      r0,[r0,r1]            ;1448
00005c  f0402680          ORR      r6,r0,#0x80008000     ;1448
000060  f44f6030          MOV      r0,#0xb00             ;1448
000064  5046              STR      r6,[r0,r1]            ;1448
                  |L18.102|
000066  2000              MOVS     r0,#0                 ;1451
000068  e7db              B        |L18.34|
;;;1453   
                          ENDP

00006a  0000              DCW      0x0000
                  |L18.108|
                          DCD      0x4f54300a

                          AREA ||i.USB_EPClearStall||, CODE, READONLY, ALIGN=1

                  USB_EPClearStall PROC
;;;1173     */
;;;1174   HAL_StatusTypeDef USB_EPClearStall(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
000000  b530              PUSH     {r4,r5,lr}
;;;1175   {
000002  4604              MOV      r4,r0
000004  460b              MOV      r3,r1
;;;1176     uint32_t USBx_BASE = (uint32_t)USBx;
000006  4622              MOV      r2,r4
;;;1177     uint32_t epnum = (uint32_t)ep->num;
000008  7819              LDRB     r1,[r3,#0]
;;;1178   
;;;1179     if (ep->is_in == 1U)
00000a  7858              LDRB     r0,[r3,#1]
00000c  2801              CMP      r0,#1
00000e  d11e              BNE      |L19.78|
;;;1180     {
;;;1181       USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
000010  f5026010          ADD      r0,r2,#0x900
000014  eb001041          ADD      r0,r0,r1,LSL #5
000018  6800              LDR      r0,[r0,#0]
00001a  f4201500          BIC      r5,r0,#0x200000
00001e  f5026010          ADD      r0,r2,#0x900
000022  eb001041          ADD      r0,r0,r1,LSL #5
000026  6005              STR      r5,[r0,#0]
;;;1182       if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
000028  7918              LDRB     r0,[r3,#4]
00002a  2803              CMP      r0,#3
00002c  d002              BEQ      |L19.52|
00002e  7918              LDRB     r0,[r3,#4]
000030  2802              CMP      r0,#2
000032  d12a              BNE      |L19.138|
                  |L19.52|
;;;1183       {
;;;1184         USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
000034  f5026010          ADD      r0,r2,#0x900
000038  eb001041          ADD      r0,r0,r1,LSL #5
00003c  6800              LDR      r0,[r0,#0]
00003e  f0405580          ORR      r5,r0,#0x10000000
000042  f5026010          ADD      r0,r2,#0x900
000046  eb001041          ADD      r0,r0,r1,LSL #5
00004a  6005              STR      r5,[r0,#0]
00004c  e01d              B        |L19.138|
                  |L19.78|
;;;1185       }
;;;1186     }
;;;1187     else
;;;1188     {
;;;1189       USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
00004e  f5026030          ADD      r0,r2,#0xb00
000052  eb001041          ADD      r0,r0,r1,LSL #5
000056  6800              LDR      r0,[r0,#0]
000058  f4201500          BIC      r5,r0,#0x200000
00005c  f5026030          ADD      r0,r2,#0xb00
000060  eb001041          ADD      r0,r0,r1,LSL #5
000064  6005              STR      r5,[r0,#0]
;;;1190       if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
000066  7918              LDRB     r0,[r3,#4]
000068  2803              CMP      r0,#3
00006a  d002              BEQ      |L19.114|
00006c  7918              LDRB     r0,[r3,#4]
00006e  2802              CMP      r0,#2
000070  d10b              BNE      |L19.138|
                  |L19.114|
;;;1191       {
;;;1192         USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
000072  f5026030          ADD      r0,r2,#0xb00
000076  eb001041          ADD      r0,r0,r1,LSL #5
00007a  6800              LDR      r0,[r0,#0]
00007c  f0405580          ORR      r5,r0,#0x10000000
000080  f5026030          ADD      r0,r2,#0xb00
000084  eb001041          ADD      r0,r0,r1,LSL #5
000088  6005              STR      r5,[r0,#0]
                  |L19.138|
;;;1193       }
;;;1194     }
;;;1195     return HAL_OK;
00008a  2000              MOVS     r0,#0
;;;1196   }
00008c  bd30              POP      {r4,r5,pc}
;;;1197   
                          ENDP


                          AREA ||i.USB_EPSetStall||, CODE, READONLY, ALIGN=1

                  USB_EPSetStall PROC
;;;1142     */
;;;1143   HAL_StatusTypeDef USB_EPSetStall(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
000000  b530              PUSH     {r4,r5,lr}
;;;1144   {
000002  4604              MOV      r4,r0
000004  460b              MOV      r3,r1
;;;1145     uint32_t USBx_BASE = (uint32_t)USBx;
000006  4622              MOV      r2,r4
;;;1146     uint32_t epnum = (uint32_t)ep->num;
000008  7819              LDRB     r1,[r3,#0]
;;;1147   
;;;1148     if (ep->is_in == 1U)
00000a  7858              LDRB     r0,[r3,#1]
00000c  2801              CMP      r0,#1
00000e  d121              BNE      |L20.84|
;;;1149     {
;;;1150       if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
000010  f5026010          ADD      r0,r2,#0x900
000014  eb001041          ADD      r0,r0,r1,LSL #5
000018  6800              LDR      r0,[r0,#0]
00001a  f0004000          AND      r0,r0,#0x80000000
00001e  b960              CBNZ     r0,|L20.58|
000020  b159              CBZ      r1,|L20.58|
;;;1151       {
;;;1152         USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS);
000022  f5026010          ADD      r0,r2,#0x900
000026  eb001041          ADD      r0,r0,r1,LSL #5
00002a  6800              LDR      r0,[r0,#0]
00002c  f0204580          BIC      r5,r0,#0x40000000
000030  f5026010          ADD      r0,r2,#0x900
000034  eb001041          ADD      r0,r0,r1,LSL #5
000038  6005              STR      r5,[r0,#0]
                  |L20.58|
;;;1153       }
;;;1154       USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
00003a  f5026010          ADD      r0,r2,#0x900
00003e  eb001041          ADD      r0,r0,r1,LSL #5
000042  6800              LDR      r0,[r0,#0]
000044  f4401500          ORR      r5,r0,#0x200000
000048  f5026010          ADD      r0,r2,#0x900
00004c  eb001041          ADD      r0,r0,r1,LSL #5
000050  6005              STR      r5,[r0,#0]
000052  e020              B        |L20.150|
                  |L20.84|
;;;1155     }
;;;1156     else
;;;1157     {
;;;1158       if (((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == 0U) && (epnum != 0U))
000054  f5026030          ADD      r0,r2,#0xb00
000058  eb001041          ADD      r0,r0,r1,LSL #5
00005c  6800              LDR      r0,[r0,#0]
00005e  f0004000          AND      r0,r0,#0x80000000
000062  b960              CBNZ     r0,|L20.126|
000064  b159              CBZ      r1,|L20.126|
;;;1159       {
;;;1160         USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS);
000066  f5026030          ADD      r0,r2,#0xb00
00006a  eb001041          ADD      r0,r0,r1,LSL #5
00006e  6800              LDR      r0,[r0,#0]
000070  f0204580          BIC      r5,r0,#0x40000000
000074  f5026030          ADD      r0,r2,#0xb00
000078  eb001041          ADD      r0,r0,r1,LSL #5
00007c  6005              STR      r5,[r0,#0]
                  |L20.126|
;;;1161       }
;;;1162       USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
00007e  f5026030          ADD      r0,r2,#0xb00
000082  eb001041          ADD      r0,r0,r1,LSL #5
000086  6800              LDR      r0,[r0,#0]
000088  f4401500          ORR      r5,r0,#0x200000
00008c  f5026030          ADD      r0,r2,#0xb00
000090  eb001041          ADD      r0,r0,r1,LSL #5
000094  6005              STR      r5,[r0,#0]
                  |L20.150|
;;;1163     }
;;;1164   
;;;1165     return HAL_OK;
000096  2000              MOVS     r0,#0
;;;1166   }
000098  bd30              POP      {r4,r5,pc}
;;;1167   
                          ENDP


                          AREA ||i.USB_EPStartXfer||, CODE, READONLY, ALIGN=2

                  USB_EPStartXfer PROC
;;;762      */
;;;763    HAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep, uint8_t dma)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;764    {
000004  4681              MOV      r9,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;765      uint32_t USBx_BASE = (uint32_t)USBx;
00000a  464d              MOV      r5,r9
;;;766      uint32_t epnum = (uint32_t)ep->num;
00000c  7834              LDRB     r4,[r6,#0]
;;;767      uint16_t pktcnt;
;;;768    
;;;769      /* IN endpoint */
;;;770      if (ep->is_in == 1U)
00000e  7870              LDRB     r0,[r6,#1]
000010  2801              CMP      r0,#1
000012  d17d              BNE      |L21.272|
;;;771      {
;;;772        /* Zero Length Packet? */
;;;773        if (ep->xfer_len == 0U)
000014  69b0              LDR      r0,[r6,#0x18]
000016  bb20              CBNZ     r0,|L21.98|
;;;774        {
;;;775          USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
000018  f5056010          ADD      r0,r5,#0x900
00001c  eb001044          ADD      r0,r0,r4,LSL #5
000020  6900              LDR      r0,[r0,#0x10]
000022  49c8              LDR      r1,|L21.836|
000024  4008              ANDS     r0,r0,r1
000026  f5056110          ADD      r1,r5,#0x900
00002a  eb011144          ADD      r1,r1,r4,LSL #5
00002e  6108              STR      r0,[r1,#0x10]
;;;776          USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
000030  f5056010          ADD      r0,r5,#0x900
000034  eb001044          ADD      r0,r0,r4,LSL #5
000038  6900              LDR      r0,[r0,#0x10]
00003a  f4402100          ORR      r1,r0,#0x80000
00003e  f5056010          ADD      r0,r5,#0x900
000042  eb001044          ADD      r0,r0,r4,LSL #5
000046  6101              STR      r1,[r0,#0x10]
;;;777          USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
000048  f5056010          ADD      r0,r5,#0x900
00004c  eb001044          ADD      r0,r0,r4,LSL #5
000050  6900              LDR      r0,[r0,#0x10]
000052  0cc1              LSRS     r1,r0,#19
000054  04c9              LSLS     r1,r1,#19
000056  f5056010          ADD      r0,r5,#0x900
00005a  eb001044          ADD      r0,r0,r4,LSL #5
00005e  6101              STR      r1,[r0,#0x10]
000060  e055              B        |L21.270|
                  |L21.98|
;;;778        }
;;;779        else
;;;780        {
;;;781          /* Program the transfer size and packet count
;;;782          * as follows: xfersize = N * maxpacket +
;;;783          * short_packet pktcnt = N + (short_packet
;;;784          * exist ? 1 : 0)
;;;785          */
;;;786          USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
000062  f5056010          ADD      r0,r5,#0x900
000066  eb001044          ADD      r0,r0,r4,LSL #5
00006a  6900              LDR      r0,[r0,#0x10]
00006c  0cc1              LSRS     r1,r0,#19
00006e  04c9              LSLS     r1,r1,#19
000070  f5056010          ADD      r0,r5,#0x900
000074  eb001044          ADD      r0,r0,r4,LSL #5
000078  6101              STR      r1,[r0,#0x10]
;;;787          USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
00007a  f5056010          ADD      r0,r5,#0x900
00007e  eb001044          ADD      r0,r0,r4,LSL #5
000082  6900              LDR      r0,[r0,#0x10]
000084  49af              LDR      r1,|L21.836|
000086  4008              ANDS     r0,r0,r1
000088  f5056110          ADD      r1,r5,#0x900
00008c  eb011144          ADD      r1,r1,r4,LSL #5
000090  6108              STR      r0,[r1,#0x10]
;;;788          USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT &
000092  68f1              LDR      r1,[r6,#0xc]
000094  69b0              LDR      r0,[r6,#0x18]
000096  4408              ADD      r0,r0,r1
000098  1e40              SUBS     r0,r0,#1
00009a  fbb0f0f1          UDIV     r0,r0,r1
00009e  49a9              LDR      r1,|L21.836|
0000a0  43c9              MVNS     r1,r1
0000a2  ea0140c0          AND      r0,r1,r0,LSL #19
0000a6  f5056110          ADD      r1,r5,#0x900
0000aa  eb011144          ADD      r1,r1,r4,LSL #5
0000ae  6909              LDR      r1,[r1,#0x10]
0000b0  4308              ORRS     r0,r0,r1
0000b2  f5056110          ADD      r1,r5,#0x900
0000b6  eb011144          ADD      r1,r1,r4,LSL #5
0000ba  6108              STR      r0,[r1,#0x10]
;;;789                                         (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
;;;790    
;;;791          USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
0000bc  f5056010          ADD      r0,r5,#0x900
0000c0  eb001044          ADD      r0,r0,r4,LSL #5
0000c4  6900              LDR      r0,[r0,#0x10]
0000c6  69b1              LDR      r1,[r6,#0x18]
0000c8  f3c10112          UBFX     r1,r1,#0,#19
0000cc  4308              ORRS     r0,r0,r1
0000ce  f5056110          ADD      r1,r5,#0x900
0000d2  eb011144          ADD      r1,r1,r4,LSL #5
0000d6  6108              STR      r0,[r1,#0x10]
;;;792    
;;;793          if (ep->type == EP_TYPE_ISOC)
0000d8  7930              LDRB     r0,[r6,#4]
0000da  2801              CMP      r0,#1
0000dc  d117              BNE      |L21.270|
;;;794          {
;;;795            USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT);
0000de  f5056010          ADD      r0,r5,#0x900
0000e2  eb001044          ADD      r0,r0,r4,LSL #5
0000e6  6900              LDR      r0,[r0,#0x10]
0000e8  f02041c0          BIC      r1,r0,#0x60000000
0000ec  f5056010          ADD      r0,r5,#0x900
0000f0  eb001044          ADD      r0,r0,r4,LSL #5
0000f4  6101              STR      r1,[r0,#0x10]
;;;796            USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29));
0000f6  f5056010          ADD      r0,r5,#0x900
0000fa  eb001044          ADD      r0,r0,r4,LSL #5
0000fe  6900              LDR      r0,[r0,#0x10]
000100  f0405100          ORR      r1,r0,#0x20000000
000104  f5056010          ADD      r0,r5,#0x900
000108  eb001044          ADD      r0,r0,r4,LSL #5
00010c  6101              STR      r1,[r0,#0x10]
                  |L21.270|
;;;797          }
;;;798        }
;;;799    
;;;800        if (dma == 1U)
00010e  e000              B        |L21.274|
                  |L21.272|
000110  e07f              B        |L21.530|
                  |L21.274|
000112  2f01              CMP      r7,#1
000114  d136              BNE      |L21.388|
;;;801        {
;;;802          if ((uint32_t)ep->dma_addr != 0U)
000116  6970              LDR      r0,[r6,#0x14]
000118  b128              CBZ      r0,|L21.294|
;;;803          {
;;;804            USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
00011a  f5056010          ADD      r0,r5,#0x900
00011e  eb001044          ADD      r0,r0,r4,LSL #5
000122  6971              LDR      r1,[r6,#0x14]
000124  6141              STR      r1,[r0,#0x14]
                  |L21.294|
;;;805          }
;;;806    
;;;807          if (ep->type == EP_TYPE_ISOC)
000126  7930              LDRB     r0,[r6,#4]
000128  2801              CMP      r0,#1
00012a  d11e              BNE      |L21.362|
;;;808          {
;;;809            if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
00012c  f6400008          MOV      r0,#0x808
000130  5940              LDR      r0,[r0,r5]
000132  f4007080          AND      r0,r0,#0x100
000136  b960              CBNZ     r0,|L21.338|
;;;810            {
;;;811              USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
000138  f5056010          ADD      r0,r5,#0x900
00013c  eb001044          ADD      r0,r0,r4,LSL #5
000140  6800              LDR      r0,[r0,#0]
000142  f0405100          ORR      r1,r0,#0x20000000
000146  f5056010          ADD      r0,r5,#0x900
00014a  eb001044          ADD      r0,r0,r4,LSL #5
00014e  6001              STR      r1,[r0,#0]
000150  e00b              B        |L21.362|
                  |L21.338|
;;;812            }
;;;813            else
;;;814            {
;;;815              USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
000152  f5056010          ADD      r0,r5,#0x900
000156  eb001044          ADD      r0,r0,r4,LSL #5
00015a  6800              LDR      r0,[r0,#0]
00015c  f0405180          ORR      r1,r0,#0x10000000
000160  f5056010          ADD      r0,r5,#0x900
000164  eb001044          ADD      r0,r0,r4,LSL #5
000168  6001              STR      r1,[r0,#0]
                  |L21.362|
;;;816            }
;;;817          }
;;;818    
;;;819          /* EP enable, IN data in FIFO */
;;;820          USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
00016a  f5056010          ADD      r0,r5,#0x900
00016e  eb001044          ADD      r0,r0,r4,LSL #5
000172  6800              LDR      r0,[r0,#0]
000174  f0404104          ORR      r1,r0,#0x84000000
000178  f5056010          ADD      r0,r5,#0x900
00017c  eb001044          ADD      r0,r0,r4,LSL #5
000180  6001              STR      r1,[r0,#0]
                  |L21.386|
000182  e0dc              B        |L21.830|
                  |L21.388|
;;;821        }
;;;822        else
;;;823        {
;;;824          /* EP enable, IN data in FIFO */
;;;825          USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
000184  f5056010          ADD      r0,r5,#0x900
000188  eb001044          ADD      r0,r0,r4,LSL #5
00018c  6800              LDR      r0,[r0,#0]
00018e  f0404104          ORR      r1,r0,#0x84000000
000192  f5056010          ADD      r0,r5,#0x900
000196  eb001044          ADD      r0,r0,r4,LSL #5
00019a  6001              STR      r1,[r0,#0]
;;;826    
;;;827          if (ep->type != EP_TYPE_ISOC)
00019c  7930              LDRB     r0,[r6,#4]
00019e  2801              CMP      r0,#1
0001a0  d00f              BEQ      |L21.450|
;;;828          {
;;;829            /* Enable the Tx FIFO Empty Interrupt for this EP */
;;;830            if (ep->xfer_len > 0U)
0001a2  69b0              LDR      r0,[r6,#0x18]
0001a4  2800              CMP      r0,#0
0001a6  d0ec              BEQ      |L21.386|
;;;831            {
;;;832              USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
0001a8  f6400034          MOV      r0,#0x834
0001ac  5940              LDR      r0,[r0,r5]
0001ae  7831              LDRB     r1,[r6,#0]
0001b0  f001020f          AND      r2,r1,#0xf
0001b4  2101              MOVS     r1,#1
0001b6  4091              LSLS     r1,r1,r2
0001b8  4308              ORRS     r0,r0,r1
0001ba  f6400134          MOV      r1,#0x834
0001be  5148              STR      r0,[r1,r5]
0001c0  e0bd              B        |L21.830|
                  |L21.450|
;;;833            }
;;;834          }
;;;835          else
;;;836          {
;;;837            if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
0001c2  f6400008          MOV      r0,#0x808
0001c6  5940              LDR      r0,[r0,r5]
0001c8  f4007080          AND      r0,r0,#0x100
0001cc  b960              CBNZ     r0,|L21.488|
;;;838            {
;;;839              USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
0001ce  f5056010          ADD      r0,r5,#0x900
0001d2  eb001044          ADD      r0,r0,r4,LSL #5
0001d6  6800              LDR      r0,[r0,#0]
0001d8  f0405100          ORR      r1,r0,#0x20000000
0001dc  f5056010          ADD      r0,r5,#0x900
0001e0  eb001044          ADD      r0,r0,r4,LSL #5
0001e4  6001              STR      r1,[r0,#0]
0001e6  e00b              B        |L21.512|
                  |L21.488|
;;;840            }
;;;841            else
;;;842            {
;;;843              USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
0001e8  f5056010          ADD      r0,r5,#0x900
0001ec  eb001044          ADD      r0,r0,r4,LSL #5
0001f0  6800              LDR      r0,[r0,#0]
0001f2  f0405180          ORR      r1,r0,#0x10000000
0001f6  f5056010          ADD      r0,r5,#0x900
0001fa  eb001044          ADD      r0,r0,r4,LSL #5
0001fe  6001              STR      r1,[r0,#0]
                  |L21.512|
;;;844            }
;;;845    
;;;846            (void)USB_WritePacket(USBx, ep->xfer_buff, ep->num, (uint16_t)ep->xfer_len, dma);
000200  9700              STR      r7,[sp,#0]
000202  8b30              LDRH     r0,[r6,#0x18]
000204  b283              UXTH     r3,r0
000206  7832              LDRB     r2,[r6,#0]
000208  4648              MOV      r0,r9
00020a  6931              LDR      r1,[r6,#0x10]
00020c  f7fffffe          BL       USB_WritePacket
000210  e095              B        |L21.830|
                  |L21.530|
;;;847          }
;;;848        }
;;;849      }
;;;850      else /* OUT endpoint */
;;;851      {
;;;852        /* Program the transfer size and packet count as follows:
;;;853        * pktcnt = N
;;;854        * xfersize = N * maxpacket
;;;855        */
;;;856        USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
000212  f5056030          ADD      r0,r5,#0xb00
000216  eb001044          ADD      r0,r0,r4,LSL #5
00021a  6900              LDR      r0,[r0,#0x10]
00021c  0cc1              LSRS     r1,r0,#19
00021e  04c9              LSLS     r1,r1,#19
000220  f5056030          ADD      r0,r5,#0xb00
000224  eb001044          ADD      r0,r0,r4,LSL #5
000228  6101              STR      r1,[r0,#0x10]
;;;857        USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
00022a  f5056030          ADD      r0,r5,#0xb00
00022e  eb001044          ADD      r0,r0,r4,LSL #5
000232  6900              LDR      r0,[r0,#0x10]
000234  4943              LDR      r1,|L21.836|
000236  4008              ANDS     r0,r0,r1
000238  f5056130          ADD      r1,r5,#0xb00
00023c  eb011144          ADD      r1,r1,r4,LSL #5
000240  6108              STR      r0,[r1,#0x10]
;;;858    
;;;859        if (ep->xfer_len == 0U)
000242  69b0              LDR      r0,[r6,#0x18]
000244  b9d0              CBNZ     r0,|L21.636|
;;;860        {
;;;861          USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
000246  f5056030          ADD      r0,r5,#0xb00
00024a  eb001044          ADD      r0,r0,r4,LSL #5
00024e  6900              LDR      r0,[r0,#0x10]
000250  68f1              LDR      r1,[r6,#0xc]
000252  f3c10112          UBFX     r1,r1,#0,#19
000256  4308              ORRS     r0,r0,r1
000258  f5056130          ADD      r1,r5,#0xb00
00025c  eb011144          ADD      r1,r1,r4,LSL #5
000260  6108              STR      r0,[r1,#0x10]
;;;862          USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
000262  f5056030          ADD      r0,r5,#0xb00
000266  eb001044          ADD      r0,r0,r4,LSL #5
00026a  6900              LDR      r0,[r0,#0x10]
00026c  f4402100          ORR      r1,r0,#0x80000
000270  f5056030          ADD      r0,r5,#0xb00
000274  eb001044          ADD      r0,r0,r4,LSL #5
000278  6101              STR      r1,[r0,#0x10]
00027a  e028              B        |L21.718|
                  |L21.636|
;;;863        }
;;;864        else
;;;865        {
;;;866          pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
00027c  68f1              LDR      r1,[r6,#0xc]
00027e  69b0              LDR      r0,[r6,#0x18]
000280  4408              ADD      r0,r0,r1
000282  1e40              SUBS     r0,r0,#1
000284  fbb0f0f1          UDIV     r0,r0,r1
000288  fa1ff880          UXTH     r8,r0
;;;867          ep->xfer_size = ep->maxpacket * pktcnt;
00028c  68f0              LDR      r0,[r6,#0xc]
00028e  fb00f008          MUL      r0,r0,r8
000292  61f0              STR      r0,[r6,#0x1c]
;;;868    
;;;869          USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
000294  f5056030          ADD      r0,r5,#0xb00
000298  eb001044          ADD      r0,r0,r4,LSL #5
00029c  6900              LDR      r0,[r0,#0x10]
00029e  4929              LDR      r1,|L21.836|
0002a0  43c9              MVNS     r1,r1
0002a2  ea0141c8          AND      r1,r1,r8,LSL #19
0002a6  4308              ORRS     r0,r0,r1
0002a8  f5056130          ADD      r1,r5,#0xb00
0002ac  eb011144          ADD      r1,r1,r4,LSL #5
0002b0  6108              STR      r0,[r1,#0x10]
;;;870          USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size;
0002b2  f5056030          ADD      r0,r5,#0xb00
0002b6  eb001044          ADD      r0,r0,r4,LSL #5
0002ba  6900              LDR      r0,[r0,#0x10]
0002bc  69f1              LDR      r1,[r6,#0x1c]
0002be  f3c10112          UBFX     r1,r1,#0,#19
0002c2  4308              ORRS     r0,r0,r1
0002c4  f5056130          ADD      r1,r5,#0xb00
0002c8  eb011144          ADD      r1,r1,r4,LSL #5
0002cc  6108              STR      r0,[r1,#0x10]
                  |L21.718|
;;;871        }
;;;872    
;;;873        if (dma == 1U)
0002ce  2f01              CMP      r7,#1
0002d0  d107              BNE      |L21.738|
;;;874        {
;;;875          if ((uint32_t)ep->xfer_buff != 0U)
0002d2  6930              LDR      r0,[r6,#0x10]
0002d4  b128              CBZ      r0,|L21.738|
;;;876          {
;;;877            USBx_OUTEP(epnum)->DOEPDMA = (uint32_t)(ep->xfer_buff);
0002d6  f5056030          ADD      r0,r5,#0xb00
0002da  eb001044          ADD      r0,r0,r4,LSL #5
0002de  6931              LDR      r1,[r6,#0x10]
0002e0  6141              STR      r1,[r0,#0x14]
                  |L21.738|
;;;878          }
;;;879        }
;;;880    
;;;881        if (ep->type == EP_TYPE_ISOC)
0002e2  7930              LDRB     r0,[r6,#4]
0002e4  2801              CMP      r0,#1
0002e6  d11e              BNE      |L21.806|
;;;882        {
;;;883          if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
0002e8  f6400008          MOV      r0,#0x808
0002ec  5940              LDR      r0,[r0,r5]
0002ee  f4007080          AND      r0,r0,#0x100
0002f2  b960              CBNZ     r0,|L21.782|
;;;884          {
;;;885            USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
0002f4  f5056030          ADD      r0,r5,#0xb00
0002f8  eb001044          ADD      r0,r0,r4,LSL #5
0002fc  6800              LDR      r0,[r0,#0]
0002fe  f0405100          ORR      r1,r0,#0x20000000
000302  f5056030          ADD      r0,r5,#0xb00
000306  eb001044          ADD      r0,r0,r4,LSL #5
00030a  6001              STR      r1,[r0,#0]
00030c  e00b              B        |L21.806|
                  |L21.782|
;;;886          }
;;;887          else
;;;888          {
;;;889            USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
00030e  f5056030          ADD      r0,r5,#0xb00
000312  eb001044          ADD      r0,r0,r4,LSL #5
000316  6800              LDR      r0,[r0,#0]
000318  f0405180          ORR      r1,r0,#0x10000000
00031c  f5056030          ADD      r0,r5,#0xb00
000320  eb001044          ADD      r0,r0,r4,LSL #5
000324  6001              STR      r1,[r0,#0]
                  |L21.806|
;;;890          }
;;;891        }
;;;892        /* EP enable */
;;;893        USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
000326  f5056030          ADD      r0,r5,#0xb00
00032a  eb001044          ADD      r0,r0,r4,LSL #5
00032e  6800              LDR      r0,[r0,#0]
000330  f0404104          ORR      r1,r0,#0x84000000
000334  f5056030          ADD      r0,r5,#0xb00
000338  eb001044          ADD      r0,r0,r4,LSL #5
00033c  6001              STR      r1,[r0,#0]
                  |L21.830|
;;;894      }
;;;895    
;;;896      return HAL_OK;
00033e  2000              MOVS     r0,#0
;;;897    }
000340  e8bd83f8          POP      {r3-r9,pc}
;;;898    
                          ENDP

                  |L21.836|
                          DCD      0xe007ffff

                          AREA ||i.USB_EPStopXfer||, CODE, READONLY, ALIGN=1

                  USB_EPStopXfer PROC
;;;1005      */
;;;1006   HAL_StatusTypeDef USB_EPStopXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
000000  b578              PUSH     {r3-r6,lr}
;;;1007   {
000002  4603              MOV      r3,r0
;;;1008     __IO uint32_t count = 0U;
000004  2400              MOVS     r4,#0
000006  9400              STR      r4,[sp,#0]
;;;1009     HAL_StatusTypeDef ret = HAL_OK;
000008  2000              MOVS     r0,#0
;;;1010     uint32_t USBx_BASE = (uint32_t)USBx;
00000a  461a              MOV      r2,r3
;;;1011   
;;;1012     /* IN endpoint */
;;;1013     if (ep->is_in == 1U)
00000c  784c              LDRB     r4,[r1,#1]
00000e  2c01              CMP      r4,#1
000010  d135              BNE      |L22.126|
;;;1014     {
;;;1015       /* EP enable, IN data in FIFO */
;;;1016       if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
000012  780c              LDRB     r4,[r1,#0]
000014  f5026510          ADD      r5,r2,#0x900
000018  eb051444          ADD      r4,r5,r4,LSL #5
00001c  6824              LDR      r4,[r4,#0]
00001e  f0044400          AND      r4,r4,#0x80000000
000022  f1b44f00          CMP      r4,#0x80000000
000026  d160              BNE      |L22.234|
;;;1017       {
;;;1018         USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_SNAK);
000028  780c              LDRB     r4,[r1,#0]
00002a  eb051444          ADD      r4,r5,r4,LSL #5
00002e  6824              LDR      r4,[r4,#0]
000030  f0446600          ORR      r6,r4,#0x8000000
000034  780c              LDRB     r4,[r1,#0]
000036  eb051444          ADD      r4,r5,r4,LSL #5
00003a  6026              STR      r6,[r4,#0]
;;;1019         USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_EPDIS);
00003c  780c              LDRB     r4,[r1,#0]
00003e  eb051444          ADD      r4,r5,r4,LSL #5
000042  6824              LDR      r4,[r4,#0]
000044  f0444680          ORR      r6,r4,#0x40000000
000048  780c              LDRB     r4,[r1,#0]
00004a  eb051444          ADD      r4,r5,r4,LSL #5
00004e  6026              STR      r6,[r4,#0]
;;;1020   
;;;1021         do
000050  bf00              NOP      
                  |L22.82|
;;;1022         {
;;;1023           count++;
000052  9c00              LDR      r4,[sp,#0]
000054  1c64              ADDS     r4,r4,#1
000056  9400              STR      r4,[sp,#0]
;;;1024   
;;;1025           if (count > 10000U)
000058  f2427510          MOV      r5,#0x2710
00005c  9c00              LDR      r4,[sp,#0]
00005e  42ac              CMP      r4,r5
000060  d901              BLS      |L22.102|
;;;1026           {
;;;1027             ret = HAL_ERROR;
000062  2001              MOVS     r0,#1
;;;1028             break;
000064  e00a              B        |L22.124|
                  |L22.102|
;;;1029           }
;;;1030         } while (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) ==  USB_OTG_DIEPCTL_EPENA);
000066  780c              LDRB     r4,[r1,#0]
000068  f5026510          ADD      r5,r2,#0x900
00006c  eb051444          ADD      r4,r5,r4,LSL #5
000070  6824              LDR      r4,[r4,#0]
000072  f0044400          AND      r4,r4,#0x80000000
000076  f1b44f00          CMP      r4,#0x80000000
00007a  d0ea              BEQ      |L22.82|
                  |L22.124|
00007c  e035              B        |L22.234|
                  |L22.126|
;;;1031       }
;;;1032     }
;;;1033     else /* OUT endpoint */
;;;1034     {
;;;1035       if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
00007e  780c              LDRB     r4,[r1,#0]
000080  f5026530          ADD      r5,r2,#0xb00
000084  eb051444          ADD      r4,r5,r4,LSL #5
000088  6824              LDR      r4,[r4,#0]
00008a  f0044400          AND      r4,r4,#0x80000000
00008e  f1b44f00          CMP      r4,#0x80000000
000092  d12a              BNE      |L22.234|
;;;1036       {
;;;1037         USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_SNAK);
000094  780c              LDRB     r4,[r1,#0]
000096  eb051444          ADD      r4,r5,r4,LSL #5
00009a  6824              LDR      r4,[r4,#0]
00009c  f0446600          ORR      r6,r4,#0x8000000
0000a0  780c              LDRB     r4,[r1,#0]
0000a2  eb051444          ADD      r4,r5,r4,LSL #5
0000a6  6026              STR      r6,[r4,#0]
;;;1038         USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_EPDIS);
0000a8  780c              LDRB     r4,[r1,#0]
0000aa  eb051444          ADD      r4,r5,r4,LSL #5
0000ae  6824              LDR      r4,[r4,#0]
0000b0  f0444680          ORR      r6,r4,#0x40000000
0000b4  780c              LDRB     r4,[r1,#0]
0000b6  eb051444          ADD      r4,r5,r4,LSL #5
0000ba  6026              STR      r6,[r4,#0]
;;;1039   
;;;1040         do
0000bc  bf00              NOP      
                  |L22.190|
;;;1041         {
;;;1042           count++;
0000be  9c00              LDR      r4,[sp,#0]
0000c0  1c64              ADDS     r4,r4,#1
0000c2  9400              STR      r4,[sp,#0]
;;;1043   
;;;1044           if (count > 10000U)
0000c4  f2427510          MOV      r5,#0x2710
0000c8  9c00              LDR      r4,[sp,#0]
0000ca  42ac              CMP      r4,r5
0000cc  d901              BLS      |L22.210|
;;;1045           {
;;;1046             ret = HAL_ERROR;
0000ce  2001              MOVS     r0,#1
;;;1047             break;
0000d0  e00a              B        |L22.232|
                  |L22.210|
;;;1048           }
;;;1049         } while (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) ==  USB_OTG_DOEPCTL_EPENA);
0000d2  780c              LDRB     r4,[r1,#0]
0000d4  f5026530          ADD      r5,r2,#0xb00
0000d8  eb051444          ADD      r4,r5,r4,LSL #5
0000dc  6824              LDR      r4,[r4,#0]
0000de  f0044400          AND      r4,r4,#0x80000000
0000e2  f1b44f00          CMP      r4,#0x80000000
0000e6  d0ea              BEQ      |L22.190|
                  |L22.232|
0000e8  bf00              NOP                            ;1047
                  |L22.234|
;;;1050       }
;;;1051     }
;;;1052   
;;;1053     return ret;
;;;1054   }
0000ea  bd78              POP      {r3-r6,pc}
;;;1055   
                          ENDP


                          AREA ||i.USB_EnableGlobalInt||, CODE, READONLY, ALIGN=1

                  USB_EnableGlobalInt PROC
;;;221      */
;;;222    HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
000000  4601              MOV      r1,r0
;;;223    {
;;;224      USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
000002  6888              LDR      r0,[r1,#8]
000004  f0400001          ORR      r0,r0,#1
000008  6088              STR      r0,[r1,#8]
;;;225      return HAL_OK;
00000a  2000              MOVS     r0,#0
;;;226    }
00000c  4770              BX       lr
;;;227    
                          ENDP


                          AREA ||i.USB_FlushRxFifo||, CODE, READONLY, ALIGN=2

                  USB_FlushRxFifo PROC
;;;508      */
;;;509    HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
000000  b508              PUSH     {r3,lr}
;;;510    {
000002  4601              MOV      r1,r0
;;;511      __IO uint32_t count = 0U;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;512    
;;;513      /* Wait for AHB master IDLE state. */
;;;514      do
000008  bf00              NOP      
                  |L24.10|
;;;515      {
;;;516        count++;
00000a  9800              LDR      r0,[sp,#0]
00000c  1c40              ADDS     r0,r0,#1
00000e  9000              STR      r0,[sp,#0]
;;;517    
;;;518        if (count > 200000U)
000010  4a0f              LDR      r2,|L24.80|
000012  9800              LDR      r0,[sp,#0]
000014  4290              CMP      r0,r2
000016  d901              BLS      |L24.28|
;;;519        {
;;;520          return HAL_TIMEOUT;
000018  2003              MOVS     r0,#3
                  |L24.26|
;;;521        }
;;;522      } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
;;;523    
;;;524      /* Flush RX Fifo */
;;;525      count = 0U;
;;;526      USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
;;;527    
;;;528      do
;;;529      {
;;;530        count++;
;;;531    
;;;532        if (count > 200000U)
;;;533        {
;;;534          return HAL_TIMEOUT;
;;;535        }
;;;536      } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
;;;537    
;;;538      return HAL_OK;
;;;539    }
00001a  bd08              POP      {r3,pc}
                  |L24.28|
00001c  6908              LDR      r0,[r1,#0x10]         ;522
00001e  f0004000          AND      r0,r0,#0x80000000     ;522
000022  2800              CMP      r0,#0                 ;522
000024  d0f1              BEQ      |L24.10|
000026  2000              MOVS     r0,#0                 ;525
000028  9000              STR      r0,[sp,#0]            ;525
00002a  2010              MOVS     r0,#0x10              ;526
00002c  6108              STR      r0,[r1,#0x10]         ;526
00002e  bf00              NOP                            ;528
                  |L24.48|
000030  9800              LDR      r0,[sp,#0]            ;530
000032  1c40              ADDS     r0,r0,#1              ;530
000034  9000              STR      r0,[sp,#0]            ;530
000036  4a06              LDR      r2,|L24.80|
000038  9800              LDR      r0,[sp,#0]            ;532
00003a  4290              CMP      r0,r2                 ;532
00003c  d901              BLS      |L24.66|
00003e  2003              MOVS     r0,#3                 ;534
000040  e7eb              B        |L24.26|
                  |L24.66|
000042  6908              LDR      r0,[r1,#0x10]         ;536
000044  f0000010          AND      r0,r0,#0x10           ;536
000048  2810              CMP      r0,#0x10              ;536
00004a  d0f1              BEQ      |L24.48|
00004c  2000              MOVS     r0,#0                 ;538
00004e  e7e4              B        |L24.26|
;;;540    
                          ENDP

                  |L24.80|
                          DCD      0x00030d40

                          AREA ||i.USB_FlushTxFifo||, CODE, READONLY, ALIGN=2

                  USB_FlushTxFifo PROC
;;;471      */
;;;472    HAL_StatusTypeDef USB_FlushTxFifo(USB_OTG_GlobalTypeDef *USBx, uint32_t num)
000000  b508              PUSH     {r3,lr}
;;;473    {
000002  4602              MOV      r2,r0
;;;474      __IO uint32_t count = 0U;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;475    
;;;476      /* Wait for AHB master IDLE state. */
;;;477      do
000008  bf00              NOP      
                  |L25.10|
;;;478      {
;;;479        count++;
00000a  9800              LDR      r0,[sp,#0]
00000c  1c40              ADDS     r0,r0,#1
00000e  9000              STR      r0,[sp,#0]
;;;480    
;;;481        if (count > 200000U)
000010  4b10              LDR      r3,|L25.84|
000012  9800              LDR      r0,[sp,#0]
000014  4298              CMP      r0,r3
000016  d901              BLS      |L25.28|
;;;482        {
;;;483          return HAL_TIMEOUT;
000018  2003              MOVS     r0,#3
                  |L25.26|
;;;484        }
;;;485      } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
;;;486    
;;;487      /* Flush TX Fifo */
;;;488      count = 0U;
;;;489      USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
;;;490    
;;;491      do
;;;492      {
;;;493        count++;
;;;494    
;;;495        if (count > 200000U)
;;;496        {
;;;497          return HAL_TIMEOUT;
;;;498        }
;;;499      } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
;;;500    
;;;501      return HAL_OK;
;;;502    }
00001a  bd08              POP      {r3,pc}
                  |L25.28|
00001c  6910              LDR      r0,[r2,#0x10]         ;485
00001e  f0004000          AND      r0,r0,#0x80000000     ;485
000022  2800              CMP      r0,#0                 ;485
000024  d0f1              BEQ      |L25.10|
000026  2000              MOVS     r0,#0                 ;488
000028  9000              STR      r0,[sp,#0]            ;488
00002a  2020              MOVS     r0,#0x20              ;489
00002c  ea401081          ORR      r0,r0,r1,LSL #6       ;489
000030  6110              STR      r0,[r2,#0x10]         ;489
000032  bf00              NOP                            ;491
                  |L25.52|
000034  9800              LDR      r0,[sp,#0]            ;493
000036  1c40              ADDS     r0,r0,#1              ;493
000038  9000              STR      r0,[sp,#0]            ;493
00003a  4b06              LDR      r3,|L25.84|
00003c  9800              LDR      r0,[sp,#0]            ;495
00003e  4298              CMP      r0,r3                 ;495
000040  d901              BLS      |L25.70|
000042  2003              MOVS     r0,#3                 ;497
000044  e7e9              B        |L25.26|
                  |L25.70|
000046  6910              LDR      r0,[r2,#0x10]         ;499
000048  f0000020          AND      r0,r0,#0x20           ;499
00004c  2820              CMP      r0,#0x20              ;499
00004e  d0f1              BEQ      |L25.52|
000050  2000              MOVS     r0,#0                 ;501
000052  e7e2              B        |L25.26|
;;;503    
                          ENDP

                  |L25.84|
                          DCD      0x00030d40

                          AREA ||i.USB_GetCurrentFrame||, CODE, READONLY, ALIGN=1

                  USB_GetCurrentFrame PROC
;;;1707     */
;;;1708   uint32_t USB_GetCurrentFrame(USB_OTG_GlobalTypeDef *USBx)
000000  4601              MOV      r1,r0
;;;1709   {
;;;1710     uint32_t USBx_BASE = (uint32_t)USBx;
000002  460a              MOV      r2,r1
;;;1711   
;;;1712     return (USBx_HOST->HFNUM & USB_OTG_HFNUM_FRNUM);
000004  f44f6081          MOV      r0,#0x408
000008  5880              LDR      r0,[r0,r2]
00000a  b280              UXTH     r0,r0
;;;1713   }
00000c  4770              BX       lr
;;;1714   
                          ENDP


                          AREA ||i.USB_GetDevSpeed||, CODE, READONLY, ALIGN=1

                  USB_GetDevSpeed PROC
;;;567      */
;;;568    uint8_t USB_GetDevSpeed(USB_OTG_GlobalTypeDef *USBx)
000000  b510              PUSH     {r4,lr}
;;;569    {
000002  4601              MOV      r1,r0
;;;570      uint32_t USBx_BASE = (uint32_t)USBx;
000004  460b              MOV      r3,r1
;;;571      uint8_t speed;
;;;572      uint32_t DevEnumSpeed = USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD;
000006  f6400408          MOV      r4,#0x808
00000a  58e4              LDR      r4,[r4,r3]
00000c  f0040206          AND      r2,r4,#6
;;;573    
;;;574      if (DevEnumSpeed == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
000010  b90a              CBNZ     r2,|L27.22|
;;;575      {
;;;576        speed = USBD_HS_SPEED;
000012  2000              MOVS     r0,#0
000014  e006              B        |L27.36|
                  |L27.22|
;;;577      }
;;;578      else if ((DevEnumSpeed == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ) ||
000016  2a02              CMP      r2,#2
000018  d001              BEQ      |L27.30|
;;;579               (DevEnumSpeed == DSTS_ENUMSPD_FS_PHY_48MHZ))
00001a  2a06              CMP      r2,#6
00001c  d101              BNE      |L27.34|
                  |L27.30|
;;;580      {
;;;581        speed = USBD_FS_SPEED;
00001e  2002              MOVS     r0,#2
000020  e000              B        |L27.36|
                  |L27.34|
;;;582      }
;;;583      else
;;;584      {
;;;585        speed = 0xFU;
000022  200f              MOVS     r0,#0xf
                  |L27.36|
;;;586      }
;;;587    
;;;588      return speed;
;;;589    }
000024  bd10              POP      {r4,pc}
;;;590    
                          ENDP


                          AREA ||i.USB_GetHostSpeed||, CODE, READONLY, ALIGN=1

                  USB_GetHostSpeed PROC
;;;1693     */
;;;1694   uint32_t USB_GetHostSpeed(USB_OTG_GlobalTypeDef *USBx)
000000  b508              PUSH     {r3,lr}
;;;1695   {
000002  4601              MOV      r1,r0
;;;1696     uint32_t USBx_BASE = (uint32_t)USBx;
000004  460a              MOV      r2,r1
;;;1697     __IO uint32_t hprt0 = 0U;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;1698   
;;;1699     hprt0 = USBx_HPRT0;
00000a  f8d20440          LDR      r0,[r2,#0x440]
00000e  9000              STR      r0,[sp,#0]
;;;1700     return ((hprt0 & USB_OTG_HPRT_PSPD) >> 17);
000010  9800              LDR      r0,[sp,#0]
000012  f3c04041          UBFX     r0,r0,#17,#2
;;;1701   }
000016  bd08              POP      {r3,pc}
;;;1702   
                          ENDP


                          AREA ||i.USB_GetMode||, CODE, READONLY, ALIGN=1

                  USB_GetMode PROC
;;;1393     */
;;;1394   uint32_t USB_GetMode(USB_OTG_GlobalTypeDef *USBx)
000000  4601              MOV      r1,r0
;;;1395   {
;;;1396     return ((USBx->GINTSTS) & 0x1U);
000002  6948              LDR      r0,[r1,#0x14]
000004  f0000001          AND      r0,r0,#1
;;;1397   }
000008  4770              BX       lr
;;;1398   
                          ENDP


                          AREA ||i.USB_HC_Halt||, CODE, READONLY, ALIGN=1

                  USB_HC_Halt PROC
;;;2017     */
;;;2018   HAL_StatusTypeDef USB_HC_Halt(USB_OTG_GlobalTypeDef *USBx, uint8_t hc_num)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2019   {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;2020     uint32_t USBx_BASE = (uint32_t)USBx;
000006  461a              MOV      r2,r3
;;;2021     uint32_t hcnum = (uint32_t)hc_num;
000008  4621              MOV      r1,r4
;;;2022     __IO uint32_t count = 0U;
00000a  2000              MOVS     r0,#0
00000c  9000              STR      r0,[sp,#0]
;;;2023     uint32_t HcEpType = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_EPTYP) >> 18;
00000e  f50260a0          ADD      r0,r2,#0x500
000012  eb001041          ADD      r0,r0,r1,LSL #5
000016  6800              LDR      r0,[r0,#0]
000018  f3c04581          UBFX     r5,r0,#18,#2
;;;2024     uint32_t ChannelEna = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) >> 31;
00001c  f50260a0          ADD      r0,r2,#0x500
000020  eb001041          ADD      r0,r0,r1,LSL #5
000024  6800              LDR      r0,[r0,#0]
000026  0fc6              LSRS     r6,r0,#31
;;;2025   
;;;2026     if (((USBx->GAHBCFG & USB_OTG_GAHBCFG_DMAEN) == USB_OTG_GAHBCFG_DMAEN) &&
000028  6898              LDR      r0,[r3,#8]
00002a  f0000020          AND      r0,r0,#0x20
00002e  2820              CMP      r0,#0x20
000030  d102              BNE      |L30.56|
;;;2027         (ChannelEna == 0U))
000032  b90e              CBNZ     r6,|L30.56|
;;;2028     {
;;;2029       return HAL_OK;
000034  2000              MOVS     r0,#0
                  |L30.54|
;;;2030     }
;;;2031   
;;;2032     /* Check for space in the request queue to issue the halt. */
;;;2033     if ((HcEpType == HCCHAR_CTRL) || (HcEpType == HCCHAR_BULK))
;;;2034     {
;;;2035       USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
;;;2036   
;;;2037       if ((USBx->GAHBCFG & USB_OTG_GAHBCFG_DMAEN) == 0U)
;;;2038       {
;;;2039         if ((USBx->HNPTXSTS & (0xFFU << 16)) == 0U)
;;;2040         {
;;;2041           USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
;;;2042           USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
;;;2043           do
;;;2044           {
;;;2045             count++;
;;;2046   
;;;2047             if (count > 1000U)
;;;2048             {
;;;2049               break;
;;;2050             }
;;;2051           } while ((USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
;;;2052         }
;;;2053         else
;;;2054         {
;;;2055           USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
;;;2056         }
;;;2057       }
;;;2058     }
;;;2059     else
;;;2060     {
;;;2061       USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
;;;2062   
;;;2063       if ((USBx_HOST->HPTXSTS & (0xFFU << 16)) == 0U)
;;;2064       {
;;;2065         USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
;;;2066         USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
;;;2067         do
;;;2068         {
;;;2069           count++;
;;;2070   
;;;2071           if (count > 1000U)
;;;2072           {
;;;2073             break;
;;;2074           }
;;;2075         } while ((USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
;;;2076       }
;;;2077       else
;;;2078       {
;;;2079         USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
;;;2080       }
;;;2081     }
;;;2082   
;;;2083     return HAL_OK;
;;;2084   }
000036  bdf8              POP      {r3-r7,pc}
                  |L30.56|
000038  b10d              CBZ      r5,|L30.62|
00003a  2d02              CMP      r5,#2                 ;2033
00003c  d14d              BNE      |L30.218|
                  |L30.62|
00003e  f50260a0          ADD      r0,r2,#0x500          ;2035
000042  eb001041          ADD      r0,r0,r1,LSL #5       ;2035
000046  6800              LDR      r0,[r0,#0]            ;2035
000048  f0404780          ORR      r7,r0,#0x40000000     ;2035
00004c  f50260a0          ADD      r0,r2,#0x500          ;2035
000050  eb001041          ADD      r0,r0,r1,LSL #5       ;2035
000054  6007              STR      r7,[r0,#0]            ;2035
000056  6898              LDR      r0,[r3,#8]            ;2037
000058  f0000020          AND      r0,r0,#0x20           ;2037
00005c  2800              CMP      r0,#0                 ;2037
00005e  d12e              BNE      |L30.190|
000060  6ad8              LDR      r0,[r3,#0x2c]         ;2039
000062  f400007f          AND      r0,r0,#0xff0000       ;2039
000066  bb58              CBNZ     r0,|L30.192|
000068  f50260a0          ADD      r0,r2,#0x500          ;2041
00006c  eb001041          ADD      r0,r0,r1,LSL #5       ;2041
000070  6800              LDR      r0,[r0,#0]            ;2041
000072  f0204700          BIC      r7,r0,#0x80000000     ;2041
000076  f50260a0          ADD      r0,r2,#0x500          ;2041
00007a  eb001041          ADD      r0,r0,r1,LSL #5       ;2041
00007e  6007              STR      r7,[r0,#0]            ;2041
000080  f50260a0          ADD      r0,r2,#0x500          ;2042
000084  eb001041          ADD      r0,r0,r1,LSL #5       ;2042
000088  6800              LDR      r0,[r0,#0]            ;2042
00008a  f0404700          ORR      r7,r0,#0x80000000     ;2042
00008e  f50260a0          ADD      r0,r2,#0x500          ;2042
000092  eb001041          ADD      r0,r0,r1,LSL #5       ;2042
000096  6007              STR      r7,[r0,#0]            ;2042
000098  bf00              NOP                            ;2043
                  |L30.154|
00009a  9800              LDR      r0,[sp,#0]            ;2045
00009c  1c40              ADDS     r0,r0,#1              ;2045
00009e  9000              STR      r0,[sp,#0]            ;2045
0000a0  9800              LDR      r0,[sp,#0]            ;2047
0000a2  f5b07f7a          CMP      r0,#0x3e8             ;2047
0000a6  d900              BLS      |L30.170|
0000a8  e009              B        |L30.190|
                  |L30.170|
0000aa  f50260a0          ADD      r0,r2,#0x500          ;2051
0000ae  eb001041          ADD      r0,r0,r1,LSL #5       ;2051
0000b2  6800              LDR      r0,[r0,#0]            ;2051
0000b4  f0004000          AND      r0,r0,#0x80000000     ;2051
0000b8  f1b04f00          CMP      r0,#0x80000000        ;2051
0000bc  d0ed              BEQ      |L30.154|
                  |L30.190|
0000be  e056              B        |L30.366|
                  |L30.192|
0000c0  f50260a0          ADD      r0,r2,#0x500          ;2055
0000c4  eb001041          ADD      r0,r0,r1,LSL #5       ;2055
0000c8  6800              LDR      r0,[r0,#0]            ;2055
0000ca  f0404700          ORR      r7,r0,#0x80000000     ;2055
0000ce  f50260a0          ADD      r0,r2,#0x500          ;2055
0000d2  eb001041          ADD      r0,r0,r1,LSL #5       ;2055
0000d6  6007              STR      r7,[r0,#0]            ;2055
0000d8  e049              B        |L30.366|
                  |L30.218|
0000da  f50260a0          ADD      r0,r2,#0x500          ;2061
0000de  eb001041          ADD      r0,r0,r1,LSL #5       ;2061
0000e2  6800              LDR      r0,[r0,#0]            ;2061
0000e4  f0404780          ORR      r7,r0,#0x40000000     ;2061
0000e8  f50260a0          ADD      r0,r2,#0x500          ;2061
0000ec  eb001041          ADD      r0,r0,r1,LSL #5       ;2061
0000f0  6007              STR      r7,[r0,#0]            ;2061
0000f2  f44f6082          MOV      r0,#0x410             ;2063
0000f6  5880              LDR      r0,[r0,r2]            ;2063
0000f8  f400007f          AND      r0,r0,#0xff0000       ;2063
0000fc  bb58              CBNZ     r0,|L30.342|
0000fe  f50260a0          ADD      r0,r2,#0x500          ;2065
000102  eb001041          ADD      r0,r0,r1,LSL #5       ;2065
000106  6800              LDR      r0,[r0,#0]            ;2065
000108  f0204700          BIC      r7,r0,#0x80000000     ;2065
00010c  f50260a0          ADD      r0,r2,#0x500          ;2065
000110  eb001041          ADD      r0,r0,r1,LSL #5       ;2065
000114  6007              STR      r7,[r0,#0]            ;2065
000116  f50260a0          ADD      r0,r2,#0x500          ;2066
00011a  eb001041          ADD      r0,r0,r1,LSL #5       ;2066
00011e  6800              LDR      r0,[r0,#0]            ;2066
000120  f0404700          ORR      r7,r0,#0x80000000     ;2066
000124  f50260a0          ADD      r0,r2,#0x500          ;2066
000128  eb001041          ADD      r0,r0,r1,LSL #5       ;2066
00012c  6007              STR      r7,[r0,#0]            ;2066
00012e  bf00              NOP                            ;2067
                  |L30.304|
000130  9800              LDR      r0,[sp,#0]            ;2069
000132  1c40              ADDS     r0,r0,#1              ;2069
000134  9000              STR      r0,[sp,#0]            ;2069
000136  9800              LDR      r0,[sp,#0]            ;2071
000138  f5b07f7a          CMP      r0,#0x3e8             ;2071
00013c  d900              BLS      |L30.320|
00013e  e009              B        |L30.340|
                  |L30.320|
000140  f50260a0          ADD      r0,r2,#0x500          ;2075
000144  eb001041          ADD      r0,r0,r1,LSL #5       ;2075
000148  6800              LDR      r0,[r0,#0]            ;2075
00014a  f0004000          AND      r0,r0,#0x80000000     ;2075
00014e  f1b04f00          CMP      r0,#0x80000000        ;2075
000152  d0ed              BEQ      |L30.304|
                  |L30.340|
000154  e00b              B        |L30.366|
                  |L30.342|
000156  f50260a0          ADD      r0,r2,#0x500          ;2079
00015a  eb001041          ADD      r0,r0,r1,LSL #5       ;2079
00015e  6800              LDR      r0,[r0,#0]            ;2079
000160  f0404700          ORR      r7,r0,#0x80000000     ;2079
000164  f50260a0          ADD      r0,r2,#0x500          ;2079
000168  eb001041          ADD      r0,r0,r1,LSL #5       ;2079
00016c  6007              STR      r7,[r0,#0]            ;2079
                  |L30.366|
00016e  2000              MOVS     r0,#0                 ;2083
000170  e761              B        |L30.54|
;;;2085   
                          ENDP


                          AREA ||i.USB_HC_Init||, CODE, READONLY, ALIGN=1

                  USB_HC_Init PROC
;;;1738     */
;;;1739   HAL_StatusTypeDef USB_HC_Init(USB_OTG_GlobalTypeDef *USBx, uint8_t ch_num,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1740                                 uint8_t epnum, uint8_t dev_address, uint8_t speed,
;;;1741                                 uint8_t ep_type, uint16_t mps)
;;;1742   {
000004  b081              SUB      sp,sp,#4
000006  4606              MOV      r6,r0
000008  460c              MOV      r4,r1
00000a  4617              MOV      r7,r2
00000c  f8dd803c          LDR      r8,[sp,#0x3c]
;;;1743     HAL_StatusTypeDef ret = HAL_OK;
000010  2000              MOVS     r0,#0
000012  9000              STR      r0,[sp,#0]
;;;1744     uint32_t USBx_BASE = (uint32_t)USBx;
000014  4635              MOV      r5,r6
;;;1745     uint32_t HCcharEpDir;
;;;1746     uint32_t HCcharLowSpeed;
;;;1747     uint32_t HostCoreSpeed;
;;;1748   
;;;1749     /* Clear old interrupt conditions for this host channel. */
;;;1750     USBx_HC((uint32_t)ch_num)->HCINT = 0xFFFFFFFFU;
000016  1e41              SUBS     r1,r0,#1
000018  f50560a0          ADD      r0,r5,#0x500
00001c  eb001044          ADD      r0,r0,r4,LSL #5
000020  6081              STR      r1,[r0,#8]
;;;1751   
;;;1752     /* Enable channel interrupts required for this transfer. */
;;;1753     switch (ep_type)
000022  f1b80f00          CMP      r8,#0
000026  d009              BEQ      |L31.60|
000028  f1b80f01          CMP      r8,#1
00002c  d048              BEQ      |L31.192|
00002e  f1b80f02          CMP      r8,#2
000032  d004              BEQ      |L31.62|
000034  f1b80f03          CMP      r8,#3
000038  d15a              BNE      |L31.240|
00003a  e029              B        |L31.144|
                  |L31.60|
;;;1754     {
;;;1755       case EP_TYPE_CTRL:
;;;1756       case EP_TYPE_BULK:
00003c  bf00              NOP      
                  |L31.62|
;;;1757         USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
00003e  f240419d          MOV      r1,#0x49d
000042  f50560a0          ADD      r0,r5,#0x500
000046  eb001044          ADD      r0,r0,r4,LSL #5
00004a  60c1              STR      r1,[r0,#0xc]
;;;1758                                               USB_OTG_HCINTMSK_STALLM |
;;;1759                                               USB_OTG_HCINTMSK_TXERRM |
;;;1760                                               USB_OTG_HCINTMSK_DTERRM |
;;;1761                                               USB_OTG_HCINTMSK_AHBERR |
;;;1762                                               USB_OTG_HCINTMSK_NAKM;
;;;1763   
;;;1764         if ((epnum & 0x80U) == 0x80U)
00004c  f0070080          AND      r0,r7,#0x80
000050  2880              CMP      r0,#0x80
000052  d10c              BNE      |L31.110|
;;;1765         {
;;;1766           USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;
000054  f50560a0          ADD      r0,r5,#0x500
000058  eb001044          ADD      r0,r0,r4,LSL #5
00005c  68c0              LDR      r0,[r0,#0xc]
00005e  f4407180          ORR      r1,r0,#0x100
000062  f50560a0          ADD      r0,r5,#0x500
000066  eb001044          ADD      r0,r0,r4,LSL #5
00006a  60c1              STR      r1,[r0,#0xc]
00006c  e00f              B        |L31.142|
                  |L31.110|
;;;1767         }
;;;1768         else
;;;1769         {
;;;1770           if ((USBx->CID & (0x1U << 8)) != 0U)
00006e  6bf0              LDR      r0,[r6,#0x3c]
000070  f4007080          AND      r0,r0,#0x100
000074  b158              CBZ      r0,|L31.142|
;;;1771           {
;;;1772             USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_NYET |
000076  f50560a0          ADD      r0,r5,#0x500
00007a  eb001044          ADD      r0,r0,r4,LSL #5
00007e  68c0              LDR      r0,[r0,#0xc]
000080  f0400160          ORR      r1,r0,#0x60
000084  f50560a0          ADD      r0,r5,#0x500
000088  eb001044          ADD      r0,r0,r4,LSL #5
00008c  60c1              STR      r1,[r0,#0xc]
                  |L31.142|
;;;1773                                                    USB_OTG_HCINTMSK_ACKM;
;;;1774           }
;;;1775         }
;;;1776         break;
00008e  e032              B        |L31.246|
                  |L31.144|
;;;1777   
;;;1778       case EP_TYPE_INTR:
;;;1779         USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
000090  f240619d          MOV      r1,#0x69d
000094  f50560a0          ADD      r0,r5,#0x500
000098  eb001044          ADD      r0,r0,r4,LSL #5
00009c  60c1              STR      r1,[r0,#0xc]
;;;1780                                               USB_OTG_HCINTMSK_STALLM |
;;;1781                                               USB_OTG_HCINTMSK_TXERRM |
;;;1782                                               USB_OTG_HCINTMSK_DTERRM |
;;;1783                                               USB_OTG_HCINTMSK_NAKM   |
;;;1784                                               USB_OTG_HCINTMSK_AHBERR |
;;;1785                                               USB_OTG_HCINTMSK_FRMORM;
;;;1786   
;;;1787         if ((epnum & 0x80U) == 0x80U)
00009e  f0070080          AND      r0,r7,#0x80
0000a2  2880              CMP      r0,#0x80
0000a4  d10b              BNE      |L31.190|
;;;1788         {
;;;1789           USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;
0000a6  f50560a0          ADD      r0,r5,#0x500
0000aa  eb001044          ADD      r0,r0,r4,LSL #5
0000ae  68c0              LDR      r0,[r0,#0xc]
0000b0  f4407180          ORR      r1,r0,#0x100
0000b4  f50560a0          ADD      r0,r5,#0x500
0000b8  eb001044          ADD      r0,r0,r4,LSL #5
0000bc  60c1              STR      r1,[r0,#0xc]
                  |L31.190|
;;;1790         }
;;;1791   
;;;1792         break;
0000be  e01a              B        |L31.246|
                  |L31.192|
;;;1793   
;;;1794       case EP_TYPE_ISOC:
;;;1795         USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
0000c0  f2402125          MOV      r1,#0x225
0000c4  f50560a0          ADD      r0,r5,#0x500
0000c8  eb001044          ADD      r0,r0,r4,LSL #5
0000cc  60c1              STR      r1,[r0,#0xc]
;;;1796                                               USB_OTG_HCINTMSK_ACKM   |
;;;1797                                               USB_OTG_HCINTMSK_AHBERR |
;;;1798                                               USB_OTG_HCINTMSK_FRMORM;
;;;1799   
;;;1800         if ((epnum & 0x80U) == 0x80U)
0000ce  f0070080          AND      r0,r7,#0x80
0000d2  2880              CMP      r0,#0x80
0000d4  d10b              BNE      |L31.238|
;;;1801         {
;;;1802           USBx_HC((uint32_t)ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_TXERRM | USB_OTG_HCINTMSK_BBERRM);
0000d6  f50560a0          ADD      r0,r5,#0x500
0000da  eb001044          ADD      r0,r0,r4,LSL #5
0000de  68c0              LDR      r0,[r0,#0xc]
0000e0  f44071c0          ORR      r1,r0,#0x180
0000e4  f50560a0          ADD      r0,r5,#0x500
0000e8  eb001044          ADD      r0,r0,r4,LSL #5
0000ec  60c1              STR      r1,[r0,#0xc]
                  |L31.238|
;;;1803         }
;;;1804         break;
0000ee  e002              B        |L31.246|
                  |L31.240|
;;;1805   
;;;1806       default:
;;;1807         ret = HAL_ERROR;
0000f0  2001              MOVS     r0,#1
0000f2  9000              STR      r0,[sp,#0]
;;;1808         break;
0000f4  bf00              NOP      
                  |L31.246|
0000f6  bf00              NOP                            ;1776
;;;1809     }
;;;1810   
;;;1811     /* Enable host channel Halt interrupt */
;;;1812     USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_CHHM;
0000f8  f50560a0          ADD      r0,r5,#0x500
0000fc  eb001044          ADD      r0,r0,r4,LSL #5
000100  68c0              LDR      r0,[r0,#0xc]
000102  f0400102          ORR      r1,r0,#2
000106  f50560a0          ADD      r0,r5,#0x500
00010a  eb001044          ADD      r0,r0,r4,LSL #5
00010e  60c1              STR      r1,[r0,#0xc]
;;;1813   
;;;1814     /* Enable the top level host channel interrupt. */
;;;1815     USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
000110  f44f6083          MOV      r0,#0x418
000114  5941              LDR      r1,[r0,r5]
000116  f004020f          AND      r2,r4,#0xf
00011a  2001              MOVS     r0,#1
00011c  4090              LSLS     r0,r0,r2
00011e  4308              ORRS     r0,r0,r1
000120  f44f6183          MOV      r1,#0x418
000124  5148              STR      r0,[r1,r5]
;;;1816   
;;;1817     /* Make sure host channel interrupts are enabled. */
;;;1818     USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
000126  69b0              LDR      r0,[r6,#0x18]
000128  f0407000          ORR      r0,r0,#0x2000000
00012c  61b0              STR      r0,[r6,#0x18]
;;;1819   
;;;1820     /* Program the HCCHAR register */
;;;1821     if ((epnum & 0x80U) == 0x80U)
00012e  f0070080          AND      r0,r7,#0x80
000132  2880              CMP      r0,#0x80
000134  d102              BNE      |L31.316|
;;;1822     {
;;;1823       HCcharEpDir = (0x1U << 15) & USB_OTG_HCCHAR_EPDIR;
000136  f44f4900          MOV      r9,#0x8000
00013a  e001              B        |L31.320|
                  |L31.316|
;;;1824     }
;;;1825     else
;;;1826     {
;;;1827       HCcharEpDir = 0U;
00013c  f04f0900          MOV      r9,#0
                  |L31.320|
;;;1828     }
;;;1829   
;;;1830     HostCoreSpeed = USB_GetHostSpeed(USBx);
000140  4630              MOV      r0,r6
000142  f7fffffe          BL       USB_GetHostSpeed
000146  4683              MOV      r11,r0
;;;1831   
;;;1832     /* LS device plugged to HUB */
;;;1833     if ((speed == HPRT0_PRTSPD_LOW_SPEED) && (HostCoreSpeed != HPRT0_PRTSPD_LOW_SPEED))
000148  980e              LDR      r0,[sp,#0x38]
00014a  2802              CMP      r0,#2
00014c  d105              BNE      |L31.346|
00014e  f1bb0f02          CMP      r11,#2
000152  d002              BEQ      |L31.346|
;;;1834     {
;;;1835       HCcharLowSpeed = (0x1U << 17) & USB_OTG_HCCHAR_LSDEV;
000154  f44f3a00          MOV      r10,#0x20000
000158  e001              B        |L31.350|
                  |L31.346|
;;;1836     }
;;;1837     else
;;;1838     {
;;;1839       HCcharLowSpeed = 0U;
00015a  f04f0a00          MOV      r10,#0
                  |L31.350|
;;;1840     }
;;;1841   
;;;1842     USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
00015e  f04f51fe          MOV      r1,#0x1fc00000
000162  9804              LDR      r0,[sp,#0x10]
000164  ea015080          AND      r0,r1,r0,LSL #22
000168  f44f41f0          MOV      r1,#0x7800
00016c  ea0121c7          AND      r1,r1,r7,LSL #11
000170  4308              ORRS     r0,r0,r1
000172  f44f2140          MOV      r1,#0xc0000
000176  ea014188          AND      r1,r1,r8,LSL #18
00017a  4308              ORRS     r0,r0,r1
00017c  9910              LDR      r1,[sp,#0x40]
00017e  f3c1010a          UBFX     r1,r1,#0,#11
000182  4308              ORRS     r0,r0,r1
000184  ea400009          ORR      r0,r0,r9
000188  ea40000a          ORR      r0,r0,r10
00018c  f50561a0          ADD      r1,r5,#0x500
000190  eb011144          ADD      r1,r1,r4,LSL #5
000194  6008              STR      r0,[r1,#0]
;;;1843                                         ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
;;;1844                                         (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
;;;1845                                         ((uint32_t)mps & USB_OTG_HCCHAR_MPSIZ) | HCcharEpDir | HCcharLowSpeed;
;;;1846   
;;;1847     if ((ep_type == EP_TYPE_INTR) || (ep_type == EP_TYPE_ISOC))
000196  f1b80f03          CMP      r8,#3
00019a  d002              BEQ      |L31.418|
00019c  f1b80f01          CMP      r8,#1
0001a0  d10b              BNE      |L31.442|
                  |L31.418|
;;;1848     {
;;;1849       USBx_HC((uint32_t)ch_num)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM;
0001a2  f50560a0          ADD      r0,r5,#0x500
0001a6  eb001044          ADD      r0,r0,r4,LSL #5
0001aa  6800              LDR      r0,[r0,#0]
0001ac  f0405100          ORR      r1,r0,#0x20000000
0001b0  f50560a0          ADD      r0,r5,#0x500
0001b4  eb001044          ADD      r0,r0,r4,LSL #5
0001b8  6001              STR      r1,[r0,#0]
                  |L31.442|
;;;1850     }
;;;1851   
;;;1852     return ret;
0001ba  9800              LDR      r0,[sp,#0]
;;;1853   }
0001bc  b005              ADD      sp,sp,#0x14
0001be  e8bd8ff0          POP      {r4-r11,pc}
;;;1854   
                          ENDP


                          AREA ||i.USB_HC_ReadInterrupt||, CODE, READONLY, ALIGN=1

                  USB_HC_ReadInterrupt PROC
;;;2003     */
;;;2004   uint32_t USB_HC_ReadInterrupt(USB_OTG_GlobalTypeDef *USBx)
000000  4601              MOV      r1,r0
;;;2005   {
;;;2006     uint32_t USBx_BASE = (uint32_t)USBx;
000002  460a              MOV      r2,r1
;;;2007   
;;;2008     return ((USBx_HOST->HAINT) & 0xFFFFU);
000004  f2404014          MOV      r0,#0x414
000008  5880              LDR      r0,[r0,r2]
00000a  b280              UXTH     r0,r0
;;;2009   }
00000c  4770              BX       lr
;;;2010   
                          ENDP


                          AREA ||i.USB_HC_StartXfer||, CODE, READONLY, ALIGN=2

                  USB_HC_StartXfer PROC
;;;1864     */
;;;1865   HAL_StatusTypeDef USB_HC_StartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_HCTypeDef *hc, uint8_t dma)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;1866   {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4691              MOV      r9,r2
;;;1867     uint32_t USBx_BASE = (uint32_t)USBx;
00000a  463e              MOV      r6,r7
;;;1868     uint32_t ch_num = (uint32_t)hc->ch_num;
00000c  7865              LDRB     r5,[r4,#1]
;;;1869     __IO uint32_t tmpreg;
;;;1870     uint8_t  is_oddframe;
;;;1871     uint16_t len_words;
;;;1872     uint16_t num_packets;
;;;1873     uint16_t max_hc_pkt_count = 256U;
00000e  f44f7b80          MOV      r11,#0x100
;;;1874   
;;;1875     if (((USBx->CID & (0x1U << 8)) != 0U) && (hc->speed == USBH_HS_SPEED))
000012  6bf8              LDR      r0,[r7,#0x3c]
000014  f4007080          AND      r0,r0,#0x100
000018  b310              CBZ      r0,|L33.96|
00001a  7920              LDRB     r0,[r4,#4]
00001c  bb00              CBNZ     r0,|L33.96|
;;;1876     {
;;;1877       /* in DMA mode host Core automatically issues ping  in case of NYET/NAK */
;;;1878       if ((dma == 1U) && ((hc->ep_type == EP_TYPE_CTRL) || (hc->ep_type == EP_TYPE_BULK)))
00001e  f1b90f01          CMP      r9,#1
000022  d110              BNE      |L33.70|
000024  79e0              LDRB     r0,[r4,#7]
000026  b110              CBZ      r0,|L33.46|
000028  79e0              LDRB     r0,[r4,#7]
00002a  2802              CMP      r0,#2
00002c  d10b              BNE      |L33.70|
                  |L33.46|
;;;1879       {
;;;1880         USBx_HC((uint32_t)ch_num)->HCINTMSK &= ~(USB_OTG_HCINTMSK_NYET |
00002e  f50660a0          ADD      r0,r6,#0x500
000032  eb001045          ADD      r0,r0,r5,LSL #5
000036  68c0              LDR      r0,[r0,#0xc]
000038  f0200170          BIC      r1,r0,#0x70
00003c  f50660a0          ADD      r0,r6,#0x500
000040  eb001045          ADD      r0,r0,r5,LSL #5
000044  60c1              STR      r1,[r0,#0xc]
                  |L33.70|
;;;1881                                                  USB_OTG_HCINTMSK_ACKM |
;;;1882                                                  USB_OTG_HCINTMSK_NAKM);
;;;1883       }
;;;1884   
;;;1885       if ((dma == 0U) && (hc->do_ping == 1U))
000046  f1b90f00          CMP      r9,#0
00004a  d109              BNE      |L33.96|
00004c  7960              LDRB     r0,[r4,#5]
00004e  2801              CMP      r0,#1
000050  d106              BNE      |L33.96|
;;;1886       {
;;;1887         (void)USB_DoPing(USBx, hc->ch_num);
000052  7861              LDRB     r1,[r4,#1]
000054  4638              MOV      r0,r7
000056  f7fffffe          BL       USB_DoPing
;;;1888         return HAL_OK;
00005a  2000              MOVS     r0,#0
                  |L33.92|
;;;1889       }
;;;1890   
;;;1891     }
;;;1892   
;;;1893     /* Compute the expected number of packets associated to the transfer */
;;;1894     if (hc->xfer_len > 0U)
;;;1895     {
;;;1896       num_packets = (uint16_t)((hc->xfer_len + hc->max_packet - 1U) / hc->max_packet);
;;;1897   
;;;1898       if (num_packets > max_hc_pkt_count)
;;;1899       {
;;;1900         num_packets = max_hc_pkt_count;
;;;1901         hc->XferSize = (uint32_t)num_packets * hc->max_packet;
;;;1902       }
;;;1903     }
;;;1904     else
;;;1905     {
;;;1906       num_packets = 1U;
;;;1907     }
;;;1908   
;;;1909     /*
;;;1910      * For IN channel HCTSIZ.XferSize is expected to be an integer multiple of
;;;1911      * max_packet size.
;;;1912      */
;;;1913     if (hc->ep_is_in != 0U)
;;;1914     {
;;;1915       hc->XferSize = (uint32_t)num_packets * hc->max_packet;
;;;1916     }
;;;1917     else
;;;1918     {
;;;1919       hc->XferSize = hc->xfer_len;
;;;1920     }
;;;1921   
;;;1922     /* Initialize the HCTSIZn register */
;;;1923     USBx_HC(ch_num)->HCTSIZ = (hc->XferSize & USB_OTG_HCTSIZ_XFRSIZ) |
;;;1924                               (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
;;;1925                               (((uint32_t)hc->data_pid << 29) & USB_OTG_HCTSIZ_DPID);
;;;1926   
;;;1927     if (dma != 0U)
;;;1928     {
;;;1929       /* xfer_buff MUST be 32-bits aligned */
;;;1930       USBx_HC(ch_num)->HCDMA = (uint32_t)hc->xfer_buff;
;;;1931     }
;;;1932   
;;;1933     is_oddframe = (((uint32_t)USBx_HOST->HFNUM & 0x01U) != 0U) ? 0U : 1U;
;;;1934     USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
;;;1935     USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
;;;1936   
;;;1937     /* Set host channel enable */
;;;1938     tmpreg = USBx_HC(ch_num)->HCCHAR;
;;;1939     tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
;;;1940   
;;;1941     /* make sure to set the correct ep direction */
;;;1942     if (hc->ep_is_in != 0U)
;;;1943     {
;;;1944       tmpreg |= USB_OTG_HCCHAR_EPDIR;
;;;1945     }
;;;1946     else
;;;1947     {
;;;1948       tmpreg &= ~USB_OTG_HCCHAR_EPDIR;
;;;1949     }
;;;1950     tmpreg |= USB_OTG_HCCHAR_CHENA;
;;;1951     USBx_HC(ch_num)->HCCHAR = tmpreg;
;;;1952   
;;;1953     if (dma != 0U) /* dma mode */
;;;1954     {
;;;1955       return HAL_OK;
;;;1956     }
;;;1957   
;;;1958     if ((hc->ep_is_in == 0U) && (hc->xfer_len > 0U))
;;;1959     {
;;;1960       switch (hc->ep_type)
;;;1961       {
;;;1962         /* Non periodic transfer */
;;;1963         case EP_TYPE_CTRL:
;;;1964         case EP_TYPE_BULK:
;;;1965   
;;;1966           len_words = (uint16_t)((hc->xfer_len + 3U) / 4U);
;;;1967   
;;;1968           /* check if there is enough space in FIFO space */
;;;1969           if (len_words > (USBx->HNPTXSTS & 0xFFFFU))
;;;1970           {
;;;1971             /* need to process data in nptxfempty interrupt */
;;;1972             USBx->GINTMSK |= USB_OTG_GINTMSK_NPTXFEM;
;;;1973           }
;;;1974           break;
;;;1975   
;;;1976         /* Periodic transfer */
;;;1977         case EP_TYPE_INTR:
;;;1978         case EP_TYPE_ISOC:
;;;1979           len_words = (uint16_t)((hc->xfer_len + 3U) / 4U);
;;;1980           /* check if there is enough space in FIFO space */
;;;1981           if (len_words > (USBx_HOST->HPTXSTS & 0xFFFFU)) /* split the transfer */
;;;1982           {
;;;1983             /* need to process data in ptxfempty interrupt */
;;;1984             USBx->GINTMSK |= USB_OTG_GINTMSK_PTXFEM;
;;;1985           }
;;;1986           break;
;;;1987   
;;;1988         default:
;;;1989           break;
;;;1990       }
;;;1991   
;;;1992       /* Write packet into the Tx FIFO. */
;;;1993       (void)USB_WritePacket(USBx, hc->xfer_buff, hc->ch_num, (uint16_t)hc->xfer_len, 0);
;;;1994     }
;;;1995   
;;;1996     return HAL_OK;
;;;1997   }
00005c  e8bd8ffe          POP      {r1-r11,pc}
                  |L33.96|
000060  6960              LDR      r0,[r4,#0x14]         ;1894
000062  b178              CBZ      r0,|L33.132|
000064  8921              LDRH     r1,[r4,#8]            ;1896
000066  6960              LDR      r0,[r4,#0x14]         ;1896
000068  4408              ADD      r0,r0,r1              ;1896
00006a  1e40              SUBS     r0,r0,#1              ;1896
00006c  fbb0f0f1          UDIV     r0,r0,r1              ;1896
000070  fa1ff880          UXTH     r8,r0                 ;1896
000074  45d8              CMP      r8,r11                ;1898
000076  dd07              BLE      |L33.136|
000078  46d8              MOV      r8,r11                ;1900
00007a  8920              LDRH     r0,[r4,#8]            ;1901
00007c  fb00f008          MUL      r0,r0,r8              ;1901
000080  6120              STR      r0,[r4,#0x10]         ;1901
000082  e001              B        |L33.136|
                  |L33.132|
000084  f04f0801          MOV      r8,#1                 ;1906
                  |L33.136|
000088  78e0              LDRB     r0,[r4,#3]            ;1913
00008a  b120              CBZ      r0,|L33.150|
00008c  8920              LDRH     r0,[r4,#8]            ;1915
00008e  fb00f008          MUL      r0,r0,r8              ;1915
000092  6120              STR      r0,[r4,#0x10]         ;1915
000094  e001              B        |L33.154|
                  |L33.150|
000096  6960              LDR      r0,[r4,#0x14]         ;1919
000098  6120              STR      r0,[r4,#0x10]         ;1919
                  |L33.154|
00009a  6920              LDR      r0,[r4,#0x10]         ;1923
00009c  f3c00012          UBFX     r0,r0,#0,#19          ;1923
0000a0  494a              LDR      r1,|L33.460|
0000a2  ea0141c8          AND      r1,r1,r8,LSL #19      ;1923
0000a6  4308              ORRS     r0,r0,r1              ;1923
0000a8  7aa1              LDRB     r1,[r4,#0xa]          ;1923
0000aa  f04f42c0          MOV      r2,#0x60000000        ;1923
0000ae  ea027141          AND      r1,r2,r1,LSL #29      ;1923
0000b2  4308              ORRS     r0,r0,r1              ;1923
0000b4  f50661a0          ADD      r1,r6,#0x500          ;1923
0000b8  eb011145          ADD      r1,r1,r5,LSL #5       ;1923
0000bc  6108              STR      r0,[r1,#0x10]         ;1923
0000be  f1b90f00          CMP      r9,#0                 ;1927
0000c2  d005              BEQ      |L33.208|
0000c4  f50660a0          ADD      r0,r6,#0x500          ;1930
0000c8  eb001045          ADD      r0,r0,r5,LSL #5       ;1930
0000cc  68e1              LDR      r1,[r4,#0xc]          ;1930
0000ce  6141              STR      r1,[r0,#0x14]         ;1930
                  |L33.208|
0000d0  f44f6081          MOV      r0,#0x408             ;1933
0000d4  5980              LDR      r0,[r0,r6]            ;1933
0000d6  f0000001          AND      r0,r0,#1              ;1933
0000da  f0800001          EOR      r0,r0,#1              ;1933
0000de  9001              STR      r0,[sp,#4]            ;1933
0000e0  f50660a0          ADD      r0,r6,#0x500          ;1934
0000e4  eb001045          ADD      r0,r0,r5,LSL #5       ;1934
0000e8  6800              LDR      r0,[r0,#0]            ;1934
0000ea  f0205100          BIC      r1,r0,#0x20000000     ;1934
0000ee  f50660a0          ADD      r0,r6,#0x500          ;1934
0000f2  eb001045          ADD      r0,r0,r5,LSL #5       ;1934
0000f6  6001              STR      r1,[r0,#0]            ;1934
0000f8  f50660a0          ADD      r0,r6,#0x500          ;1935
0000fc  eb001045          ADD      r0,r0,r5,LSL #5       ;1935
000100  6801              LDR      r1,[r0,#0]            ;1935
000102  9801              LDR      r0,[sp,#4]            ;1935
000104  ea417140          ORR      r1,r1,r0,LSL #29      ;1935
000108  f50660a0          ADD      r0,r6,#0x500          ;1935
00010c  eb001045          ADD      r0,r0,r5,LSL #5       ;1935
000110  6001              STR      r1,[r0,#0]            ;1935
000112  f50660a0          ADD      r0,r6,#0x500          ;1938
000116  eb001045          ADD      r0,r0,r5,LSL #5       ;1938
00011a  6800              LDR      r0,[r0,#0]            ;1938
00011c  9002              STR      r0,[sp,#8]            ;1938
00011e  9802              LDR      r0,[sp,#8]            ;1939
000120  f0204080          BIC      r0,r0,#0x40000000     ;1939
000124  9002              STR      r0,[sp,#8]            ;1939
000126  78e0              LDRB     r0,[r4,#3]            ;1942
000128  b120              CBZ      r0,|L33.308|
00012a  9802              LDR      r0,[sp,#8]            ;1944
00012c  f4404000          ORR      r0,r0,#0x8000         ;1944
000130  9002              STR      r0,[sp,#8]            ;1944
000132  e003              B        |L33.316|
                  |L33.308|
000134  9802              LDR      r0,[sp,#8]            ;1948
000136  f4204000          BIC      r0,r0,#0x8000         ;1948
00013a  9002              STR      r0,[sp,#8]            ;1948
                  |L33.316|
00013c  9802              LDR      r0,[sp,#8]            ;1950
00013e  f0404000          ORR      r0,r0,#0x80000000     ;1950
000142  9002              STR      r0,[sp,#8]            ;1950
000144  f50660a0          ADD      r0,r6,#0x500          ;1951
000148  eb001045          ADD      r0,r0,r5,LSL #5       ;1951
00014c  9902              LDR      r1,[sp,#8]            ;1951
00014e  6001              STR      r1,[r0,#0]            ;1951
000150  f1b90f00          CMP      r9,#0                 ;1953
000154  d001              BEQ      |L33.346|
000156  2000              MOVS     r0,#0                 ;1955
000158  e780              B        |L33.92|
                  |L33.346|
00015a  78e0              LDRB     r0,[r4,#3]            ;1958
00015c  bb98              CBNZ     r0,|L33.454|
00015e  6960              LDR      r0,[r4,#0x14]         ;1958
000160  b388              CBZ      r0,|L33.454|
000162  79e0              LDRB     r0,[r4,#7]            ;1960
000164  b130              CBZ      r0,|L33.372|
000166  2801              CMP      r0,#1                 ;1960
000168  d013              BEQ      |L33.402|
00016a  2802              CMP      r0,#2                 ;1960
00016c  d003              BEQ      |L33.374|
00016e  2803              CMP      r0,#3                 ;1960
000170  d11e              BNE      |L33.432|
000172  e00d              B        |L33.400|
                  |L33.372|
000174  bf00              NOP                            ;1964
                  |L33.374|
000176  6960              LDR      r0,[r4,#0x14]         ;1966
000178  1cc0              ADDS     r0,r0,#3              ;1966
00017a  f3c00a8f          UBFX     r10,r0,#2,#16         ;1966
00017e  6af8              LDR      r0,[r7,#0x2c]         ;1969
000180  b280              UXTH     r0,r0                 ;1969
000182  4550              CMP      r0,r10                ;1969
000184  d203              BCS      |L33.398|
000186  69b8              LDR      r0,[r7,#0x18]         ;1972
000188  f0400020          ORR      r0,r0,#0x20           ;1972
00018c  61b8              STR      r0,[r7,#0x18]         ;1972
                  |L33.398|
00018e  e010              B        |L33.434|
                  |L33.400|
000190  bf00              NOP                            ;1978
                  |L33.402|
000192  6960              LDR      r0,[r4,#0x14]         ;1979
000194  1cc0              ADDS     r0,r0,#3              ;1979
000196  f3c00a8f          UBFX     r10,r0,#2,#16         ;1979
00019a  f44f6082          MOV      r0,#0x410             ;1981
00019e  5980              LDR      r0,[r0,r6]            ;1981
0001a0  b280              UXTH     r0,r0                 ;1981
0001a2  4550              CMP      r0,r10                ;1981
0001a4  d203              BCS      |L33.430|
0001a6  69b8              LDR      r0,[r7,#0x18]         ;1984
0001a8  f0406080          ORR      r0,r0,#0x4000000      ;1984
0001ac  61b8              STR      r0,[r7,#0x18]         ;1984
                  |L33.430|
0001ae  e000              B        |L33.434|
                  |L33.432|
0001b0  bf00              NOP                            ;1989
                  |L33.434|
0001b2  bf00              NOP                            ;1974
0001b4  2000              MOVS     r0,#0                 ;1993
0001b6  9000              STR      r0,[sp,#0]            ;1993
0001b8  8aa0              LDRH     r0,[r4,#0x14]         ;1993
0001ba  b283              UXTH     r3,r0                 ;1993
0001bc  7862              LDRB     r2,[r4,#1]            ;1993
0001be  4638              MOV      r0,r7                 ;1993
0001c0  68e1              LDR      r1,[r4,#0xc]          ;1993
0001c2  f7fffffe          BL       USB_WritePacket
                  |L33.454|
0001c6  2000              MOVS     r0,#0                 ;1996
0001c8  e748              B        |L33.92|
;;;1998   
                          ENDP

0001ca  0000              DCW      0x0000
                  |L33.460|
                          DCD      0x1ff80000

                          AREA ||i.USB_HostInit||, CODE, READONLY, ALIGN=2

                  USB_HostInit PROC
;;;1498     */
;;;1499   HAL_StatusTypeDef USB_HostInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
000000  b40f              PUSH     {r0-r3}
;;;1500   {
000002  b5f0              PUSH     {r4-r7,lr}
000004  4604              MOV      r4,r0
;;;1501     HAL_StatusTypeDef ret = HAL_OK;
000006  2700              MOVS     r7,#0
;;;1502     uint32_t USBx_BASE = (uint32_t)USBx;
000008  4625              MOV      r5,r4
;;;1503     uint32_t i;
;;;1504   
;;;1505     /* Restart the Phy Clock */
;;;1506     USBx_PCGCCTL = 0U;
00000a  2000              MOVS     r0,#0
00000c  f8c50e00          STR      r0,[r5,#0xe00]
;;;1507   
;;;1508   #if defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
;;;1509     /* Disable HW VBUS sensing */
;;;1510     USBx->GCCFG &= ~(USB_OTG_GCCFG_VBDEN);
;;;1511   #else
;;;1512     /*
;;;1513     * Disable HW VBUS sensing. VBUS is internally considered to be always
;;;1514     * at VBUS-Valid level (5V).
;;;1515     */
;;;1516     USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
000010  6ba0              LDR      r0,[r4,#0x38]
000012  f4401000          ORR      r0,r0,#0x200000
000016  63a0              STR      r0,[r4,#0x38]
;;;1517     USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSBSEN;
000018  6ba0              LDR      r0,[r4,#0x38]
00001a  f4202000          BIC      r0,r0,#0x80000
00001e  63a0              STR      r0,[r4,#0x38]
;;;1518     USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSASEN;
000020  6ba0              LDR      r0,[r4,#0x38]
000022  f4202080          BIC      r0,r0,#0x40000
000026  63a0              STR      r0,[r4,#0x38]
;;;1519   #endif /* defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx) */
;;;1520   #if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
;;;1521     /* Disable Battery chargin detector */
;;;1522     USBx->GCCFG &= ~(USB_OTG_GCCFG_BCDEN);
;;;1523   #endif /* defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx) */
;;;1524   
;;;1525     if ((USBx->CID & (0x1U << 8)) != 0U)
000028  6be0              LDR      r0,[r4,#0x3c]
00002a  f4007080          AND      r0,r0,#0x100
00002e  b180              CBZ      r0,|L34.82|
;;;1526     {
;;;1527       if (cfg.speed == USBH_FSLS_SPEED)
000030  9808              LDR      r0,[sp,#0x20]
000032  2801              CMP      r0,#1
000034  d106              BNE      |L34.68|
;;;1528       {
;;;1529         /* Force Device Enumeration to FS/LS mode only */
;;;1530         USBx_HOST->HCFG |= USB_OTG_HCFG_FSLSS;
000036  f8d50400          LDR      r0,[r5,#0x400]
00003a  f0400004          ORR      r0,r0,#4
00003e  f8c50400          STR      r0,[r5,#0x400]
000042  e00c              B        |L34.94|
                  |L34.68|
;;;1531       }
;;;1532       else
;;;1533       {
;;;1534         /* Set default Max speed support */
;;;1535         USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);
000044  f8d50400          LDR      r0,[r5,#0x400]
000048  f0200004          BIC      r0,r0,#4
00004c  f8c50400          STR      r0,[r5,#0x400]
000050  e005              B        |L34.94|
                  |L34.82|
;;;1536       }
;;;1537     }
;;;1538     else
;;;1539     {
;;;1540       /* Set default Max speed support */
;;;1541       USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);
000052  f8d50400          LDR      r0,[r5,#0x400]
000056  f0200004          BIC      r0,r0,#4
00005a  f8c50400          STR      r0,[r5,#0x400]
                  |L34.94|
;;;1542     }
;;;1543   
;;;1544     /* Make sure the FIFOs are flushed. */
;;;1545     if (USB_FlushTxFifo(USBx, 0x10U) != HAL_OK) /* all Tx FIFOs */
00005e  2110              MOVS     r1,#0x10
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       USB_FlushTxFifo
000066  b100              CBZ      r0,|L34.106|
;;;1546     {
;;;1547       ret = HAL_ERROR;
000068  2701              MOVS     r7,#1
                  |L34.106|
;;;1548     }
;;;1549   
;;;1550     if (USB_FlushRxFifo(USBx) != HAL_OK)
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       USB_FlushRxFifo
000070  b100              CBZ      r0,|L34.116|
;;;1551     {
;;;1552       ret = HAL_ERROR;
000072  2701              MOVS     r7,#1
                  |L34.116|
;;;1553     }
;;;1554   
;;;1555     /* Clear all pending HC Interrupts */
;;;1556     for (i = 0U; i < cfg.Host_channels; i++)
000074  2600              MOVS     r6,#0
000076  e00d              B        |L34.148|
                  |L34.120|
;;;1557     {
;;;1558       USBx_HC(i)->HCINT = 0xFFFFFFFFU;
000078  f04f31ff          MOV      r1,#0xffffffff
00007c  f50560a0          ADD      r0,r5,#0x500
000080  eb001046          ADD      r0,r0,r6,LSL #5
000084  6081              STR      r1,[r0,#8]
;;;1559       USBx_HC(i)->HCINTMSK = 0U;
000086  2100              MOVS     r1,#0
000088  f50560a0          ADD      r0,r5,#0x500
00008c  eb001046          ADD      r0,r0,r6,LSL #5
000090  60c1              STR      r1,[r0,#0xc]
000092  1c76              ADDS     r6,r6,#1              ;1556
                  |L34.148|
000094  9807              LDR      r0,[sp,#0x1c]         ;1556
000096  42b0              CMP      r0,r6                 ;1556
000098  d8ee              BHI      |L34.120|
;;;1560     }
;;;1561   
;;;1562     /* Disable all interrupts. */
;;;1563     USBx->GINTMSK = 0U;
00009a  2000              MOVS     r0,#0
00009c  61a0              STR      r0,[r4,#0x18]
;;;1564   
;;;1565     /* Clear any pending interrupts */
;;;1566     USBx->GINTSTS = 0xFFFFFFFFU;
00009e  1e40              SUBS     r0,r0,#1
0000a0  6160              STR      r0,[r4,#0x14]
;;;1567   
;;;1568     if ((USBx->CID & (0x1U << 8)) != 0U)
0000a2  6be0              LDR      r0,[r4,#0x3c]
0000a4  f4007080          AND      r0,r0,#0x100
0000a8  b140              CBZ      r0,|L34.188|
;;;1569     {
;;;1570       /* set Rx FIFO size */
;;;1571       USBx->GRXFSIZ  = 0x200U;
0000aa  f44f7000          MOV      r0,#0x200
0000ae  6260              STR      r0,[r4,#0x24]
;;;1572       USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x100U << 16) & USB_OTG_NPTXFD) | 0x200U);
0000b0  480d              LDR      r0,|L34.232|
0000b2  62a0              STR      r0,[r4,#0x28]
;;;1573       USBx->HPTXFSIZ = (uint32_t)(((0xE0U << 16) & USB_OTG_HPTXFSIZ_PTXFD) | 0x300U);
0000b4  480d              LDR      r0,|L34.236|
0000b6  f8c40100          STR      r0,[r4,#0x100]
0000ba  e006              B        |L34.202|
                  |L34.188|
;;;1574     }
;;;1575     else
;;;1576     {
;;;1577       /* set Rx FIFO size */
;;;1578       USBx->GRXFSIZ  = 0x80U;
0000bc  2080              MOVS     r0,#0x80
0000be  6260              STR      r0,[r4,#0x24]
;;;1579       USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x60U << 16) & USB_OTG_NPTXFD) | 0x80U);
0000c0  480b              LDR      r0,|L34.240|
0000c2  62a0              STR      r0,[r4,#0x28]
;;;1580       USBx->HPTXFSIZ = (uint32_t)(((0x40U << 16)& USB_OTG_HPTXFSIZ_PTXFD) | 0xE0U);
0000c4  480b              LDR      r0,|L34.244|
0000c6  f8c40100          STR      r0,[r4,#0x100]
                  |L34.202|
;;;1581     }
;;;1582   
;;;1583     /* Enable the common interrupts */
;;;1584     if (cfg.dma_enable == 0U)
0000ca  9809              LDR      r0,[sp,#0x24]
0000cc  b918              CBNZ     r0,|L34.214|
;;;1585     {
;;;1586       USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
0000ce  69a0              LDR      r0,[r4,#0x18]
0000d0  f0400010          ORR      r0,r0,#0x10
0000d4  61a0              STR      r0,[r4,#0x18]
                  |L34.214|
;;;1587     }
;;;1588   
;;;1589     /* Enable interrupts matching to the Host mode ONLY */
;;;1590     USBx->GINTMSK |= (USB_OTG_GINTMSK_PRTIM            | USB_OTG_GINTMSK_HCIM | \
0000d6  69a0              LDR      r0,[r4,#0x18]
0000d8  4907              LDR      r1,|L34.248|
0000da  4308              ORRS     r0,r0,r1
0000dc  61a0              STR      r0,[r4,#0x18]
;;;1591                       USB_OTG_GINTMSK_SOFM             | USB_OTG_GINTSTS_DISCINT | \
;;;1592                       USB_OTG_GINTMSK_PXFRM_IISOOXFRM  | USB_OTG_GINTMSK_WUIM);
;;;1593   
;;;1594     return ret;
0000de  4638              MOV      r0,r7
;;;1595   }
0000e0  bcf0              POP      {r4-r7}
0000e2  f85dfb14          LDR      pc,[sp],#0x14
;;;1596   
                          ENDP

0000e6  0000              DCW      0x0000
                  |L34.232|
                          DCD      0x01000200
                  |L34.236|
                          DCD      0x00e00300
                  |L34.240|
                          DCD      0x00600080
                  |L34.244|
                          DCD      0x004000e0
                  |L34.248|
                          DCD      0xa3200008

                          AREA ||i.USB_InitFSLSPClkSel||, CODE, READONLY, ALIGN=1

                  USB_InitFSLSPClkSel PROC
;;;1606     */
;;;1607   HAL_StatusTypeDef USB_InitFSLSPClkSel(USB_OTG_GlobalTypeDef *USBx, uint8_t freq)
000000  b510              PUSH     {r4,lr}
;;;1608   {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;1609     uint32_t USBx_BASE = (uint32_t)USBx;
000006  4611              MOV      r1,r2
;;;1610   
;;;1611     USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSPCS);
000008  f8d10400          LDR      r0,[r1,#0x400]
00000c  f0200003          BIC      r0,r0,#3
000010  f8c10400          STR      r0,[r1,#0x400]
;;;1612     USBx_HOST->HCFG |= (uint32_t)freq & USB_OTG_HCFG_FSLSPCS;
000014  f8d10400          LDR      r0,[r1,#0x400]
000018  f0030403          AND      r4,r3,#3
00001c  4320              ORRS     r0,r0,r4
00001e  f8c10400          STR      r0,[r1,#0x400]
;;;1613   
;;;1614     if (freq == HCFG_48_MHZ)
000022  2b01              CMP      r3,#1
000024  d105              BNE      |L35.50|
;;;1615     {
;;;1616       USBx_HOST->HFIR = 48000U;
000026  f64b3480          MOV      r4,#0xbb80
00002a  f2404004          MOV      r0,#0x404
00002e  5044              STR      r4,[r0,r1]
000030  e006              B        |L35.64|
                  |L35.50|
;;;1617     }
;;;1618     else if (freq == HCFG_6_MHZ)
000032  2b02              CMP      r3,#2
000034  d104              BNE      |L35.64|
;;;1619     {
;;;1620       USBx_HOST->HFIR = 6000U;
000036  f2417470          MOV      r4,#0x1770
00003a  f2404004          MOV      r0,#0x404
00003e  5044              STR      r4,[r0,r1]
                  |L35.64|
;;;1621     }
;;;1622     else
;;;1623     {
;;;1624       /* ... */
;;;1625     }
;;;1626   
;;;1627     return HAL_OK;
000040  2000              MOVS     r0,#0
;;;1628   }
000042  bd10              POP      {r4,pc}
;;;1629   
                          ENDP


                          AREA ||i.USB_ReadDevAllInEpInterrupt||, CODE, READONLY, ALIGN=1

                  USB_ReadDevAllInEpInterrupt PROC
;;;1323     */
;;;1324   uint32_t USB_ReadDevAllInEpInterrupt(USB_OTG_GlobalTypeDef *USBx)
000000  4601              MOV      r1,r0
;;;1325   {
;;;1326     uint32_t USBx_BASE = (uint32_t)USBx;
000002  460b              MOV      r3,r1
;;;1327     uint32_t tmpreg;
;;;1328   
;;;1329     tmpreg  = USBx_DEVICE->DAINT;
000004  f6400018          MOV      r0,#0x818
000008  58c2              LDR      r2,[r0,r3]
;;;1330     tmpreg &= USBx_DEVICE->DAINTMSK;
00000a  1d00              ADDS     r0,r0,#4
00000c  58c0              LDR      r0,[r0,r3]
00000e  4002              ANDS     r2,r2,r0
;;;1331   
;;;1332     return ((tmpreg & 0xFFFFU));
000010  b290              UXTH     r0,r2
;;;1333   }
000012  4770              BX       lr
;;;1334   
                          ENDP


                          AREA ||i.USB_ReadDevAllOutEpInterrupt||, CODE, READONLY, ALIGN=1

                  USB_ReadDevAllOutEpInterrupt PROC
;;;1307     */
;;;1308   uint32_t USB_ReadDevAllOutEpInterrupt(USB_OTG_GlobalTypeDef *USBx)
000000  4601              MOV      r1,r0
;;;1309   {
;;;1310     uint32_t USBx_BASE = (uint32_t)USBx;
000002  460b              MOV      r3,r1
;;;1311     uint32_t tmpreg;
;;;1312   
;;;1313     tmpreg  = USBx_DEVICE->DAINT;
000004  f6400018          MOV      r0,#0x818
000008  58c2              LDR      r2,[r0,r3]
;;;1314     tmpreg &= USBx_DEVICE->DAINTMSK;
00000a  1d00              ADDS     r0,r0,#4
00000c  58c0              LDR      r0,[r0,r3]
00000e  4002              ANDS     r2,r2,r0
;;;1315   
;;;1316     return ((tmpreg & 0xffff0000U) >> 16);
000010  0c10              LSRS     r0,r2,#16
;;;1317   }
000012  4770              BX       lr
;;;1318   
                          ENDP


                          AREA ||i.USB_ReadDevInEPInterrupt||, CODE, READONLY, ALIGN=1

                  USB_ReadDevInEPInterrupt PROC
;;;1359     */
;;;1360   uint32_t USB_ReadDevInEPInterrupt(USB_OTG_GlobalTypeDef *USBx, uint8_t epnum)
000000  b570              PUSH     {r4-r6,lr}
;;;1361   {
000002  4602              MOV      r2,r0
;;;1362     uint32_t USBx_BASE = (uint32_t)USBx;
000004  4613              MOV      r3,r2
;;;1363     uint32_t tmpreg;
;;;1364     uint32_t msk;
;;;1365     uint32_t emp;
;;;1366   
;;;1367     msk = USBx_DEVICE->DIEPMSK;
000006  f44f6601          MOV      r6,#0x810
00000a  58f4              LDR      r4,[r6,r3]
;;;1368     emp = USBx_DEVICE->DIEPEMPMSK;
00000c  f6400634          MOV      r6,#0x834
000010  58f5              LDR      r5,[r6,r3]
;;;1369     msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
000012  f001060f          AND      r6,r1,#0xf
000016  fa25f606          LSR      r6,r5,r6
00001a  f0060601          AND      r6,r6,#1
00001e  ea4414c6          ORR      r4,r4,r6,LSL #7
;;;1370     tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
000022  f5036610          ADD      r6,r3,#0x900
000026  eb061641          ADD      r6,r6,r1,LSL #5
00002a  68b6              LDR      r6,[r6,#8]
00002c  ea060004          AND      r0,r6,r4
;;;1371   
;;;1372     return tmpreg;
;;;1373   }
000030  bd70              POP      {r4-r6,pc}
;;;1374   
                          ENDP


                          AREA ||i.USB_ReadDevOutEPInterrupt||, CODE, READONLY, ALIGN=1

                  USB_ReadDevOutEPInterrupt PROC
;;;1341     */
;;;1342   uint32_t USB_ReadDevOutEPInterrupt(USB_OTG_GlobalTypeDef *USBx, uint8_t epnum)
000000  b510              PUSH     {r4,lr}
;;;1343   {
000002  4602              MOV      r2,r0
;;;1344     uint32_t USBx_BASE = (uint32_t)USBx;
000004  4613              MOV      r3,r2
;;;1345     uint32_t tmpreg;
;;;1346   
;;;1347     tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
000006  f5036430          ADD      r4,r3,#0xb00
00000a  eb041441          ADD      r4,r4,r1,LSL #5
00000e  68a0              LDR      r0,[r4,#8]
;;;1348     tmpreg &= USBx_DEVICE->DOEPMSK;
000010  f6400414          MOV      r4,#0x814
000014  58e4              LDR      r4,[r4,r3]
000016  4020              ANDS     r0,r0,r4
;;;1349   
;;;1350     return tmpreg;
;;;1351   }
000018  bd10              POP      {r4,pc}
;;;1352   
                          ENDP


                          AREA ||i.USB_ReadInterrupts||, CODE, READONLY, ALIGN=1

                  USB_ReadInterrupts PROC
;;;1292     */
;;;1293   uint32_t  USB_ReadInterrupts(USB_OTG_GlobalTypeDef *USBx)
000000  4601              MOV      r1,r0
;;;1294   {
;;;1295     uint32_t tmpreg;
;;;1296   
;;;1297     tmpreg = USBx->GINTSTS;
000002  6948              LDR      r0,[r1,#0x14]
;;;1298     tmpreg &= USBx->GINTMSK;
000004  698a              LDR      r2,[r1,#0x18]
000006  4010              ANDS     r0,r0,r2
;;;1299   
;;;1300     return tmpreg;
;;;1301   }
000008  4770              BX       lr
;;;1302   
                          ENDP


                          AREA ||i.USB_ReadPacket||, CODE, READONLY, ALIGN=1

                  USB_ReadPacket PROC
;;;1100     */
;;;1101   void *USB_ReadPacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1102   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1103     uint32_t USBx_BASE = (uint32_t)USBx;
000008  4627              MOV      r7,r4
;;;1104     uint8_t *pDest = dest;
00000a  4628              MOV      r0,r5
;;;1105     uint32_t pData;
;;;1106     uint32_t i;
;;;1107     uint32_t count32b = (uint32_t)len >> 2U;
00000c  ea4f0c92          LSR      r12,r2,#2
;;;1108     uint16_t remaining_bytes = len % 4U;
000010  f0020303          AND      r3,r2,#3
;;;1109   
;;;1110     for (i = 0U; i < count32b; i++)
000014  2100              MOVS     r1,#0
000016  e00a              B        |L41.46|
                  |L41.24|
;;;1111     {
;;;1112       __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));
000018  f44f5880          MOV      r8,#0x1000
00001c  f8588007          LDR      r8,[r8,r7]
000020  f8c08000          STR      r8,[r0,#0]
;;;1113       pDest++;
000024  1c40              ADDS     r0,r0,#1
;;;1114       pDest++;
000026  1c40              ADDS     r0,r0,#1
;;;1115       pDest++;
000028  1c40              ADDS     r0,r0,#1
;;;1116       pDest++;
00002a  1c40              ADDS     r0,r0,#1
00002c  1c49              ADDS     r1,r1,#1              ;1110
                  |L41.46|
00002e  4561              CMP      r1,r12                ;1110
000030  d3f2              BCC      |L41.24|
;;;1117     }
;;;1118   
;;;1119     /* When Number of data is not word aligned, read the remaining byte */
;;;1120     if (remaining_bytes != 0U)
000032  b19b              CBZ      r3,|L41.92|
;;;1121     {
;;;1122       i = 0U;
000034  2100              MOVS     r1,#0
;;;1123       __UNALIGNED_UINT32_WRITE(&pData, USBx_DFIFO(0U));
000036  f44f5880          MOV      r8,#0x1000
00003a  f8586007          LDR      r6,[r8,r7]
;;;1124   
;;;1125       do
00003e  bf00              NOP      
                  |L41.64|
;;;1126       {
;;;1127         *(uint8_t *)pDest = (uint8_t)(pData >> (8U * (uint8_t)(i)));
000040  ea4f08c1          LSL      r8,r1,#3
000044  fa26f808          LSR      r8,r6,r8
000048  f8808000          STRB     r8,[r0,#0]
;;;1128         i++;
00004c  1c49              ADDS     r1,r1,#1
;;;1129         pDest++;
00004e  1c40              ADDS     r0,r0,#1
;;;1130         remaining_bytes--;
000050  f1a30801          SUB      r8,r3,#1
000054  fa1ff388          UXTH     r3,r8
;;;1131       } while (remaining_bytes != 0U);
000058  2b00              CMP      r3,#0
00005a  d1f1              BNE      |L41.64|
                  |L41.92|
;;;1132     }
;;;1133   
;;;1134     return ((void *)pDest);
;;;1135   }
00005c  e8bd81f0          POP      {r4-r8,pc}
;;;1136   
                          ENDP


                          AREA ||i.USB_ResetPort||, CODE, READONLY, ALIGN=1

                  USB_ResetPort PROC
;;;1636     */
;;;1637   HAL_StatusTypeDef USB_ResetPort(USB_OTG_GlobalTypeDef *USBx)
000000  b538              PUSH     {r3-r5,lr}
;;;1638   {
000002  4604              MOV      r4,r0
;;;1639     uint32_t USBx_BASE = (uint32_t)USBx;
000004  4625              MOV      r5,r4
;;;1640   
;;;1641     __IO uint32_t hprt0 = 0U;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;1642   
;;;1643     hprt0 = USBx_HPRT0;
00000a  f8d50440          LDR      r0,[r5,#0x440]
00000e  9000              STR      r0,[sp,#0]
;;;1644   
;;;1645     hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
000010  9800              LDR      r0,[sp,#0]
000012  f020002e          BIC      r0,r0,#0x2e
000016  9000              STR      r0,[sp,#0]
;;;1646                USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);
;;;1647   
;;;1648     USBx_HPRT0 = (USB_OTG_HPRT_PRST | hprt0);
000018  9800              LDR      r0,[sp,#0]
00001a  f4407080          ORR      r0,r0,#0x100
00001e  f8c50440          STR      r0,[r5,#0x440]
;;;1649     HAL_Delay(100U);                                 /* See Note #1 */
000022  2064              MOVS     r0,#0x64
000024  f7fffffe          BL       HAL_Delay
;;;1650     USBx_HPRT0 = ((~USB_OTG_HPRT_PRST) & hprt0);
000028  9800              LDR      r0,[sp,#0]
00002a  f4207080          BIC      r0,r0,#0x100
00002e  f8c50440          STR      r0,[r5,#0x440]
;;;1651     HAL_Delay(10U);
000032  200a              MOVS     r0,#0xa
000034  f7fffffe          BL       HAL_Delay
;;;1652   
;;;1653     return HAL_OK;
000038  2000              MOVS     r0,#0
;;;1654   }
00003a  bd38              POP      {r3-r5,pc}
;;;1655   
                          ENDP


                          AREA ||i.USB_SetCurrentMode||, CODE, READONLY, ALIGN=1

                  USB_SetCurrentMode PROC
;;;248      */
;;;249    HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx, USB_OTG_ModeTypeDef mode)
000000  b570              PUSH     {r4-r6,lr}
;;;250    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;251      uint32_t ms = 0U;
000006  2500              MOVS     r5,#0
;;;252    
;;;253      USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
000008  68e0              LDR      r0,[r4,#0xc]
00000a  f02040c0          BIC      r0,r0,#0x60000000
00000e  60e0              STR      r0,[r4,#0xc]
;;;254    
;;;255      if (mode == USB_HOST_MODE)
000010  2e01              CMP      r6,#1
000012  d110              BNE      |L43.54|
;;;256      {
;;;257        USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
000014  68e0              LDR      r0,[r4,#0xc]
000016  f0405000          ORR      r0,r0,#0x20000000
00001a  60e0              STR      r0,[r4,#0xc]
;;;258    
;;;259        do
00001c  bf00              NOP      
                  |L43.30|
;;;260        {
;;;261          HAL_Delay(1U);
00001e  2001              MOVS     r0,#1
000020  f7fffffe          BL       HAL_Delay
;;;262          ms++;
000024  1c6d              ADDS     r5,r5,#1
;;;263        } while ((USB_GetMode(USBx) != (uint32_t)USB_HOST_MODE) && (ms < 50U));
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       USB_GetMode
00002c  2801              CMP      r0,#1
00002e  d015              BEQ      |L43.92|
000030  2d32              CMP      r5,#0x32
000032  d3f4              BCC      |L43.30|
000034  e012              B        |L43.92|
                  |L43.54|
;;;264      }
;;;265      else if (mode == USB_DEVICE_MODE)
000036  b97e              CBNZ     r6,|L43.88|
;;;266      {
;;;267        USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
000038  68e0              LDR      r0,[r4,#0xc]
00003a  f0404080          ORR      r0,r0,#0x40000000
00003e  60e0              STR      r0,[r4,#0xc]
;;;268    
;;;269        do
000040  bf00              NOP      
                  |L43.66|
;;;270        {
;;;271          HAL_Delay(1U);
000042  2001              MOVS     r0,#1
000044  f7fffffe          BL       HAL_Delay
;;;272          ms++;
000048  1c6d              ADDS     r5,r5,#1
;;;273        } while ((USB_GetMode(USBx) != (uint32_t)USB_DEVICE_MODE) && (ms < 50U));
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       USB_GetMode
000050  b120              CBZ      r0,|L43.92|
000052  2d32              CMP      r5,#0x32
000054  d3f5              BCC      |L43.66|
000056  e001              B        |L43.92|
                  |L43.88|
;;;274      }
;;;275      else
;;;276      {
;;;277        return HAL_ERROR;
000058  2001              MOVS     r0,#1
                  |L43.90|
;;;278      }
;;;279    
;;;280      if (ms == 50U)
;;;281      {
;;;282        return HAL_ERROR;
;;;283      }
;;;284    
;;;285      return HAL_OK;
;;;286    }
00005a  bd70              POP      {r4-r6,pc}
                  |L43.92|
00005c  2d32              CMP      r5,#0x32              ;280
00005e  d101              BNE      |L43.100|
000060  2001              MOVS     r0,#1                 ;282
000062  e7fa              B        |L43.90|
                  |L43.100|
000064  2000              MOVS     r0,#0                 ;285
000066  e7f8              B        |L43.90|
;;;287    
                          ENDP


                          AREA ||i.USB_SetDevAddress||, CODE, READONLY, ALIGN=1

                  USB_SetDevAddress PROC
;;;1243     */
;;;1244   HAL_StatusTypeDef  USB_SetDevAddress(USB_OTG_GlobalTypeDef *USBx, uint8_t address)
000000  b510              PUSH     {r4,lr}
;;;1245   {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;1246     uint32_t USBx_BASE = (uint32_t)USBx;
000006  4611              MOV      r1,r2
;;;1247   
;;;1248     USBx_DEVICE->DCFG &= ~(USB_OTG_DCFG_DAD);
000008  f8d10800          LDR      r0,[r1,#0x800]
00000c  f42060fe          BIC      r0,r0,#0x7f0
000010  f8c10800          STR      r0,[r1,#0x800]
;;;1249     USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;
000014  f8d10800          LDR      r0,[r1,#0x800]
000018  f44f64fe          MOV      r4,#0x7f0
00001c  ea041403          AND      r4,r4,r3,LSL #4
000020  4320              ORRS     r0,r0,r4
000022  f8c10800          STR      r0,[r1,#0x800]
;;;1250   
;;;1251     return HAL_OK;
000026  2000              MOVS     r0,#0
;;;1252   }
000028  bd10              POP      {r4,pc}
;;;1253   
                          ENDP


                          AREA ||i.USB_SetDevSpeed||, CODE, READONLY, ALIGN=1

                  USB_SetDevSpeed PROC
;;;551      */
;;;552    HAL_StatusTypeDef USB_SetDevSpeed(USB_OTG_GlobalTypeDef *USBx, uint8_t speed)
000000  4602              MOV      r2,r0
;;;553    {
;;;554      uint32_t USBx_BASE = (uint32_t)USBx;
000002  4613              MOV      r3,r2
;;;555    
;;;556      USBx_DEVICE->DCFG |= speed;
000004  f8d30800          LDR      r0,[r3,#0x800]
000008  4308              ORRS     r0,r0,r1
00000a  f8c30800          STR      r0,[r3,#0x800]
;;;557      return HAL_OK;
00000e  2000              MOVS     r0,#0
;;;558    }
000010  4770              BX       lr
;;;559    
                          ENDP


                          AREA ||i.USB_SetTurnaroundTime||, CODE, READONLY, ALIGN=2

                  USB_SetTurnaroundTime PROC
;;;138      */
;;;139    HAL_StatusTypeDef USB_SetTurnaroundTime(USB_OTG_GlobalTypeDef *USBx,
000000  b530              PUSH     {r4,r5,lr}
;;;140                                            uint32_t hclk, uint8_t speed)
;;;141    {
000002  4603              MOV      r3,r0
000004  4614              MOV      r4,r2
;;;142      uint32_t UsbTrd;
;;;143    
;;;144      /* The USBTRD is configured according to the tables below, depending on AHB frequency
;;;145      used by application. In the low AHB frequency range it is used to stretch enough the USB response
;;;146      time to IN tokens, the USB turnaround time, so to compensate for the longer AHB read access
;;;147      latency to the Data FIFO */
;;;148      if (speed == USBD_FS_SPEED)
000006  2c02              CMP      r4,#2
000008  d149              BNE      |L46.158|
;;;149      {
;;;150        if ((hclk >= 14200000U) && (hclk < 15000000U))
00000a  482d              LDR      r0,|L46.192|
00000c  4281              CMP      r1,r0
00000e  d304              BCC      |L46.26|
000010  482c              LDR      r0,|L46.196|
000012  4281              CMP      r1,r0
000014  d201              BCS      |L46.26|
;;;151        {
;;;152          /* hclk Clock Range between 14.2-15 MHz */
;;;153          UsbTrd = 0xFU;
000016  220f              MOVS     r2,#0xf
000018  e045              B        |L46.166|
                  |L46.26|
;;;154        }
;;;155        else if ((hclk >= 15000000U) && (hclk < 16000000U))
00001a  482a              LDR      r0,|L46.196|
00001c  4281              CMP      r1,r0
00001e  d304              BCC      |L46.42|
000020  4829              LDR      r0,|L46.200|
000022  4281              CMP      r1,r0
000024  d201              BCS      |L46.42|
;;;156        {
;;;157          /* hclk Clock Range between 15-16 MHz */
;;;158          UsbTrd = 0xEU;
000026  220e              MOVS     r2,#0xe
000028  e03d              B        |L46.166|
                  |L46.42|
;;;159        }
;;;160        else if ((hclk >= 16000000U) && (hclk < 17200000U))
00002a  4827              LDR      r0,|L46.200|
00002c  4281              CMP      r1,r0
00002e  d304              BCC      |L46.58|
000030  4826              LDR      r0,|L46.204|
000032  4281              CMP      r1,r0
000034  d201              BCS      |L46.58|
;;;161        {
;;;162          /* hclk Clock Range between 16-17.2 MHz */
;;;163          UsbTrd = 0xDU;
000036  220d              MOVS     r2,#0xd
000038  e035              B        |L46.166|
                  |L46.58|
;;;164        }
;;;165        else if ((hclk >= 17200000U) && (hclk < 18500000U))
00003a  4824              LDR      r0,|L46.204|
00003c  4281              CMP      r1,r0
00003e  d304              BCC      |L46.74|
000040  4823              LDR      r0,|L46.208|
000042  4281              CMP      r1,r0
000044  d201              BCS      |L46.74|
;;;166        {
;;;167          /* hclk Clock Range between 17.2-18.5 MHz */
;;;168          UsbTrd = 0xCU;
000046  220c              MOVS     r2,#0xc
000048  e02d              B        |L46.166|
                  |L46.74|
;;;169        }
;;;170        else if ((hclk >= 18500000U) && (hclk < 20000000U))
00004a  4821              LDR      r0,|L46.208|
00004c  4281              CMP      r1,r0
00004e  d304              BCC      |L46.90|
000050  4820              LDR      r0,|L46.212|
000052  4281              CMP      r1,r0
000054  d201              BCS      |L46.90|
;;;171        {
;;;172          /* hclk Clock Range between 18.5-20 MHz */
;;;173          UsbTrd = 0xBU;
000056  220b              MOVS     r2,#0xb
000058  e025              B        |L46.166|
                  |L46.90|
;;;174        }
;;;175        else if ((hclk >= 20000000U) && (hclk < 21800000U))
00005a  481e              LDR      r0,|L46.212|
00005c  4281              CMP      r1,r0
00005e  d304              BCC      |L46.106|
000060  481d              LDR      r0,|L46.216|
000062  4281              CMP      r1,r0
000064  d201              BCS      |L46.106|
;;;176        {
;;;177          /* hclk Clock Range between 20-21.8 MHz */
;;;178          UsbTrd = 0xAU;
000066  220a              MOVS     r2,#0xa
000068  e01d              B        |L46.166|
                  |L46.106|
;;;179        }
;;;180        else if ((hclk >= 21800000U) && (hclk < 24000000U))
00006a  481b              LDR      r0,|L46.216|
00006c  4281              CMP      r1,r0
00006e  d304              BCC      |L46.122|
000070  481a              LDR      r0,|L46.220|
000072  4281              CMP      r1,r0
000074  d201              BCS      |L46.122|
;;;181        {
;;;182          /* hclk Clock Range between 21.8-24 MHz */
;;;183          UsbTrd = 0x9U;
000076  2209              MOVS     r2,#9
000078  e015              B        |L46.166|
                  |L46.122|
;;;184        }
;;;185        else if ((hclk >= 24000000U) && (hclk < 27700000U))
00007a  4818              LDR      r0,|L46.220|
00007c  4281              CMP      r1,r0
00007e  d304              BCC      |L46.138|
000080  4817              LDR      r0,|L46.224|
000082  4281              CMP      r1,r0
000084  d201              BCS      |L46.138|
;;;186        {
;;;187          /* hclk Clock Range between 24-27.7 MHz */
;;;188          UsbTrd = 0x8U;
000086  2208              MOVS     r2,#8
000088  e00d              B        |L46.166|
                  |L46.138|
;;;189        }
;;;190        else if ((hclk >= 27700000U) && (hclk < 32000000U))
00008a  4815              LDR      r0,|L46.224|
00008c  4281              CMP      r1,r0
00008e  d304              BCC      |L46.154|
000090  4814              LDR      r0,|L46.228|
000092  4281              CMP      r1,r0
000094  d201              BCS      |L46.154|
;;;191        {
;;;192          /* hclk Clock Range between 27.7-32 MHz */
;;;193          UsbTrd = 0x7U;
000096  2207              MOVS     r2,#7
000098  e005              B        |L46.166|
                  |L46.154|
;;;194        }
;;;195        else /* if(hclk >= 32000000) */
;;;196        {
;;;197          /* hclk Clock Range between 32-200 MHz */
;;;198          UsbTrd = 0x6U;
00009a  2206              MOVS     r2,#6
00009c  e003              B        |L46.166|
                  |L46.158|
;;;199        }
;;;200      }
;;;201      else if (speed == USBD_HS_SPEED)
00009e  b90c              CBNZ     r4,|L46.164|
;;;202      {
;;;203        UsbTrd = USBD_HS_TRDT_VALUE;
0000a0  2209              MOVS     r2,#9
0000a2  e000              B        |L46.166|
                  |L46.164|
;;;204      }
;;;205      else
;;;206      {
;;;207        UsbTrd = USBD_DEFAULT_TRDT_VALUE;
0000a4  2209              MOVS     r2,#9
                  |L46.166|
;;;208      }
;;;209    
;;;210      USBx->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
0000a6  68d8              LDR      r0,[r3,#0xc]
0000a8  f4205070          BIC      r0,r0,#0x3c00
0000ac  60d8              STR      r0,[r3,#0xc]
;;;211      USBx->GUSBCFG |= (uint32_t)((UsbTrd << 10) & USB_OTG_GUSBCFG_TRDT);
0000ae  68d8              LDR      r0,[r3,#0xc]
0000b0  f44f5570          MOV      r5,#0x3c00
0000b4  ea052582          AND      r5,r5,r2,LSL #10
0000b8  4328              ORRS     r0,r0,r5
0000ba  60d8              STR      r0,[r3,#0xc]
;;;212    
;;;213      return HAL_OK;
0000bc  2000              MOVS     r0,#0
;;;214    }
0000be  bd30              POP      {r4,r5,pc}
;;;215    
                          ENDP

                  |L46.192|
                          DCD      0x00d8acc0
                  |L46.196|
                          DCD      0x00e4e1c0
                  |L46.200|
                          DCD      0x00f42400
                  |L46.204|
                          DCD      0x01067380
                  |L46.208|
                          DCD      0x011a49a0
                  |L46.212|
                          DCD      0x01312d00
                  |L46.216|
                          DCD      0x014ca440
                  |L46.220|
                          DCD      0x016e3600
                  |L46.224|
                          DCD      0x01a6ab20
                  |L46.228|
                          DCD      0x01e84800

                          AREA ||i.USB_StopDevice||, CODE, READONLY, ALIGN=1

                  USB_StopDevice PROC
;;;1202     */
;;;1203   HAL_StatusTypeDef USB_StopDevice(USB_OTG_GlobalTypeDef *USBx)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1204   {
000002  4607              MOV      r7,r0
;;;1205     HAL_StatusTypeDef ret;
;;;1206     uint32_t USBx_BASE = (uint32_t)USBx;
000004  463d              MOV      r5,r7
;;;1207     uint32_t i;
;;;1208   
;;;1209     /* Clear Pending interrupt */
;;;1210     for (i = 0U; i < 15U; i++)
000006  2400              MOVS     r4,#0
000008  e00c              B        |L47.36|
                  |L47.10|
;;;1211     {
;;;1212       USBx_INEP(i)->DIEPINT = 0xFB7FU;
00000a  f64f317f          MOV      r1,#0xfb7f
00000e  f5056010          ADD      r0,r5,#0x900
000012  eb001044          ADD      r0,r0,r4,LSL #5
000016  6081              STR      r1,[r0,#8]
;;;1213       USBx_OUTEP(i)->DOEPINT = 0xFB7FU;
000018  f5056030          ADD      r0,r5,#0xb00
00001c  eb001044          ADD      r0,r0,r4,LSL #5
000020  6081              STR      r1,[r0,#8]
000022  1c64              ADDS     r4,r4,#1              ;1210
                  |L47.36|
000024  2c0f              CMP      r4,#0xf               ;1210
000026  d3f0              BCC      |L47.10|
;;;1214     }
;;;1215   
;;;1216     /* Clear interrupt masks */
;;;1217     USBx_DEVICE->DIEPMSK  = 0U;
000028  2100              MOVS     r1,#0
00002a  f44f6001          MOV      r0,#0x810
00002e  5141              STR      r1,[r0,r5]
;;;1218     USBx_DEVICE->DOEPMSK  = 0U;
000030  1d00              ADDS     r0,r0,#4
000032  5141              STR      r1,[r0,r5]
;;;1219     USBx_DEVICE->DAINTMSK = 0U;
000034  f640001c          MOV      r0,#0x81c
000038  5141              STR      r1,[r0,r5]
;;;1220   
;;;1221     /* Flush the FIFO */
;;;1222     ret = USB_FlushRxFifo(USBx);
00003a  4638              MOV      r0,r7
00003c  f7fffffe          BL       USB_FlushRxFifo
000040  4606              MOV      r6,r0
;;;1223     if (ret != HAL_OK)
000042  b10e              CBZ      r6,|L47.72|
;;;1224     {
;;;1225       return ret;
000044  4630              MOV      r0,r6
                  |L47.70|
;;;1226     }
;;;1227   
;;;1228     ret = USB_FlushTxFifo(USBx,  0x10U);
;;;1229     if (ret != HAL_OK)
;;;1230     {
;;;1231       return ret;
;;;1232     }
;;;1233   
;;;1234     return ret;
;;;1235   }
000046  bdf0              POP      {r4-r7,pc}
                  |L47.72|
000048  2110              MOVS     r1,#0x10              ;1228
00004a  4638              MOV      r0,r7                 ;1228
00004c  f7fffffe          BL       USB_FlushTxFifo
000050  4606              MOV      r6,r0                 ;1228
000052  b10e              CBZ      r6,|L47.88|
000054  4630              MOV      r0,r6                 ;1231
000056  e7f6              B        |L47.70|
                  |L47.88|
000058  4630              MOV      r0,r6                 ;1234
00005a  e7f4              B        |L47.70|
;;;1236   
                          ENDP


                          AREA ||i.USB_StopHost||, CODE, READONLY, ALIGN=1

                  USB_StopHost PROC
;;;2116     */
;;;2117   HAL_StatusTypeDef USB_StopHost(USB_OTG_GlobalTypeDef *USBx)
000000  e92d41f8          PUSH     {r3-r8,lr}
;;;2118   {
000004  4607              MOV      r7,r0
;;;2119     HAL_StatusTypeDef ret = HAL_OK;
000006  f04f0800          MOV      r8,#0
;;;2120     uint32_t USBx_BASE = (uint32_t)USBx;
00000a  463e              MOV      r6,r7
;;;2121     __IO uint32_t count = 0U;
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
;;;2122     uint32_t value;
;;;2123     uint32_t i;
;;;2124   
;;;2125     (void)USB_DisableGlobalInt(USBx);
000010  4638              MOV      r0,r7
000012  f7fffffe          BL       USB_DisableGlobalInt
;;;2126   
;;;2127     /* Flush USB FIFO */
;;;2128     if (USB_FlushTxFifo(USBx, 0x10U) != HAL_OK) /* all Tx FIFOs */
000016  2110              MOVS     r1,#0x10
000018  4638              MOV      r0,r7
00001a  f7fffffe          BL       USB_FlushTxFifo
00001e  b108              CBZ      r0,|L48.36|
;;;2129     {
;;;2130       ret = HAL_ERROR;
000020  f04f0801          MOV      r8,#1
                  |L48.36|
;;;2131     }
;;;2132   
;;;2133     if (USB_FlushRxFifo(USBx) != HAL_OK)
000024  4638              MOV      r0,r7
000026  f7fffffe          BL       USB_FlushRxFifo
00002a  b108              CBZ      r0,|L48.48|
;;;2134     {
;;;2135       ret = HAL_ERROR;
00002c  f04f0801          MOV      r8,#1
                  |L48.48|
;;;2136     }
;;;2137   
;;;2138     /* Flush out any leftover queued requests. */
;;;2139     for (i = 0U; i <= 15U; i++)
000030  2400              MOVS     r4,#0
000032  e010              B        |L48.86|
                  |L48.52|
;;;2140     {
;;;2141       value = USBx_HC(i)->HCCHAR;
000034  f50660a0          ADD      r0,r6,#0x500
000038  eb001044          ADD      r0,r0,r4,LSL #5
00003c  6805              LDR      r5,[r0,#0]
;;;2142       value |=  USB_OTG_HCCHAR_CHDIS;
00003e  f0454580          ORR      r5,r5,#0x40000000
;;;2143       value &= ~USB_OTG_HCCHAR_CHENA;
000042  f0254500          BIC      r5,r5,#0x80000000
;;;2144       value &= ~USB_OTG_HCCHAR_EPDIR;
000046  f4254500          BIC      r5,r5,#0x8000
;;;2145       USBx_HC(i)->HCCHAR = value;
00004a  f50660a0          ADD      r0,r6,#0x500
00004e  eb001044          ADD      r0,r0,r4,LSL #5
000052  6005              STR      r5,[r0,#0]
000054  1c64              ADDS     r4,r4,#1              ;2139
                  |L48.86|
000056  2c0f              CMP      r4,#0xf               ;2139
000058  d9ec              BLS      |L48.52|
;;;2146     }
;;;2147   
;;;2148     /* Halt all channels to put them into a known state. */
;;;2149     for (i = 0U; i <= 15U; i++)
00005a  2400              MOVS     r4,#0
00005c  e024              B        |L48.168|
                  |L48.94|
;;;2150     {
;;;2151       value = USBx_HC(i)->HCCHAR;
00005e  f50660a0          ADD      r0,r6,#0x500
000062  eb001044          ADD      r0,r0,r4,LSL #5
000066  6805              LDR      r5,[r0,#0]
;;;2152       value |= USB_OTG_HCCHAR_CHDIS;
000068  f0454580          ORR      r5,r5,#0x40000000
;;;2153       value |= USB_OTG_HCCHAR_CHENA;
00006c  f0454500          ORR      r5,r5,#0x80000000
;;;2154       value &= ~USB_OTG_HCCHAR_EPDIR;
000070  f4254500          BIC      r5,r5,#0x8000
;;;2155       USBx_HC(i)->HCCHAR = value;
000074  f50660a0          ADD      r0,r6,#0x500
000078  eb001044          ADD      r0,r0,r4,LSL #5
00007c  6005              STR      r5,[r0,#0]
;;;2156   
;;;2157       do
00007e  bf00              NOP      
                  |L48.128|
;;;2158       {
;;;2159         count++;
000080  9800              LDR      r0,[sp,#0]
000082  1c40              ADDS     r0,r0,#1
000084  9000              STR      r0,[sp,#0]
;;;2160   
;;;2161         if (count > 1000U)
000086  9800              LDR      r0,[sp,#0]
000088  f5b07f7a          CMP      r0,#0x3e8
00008c  d900              BLS      |L48.144|
;;;2162         {
;;;2163           break;
00008e  e009              B        |L48.164|
                  |L48.144|
;;;2164         }
;;;2165       } while ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
000090  f50660a0          ADD      r0,r6,#0x500
000094  eb001044          ADD      r0,r0,r4,LSL #5
000098  6800              LDR      r0,[r0,#0]
00009a  f0004000          AND      r0,r0,#0x80000000
00009e  f1b04f00          CMP      r0,#0x80000000
0000a2  d0ed              BEQ      |L48.128|
                  |L48.164|
0000a4  bf00              NOP                            ;2163
0000a6  1c64              ADDS     r4,r4,#1              ;2149
                  |L48.168|
0000a8  2c0f              CMP      r4,#0xf               ;2149
0000aa  d9d8              BLS      |L48.94|
;;;2166     }
;;;2167   
;;;2168     /* Clear any pending Host interrupts */
;;;2169     USBx_HOST->HAINT = 0xFFFFFFFFU;
0000ac  f04f31ff          MOV      r1,#0xffffffff
0000b0  f2404014          MOV      r0,#0x414
0000b4  5181              STR      r1,[r0,r6]
;;;2170     USBx->GINTSTS = 0xFFFFFFFFU;
0000b6  4608              MOV      r0,r1
0000b8  6178              STR      r0,[r7,#0x14]
;;;2171   
;;;2172     (void)USB_EnableGlobalInt(USBx);
0000ba  4638              MOV      r0,r7
0000bc  f7fffffe          BL       USB_EnableGlobalInt
;;;2173   
;;;2174     return ret;
0000c0  4640              MOV      r0,r8
;;;2175   }
0000c2  e8bd81f8          POP      {r3-r8,pc}
;;;2176   
                          ENDP


                          AREA ||i.USB_WritePacket||, CODE, READONLY, ALIGN=1

                  USB_WritePacket PROC
;;;1069     */
;;;1070   HAL_StatusTypeDef USB_WritePacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *src,
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;1071                                     uint8_t ch_ep_num, uint16_t len, uint8_t dma)
;;;1072   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  461e              MOV      r6,r3
00000a  f8ddc01c          LDR      r12,[sp,#0x1c]
;;;1073     uint32_t USBx_BASE = (uint32_t)USBx;
00000e  46a0              MOV      r8,r4
;;;1074     uint8_t *pSrc = src;
000010  4629              MOV      r1,r5
;;;1075     uint32_t count32b;
;;;1076     uint32_t i;
;;;1077   
;;;1078     if (dma == 0U)
000012  f1bc0f00          CMP      r12,#0
000016  d112              BNE      |L49.62|
;;;1079     {
;;;1080       count32b = ((uint32_t)len + 3U) / 4U;
000018  1cf0              ADDS     r0,r6,#3
00001a  0887              LSRS     r7,r0,#2
;;;1081       for (i = 0U; i < count32b; i++)
00001c  2300              MOVS     r3,#0
00001e  e00c              B        |L49.58|
                  |L49.32|
;;;1082       {
;;;1083         USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
000020  f8d19000          LDR      r9,[r1,#0]
000024  f5085080          ADD      r0,r8,#0x1000
000028  eb003002          ADD      r0,r0,r2,LSL #12
00002c  f8c09000          STR      r9,[r0,#0]
;;;1084         pSrc++;
000030  1c49              ADDS     r1,r1,#1
;;;1085         pSrc++;
000032  1c49              ADDS     r1,r1,#1
;;;1086         pSrc++;
000034  1c49              ADDS     r1,r1,#1
;;;1087         pSrc++;
000036  1c49              ADDS     r1,r1,#1
000038  1c5b              ADDS     r3,r3,#1              ;1081
                  |L49.58|
00003a  42bb              CMP      r3,r7                 ;1081
00003c  d3f0              BCC      |L49.32|
                  |L49.62|
;;;1088       }
;;;1089     }
;;;1090   
;;;1091     return HAL_OK;
00003e  2000              MOVS     r0,#0
;;;1092   }
000040  e8bd83f0          POP      {r4-r9,pc}
;;;1093   
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_usb.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_ll_usb_c_832330cf____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___18_stm32f4xx_ll_usb_c_832330cf____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_ll_usb_c_832330cf____REVSH|
#line 478
|__asm___18_stm32f4xx_ll_usb_c_832330cf____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_ll_usb_c_832330cf____RRX|
#line 665
|__asm___18_stm32f4xx_ll_usb_c_832330cf____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
