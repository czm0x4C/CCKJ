; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o4gcamera\timers.o --asm_dir=.\ --list_dir=.\ --depend=4gcamera\timers.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../USB_DEVICE/App -I../USB_DEVICE/Target -I../Core/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Middlewares/ST/STM32_USB_Device_Library/Core/Inc -I../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 -I../Middlewares/Third_Party/FreeRTOS/Source/portable/RVDS/ARM_CM4F -I../HARDWARE/OV2640 -I../HARDWARE/WS2812B -I../HARDWARE/RING_BUFFER -I../HARDWARE/FLASH -I.\RTE\_4GCAMERA -IC:\Users\czm\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\czm\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=536 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F407xx --omf_browse=4gcamera\timers.crf ../Middlewares/Third_Party/FreeRTOS/Source/timers.c]
                          THUMB

                          AREA ||i.pcTimerGetName||, CODE, READONLY, ALIGN=1

                  pcTimerGetName PROC
;;;497    
;;;498    const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  4601              MOV      r1,r0
;;;499    {
;;;500    Timer_t *pxTimer = xTimer;
000002  460a              MOV      r2,r1
;;;501    
;;;502    	configASSERT( xTimer );
000004  b951              CBNZ     r1,|L1.28|
000006  bf00              NOP      
000008  2050              MOVS     r0,#0x50
00000a  f3808811          MSR      BASEPRI,r0
00000e  f3bf8f4f          DSB      
000012  f3bf8f6f          ISB      
000016  bf00              NOP      
000018  bf00              NOP      
                  |L1.26|
00001a  e7fe              B        |L1.26|
                  |L1.28|
;;;503    	return pxTimer->pcTimerName;
00001c  6810              LDR      r0,[r2,#0]
;;;504    }
00001e  4770              BX       lr
;;;505    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvCheckForValidListAndQueue||, CODE, READONLY, ALIGN=2

                  prvCheckForValidListAndQueue PROC
;;;940    
;;;941    static void prvCheckForValidListAndQueue( void )
000000  b508              PUSH     {r3,lr}
;;;942    {
;;;943    	/* Check that the list from which active timers are referenced, and the
;;;944    	queue used to communicate with the timer service, have been
;;;945    	initialised. */
;;;946    	taskENTER_CRITICAL();
000002  f7fffffe          BL       vPortEnterCritical
;;;947    	{
;;;948    		if( xTimerQueue == NULL )
000006  4812              LDR      r0,|L2.80|
000008  6800              LDR      r0,[r0,#0]  ; xTimerQueue
00000a  b9e8              CBNZ     r0,|L2.72|
;;;949    		{
;;;950    			vListInitialise( &xActiveTimerList1 );
00000c  4811              LDR      r0,|L2.84|
00000e  f7fffffe          BL       vListInitialise
;;;951    			vListInitialise( &xActiveTimerList2 );
000012  4811              LDR      r0,|L2.88|
000014  f7fffffe          BL       vListInitialise
;;;952    			pxCurrentTimerList = &xActiveTimerList1;
000018  480e              LDR      r0,|L2.84|
00001a  4910              LDR      r1,|L2.92|
00001c  6008              STR      r0,[r1,#0]  ; pxCurrentTimerList
;;;953    			pxOverflowTimerList = &xActiveTimerList2;
00001e  480e              LDR      r0,|L2.88|
000020  490f              LDR      r1,|L2.96|
000022  6008              STR      r0,[r1,#0]  ; pxOverflowTimerList
;;;954    
;;;955    			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;956    			{
;;;957    				/* The timer queue is allocated statically in case
;;;958    				configSUPPORT_DYNAMIC_ALLOCATION is 0. */
;;;959    				static StaticQueue_t xStaticTimerQueue; /*lint !e956 Ok to declare in this manner to prevent additional conditional compilation guards in other locations. */
;;;960    				static uint8_t ucStaticTimerQueueStorage[ ( size_t ) configTIMER_QUEUE_LENGTH * sizeof( DaemonTaskMessage_t ) ]; /*lint !e956 Ok to declare in this manner to prevent additional conditional compilation guards in other locations. */
;;;961    
;;;962    				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
000024  2000              MOVS     r0,#0
000026  4b0f              LDR      r3,|L2.100|
000028  4a0f              LDR      r2,|L2.104|
00002a  2110              MOVS     r1,#0x10
00002c  9000              STR      r0,[sp,#0]
00002e  200a              MOVS     r0,#0xa
000030  f7fffffe          BL       xQueueGenericCreateStatic
000034  4906              LDR      r1,|L2.80|
000036  6008              STR      r0,[r1,#0]  ; xTimerQueue
;;;963    			}
;;;964    			#else
;;;965    			{
;;;966    				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
;;;967    			}
;;;968    			#endif
;;;969    
;;;970    			#if ( configQUEUE_REGISTRY_SIZE > 0 )
;;;971    			{
;;;972    				if( xTimerQueue != NULL )
000038  4608              MOV      r0,r1
00003a  6800              LDR      r0,[r0,#0]  ; xTimerQueue
00003c  b120              CBZ      r0,|L2.72|
;;;973    				{
;;;974    					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
00003e  a10b              ADR      r1,|L2.108|
000040  4803              LDR      r0,|L2.80|
000042  6800              LDR      r0,[r0,#0]  ; xTimerQueue
000044  f7fffffe          BL       vQueueAddToRegistry
                  |L2.72|
;;;975    				}
;;;976    				else
;;;977    				{
;;;978    					mtCOVERAGE_TEST_MARKER();
;;;979    				}
;;;980    			}
;;;981    			#endif /* configQUEUE_REGISTRY_SIZE */
;;;982    		}
;;;983    		else
;;;984    		{
;;;985    			mtCOVERAGE_TEST_MARKER();
;;;986    		}
;;;987    	}
;;;988    	taskEXIT_CRITICAL();
000048  f7fffffe          BL       vPortExitCritical
;;;989    }
00004c  bd08              POP      {r3,pc}
;;;990    /*-----------------------------------------------------------*/
                          ENDP

00004e  0000              DCW      0x0000
                  |L2.80|
                          DCD      xTimerQueue
                  |L2.84|
                          DCD      xActiveTimerList1
                  |L2.88|
                          DCD      xActiveTimerList2
                  |L2.92|
                          DCD      pxCurrentTimerList
                  |L2.96|
                          DCD      pxOverflowTimerList
                  |L2.100|
                          DCD      xStaticTimerQueue
                  |L2.104|
                          DCD      ucStaticTimerQueueStorage
                  |L2.108|
00006c  546d7251          DCB      "TmrQ",0
000070  00      
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0

                          AREA ||i.prvGetNextExpireTime||, CODE, READONLY, ALIGN=2

                  prvGetNextExpireTime PROC
;;;643    
;;;644    static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
000000  4601              MOV      r1,r0
;;;645    {
;;;646    TickType_t xNextExpireTime;
;;;647    
;;;648    	/* Timers are listed in expiry time order, with the head of the list
;;;649    	referencing the task that will expire first.  Obtain the time at which
;;;650    	the timer with the nearest expiry time will expire.  If there are no
;;;651    	active timers then just set the next expire time to 0.  That will cause
;;;652    	this task to unblock when the tick count overflows, at which point the
;;;653    	timer lists will be switched and the next expiry time can be
;;;654    	re-assessed.  */
;;;655    	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
000002  4a08              LDR      r2,|L3.36|
000004  6812              LDR      r2,[r2,#0]  ; pxCurrentTimerList
000006  6812              LDR      r2,[r2,#0]
000008  b90a              CBNZ     r2,|L3.14|
00000a  2201              MOVS     r2,#1
00000c  e000              B        |L3.16|
                  |L3.14|
00000e  2200              MOVS     r2,#0
                  |L3.16|
000010  600a              STR      r2,[r1,#0]
;;;656    	if( *pxListWasEmpty == pdFALSE )
000012  680a              LDR      r2,[r1,#0]
000014  b922              CBNZ     r2,|L3.32|
;;;657    	{
;;;658    		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
000016  4a03              LDR      r2,|L3.36|
000018  6812              LDR      r2,[r2,#0]  ; pxCurrentTimerList
00001a  68d2              LDR      r2,[r2,#0xc]
00001c  6810              LDR      r0,[r2,#0]
00001e  e000              B        |L3.34|
                  |L3.32|
;;;659    	}
;;;660    	else
;;;661    	{
;;;662    		/* Ensure the task unblocks when the tick count rolls over. */
;;;663    		xNextExpireTime = ( TickType_t ) 0U;
000020  2000              MOVS     r0,#0
                  |L3.34|
;;;664    	}
;;;665    
;;;666    	return xNextExpireTime;
;;;667    }
000022  4770              BX       lr
;;;668    /*-----------------------------------------------------------*/
                          ENDP

                  |L3.36|
                          DCD      pxCurrentTimerList

                          AREA ||i.prvInitialiseNewTimer||, CODE, READONLY, ALIGN=1

                  prvInitialiseNewTimer PROC
;;;348    
;;;349    static void prvInitialiseNewTimer(	const char * const pcTimerName,			/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;350    									const TickType_t xTimerPeriodInTicks,
;;;351    									const UBaseType_t uxAutoReload,
;;;352    									void * const pvTimerID,
;;;353    									TimerCallbackFunction_t pxCallbackFunction,
;;;354    									Timer_t *pxNewTimer )
;;;355    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  e9dd9408          LDRD     r9,r4,[sp,#0x20]
;;;356    	/* 0 is not a valid value for xTimerPeriodInTicks. */
;;;357    	configASSERT( ( xTimerPeriodInTicks > 0 ) );
000010  b10d              CBZ      r5,|L4.22|
000012  2001              MOVS     r0,#1
000014  e000              B        |L4.24|
                  |L4.22|
000016  2000              MOVS     r0,#0
                  |L4.24|
000018  b950              CBNZ     r0,|L4.48|
00001a  bf00              NOP      
00001c  2050              MOVS     r0,#0x50
00001e  f3808811          MSR      BASEPRI,r0
000022  f3bf8f4f          DSB      
000026  f3bf8f6f          ISB      
00002a  bf00              NOP      
00002c  bf00              NOP      
                  |L4.46|
00002e  e7fe              B        |L4.46|
                  |L4.48|
;;;358    
;;;359    	if( pxNewTimer != NULL )
000030  b18c              CBZ      r4,|L4.86|
;;;360    	{
;;;361    		/* Ensure the infrastructure used by the timer service task has been
;;;362    		created/initialised. */
;;;363    		prvCheckForValidListAndQueue();
000032  f7fffffe          BL       prvCheckForValidListAndQueue
;;;364    
;;;365    		/* Initialise the timer structure members using the function
;;;366    		parameters. */
;;;367    		pxNewTimer->pcTimerName = pcTimerName;
000036  6026              STR      r6,[r4,#0]
;;;368    		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
000038  61a5              STR      r5,[r4,#0x18]
;;;369    		pxNewTimer->pvTimerID = pvTimerID;
00003a  f8c4801c          STR      r8,[r4,#0x1c]
;;;370    		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
00003e  f8c49020          STR      r9,[r4,#0x20]
;;;371    		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
000042  1d20              ADDS     r0,r4,#4
000044  f7fffffe          BL       vListInitialiseItem
;;;372    		if( uxAutoReload != pdFALSE )
000048  b12f              CBZ      r7,|L4.86|
;;;373    		{
;;;374    			pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
00004a  f8940028          LDRB     r0,[r4,#0x28]
00004e  f0400004          ORR      r0,r0,#4
000052  f8840028          STRB     r0,[r4,#0x28]
                  |L4.86|
;;;375    		}
;;;376    		traceTIMER_CREATE( pxNewTimer );
;;;377    	}
;;;378    }
000056  e8bd87f0          POP      {r4-r10,pc}
;;;379    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvInsertTimerInActiveList||, CODE, READONLY, ALIGN=2

                  prvInsertTimerInActiveList PROC
;;;692    
;;;693    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;694    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;695    BaseType_t xProcessTimerNow = pdFALSE;
00000c  f04f0800          MOV      r8,#0
;;;696    
;;;697    	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
000010  6065              STR      r5,[r4,#4]
;;;698    	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
000012  6124              STR      r4,[r4,#0x10]
;;;699    
;;;700    	if( xNextExpiryTime <= xTimeNow )
000014  42b5              CMP      r5,r6
000016  d80c              BHI      |L5.50|
;;;701    	{
;;;702    		/* Has the expiry time elapsed between the command to start/reset a
;;;703    		timer was issued, and the time the command was processed? */
;;;704    		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000018  1bf0              SUBS     r0,r6,r7
00001a  69a1              LDR      r1,[r4,#0x18]
00001c  4288              CMP      r0,r1
00001e  d302              BCC      |L5.38|
;;;705    		{
;;;706    			/* The time between a command being issued and the command being
;;;707    			processed actually exceeds the timers period.  */
;;;708    			xProcessTimerNow = pdTRUE;
000020  f04f0801          MOV      r8,#1
000024  e011              B        |L5.74|
                  |L5.38|
;;;709    		}
;;;710    		else
;;;711    		{
;;;712    			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
000026  1d21              ADDS     r1,r4,#4
000028  4809              LDR      r0,|L5.80|
00002a  6800              LDR      r0,[r0,#0]  ; pxOverflowTimerList
00002c  f7fffffe          BL       vListInsert
000030  e00b              B        |L5.74|
                  |L5.50|
;;;713    		}
;;;714    	}
;;;715    	else
;;;716    	{
;;;717    		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
000032  42be              CMP      r6,r7
000034  d204              BCS      |L5.64|
000036  42bd              CMP      r5,r7
000038  d302              BCC      |L5.64|
;;;718    		{
;;;719    			/* If, since the command was issued, the tick count has overflowed
;;;720    			but the expiry time has not, then the timer must have already passed
;;;721    			its expiry time and should be processed immediately. */
;;;722    			xProcessTimerNow = pdTRUE;
00003a  f04f0801          MOV      r8,#1
00003e  e004              B        |L5.74|
                  |L5.64|
;;;723    		}
;;;724    		else
;;;725    		{
;;;726    			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
000040  1d21              ADDS     r1,r4,#4
000042  4804              LDR      r0,|L5.84|
000044  6800              LDR      r0,[r0,#0]  ; pxCurrentTimerList
000046  f7fffffe          BL       vListInsert
                  |L5.74|
;;;727    		}
;;;728    	}
;;;729    
;;;730    	return xProcessTimerNow;
00004a  4640              MOV      r0,r8
;;;731    }
00004c  e8bd81f0          POP      {r4-r8,pc}
;;;732    /*-----------------------------------------------------------*/
                          ENDP

                  |L5.80|
                          DCD      pxOverflowTimerList
                  |L5.84|
                          DCD      pxCurrentTimerList

                          AREA ||i.prvProcessExpiredTimer||, CODE, READONLY, ALIGN=2

                  prvProcessExpiredTimer PROC
;;;506    
;;;507    static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
000000  b5f8              PUSH     {r3-r7,lr}
;;;508    {
000002  4605              MOV      r5,r0
000004  460f              MOV      r7,r1
;;;509    BaseType_t xResult;
;;;510    Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000006  481a              LDR      r0,|L6.112|
000008  6800              LDR      r0,[r0,#0]  ; pxCurrentTimerList
00000a  68c0              LDR      r0,[r0,#0xc]
00000c  68c4              LDR      r4,[r0,#0xc]
;;;511    
;;;512    	/* Remove the timer from the list of active timers.  A check has already
;;;513    	been performed to ensure the list is not empty. */
;;;514    	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
00000e  1d20              ADDS     r0,r4,#4
000010  f7fffffe          BL       uxListRemove
;;;515    	traceTIMER_EXPIRED( pxTimer );
;;;516    
;;;517    	/* If the timer is an auto-reload timer then calculate the next
;;;518    	expiry time and re-insert the timer in the list of active timers. */
;;;519    	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
000014  f8940028          LDRB     r0,[r4,#0x28]
000018  f0000004          AND      r0,r0,#4
00001c  b1e8              CBZ      r0,|L6.90|
;;;520    	{
;;;521    		/* The timer is inserted into a list using a time relative to anything
;;;522    		other than the current time.  It will therefore be inserted into the
;;;523    		correct list relative to the time this task thinks it is now. */
;;;524    		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
00001e  69a0              LDR      r0,[r4,#0x18]
000020  1941              ADDS     r1,r0,r5
000022  462b              MOV      r3,r5
000024  463a              MOV      r2,r7
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       prvInsertTimerInActiveList
00002c  b1d8              CBZ      r0,|L6.102|
;;;525    		{
;;;526    			/* The timer expired before it was added to the active timer
;;;527    			list.  Reload it now.  */
;;;528    			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
00002e  2000              MOVS     r0,#0
000030  4603              MOV      r3,r0
000032  462a              MOV      r2,r5
000034  4601              MOV      r1,r0
000036  9000              STR      r0,[sp,#0]
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       xTimerGenericCommand
00003e  4606              MOV      r6,r0
;;;529    			configASSERT( xResult );
000040  b956              CBNZ     r6,|L6.88|
000042  bf00              NOP      
000044  2050              MOVS     r0,#0x50
000046  f3808811          MSR      BASEPRI,r0
00004a  f3bf8f4f          DSB      
00004e  f3bf8f6f          ISB      
000052  bf00              NOP      
000054  bf00              NOP      
                  |L6.86|
000056  e7fe              B        |L6.86|
                  |L6.88|
;;;530    			( void ) xResult;
000058  e005              B        |L6.102|
                  |L6.90|
;;;531    		}
;;;532    		else
;;;533    		{
;;;534    			mtCOVERAGE_TEST_MARKER();
;;;535    		}
;;;536    	}
;;;537    	else
;;;538    	{
;;;539    		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
00005a  f8940028          LDRB     r0,[r4,#0x28]
00005e  f0200001          BIC      r0,r0,#1
000062  f8840028          STRB     r0,[r4,#0x28]
                  |L6.102|
;;;540    		mtCOVERAGE_TEST_MARKER();
;;;541    	}
;;;542    
;;;543    	/* Call the timer callback. */
;;;544    	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
000066  4620              MOV      r0,r4
000068  6a21              LDR      r1,[r4,#0x20]
00006a  4788              BLX      r1
;;;545    }
00006c  bdf8              POP      {r3-r7,pc}
;;;546    /*-----------------------------------------------------------*/
                          ENDP

00006e  0000              DCW      0x0000
                  |L6.112|
                          DCD      pxCurrentTimerList

                          AREA ||i.prvProcessReceivedCommands||, CODE, READONLY, ALIGN=2

                  prvProcessReceivedCommands PROC
;;;733    
;;;734    static void	prvProcessReceivedCommands( void )
000000  b5f0              PUSH     {r4-r7,lr}
;;;735    {
000002  b087              SUB      sp,sp,#0x1c
                  |L7.4|
;;;736    DaemonTaskMessage_t xMessage;
;;;737    Timer_t *pxTimer;
;;;738    BaseType_t xTimerListsWereSwitched, xResult;
;;;739    TickType_t xTimeNow;
;;;740    
;;;741    	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
000004  e0a0              B        |L7.328|
                  |L7.6|
;;;742    	{
;;;743    		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
;;;744    		{
;;;745    			/* Negative commands are pended function calls rather than timer
;;;746    			commands. */
;;;747    			if( xMessage.xMessageID < ( BaseType_t ) 0 )
000006  9803              LDR      r0,[sp,#0xc]
000008  2800              CMP      r0,#0
00000a  da11              BGE      |L7.48|
;;;748    			{
;;;749    				const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
00000c  ae04              ADD      r6,sp,#0x10
;;;750    
;;;751    				/* The timer uses the xCallbackParameters member to request a
;;;752    				callback be executed.  Check the callback is not NULL. */
;;;753    				configASSERT( pxCallback );
00000e  b956              CBNZ     r6,|L7.38|
000010  bf00              NOP      
000012  2050              MOVS     r0,#0x50
000014  f3808811          MSR      BASEPRI,r0
000018  f3bf8f4f          DSB      
00001c  f3bf8f6f          ISB      
000020  bf00              NOP      
000022  bf00              NOP      
                  |L7.36|
000024  e7fe              B        |L7.36|
                  |L7.38|
;;;754    
;;;755    				/* Call the function. */
;;;756    				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
000026  e9d62000          LDRD     r2,r0,[r6,#0]
00002a  68b1              LDR      r1,[r6,#8]
00002c  4790              BLX      r2
;;;757    			}
00002e  bf00              NOP      
                  |L7.48|
;;;758    			else
;;;759    			{
;;;760    				mtCOVERAGE_TEST_MARKER();
;;;761    			}
;;;762    		}
;;;763    		#endif /* INCLUDE_xTimerPendFunctionCall */
;;;764    
;;;765    		/* Commands that are positive are timer commands rather than pended
;;;766    		function calls. */
;;;767    		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
000030  9803              LDR      r0,[sp,#0xc]
000032  2800              CMP      r0,#0
000034  dbe6              BLT      |L7.4|
;;;768    		{
;;;769    			/* The messages uses the xTimerParameters member to work on a
;;;770    			software timer. */
;;;771    			pxTimer = xMessage.u.xTimerParameters.pxTimer;
000036  9c05              LDR      r4,[sp,#0x14]
;;;772    
;;;773    			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
000038  6960              LDR      r0,[r4,#0x14]
00003a  b908              CBNZ     r0,|L7.64|
00003c  2001              MOVS     r0,#1
00003e  e000              B        |L7.66|
                  |L7.64|
000040  2000              MOVS     r0,#0
                  |L7.66|
000042  b910              CBNZ     r0,|L7.74|
;;;774    			{
;;;775    				/* The timer is in a list, remove it. */
;;;776    				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
000044  1d20              ADDS     r0,r4,#4
000046  f7fffffe          BL       uxListRemove
                  |L7.74|
;;;777    			}
;;;778    			else
;;;779    			{
;;;780    				mtCOVERAGE_TEST_MARKER();
;;;781    			}
;;;782    
;;;783    			traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.u.xTimerParameters.xMessageValue );
;;;784    
;;;785    			/* In this case the xTimerListsWereSwitched parameter is not used, but
;;;786    			it must be present in the function call.  prvSampleTimeNow() must be
;;;787    			called after the message is received from xTimerQueue so there is no
;;;788    			possibility of a higher priority task adding a message to the message
;;;789    			queue with a time that is ahead of the timer daemon task (because it
;;;790    			pre-empted the timer daemon task after the xTimeNow value was set). */
;;;791    			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
00004a  a802              ADD      r0,sp,#8
00004c  f7fffffe          BL       prvSampleTimeNow
000050  4605              MOV      r5,r0
;;;792    
;;;793    			switch( xMessage.xMessageID )
000052  9803              LDR      r0,[sp,#0xc]
000054  280a              CMP      r0,#0xa
000056  d275              BCS      |L7.324|
000058  e8dff000          TBB      [pc,r0]
00005c  09050739          DCB      0x09,0x05,0x07,0x39
000060  41630608          DCB      0x41,0x63,0x06,0x08
000064  3a42              DCB      0x3a,0x42
;;;794    			{
;;;795    				case tmrCOMMAND_START :
;;;796    				case tmrCOMMAND_START_FROM_ISR :
000066  bf00              NOP      
;;;797    				case tmrCOMMAND_RESET :
000068  bf00              NOP      
;;;798    				case tmrCOMMAND_RESET_FROM_ISR :
00006a  bf00              NOP      
;;;799    				case tmrCOMMAND_START_DONT_TRACE :
00006c  bf00              NOP      
;;;800    					/* Start or restart a timer. */
;;;801    					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
00006e  f8940028          LDRB     r0,[r4,#0x28]
000072  f0400001          ORR      r0,r0,#1
000076  f8840028          STRB     r0,[r4,#0x28]
;;;802    					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
00007a  9804              LDR      r0,[sp,#0x10]
00007c  69a2              LDR      r2,[r4,#0x18]
00007e  1881              ADDS     r1,r0,r2
000080  4603              MOV      r3,r0
000082  462a              MOV      r2,r5
000084  4620              MOV      r0,r4
000086  f7fffffe          BL       prvInsertTimerInActiveList
00008a  b1f8              CBZ      r0,|L7.204|
;;;803    					{
;;;804    						/* The timer expired before it was added to the active
;;;805    						timer list.  Process it now. */
;;;806    						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
00008c  4620              MOV      r0,r4
00008e  6a21              LDR      r1,[r4,#0x20]
000090  4788              BLX      r1
;;;807    						traceTIMER_EXPIRED( pxTimer );
;;;808    
;;;809    						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
000092  f8940028          LDRB     r0,[r4,#0x28]
000096  f0000004          AND      r0,r0,#4
00009a  b1b8              CBZ      r0,|L7.204|
;;;810    						{
;;;811    							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
00009c  2000              MOVS     r0,#0
00009e  9000              STR      r0,[sp,#0]
0000a0  9804              LDR      r0,[sp,#0x10]
0000a2  69a1              LDR      r1,[r4,#0x18]
0000a4  1842              ADDS     r2,r0,r1
0000a6  2300              MOVS     r3,#0
0000a8  4619              MOV      r1,r3
0000aa  4620              MOV      r0,r4
0000ac  f7fffffe          BL       xTimerGenericCommand
0000b0  4607              MOV      r7,r0
;;;812    							configASSERT( xResult );
0000b2  b957              CBNZ     r7,|L7.202|
0000b4  bf00              NOP      
0000b6  2050              MOVS     r0,#0x50
0000b8  f3808811          MSR      BASEPRI,r0
0000bc  f3bf8f4f          DSB      
0000c0  f3bf8f6f          ISB      
0000c4  bf00              NOP      
0000c6  bf00              NOP      
                  |L7.200|
0000c8  e7fe              B        |L7.200|
                  |L7.202|
;;;813    							( void ) xResult;
0000ca  bf00              NOP      
                  |L7.204|
;;;814    						}
;;;815    						else
;;;816    						{
;;;817    							mtCOVERAGE_TEST_MARKER();
;;;818    						}
;;;819    					}
;;;820    					else
;;;821    					{
;;;822    						mtCOVERAGE_TEST_MARKER();
;;;823    					}
;;;824    					break;
0000cc  e03b              B        |L7.326|
;;;825    
;;;826    				case tmrCOMMAND_STOP :
;;;827    				case tmrCOMMAND_STOP_FROM_ISR :
0000ce  bf00              NOP      
;;;828    					/* The timer has already been removed from the active list. */
;;;829    					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
0000d0  f8940028          LDRB     r0,[r4,#0x28]
0000d4  f0200001          BIC      r0,r0,#1
0000d8  f8840028          STRB     r0,[r4,#0x28]
;;;830    					break;
0000dc  e033              B        |L7.326|
;;;831    
;;;832    				case tmrCOMMAND_CHANGE_PERIOD :
;;;833    				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
0000de  bf00              NOP      
;;;834    					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
0000e0  f8940028          LDRB     r0,[r4,#0x28]
0000e4  f0400001          ORR      r0,r0,#1
0000e8  f8840028          STRB     r0,[r4,#0x28]
;;;835    					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
0000ec  9804              LDR      r0,[sp,#0x10]
0000ee  61a0              STR      r0,[r4,#0x18]
;;;836    					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
0000f0  69a0              LDR      r0,[r4,#0x18]
0000f2  b108              CBZ      r0,|L7.248|
0000f4  2001              MOVS     r0,#1
0000f6  e000              B        |L7.250|
                  |L7.248|
0000f8  2000              MOVS     r0,#0
                  |L7.250|
0000fa  b950              CBNZ     r0,|L7.274|
0000fc  bf00              NOP      
0000fe  2050              MOVS     r0,#0x50
000100  f3808811          MSR      BASEPRI,r0
000104  f3bf8f4f          DSB      
000108  f3bf8f6f          ISB      
00010c  bf00              NOP      
00010e  bf00              NOP      
                  |L7.272|
000110  e7fe              B        |L7.272|
                  |L7.274|
;;;837    
;;;838    					/* The new period does not really have a reference, and can
;;;839    					be longer or shorter than the old one.  The command time is
;;;840    					therefore set to the current time, and as the period cannot
;;;841    					be zero the next expiry time can only be in the future,
;;;842    					meaning (unlike for the xTimerStart() case above) there is
;;;843    					no fail case that needs to be handled here. */
;;;844    					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
000112  69a0              LDR      r0,[r4,#0x18]
000114  1941              ADDS     r1,r0,r5
000116  462b              MOV      r3,r5
000118  462a              MOV      r2,r5
00011a  4620              MOV      r0,r4
00011c  f7fffffe          BL       prvInsertTimerInActiveList
;;;845    					break;
000120  e011              B        |L7.326|
;;;846    
;;;847    				case tmrCOMMAND_DELETE :
;;;848    					#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
;;;849    					{
;;;850    						/* The timer has already been removed from the active list,
;;;851    						just free up the memory if the memory was dynamically
;;;852    						allocated. */
;;;853    						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
000122  f8940028          LDRB     r0,[r4,#0x28]
000126  f0000002          AND      r0,r0,#2
00012a  b918              CBNZ     r0,|L7.308|
;;;854    						{
;;;855    							vPortFree( pxTimer );
00012c  4620              MOV      r0,r4
00012e  f7fffffe          BL       vPortFree
000132  e005              B        |L7.320|
                  |L7.308|
;;;856    						}
;;;857    						else
;;;858    						{
;;;859    							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
000134  f8940028          LDRB     r0,[r4,#0x28]
000138  f0200001          BIC      r0,r0,#1
00013c  f8840028          STRB     r0,[r4,#0x28]
                  |L7.320|
;;;860    						}
;;;861    					}
;;;862    					#else
;;;863    					{
;;;864    						/* If dynamic allocation is not enabled, the memory
;;;865    						could not have been dynamically allocated. So there is
;;;866    						no need to free the memory - just mark the timer as
;;;867    						"not active". */
;;;868    						pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
;;;869    					}
;;;870    					#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;871    					break;
000140  e001              B        |L7.326|
000142  e7ff              B        |L7.324|
                  |L7.324|
;;;872    
;;;873    				default	:
;;;874    					/* Don't expect to get here. */
;;;875    					break;
000144  bf00              NOP      
                  |L7.326|
000146  bf00              NOP                            ;824
                  |L7.328|
000148  2200              MOVS     r2,#0                 ;741
00014a  a903              ADD      r1,sp,#0xc            ;741
00014c  4804              LDR      r0,|L7.352|
00014e  6800              LDR      r0,[r0,#0]            ;741  ; xTimerQueue
000150  f7fffffe          BL       xQueueReceive
000154  2800              CMP      r0,#0                 ;741
000156  f47faf56          BNE      |L7.6|
;;;876    			}
;;;877    		}
;;;878    	}
;;;879    }
00015a  b007              ADD      sp,sp,#0x1c
00015c  bdf0              POP      {r4-r7,pc}
;;;880    /*-----------------------------------------------------------*/
                          ENDP

00015e  0000              DCW      0x0000
                  |L7.352|
                          DCD      xTimerQueue

                          AREA ||i.prvProcessTimerOrBlockTask||, CODE, READONLY, ALIGN=2

                  prvProcessTimerOrBlockTask PROC
;;;583    
;;;584    static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
000000  b5f8              PUSH     {r3-r7,lr}
;;;585    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;586    TickType_t xTimeNow;
;;;587    BaseType_t xTimerListsWereSwitched;
;;;588    
;;;589    	vTaskSuspendAll();
000006  f7fffffe          BL       vTaskSuspendAll
;;;590    	{
;;;591    		/* Obtain the time now to make an assessment as to whether the timer
;;;592    		has expired or not.  If obtaining the time causes the lists to switch
;;;593    		then don't process this timer as any timers that remained in the list
;;;594    		when the lists were switched will have been processed within the
;;;595    		prvSampleTimeNow() function. */
;;;596    		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       prvSampleTimeNow
000010  4606              MOV      r6,r0
;;;597    		if( xTimerListsWereSwitched == pdFALSE )
000012  9800              LDR      r0,[sp,#0]
000014  bb20              CBNZ     r0,|L8.96|
;;;598    		{
;;;599    			/* The tick count has not overflowed, has the timer expired? */
;;;600    			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
000016  b944              CBNZ     r4,|L8.42|
000018  42b5              CMP      r5,r6
00001a  d806              BHI      |L8.42|
;;;601    			{
;;;602    				( void ) xTaskResumeAll();
00001c  f7fffffe          BL       xTaskResumeAll
;;;603    				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
000020  4631              MOV      r1,r6
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       prvProcessExpiredTimer
000028  e01c              B        |L8.100|
                  |L8.42|
;;;604    			}
;;;605    			else
;;;606    			{
;;;607    				/* The tick count has not overflowed, and the next expire
;;;608    				time has not been reached yet.  This task should therefore
;;;609    				block to wait for the next expire time or a command to be
;;;610    				received - whichever comes first.  The following line cannot
;;;611    				be reached unless xNextExpireTime > xTimeNow, except in the
;;;612    				case when the current timer list is empty. */
;;;613    				if( xListWasEmpty != pdFALSE )
00002a  b13c              CBZ      r4,|L8.60|
;;;614    				{
;;;615    					/* The current timer list is empty - is the overflow list
;;;616    					also empty? */
;;;617    					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
00002c  480e              LDR      r0,|L8.104|
00002e  6800              LDR      r0,[r0,#0]  ; pxOverflowTimerList
000030  6800              LDR      r0,[r0,#0]
000032  b908              CBNZ     r0,|L8.56|
000034  2001              MOVS     r0,#1
000036  e000              B        |L8.58|
                  |L8.56|
000038  2000              MOVS     r0,#0
                  |L8.58|
00003a  4604              MOV      r4,r0
                  |L8.60|
;;;618    				}
;;;619    
;;;620    				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
00003c  1ba9              SUBS     r1,r5,r6
00003e  4622              MOV      r2,r4
000040  480a              LDR      r0,|L8.108|
000042  6800              LDR      r0,[r0,#0]  ; xTimerQueue
000044  f7fffffe          BL       vQueueWaitForMessageRestricted
;;;621    
;;;622    				if( xTaskResumeAll() == pdFALSE )
000048  f7fffffe          BL       xTaskResumeAll
00004c  b950              CBNZ     r0,|L8.100|
;;;623    				{
;;;624    					/* Yield to wait for either a command to arrive, or the
;;;625    					block time to expire.  If a command arrived between the
;;;626    					critical section being exited and this yield then the yield
;;;627    					will not cause the task to block. */
;;;628    					portYIELD_WITHIN_API();
00004e  f04f5080          MOV      r0,#0x10000000
000052  4907              LDR      r1,|L8.112|
000054  6008              STR      r0,[r1,#0]
000056  f3bf8f4f          DSB      
00005a  f3bf8f6f          ISB      
00005e  e001              B        |L8.100|
                  |L8.96|
;;;629    				}
;;;630    				else
;;;631    				{
;;;632    					mtCOVERAGE_TEST_MARKER();
;;;633    				}
;;;634    			}
;;;635    		}
;;;636    		else
;;;637    		{
;;;638    			( void ) xTaskResumeAll();
000060  f7fffffe          BL       xTaskResumeAll
                  |L8.100|
;;;639    		}
;;;640    	}
;;;641    }
000064  bdf8              POP      {r3-r7,pc}
;;;642    /*-----------------------------------------------------------*/
                          ENDP

000066  0000              DCW      0x0000
                  |L8.104|
                          DCD      pxOverflowTimerList
                  |L8.108|
                          DCD      xTimerQueue
                  |L8.112|
                          DCD      0xe000ed04

                          AREA ||i.prvSampleTimeNow||, CODE, READONLY, ALIGN=2

                  prvSampleTimeNow PROC
;;;669    
;;;670    static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
000000  b570              PUSH     {r4-r6,lr}
;;;671    {
000002  4604              MOV      r4,r0
;;;672    TickType_t xTimeNow;
;;;673    PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */
;;;674    
;;;675    	xTimeNow = xTaskGetTickCount();
000004  f7fffffe          BL       xTaskGetTickCount
000008  4605              MOV      r5,r0
;;;676    
;;;677    	if( xTimeNow < xLastTime )
00000a  4807              LDR      r0,|L9.40|
00000c  6800              LDR      r0,[r0,#0]  ; xLastTime
00000e  4285              CMP      r5,r0
000010  d204              BCS      |L9.28|
;;;678    	{
;;;679    		prvSwitchTimerLists();
000012  f7fffffe          BL       prvSwitchTimerLists
;;;680    		*pxTimerListsWereSwitched = pdTRUE;
000016  2001              MOVS     r0,#1
000018  6020              STR      r0,[r4,#0]
00001a  e001              B        |L9.32|
                  |L9.28|
;;;681    	}
;;;682    	else
;;;683    	{
;;;684    		*pxTimerListsWereSwitched = pdFALSE;
00001c  2000              MOVS     r0,#0
00001e  6020              STR      r0,[r4,#0]
                  |L9.32|
;;;685    	}
;;;686    
;;;687    	xLastTime = xTimeNow;
000020  4801              LDR      r0,|L9.40|
000022  6005              STR      r5,[r0,#0]  ; xLastTime
;;;688    
;;;689    	return xTimeNow;
000024  4628              MOV      r0,r5
;;;690    }
000026  bd70              POP      {r4-r6,pc}
;;;691    /*-----------------------------------------------------------*/
                          ENDP

                  |L9.40|
                          DCD      xLastTime

                          AREA ||i.prvSwitchTimerLists||, CODE, READONLY, ALIGN=2

                  prvSwitchTimerLists PROC
;;;881    
;;;882    static void prvSwitchTimerLists( void )
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;883    {
;;;884    TickType_t xNextExpireTime, xReloadTime;
;;;885    List_t *pxTemp;
;;;886    Timer_t *pxTimer;
;;;887    BaseType_t xResult;
;;;888    
;;;889    	/* The tick count has overflowed.  The timer lists must be switched.
;;;890    	If there are any timers still referenced from the current timer list
;;;891    	then they must have expired and should be processed before the lists
;;;892    	are switched. */
;;;893    	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
000004  e034              B        |L10.112|
                  |L10.6|
;;;894    	{
;;;895    		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
000006  4825              LDR      r0,|L10.156|
000008  6800              LDR      r0,[r0,#0]  ; pxCurrentTimerList
00000a  68c0              LDR      r0,[r0,#0xc]
00000c  6805              LDR      r5,[r0,#0]
;;;896    
;;;897    		/* Remove the timer from the list. */
;;;898    		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
00000e  4823              LDR      r0,|L10.156|
000010  6800              LDR      r0,[r0,#0]  ; pxCurrentTimerList
000012  68c0              LDR      r0,[r0,#0xc]
000014  68c4              LDR      r4,[r0,#0xc]
;;;899    		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
000016  1d20              ADDS     r0,r4,#4
000018  f7fffffe          BL       uxListRemove
;;;900    		traceTIMER_EXPIRED( pxTimer );
;;;901    
;;;902    		/* Execute its callback, then send a command to restart the timer if
;;;903    		it is an auto-reload timer.  It cannot be restarted here as the lists
;;;904    		have not yet been switched. */
;;;905    		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
00001c  4620              MOV      r0,r4
00001e  6a21              LDR      r1,[r4,#0x20]
000020  4788              BLX      r1
;;;906    
;;;907    		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
000022  f8940028          LDRB     r0,[r4,#0x28]
000026  f0000004          AND      r0,r0,#4
00002a  b308              CBZ      r0,|L10.112|
;;;908    		{
;;;909    			/* Calculate the reload value, and if the reload value results in
;;;910    			the timer going into the same timer list then it has already expired
;;;911    			and the timer should be re-inserted into the current list so it is
;;;912    			processed again within this loop.  Otherwise a command should be sent
;;;913    			to restart the timer to ensure it is only inserted into a list after
;;;914    			the lists have been swapped. */
;;;915    			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
00002c  69a0              LDR      r0,[r4,#0x18]
00002e  1946              ADDS     r6,r0,r5
;;;916    			if( xReloadTime > xNextExpireTime )
000030  42ae              CMP      r6,r5
000032  d907              BLS      |L10.68|
;;;917    			{
;;;918    				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
000034  6066              STR      r6,[r4,#4]
;;;919    				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
000036  6124              STR      r4,[r4,#0x10]
;;;920    				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
000038  1d21              ADDS     r1,r4,#4
00003a  4818              LDR      r0,|L10.156|
00003c  6800              LDR      r0,[r0,#0]  ; pxCurrentTimerList
00003e  f7fffffe          BL       vListInsert
000042  e015              B        |L10.112|
                  |L10.68|
;;;921    			}
;;;922    			else
;;;923    			{
;;;924    				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
000044  2000              MOVS     r0,#0
000046  4603              MOV      r3,r0
000048  462a              MOV      r2,r5
00004a  4601              MOV      r1,r0
00004c  9000              STR      r0,[sp,#0]
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       xTimerGenericCommand
000054  4607              MOV      r7,r0
;;;925    				configASSERT( xResult );
000056  b957              CBNZ     r7,|L10.110|
000058  bf00              NOP      
00005a  2050              MOVS     r0,#0x50
00005c  f3808811          MSR      BASEPRI,r0
000060  f3bf8f4f          DSB      
000064  f3bf8f6f          ISB      
000068  bf00              NOP      
00006a  bf00              NOP      
                  |L10.108|
00006c  e7fe              B        |L10.108|
                  |L10.110|
;;;926    				( void ) xResult;
00006e  bf00              NOP      
                  |L10.112|
000070  480a              LDR      r0,|L10.156|
000072  6800              LDR      r0,[r0,#0]            ;893  ; pxCurrentTimerList
000074  6800              LDR      r0,[r0,#0]            ;893
000076  b908              CBNZ     r0,|L10.124|
000078  2001              MOVS     r0,#1                 ;893
00007a  e000              B        |L10.126|
                  |L10.124|
00007c  2000              MOVS     r0,#0                 ;893
                  |L10.126|
00007e  2800              CMP      r0,#0                 ;893
000080  d0c1              BEQ      |L10.6|
;;;927    			}
;;;928    		}
;;;929    		else
;;;930    		{
;;;931    			mtCOVERAGE_TEST_MARKER();
;;;932    		}
;;;933    	}
;;;934    
;;;935    	pxTemp = pxCurrentTimerList;
000082  4806              LDR      r0,|L10.156|
000084  f8d08000          LDR      r8,[r0,#0]  ; pxCurrentTimerList
;;;936    	pxCurrentTimerList = pxOverflowTimerList;
000088  4805              LDR      r0,|L10.160|
00008a  6800              LDR      r0,[r0,#0]  ; pxOverflowTimerList
00008c  4903              LDR      r1,|L10.156|
00008e  6008              STR      r0,[r1,#0]  ; pxCurrentTimerList
;;;937    	pxOverflowTimerList = pxTemp;
000090  4803              LDR      r0,|L10.160|
000092  f8c08000          STR      r8,[r0,#0]  ; pxOverflowTimerList
;;;938    }
000096  e8bd83f8          POP      {r3-r9,pc}
;;;939    /*-----------------------------------------------------------*/
                          ENDP

00009a  0000              DCW      0x0000
                  |L10.156|
                          DCD      pxCurrentTimerList
                  |L10.160|
                          DCD      pxOverflowTimerList

                          AREA ||i.prvTimerTask||, CODE, READONLY, ALIGN=1

                  prvTimerTask PROC
;;;547    
;;;548    static portTASK_FUNCTION( prvTimerTask, pvParameters )
000000  b508              PUSH     {r3,lr}
;;;549    {
;;;550    TickType_t xNextExpireTime;
;;;551    BaseType_t xListWasEmpty;
;;;552    
;;;553    	/* Just to avoid compiler warnings. */
;;;554    	( void ) pvParameters;
;;;555    
;;;556    	#if( configUSE_DAEMON_TASK_STARTUP_HOOK == 1 )
;;;557    	{
;;;558    		extern void vApplicationDaemonTaskStartupHook( void );
;;;559    
;;;560    		/* Allow the application writer to execute some code in the context of
;;;561    		this task at the point the task starts executing.  This is useful if the
;;;562    		application includes initialisation code that would benefit from
;;;563    		executing after the scheduler has been started. */
;;;564    		vApplicationDaemonTaskStartupHook();
;;;565    	}
;;;566    	#endif /* configUSE_DAEMON_TASK_STARTUP_HOOK */
;;;567    
;;;568    	for( ;; )
000002  bf00              NOP      
                  |L11.4|
;;;569    	{
;;;570    		/* Query the timers list to see if it contains any timers, and if so,
;;;571    		obtain the time at which the next timer will expire. */
;;;572    		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
000004  4668              MOV      r0,sp
000006  f7fffffe          BL       prvGetNextExpireTime
00000a  4604              MOV      r4,r0
;;;573    
;;;574    		/* If a timer has expired, process it.  Otherwise, block this task
;;;575    		until either a timer does expire, or a command is received. */
;;;576    		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
00000c  4620              MOV      r0,r4
00000e  9900              LDR      r1,[sp,#0]
000010  f7fffffe          BL       prvProcessTimerOrBlockTask
;;;577    
;;;578    		/* Empty the command queue. */
;;;579    		prvProcessReceivedCommands();
000014  f7fffffe          BL       prvProcessReceivedCommands
000018  e7f4              B        |L11.4|
;;;580    	}
;;;581    }
;;;582    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.pvTimerGetTimerID||, CODE, READONLY, ALIGN=1

                  pvTimerGetTimerID PROC
;;;1016   
;;;1017   void *pvTimerGetTimerID( const TimerHandle_t xTimer )
000000  b570              PUSH     {r4-r6,lr}
;;;1018   {
000002  4604              MOV      r4,r0
;;;1019   Timer_t * const pxTimer = xTimer;
000004  4625              MOV      r5,r4
;;;1020   void *pvReturn;
;;;1021   
;;;1022   	configASSERT( xTimer );
000006  b954              CBNZ     r4,|L12.30|
000008  bf00              NOP      
00000a  2050              MOVS     r0,#0x50
00000c  f3808811          MSR      BASEPRI,r0
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L12.28|
00001c  e7fe              B        |L12.28|
                  |L12.30|
;;;1023   
;;;1024   	taskENTER_CRITICAL();
00001e  f7fffffe          BL       vPortEnterCritical
;;;1025   	{
;;;1026   		pvReturn = pxTimer->pvTimerID;
000022  69ee              LDR      r6,[r5,#0x1c]
;;;1027   	}
;;;1028   	taskEXIT_CRITICAL();
000024  f7fffffe          BL       vPortExitCritical
;;;1029   
;;;1030   	return pvReturn;
000028  4630              MOV      r0,r6
;;;1031   }
00002a  bd70              POP      {r4-r6,pc}
;;;1032   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxTimerGetReloadMode||, CODE, READONLY, ALIGN=1

                  uxTimerGetReloadMode PROC
;;;461    
;;;462    UBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer )
000000  b570              PUSH     {r4-r6,lr}
;;;463    {
000002  4604              MOV      r4,r0
;;;464    Timer_t * pxTimer =  xTimer;
000004  4626              MOV      r6,r4
;;;465    UBaseType_t uxReturn;
;;;466    
;;;467    	configASSERT( xTimer );
000006  b954              CBNZ     r4,|L13.30|
000008  bf00              NOP      
00000a  2050              MOVS     r0,#0x50
00000c  f3808811          MSR      BASEPRI,r0
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L13.28|
00001c  e7fe              B        |L13.28|
                  |L13.30|
;;;468    	taskENTER_CRITICAL();
00001e  f7fffffe          BL       vPortEnterCritical
;;;469    	{
;;;470    		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) == 0 )
000022  f8960028          LDRB     r0,[r6,#0x28]
000026  f0000004          AND      r0,r0,#4
00002a  b908              CBNZ     r0,|L13.48|
;;;471    		{
;;;472    			/* Not an auto-reload timer. */
;;;473    			uxReturn = ( UBaseType_t ) pdFALSE;
00002c  2500              MOVS     r5,#0
00002e  e000              B        |L13.50|
                  |L13.48|
;;;474    		}
;;;475    		else
;;;476    		{
;;;477    			/* Is an auto-reload timer. */
;;;478    			uxReturn = ( UBaseType_t ) pdTRUE;
000030  2501              MOVS     r5,#1
                  |L13.50|
;;;479    		}
;;;480    	}
;;;481    	taskEXIT_CRITICAL();
000032  f7fffffe          BL       vPortExitCritical
;;;482    
;;;483    	return uxReturn;
000036  4628              MOV      r0,r5
;;;484    }
000038  bd70              POP      {r4-r6,pc}
;;;485    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxTimerGetTimerNumber||, CODE, READONLY, ALIGN=1

                  uxTimerGetTimerNumber PROC
;;;1102   
;;;1103   	UBaseType_t uxTimerGetTimerNumber( TimerHandle_t xTimer )
000000  4601              MOV      r1,r0
;;;1104   	{
;;;1105   		return ( ( Timer_t * ) xTimer )->uxTimerNumber;
000002  6a48              LDR      r0,[r1,#0x24]
;;;1106   	}
000004  4770              BX       lr
;;;1107   
                          ENDP


                          AREA ||i.vTimerSetReloadMode||, CODE, READONLY, ALIGN=1

                  vTimerSetReloadMode PROC
;;;441    
;;;442    void vTimerSetReloadMode( TimerHandle_t xTimer, const UBaseType_t uxAutoReload )
000000  b570              PUSH     {r4-r6,lr}
;;;443    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;444    Timer_t * pxTimer =  xTimer;
000006  462c              MOV      r4,r5
;;;445    
;;;446    	configASSERT( xTimer );
000008  b955              CBNZ     r5,|L15.32|
00000a  bf00              NOP      
00000c  2050              MOVS     r0,#0x50
00000e  f3808811          MSR      BASEPRI,r0
000012  f3bf8f4f          DSB      
000016  f3bf8f6f          ISB      
00001a  bf00              NOP      
00001c  bf00              NOP      
                  |L15.30|
00001e  e7fe              B        |L15.30|
                  |L15.32|
;;;447    	taskENTER_CRITICAL();
000020  f7fffffe          BL       vPortEnterCritical
;;;448    	{
;;;449    		if( uxAutoReload != pdFALSE )
000024  b136              CBZ      r6,|L15.52|
;;;450    		{
;;;451    			pxTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
000026  f8940028          LDRB     r0,[r4,#0x28]
00002a  f0400004          ORR      r0,r0,#4
00002e  f8840028          STRB     r0,[r4,#0x28]
000032  e005              B        |L15.64|
                  |L15.52|
;;;452    		}
;;;453    		else
;;;454    		{
;;;455    			pxTimer->ucStatus &= ~tmrSTATUS_IS_AUTORELOAD;
000034  f8940028          LDRB     r0,[r4,#0x28]
000038  f0200004          BIC      r0,r0,#4
00003c  f8840028          STRB     r0,[r4,#0x28]
                  |L15.64|
;;;456    		}
;;;457    	}
;;;458    	taskEXIT_CRITICAL();
000040  f7fffffe          BL       vPortExitCritical
;;;459    }
000044  bd70              POP      {r4-r6,pc}
;;;460    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vTimerSetTimerID||, CODE, READONLY, ALIGN=1

                  vTimerSetTimerID PROC
;;;1033   
;;;1034   void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID )
000000  b570              PUSH     {r4-r6,lr}
;;;1035   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1036   Timer_t * const pxTimer = xTimer;
000006  4626              MOV      r6,r4
;;;1037   
;;;1038   	configASSERT( xTimer );
000008  b954              CBNZ     r4,|L16.32|
00000a  bf00              NOP      
00000c  2050              MOVS     r0,#0x50
00000e  f3808811          MSR      BASEPRI,r0
000012  f3bf8f4f          DSB      
000016  f3bf8f6f          ISB      
00001a  bf00              NOP      
00001c  bf00              NOP      
                  |L16.30|
00001e  e7fe              B        |L16.30|
                  |L16.32|
;;;1039   
;;;1040   	taskENTER_CRITICAL();
000020  f7fffffe          BL       vPortEnterCritical
;;;1041   	{
;;;1042   		pxTimer->pvTimerID = pvNewID;
000024  61f5              STR      r5,[r6,#0x1c]
;;;1043   	}
;;;1044   	taskEXIT_CRITICAL();
000026  f7fffffe          BL       vPortExitCritical
;;;1045   }
00002a  bd70              POP      {r4-r6,pc}
;;;1046   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vTimerSetTimerNumber||, CODE, READONLY, ALIGN=1

                  vTimerSetTimerNumber PROC
;;;1112   
;;;1113   	void vTimerSetTimerNumber( TimerHandle_t xTimer, UBaseType_t uxTimerNumber )
000000  6241              STR      r1,[r0,#0x24]
;;;1114   	{
;;;1115   		( ( Timer_t * ) xTimer )->uxTimerNumber = uxTimerNumber;
;;;1116   	}
000002  4770              BX       lr
;;;1117   
                          ENDP


                          AREA ||i.xTimerCreate||, CODE, READONLY, ALIGN=1

                  xTimerCreate PROC
;;;281    
;;;282    	TimerHandle_t xTimerCreate(	const char * const pcTimerName,			/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;283    								const TickType_t xTimerPeriodInTicks,
;;;284    								const UBaseType_t uxAutoReload,
;;;285    								void * const pvTimerID,
;;;286    								TimerCallbackFunction_t pxCallbackFunction )
;;;287    	{
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  f8dd9028          LDR      r9,[sp,#0x28]
;;;288    	Timer_t *pxNewTimer;
;;;289    
;;;290    		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
000010  202c              MOVS     r0,#0x2c
000012  f7fffffe          BL       pvPortMalloc
000016  4604              MOV      r4,r0
;;;291    
;;;292    		if( pxNewTimer != NULL )
000018  b154              CBZ      r4,|L18.48|
;;;293    		{
;;;294    			/* Status is thus far zero as the timer is not created statically
;;;295    			and has not been started.  The auto-reload bit may get set in
;;;296    			prvInitialiseNewTimer. */
;;;297    			pxNewTimer->ucStatus = 0x00;
00001a  2000              MOVS     r0,#0
00001c  f8840028          STRB     r0,[r4,#0x28]
;;;298    			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
000020  4643              MOV      r3,r8
000022  463a              MOV      r2,r7
000024  4631              MOV      r1,r6
000026  4628              MOV      r0,r5
000028  e9cd9400          STRD     r9,r4,[sp,#0]
00002c  f7fffffe          BL       prvInitialiseNewTimer
                  |L18.48|
;;;299    		}
;;;300    
;;;301    		return pxNewTimer;
000030  4620              MOV      r0,r4
;;;302    	}
000032  e8bd87fc          POP      {r2-r10,pc}
;;;303    
                          ENDP


                          AREA ||i.xTimerCreateStatic||, CODE, READONLY, ALIGN=1

                  xTimerCreateStatic PROC
;;;308    
;;;309    	TimerHandle_t xTimerCreateStatic(	const char * const pcTimerName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;310    										const TickType_t xTimerPeriodInTicks,
;;;311    										const UBaseType_t uxAutoReload,
;;;312    										void * const pvTimerID,
;;;313    										TimerCallbackFunction_t pxCallbackFunction,
;;;314    										StaticTimer_t *pxTimerBuffer )
;;;315    	{
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  e9dda50a          LDRD     r10,r5,[sp,#0x28]
;;;316    	Timer_t *pxNewTimer;
;;;317    
;;;318    		#if( configASSERT_DEFINED == 1 )
;;;319    		{
;;;320    			/* Sanity check that the size of the structure used to declare a
;;;321    			variable of type StaticTimer_t equals the size of the real timer
;;;322    			structure. */
;;;323    			volatile size_t xSize = sizeof( StaticTimer_t );
000010  202c              MOVS     r0,#0x2c
000012  9001              STR      r0,[sp,#4]
;;;324    			configASSERT( xSize == sizeof( Timer_t ) );
000014  9801              LDR      r0,[sp,#4]
000016  282c              CMP      r0,#0x2c
000018  d101              BNE      |L19.30|
00001a  2001              MOVS     r0,#1
00001c  e000              B        |L19.32|
                  |L19.30|
00001e  2000              MOVS     r0,#0
                  |L19.32|
000020  b950              CBNZ     r0,|L19.56|
000022  bf00              NOP      
000024  2050              MOVS     r0,#0x50
000026  f3808811          MSR      BASEPRI,r0
00002a  f3bf8f4f          DSB      
00002e  f3bf8f6f          ISB      
000032  bf00              NOP      
000034  bf00              NOP      
                  |L19.54|
000036  e7fe              B        |L19.54|
                  |L19.56|
;;;325    			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
000038  bf00              NOP      
;;;326    		}
;;;327    		#endif /* configASSERT_DEFINED */
;;;328    
;;;329    		/* A pointer to a StaticTimer_t structure MUST be provided, use it. */
;;;330    		configASSERT( pxTimerBuffer );
00003a  b955              CBNZ     r5,|L19.82|
00003c  bf00              NOP      
00003e  2050              MOVS     r0,#0x50
000040  f3808811          MSR      BASEPRI,r0
000044  f3bf8f4f          DSB      
000048  f3bf8f6f          ISB      
00004c  bf00              NOP      
00004e  bf00              NOP      
                  |L19.80|
000050  e7fe              B        |L19.80|
                  |L19.82|
;;;331    		pxNewTimer = ( Timer_t * ) pxTimerBuffer; /*lint !e740 !e9087 StaticTimer_t is a pointer to a Timer_t, so guaranteed to be aligned and sized correctly (checked by an assert()), so this is safe. */
000052  462c              MOV      r4,r5
;;;332    
;;;333    		if( pxNewTimer != NULL )
000054  b154              CBZ      r4,|L19.108|
;;;334    		{
;;;335    			/* Timers can be created statically or dynamically so note this
;;;336    			timer was created statically in case it is later deleted.  The
;;;337    			auto-reload bit may get set in prvInitialiseNewTimer(). */
;;;338    			pxNewTimer->ucStatus = tmrSTATUS_IS_STATICALLY_ALLOCATED;
000056  2002              MOVS     r0,#2
000058  f8840028          STRB     r0,[r4,#0x28]
;;;339    
;;;340    			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
00005c  464b              MOV      r3,r9
00005e  4642              MOV      r2,r8
000060  4639              MOV      r1,r7
000062  4630              MOV      r0,r6
000064  e9cda400          STRD     r10,r4,[sp,#0]
000068  f7fffffe          BL       prvInitialiseNewTimer
                  |L19.108|
;;;341    		}
;;;342    
;;;343    		return pxNewTimer;
00006c  4620              MOV      r0,r4
;;;344    	}
00006e  e8bd87fc          POP      {r2-r10,pc}
;;;345    
                          ENDP


                          AREA ||i.xTimerCreateTimerTask||, CODE, READONLY, ALIGN=2

                  xTimerCreateTimerTask PROC
;;;226    
;;;227    BaseType_t xTimerCreateTimerTask( void )
000000  b510              PUSH     {r4,lr}
;;;228    {
000002  b086              SUB      sp,sp,#0x18
;;;229    BaseType_t xReturn = pdFAIL;
000004  2400              MOVS     r4,#0
;;;230    
;;;231    	/* This function is called when the scheduler is started if
;;;232    	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
;;;233    	timer service task has been created/initialised.  If timers have already
;;;234    	been created then the initialisation will already have been performed. */
;;;235    	prvCheckForValidListAndQueue();
000006  f7fffffe          BL       prvCheckForValidListAndQueue
;;;236    
;;;237    	if( xTimerQueue != NULL )
00000a  4816              LDR      r0,|L20.100|
00000c  6800              LDR      r0,[r0,#0]  ; xTimerQueue
00000e  b1d0              CBZ      r0,|L20.70|
;;;238    	{
;;;239    		#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;240    		{
;;;241    			StaticTask_t *pxTimerTaskTCBBuffer = NULL;
000010  2000              MOVS     r0,#0
000012  9005              STR      r0,[sp,#0x14]
;;;242    			StackType_t *pxTimerTaskStackBuffer = NULL;
000014  9004              STR      r0,[sp,#0x10]
;;;243    			uint32_t ulTimerTaskStackSize;
;;;244    
;;;245    			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
000016  aa03              ADD      r2,sp,#0xc
000018  a904              ADD      r1,sp,#0x10
00001a  a805              ADD      r0,sp,#0x14
00001c  f7fffffe          BL       vApplicationGetTimerTaskMemory
;;;246    			xTimerTaskHandle = xTaskCreateStatic(	prvTimerTask,
000020  2202              MOVS     r2,#2
000022  e9dd1004          LDRD     r1,r0,[sp,#0x10]
000026  2300              MOVS     r3,#0
000028  e9cd2100          STRD     r2,r1,[sp,#0]
00002c  9002              STR      r0,[sp,#8]
00002e  a10e              ADR      r1,|L20.104|
000030  480f              LDR      r0,|L20.112|
000032  9a03              LDR      r2,[sp,#0xc]
000034  f7fffffe          BL       xTaskCreateStatic
000038  490e              LDR      r1,|L20.116|
00003a  6008              STR      r0,[r1,#0]  ; xTimerTaskHandle
;;;247    													configTIMER_SERVICE_TASK_NAME,
;;;248    													ulTimerTaskStackSize,
;;;249    													NULL,
;;;250    													( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT,
;;;251    													pxTimerTaskStackBuffer,
;;;252    													pxTimerTaskTCBBuffer );
;;;253    
;;;254    			if( xTimerTaskHandle != NULL )
00003c  4608              MOV      r0,r1
00003e  6800              LDR      r0,[r0,#0]  ; xTimerTaskHandle
000040  b100              CBZ      r0,|L20.68|
;;;255    			{
;;;256    				xReturn = pdPASS;
000042  2401              MOVS     r4,#1
                  |L20.68|
;;;257    			}
;;;258    		}
000044  bf00              NOP      
                  |L20.70|
;;;259    		#else
;;;260    		{
;;;261    			xReturn = xTaskCreate(	prvTimerTask,
;;;262    									configTIMER_SERVICE_TASK_NAME,
;;;263    									configTIMER_TASK_STACK_DEPTH,
;;;264    									NULL,
;;;265    									( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT,
;;;266    									&xTimerTaskHandle );
;;;267    		}
;;;268    		#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;269    	}
;;;270    	else
;;;271    	{
;;;272    		mtCOVERAGE_TEST_MARKER();
;;;273    	}
;;;274    
;;;275    	configASSERT( xReturn );
000046  b954              CBNZ     r4,|L20.94|
000048  bf00              NOP      
00004a  2050              MOVS     r0,#0x50
00004c  f3808811          MSR      BASEPRI,r0
000050  f3bf8f4f          DSB      
000054  f3bf8f6f          ISB      
000058  bf00              NOP      
00005a  bf00              NOP      
                  |L20.92|
00005c  e7fe              B        |L20.92|
                  |L20.94|
;;;276    	return xReturn;
00005e  4620              MOV      r0,r4
;;;277    }
000060  b006              ADD      sp,sp,#0x18
000062  bd10              POP      {r4,pc}
;;;278    /*-----------------------------------------------------------*/
                          ENDP

                  |L20.100|
                          DCD      xTimerQueue
                  |L20.104|
000068  546d7220          DCB      "Tmr Svc",0
00006c  53766300
                  |L20.112|
                          DCD      prvTimerTask
                  |L20.116|
                          DCD      xTimerTaskHandle

                          AREA ||i.xTimerGenericCommand||, CODE, READONLY, ALIGN=2

                  xTimerGenericCommand PROC
;;;380    
;;;381    BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;382    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8030          LDR      r8,[sp,#0x30]
;;;383    BaseType_t xReturn = pdFAIL;
000010  f04f0900          MOV      r9,#0
;;;384    DaemonTaskMessage_t xMessage;
;;;385    
;;;386    	configASSERT( xTimer );
000014  b954              CBNZ     r4,|L21.44|
000016  bf00              NOP      
000018  2050              MOVS     r0,#0x50
00001a  f3808811          MSR      BASEPRI,r0
00001e  f3bf8f4f          DSB      
000022  f3bf8f6f          ISB      
000026  bf00              NOP      
000028  bf00              NOP      
                  |L21.42|
00002a  e7fe              B        |L21.42|
                  |L21.44|
;;;387    
;;;388    	/* Send a message to the timer service task to perform a particular action
;;;389    	on a particular timer definition. */
;;;390    	if( xTimerQueue != NULL )
00002c  4814              LDR      r0,|L21.128|
00002e  6800              LDR      r0,[r0,#0]  ; xTimerQueue
000030  b310              CBZ      r0,|L21.120|
;;;391    	{
;;;392    		/* Send a command to the timer service task to start the xTimer timer. */
;;;393    		xMessage.xMessageID = xCommandID;
000032  9500              STR      r5,[sp,#0]
;;;394    		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
000034  9601              STR      r6,[sp,#4]
;;;395    		xMessage.u.xTimerParameters.pxTimer = xTimer;
000036  9402              STR      r4,[sp,#8]
;;;396    
;;;397    		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
000038  2d06              CMP      r5,#6
00003a  da15              BGE      |L21.104|
;;;398    		{
;;;399    			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
00003c  f7fffffe          BL       xTaskGetSchedulerState
000040  2802              CMP      r0,#2
000042  d108              BNE      |L21.86|
;;;400    			{
;;;401    				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
000044  2300              MOVS     r3,#0
000046  4642              MOV      r2,r8
000048  4669              MOV      r1,sp
00004a  480d              LDR      r0,|L21.128|
00004c  6800              LDR      r0,[r0,#0]  ; xTimerQueue
00004e  f7fffffe          BL       xQueueGenericSend
000052  4681              MOV      r9,r0
000054  e010              B        |L21.120|
                  |L21.86|
;;;402    			}
;;;403    			else
;;;404    			{
;;;405    				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
000056  2300              MOVS     r3,#0
000058  461a              MOV      r2,r3
00005a  4669              MOV      r1,sp
00005c  4808              LDR      r0,|L21.128|
00005e  6800              LDR      r0,[r0,#0]  ; xTimerQueue
000060  f7fffffe          BL       xQueueGenericSend
000064  4681              MOV      r9,r0
000066  e007              B        |L21.120|
                  |L21.104|
;;;406    			}
;;;407    		}
;;;408    		else
;;;409    		{
;;;410    			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
000068  2300              MOVS     r3,#0
00006a  463a              MOV      r2,r7
00006c  4669              MOV      r1,sp
00006e  4804              LDR      r0,|L21.128|
000070  6800              LDR      r0,[r0,#0]  ; xTimerQueue
000072  f7fffffe          BL       xQueueGenericSendFromISR
000076  4681              MOV      r9,r0
                  |L21.120|
;;;411    		}
;;;412    
;;;413    		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
;;;414    	}
;;;415    	else
;;;416    	{
;;;417    		mtCOVERAGE_TEST_MARKER();
;;;418    	}
;;;419    
;;;420    	return xReturn;
000078  4648              MOV      r0,r9
;;;421    }
00007a  b004              ADD      sp,sp,#0x10
00007c  e8bd87f0          POP      {r4-r10,pc}
;;;422    /*-----------------------------------------------------------*/
                          ENDP

                  |L21.128|
                          DCD      xTimerQueue

                          AREA ||i.xTimerGetExpiryTime||, CODE, READONLY, ALIGN=1

                  xTimerGetExpiryTime PROC
;;;486    
;;;487    TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
000000  b510              PUSH     {r4,lr}
;;;488    {
000002  4601              MOV      r1,r0
;;;489    Timer_t * pxTimer =  xTimer;
000004  460a              MOV      r2,r1
;;;490    TickType_t xReturn;
;;;491    
;;;492    	configASSERT( xTimer );
000006  b951              CBNZ     r1,|L22.30|
000008  bf00              NOP      
00000a  2350              MOVS     r3,#0x50
00000c  f3838811          MSR      BASEPRI,r3
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L22.28|
00001c  e7fe              B        |L22.28|
                  |L22.30|
;;;493    	xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
00001e  6850              LDR      r0,[r2,#4]
;;;494    	return xReturn;
;;;495    }
000020  bd10              POP      {r4,pc}
;;;496    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xTimerGetPeriod||, CODE, READONLY, ALIGN=1

                  xTimerGetPeriod PROC
;;;432    
;;;433    TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
000000  4601              MOV      r1,r0
;;;434    {
;;;435    Timer_t *pxTimer = xTimer;
000002  460a              MOV      r2,r1
;;;436    
;;;437    	configASSERT( xTimer );
000004  b951              CBNZ     r1,|L23.28|
000006  bf00              NOP      
000008  2050              MOVS     r0,#0x50
00000a  f3808811          MSR      BASEPRI,r0
00000e  f3bf8f4f          DSB      
000012  f3bf8f6f          ISB      
000016  bf00              NOP      
000018  bf00              NOP      
                  |L23.26|
00001a  e7fe              B        |L23.26|
                  |L23.28|
;;;438    	return pxTimer->xTimerPeriodInTicks;
00001c  6990              LDR      r0,[r2,#0x18]
;;;439    }
00001e  4770              BX       lr
;;;440    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xTimerGetTimerDaemonTaskHandle||, CODE, READONLY, ALIGN=2

                  xTimerGetTimerDaemonTaskHandle PROC
;;;423    
;;;424    TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
000000  480a              LDR      r0,|L24.44|
;;;425    {
;;;426    	/* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
;;;427    	started, then xTimerTaskHandle will be NULL. */
;;;428    	configASSERT( ( xTimerTaskHandle != NULL ) );
000002  6800              LDR      r0,[r0,#0]  ; xTimerTaskHandle
000004  b108              CBZ      r0,|L24.10|
000006  2001              MOVS     r0,#1
000008  e000              B        |L24.12|
                  |L24.10|
00000a  2000              MOVS     r0,#0
                  |L24.12|
00000c  b950              CBNZ     r0,|L24.36|
00000e  bf00              NOP      
000010  2050              MOVS     r0,#0x50
000012  f3808811          MSR      BASEPRI,r0
000016  f3bf8f4f          DSB      
00001a  f3bf8f6f          ISB      
00001e  bf00              NOP      
000020  bf00              NOP      
                  |L24.34|
000022  e7fe              B        |L24.34|
                  |L24.36|
;;;429    	return xTimerTaskHandle;
000024  4801              LDR      r0,|L24.44|
000026  6800              LDR      r0,[r0,#0]  ; xTimerTaskHandle
;;;430    }
000028  4770              BX       lr
;;;431    /*-----------------------------------------------------------*/
                          ENDP

00002a  0000              DCW      0x0000
                  |L24.44|
                          DCD      xTimerTaskHandle

                          AREA ||i.xTimerIsTimerActive||, CODE, READONLY, ALIGN=1

                  xTimerIsTimerActive PROC
;;;991    
;;;992    BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
000000  b570              PUSH     {r4-r6,lr}
;;;993    {
000002  4604              MOV      r4,r0
;;;994    BaseType_t xReturn;
;;;995    Timer_t *pxTimer = xTimer;
000004  4626              MOV      r6,r4
;;;996    
;;;997    	configASSERT( xTimer );
000006  b954              CBNZ     r4,|L25.30|
000008  bf00              NOP      
00000a  2050              MOVS     r0,#0x50
00000c  f3808811          MSR      BASEPRI,r0
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L25.28|
00001c  e7fe              B        |L25.28|
                  |L25.30|
;;;998    
;;;999    	/* Is the timer in the list of active timers? */
;;;1000   	taskENTER_CRITICAL();
00001e  f7fffffe          BL       vPortEnterCritical
;;;1001   	{
;;;1002   		if( ( pxTimer->ucStatus & tmrSTATUS_IS_ACTIVE ) == 0 )
000022  f8960028          LDRB     r0,[r6,#0x28]
000026  f0000001          AND      r0,r0,#1
00002a  b908              CBNZ     r0,|L25.48|
;;;1003   		{
;;;1004   			xReturn = pdFALSE;
00002c  2500              MOVS     r5,#0
00002e  e000              B        |L25.50|
                  |L25.48|
;;;1005   		}
;;;1006   		else
;;;1007   		{
;;;1008   			xReturn = pdTRUE;
000030  2501              MOVS     r5,#1
                  |L25.50|
;;;1009   		}
;;;1010   	}
;;;1011   	taskEXIT_CRITICAL();
000032  f7fffffe          BL       vPortExitCritical
;;;1012   
;;;1013   	return xReturn;
000036  4628              MOV      r0,r5
;;;1014   } /*lint !e818 Can't be pointer to const due to the typedef. */
000038  bd70              POP      {r4-r6,pc}
;;;1015   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xTimerPendFunctionCall||, CODE, READONLY, ALIGN=2

                  xTimerPendFunctionCall PROC
;;;1073   
;;;1074   	BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait )
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;1075   	{
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1076   	DaemonTaskMessage_t xMessage;
;;;1077   	BaseType_t xReturn;
;;;1078   
;;;1079   		/* This function can only be called after a timer has been created or
;;;1080   		after the scheduler has been started because, until then, the timer
;;;1081   		queue does not exist. */
;;;1082   		configASSERT( xTimerQueue );
00000c  480f              LDR      r0,|L26.76|
00000e  6800              LDR      r0,[r0,#0]  ; xTimerQueue
000010  b950              CBNZ     r0,|L26.40|
000012  bf00              NOP      
000014  2050              MOVS     r0,#0x50
000016  f3808811          MSR      BASEPRI,r0
00001a  f3bf8f4f          DSB      
00001e  f3bf8f6f          ISB      
000022  bf00              NOP      
000024  bf00              NOP      
                  |L26.38|
000026  e7fe              B        |L26.38|
                  |L26.40|
;;;1083   
;;;1084   		/* Complete the message with the function parameters and post it to the
;;;1085   		daemon task. */
;;;1086   		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK;
000028  f04f30ff          MOV      r0,#0xffffffff
00002c  9000              STR      r0,[sp,#0]
;;;1087   		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
00002e  9401              STR      r4,[sp,#4]
;;;1088   		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
000030  9502              STR      r5,[sp,#8]
;;;1089   		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
000032  9603              STR      r6,[sp,#0xc]
;;;1090   
;;;1091   		xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
000034  2300              MOVS     r3,#0
000036  463a              MOV      r2,r7
000038  4669              MOV      r1,sp
00003a  4804              LDR      r0,|L26.76|
00003c  6800              LDR      r0,[r0,#0]  ; xTimerQueue
00003e  f7fffffe          BL       xQueueGenericSend
000042  4680              MOV      r8,r0
;;;1092   
;;;1093   		tracePEND_FUNC_CALL( xFunctionToPend, pvParameter1, ulParameter2, xReturn );
;;;1094   
;;;1095   		return xReturn;
000044  4640              MOV      r0,r8
;;;1096   	}
000046  b004              ADD      sp,sp,#0x10
000048  e8bd81f0          POP      {r4-r8,pc}
;;;1097   
                          ENDP

                  |L26.76|
                          DCD      xTimerQueue

                          AREA ||i.xTimerPendFunctionCallFromISR||, CODE, READONLY, ALIGN=2

                  xTimerPendFunctionCallFromISR PROC
;;;1049   
;;;1050   	BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken )
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;1051   	{
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1052   	DaemonTaskMessage_t xMessage;
;;;1053   	BaseType_t xReturn;
;;;1054   
;;;1055   		/* Complete the message with the function parameters and post it to the
;;;1056   		daemon task. */
;;;1057   		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
00000c  f06f0001          MVN      r0,#1
000010  9000              STR      r0,[sp,#0]
;;;1058   		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
000012  9401              STR      r4,[sp,#4]
;;;1059   		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
000014  9502              STR      r5,[sp,#8]
;;;1060   		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
000016  9603              STR      r6,[sp,#0xc]
;;;1061   
;;;1062   		xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
000018  2300              MOVS     r3,#0
00001a  463a              MOV      r2,r7
00001c  4669              MOV      r1,sp
00001e  4804              LDR      r0,|L27.48|
000020  6800              LDR      r0,[r0,#0]  ; xTimerQueue
000022  f7fffffe          BL       xQueueGenericSendFromISR
000026  4680              MOV      r8,r0
;;;1063   
;;;1064   		tracePEND_FUNC_CALL_FROM_ISR( xFunctionToPend, pvParameter1, ulParameter2, xReturn );
;;;1065   
;;;1066   		return xReturn;
000028  4640              MOV      r0,r8
;;;1067   	}
00002a  b004              ADD      sp,sp,#0x10
00002c  e8bd81f0          POP      {r4-r8,pc}
;;;1068   
                          ENDP

                  |L27.48|
                          DCD      xTimerQueue

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  xActiveTimerList1
                          %        20
                  xActiveTimerList2
                          %        20
                  xStaticTimerQueue
                          %        80
                  ucStaticTimerQueueStorage
                          %        160

                          AREA ||.data||, DATA, ALIGN=2

                  pxCurrentTimerList
                          DCD      0x00000000
                  pxOverflowTimerList
                          DCD      0x00000000
                  xTimerQueue
                          DCD      0x00000000
                  xTimerTaskHandle
                          DCD      0x00000000
                  xLastTime
                          DCD      0x00000000
