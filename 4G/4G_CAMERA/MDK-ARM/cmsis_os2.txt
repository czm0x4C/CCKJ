; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o4gcamera\cmsis_os2.o --asm_dir=.\ --list_dir=.\ --depend=4gcamera\cmsis_os2.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../USB_DEVICE/App -I../USB_DEVICE/Target -I../Core/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Middlewares/ST/STM32_USB_Device_Library/Core/Inc -I../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 -I../Middlewares/Third_Party/FreeRTOS/Source/portable/RVDS/ARM_CM4F -I../HARDWARE/OV2640 -I../HARDWARE/WS2812B -I../HARDWARE/RING_BUFFER -I../HARDWARE/FLASH -I.\RTE\_4GCAMERA -IC:\Users\czm\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\czm\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=536 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F407xx --omf_browse=4gcamera\cmsis_os2.crf ../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2/cmsis_os2.c]
                          THUMB

                          AREA ||i.AllocBlock||, CODE, READONLY, ALIGN=1

                  AllocBlock PROC
;;;2373   */
;;;2374   static void *AllocBlock (MemPool_t *mp) {
000000  4601              MOV      r1,r0
;;;2375     MemPoolBlock_t *p = NULL;
000002  2000              MOVS     r0,#0
;;;2376   
;;;2377     if (mp->head != NULL) {
000004  680a              LDR      r2,[r1,#0]
000006  b112              CBZ      r2,|L1.14|
;;;2378       /* List of free block exists, get head block */
;;;2379       p = mp->head;
000008  6808              LDR      r0,[r1,#0]
;;;2380   
;;;2381       /* Head block is now next on the list */
;;;2382       mp->head = p->next;
00000a  6802              LDR      r2,[r0,#0]
00000c  600a              STR      r2,[r1,#0]
                  |L1.14|
;;;2383     }
;;;2384   
;;;2385     return (p);
;;;2386   }
00000e  4770              BX       lr
;;;2387   
                          ENDP


                          AREA ||i.CreateBlock||, CODE, READONLY, ALIGN=1

                  CreateBlock PROC
;;;2356   */
;;;2357   static void *CreateBlock (MemPool_t *mp) {
000000  b510              PUSH     {r4,lr}
000002  4601              MOV      r1,r0
;;;2358     MemPoolBlock_t *p = NULL;
000004  2000              MOVS     r0,#0
;;;2359   
;;;2360     if (mp->n < mp->bl_cnt) {
000006  e9d13206          LDRD     r3,r2,[r1,#0x18]
00000a  429a              CMP      r2,r3
00000c  d207              BCS      |L2.30|
;;;2361       /* Unallocated blocks exist, set pointer to new block */
;;;2362       p = (void *)(mp->mem_arr + (mp->bl_sz * mp->n));
00000e  69cc              LDR      r4,[r1,#0x1c]
000010  694b              LDR      r3,[r1,#0x14]
000012  688a              LDR      r2,[r1,#8]
000014  fb032004          MLA      r0,r3,r4,r2
;;;2363   
;;;2364       /* Increment block index */
;;;2365       mp->n += 1U;
000018  69ca              LDR      r2,[r1,#0x1c]
00001a  1c52              ADDS     r2,r2,#1
00001c  61ca              STR      r2,[r1,#0x1c]
                  |L2.30|
;;;2366     }
;;;2367   
;;;2368     return (p);
;;;2369   }
00001e  bd10              POP      {r4,pc}
;;;2370   
                          ENDP


                          AREA ||i.FreeBlock||, CODE, READONLY, ALIGN=1

                  FreeBlock PROC
;;;2390   */
;;;2391   static void FreeBlock (MemPool_t *mp, void *block) {
000000  460a              MOV      r2,r1
;;;2392     MemPoolBlock_t *p = block;
;;;2393   
;;;2394     /* Store current head into block memory space */
;;;2395     p->next = mp->head;
000002  6803              LDR      r3,[r0,#0]
000004  6013              STR      r3,[r2,#0]
;;;2396   
;;;2397     /* Store current block as new head */
;;;2398     mp->head = p;
000006  6002              STR      r2,[r0,#0]
;;;2399   }
000008  4770              BX       lr
;;;2400   #endif /* FREERTOS_MPOOL_H_ */
                          ENDP


                          AREA ||i.OS_Tick_GetCount||, CODE, READONLY, ALIGN=1

                  OS_Tick_GetCount PROC
;;;399    /* Get OS Tick count value */
;;;400    static uint32_t OS_Tick_GetCount (void) {
000000  f04f20e0          MOV      r0,#0xe000e000
;;;401      uint32_t load = SysTick->LOAD;
000004  6941              LDR      r1,[r0,#0x14]
;;;402      return  (load - SysTick->VAL);
000006  6980              LDR      r0,[r0,#0x18]
000008  1a08              SUBS     r0,r1,r0
;;;403    }
00000a  4770              BX       lr
;;;404    
                          ENDP


                          AREA ||i.OS_Tick_GetInterval||, CODE, READONLY, ALIGN=1

                  OS_Tick_GetInterval PROC
;;;410    /* Get OS Tick interval */
;;;411    static uint32_t OS_Tick_GetInterval (void) {
000000  f04f20e0          MOV      r0,#0xe000e000
;;;412      return (SysTick->LOAD + 1U);
000004  6940              LDR      r0,[r0,#0x14]
000006  1c40              ADDS     r0,r0,#1
;;;413    }
000008  4770              BX       lr
;;;414    
                          ENDP


                          AREA ||i.OS_Tick_GetOverflow||, CODE, READONLY, ALIGN=1

                  OS_Tick_GetOverflow PROC
;;;405    /* Get OS Tick overflow status */
;;;406    static uint32_t OS_Tick_GetOverflow (void) {
000000  f04f20e0          MOV      r0,#0xe000e000
;;;407      return ((SysTick->CTRL >> 16) & 1U);
000004  6900              LDR      r0,[r0,#0x10]
000006  f3c04000          UBFX     r0,r0,#16,#1
;;;408    }
00000a  4770              BX       lr
;;;409    
                          ENDP


                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=1

                  SysTick_Handler PROC
;;;158    #if (USE_CUSTOM_SYSTICK_HANDLER_IMPLEMENTATION == 0)
;;;159    void SysTick_Handler (void) {
000000  b510              PUSH     {r4,lr}
;;;160      /* Clear overflow flag */
;;;161      SysTick->CTRL;
000002  f04f20e0          MOV      r0,#0xe000e000
000006  6900              LDR      r0,[r0,#0x10]
;;;162    
;;;163      if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) {
000008  f7fffffe          BL       xTaskGetSchedulerState
00000c  2801              CMP      r0,#1
00000e  d001              BEQ      |L7.20|
;;;164        /* Call tick handler */
;;;165        xPortSysTickHandler();
000010  f7fffffe          BL       xPortSysTickHandler
                  |L7.20|
;;;166      }
;;;167    }
000014  bd10              POP      {r4,pc}
;;;168    #endif
                          ENDP


                          AREA ||i.TimerCallback||, CODE, READONLY, ALIGN=1

                  TimerCallback PROC
;;;928    
;;;929    static void TimerCallback (TimerHandle_t hTimer) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;930      TimerCallback_t *callb;
;;;931    
;;;932      callb = (TimerCallback_t *)pvTimerGetTimerID (hTimer);
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       pvTimerGetTimerID
00000a  4604              MOV      r4,r0
;;;933    
;;;934      if (callb != NULL) {
00000c  b114              CBZ      r4,|L8.20|
;;;935        callb->func (callb->arg);
00000e  e9d41000          LDRD     r1,r0,[r4,#0]
000012  4788              BLX      r1
                  |L8.20|
;;;936      }
;;;937    }
000014  bd70              POP      {r4-r6,pc}
;;;938    
                          ENDP


                          AREA ||i.__get_IPSR||, CODE, READONLY, ALIGN=1

                  __get_IPSR PROC
;;;153     */
;;;154    __STATIC_INLINE uint32_t __get_IPSR(void)
000000  f3ef8005          MRS      r0,IPSR
;;;155    {
;;;156      register uint32_t __regIPSR          __ASM("ipsr");
;;;157      return(__regIPSR);
;;;158    }
000004  4770              BX       lr
;;;159    
                          ENDP


                          AREA ||i.osDelay||, CODE, READONLY, ALIGN=1

                  osDelay PROC
;;;880    
;;;881    osStatus_t osDelay (uint32_t ticks) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;882      osStatus_t stat;
;;;883    
;;;884      if (IS_IRQ()) {
000004  f7fffffe          BL       __get_IPSR
000008  b110              CBZ      r0,|L10.16|
;;;885        stat = osErrorISR;
00000a  f06f0405          MVN      r4,#5
00000e  e004              B        |L10.26|
                  |L10.16|
;;;886      }
;;;887      else {
;;;888        stat = osOK;
000010  2400              MOVS     r4,#0
;;;889    
;;;890        if (ticks != 0U) {
000012  b115              CBZ      r5,|L10.26|
;;;891          vTaskDelay(ticks);
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       vTaskDelay
                  |L10.26|
;;;892        }
;;;893      }
;;;894    
;;;895      return (stat);
00001a  4620              MOV      r0,r4
;;;896    }
00001c  bd70              POP      {r4-r6,pc}
;;;897    
                          ENDP


                          AREA ||i.osDelayUntil||, CODE, READONLY, ALIGN=1

                  osDelayUntil PROC
;;;897    
;;;898    osStatus_t osDelayUntil (uint32_t ticks) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4606              MOV      r6,r0
;;;899      TickType_t tcnt, delay;
;;;900      osStatus_t stat;
;;;901    
;;;902      if (IS_IRQ()) {
000004  f7fffffe          BL       __get_IPSR
000008  b110              CBZ      r0,|L11.16|
;;;903        stat = osErrorISR;
00000a  f06f0505          MVN      r5,#5
00000e  e00f              B        |L11.48|
                  |L11.16|
;;;904      }
;;;905      else {
;;;906        stat = osOK;
000010  2500              MOVS     r5,#0
;;;907        tcnt = xTaskGetTickCount();
000012  f7fffffe          BL       xTaskGetTickCount
000016  9000              STR      r0,[sp,#0]
;;;908    
;;;909        /* Determine remaining number of ticks to delay */
;;;910        delay = (TickType_t)ticks - tcnt;
000018  9800              LDR      r0,[sp,#0]
00001a  1a34              SUBS     r4,r6,r0
;;;911    
;;;912        /* Check if target tick has not expired */
;;;913        if((delay != 0U) && (0 == (delay >> (8 * sizeof(TickType_t) - 1)))) {
00001c  b134              CBZ      r4,|L11.44|
00001e  0fe0              LSRS     r0,r4,#31
000020  b920              CBNZ     r0,|L11.44|
;;;914          vTaskDelayUntil (&tcnt, delay);
000022  4621              MOV      r1,r4
000024  4668              MOV      r0,sp
000026  f7fffffe          BL       vTaskDelayUntil
00002a  e001              B        |L11.48|
                  |L11.44|
;;;915        }
;;;916        else
;;;917        {
;;;918          /* No delay or already expired */
;;;919          stat = osErrorParameter;
00002c  f06f0503          MVN      r5,#3
                  |L11.48|
;;;920        }
;;;921      }
;;;922    
;;;923      return (stat);
000030  4628              MOV      r0,r5
;;;924    }
000032  bdf8              POP      {r3-r7,pc}
;;;925    
                          ENDP


                          AREA ||i.osEventFlagsClear||, CODE, READONLY, ALIGN=1

                  osEventFlagsClear PROC
;;;1180   
;;;1181   uint32_t osEventFlagsClear (osEventFlagsId_t ef_id, uint32_t flags) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;1182     EventGroupHandle_t hEventGroup = (EventGroupHandle_t)ef_id;
000008  462f              MOV      r7,r5
;;;1183     uint32_t rflags;
;;;1184   
;;;1185     if ((hEventGroup == NULL) || ((flags & EVENT_FLAGS_INVALID_BITS) != 0U)) {
00000a  b117              CBZ      r7,|L12.18|
00000c  f006407f          AND      r0,r6,#0xff000000
000010  b110              CBZ      r0,|L12.24|
                  |L12.18|
;;;1186       rflags = (uint32_t)osErrorParameter;
000012  f06f0403          MVN      r4,#3
000016  e013              B        |L12.64|
                  |L12.24|
;;;1187     }
;;;1188     else if (IS_IRQ()) {
000018  f7fffffe          BL       __get_IPSR
00001c  b158              CBZ      r0,|L12.54|
;;;1189     #if (configUSE_OS2_EVENTFLAGS_FROM_ISR == 0)
;;;1190       /* Enable timers and xTimerPendFunctionCall function to support osEventFlagsSet from ISR */
;;;1191       rflags = (uint32_t)osErrorResource;
;;;1192     #else
;;;1193       rflags = xEventGroupGetBitsFromISR (hEventGroup);
00001e  4638              MOV      r0,r7
000020  f7fffffe          BL       xEventGroupGetBitsFromISR
000024  4604              MOV      r4,r0
;;;1194   
;;;1195       if (xEventGroupClearBitsFromISR (hEventGroup, (EventBits_t)flags) == pdFAIL) {
000026  4631              MOV      r1,r6
000028  4638              MOV      r0,r7
00002a  f7fffffe          BL       xEventGroupClearBitsFromISR
00002e  b938              CBNZ     r0,|L12.64|
;;;1196         rflags = (uint32_t)osErrorResource;
000030  f06f0402          MVN      r4,#2
000034  e004              B        |L12.64|
                  |L12.54|
;;;1197       }
;;;1198     #endif
;;;1199     }
;;;1200     else {
;;;1201       rflags = xEventGroupClearBits (hEventGroup, (EventBits_t)flags);
000036  4631              MOV      r1,r6
000038  4638              MOV      r0,r7
00003a  f7fffffe          BL       xEventGroupClearBits
00003e  4604              MOV      r4,r0
                  |L12.64|
;;;1202     }
;;;1203   
;;;1204     return (rflags);
000040  4620              MOV      r0,r4
;;;1205   }
000042  e8bd81f0          POP      {r4-r8,pc}
;;;1206   
                          ENDP


                          AREA ||i.osEventFlagsDelete||, CODE, READONLY, ALIGN=1

                  osEventFlagsDelete PROC
;;;1273   
;;;1274   osStatus_t osEventFlagsDelete (osEventFlagsId_t ef_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;1275     EventGroupHandle_t hEventGroup = (EventGroupHandle_t)ef_id;
000004  462e              MOV      r6,r5
;;;1276     osStatus_t stat;
;;;1277   
;;;1278   #ifndef USE_FreeRTOS_HEAP_1
;;;1279     if (IS_IRQ()) {
000006  f7fffffe          BL       __get_IPSR
00000a  b110              CBZ      r0,|L13.18|
;;;1280       stat = osErrorISR;
00000c  f06f0405          MVN      r4,#5
000010  e007              B        |L13.34|
                  |L13.18|
;;;1281     }
;;;1282     else if (hEventGroup == NULL) {
000012  b916              CBNZ     r6,|L13.26|
;;;1283       stat = osErrorParameter;
000014  f06f0403          MVN      r4,#3
000018  e003              B        |L13.34|
                  |L13.26|
;;;1284     }
;;;1285     else {
;;;1286       stat = osOK;
00001a  2400              MOVS     r4,#0
;;;1287       vEventGroupDelete (hEventGroup);
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       vEventGroupDelete
                  |L13.34|
;;;1288     }
;;;1289   #else
;;;1290     stat = osError;
;;;1291   #endif
;;;1292   
;;;1293     return (stat);
000022  4620              MOV      r0,r4
;;;1294   }
000024  bd70              POP      {r4-r6,pc}
;;;1295   
                          ENDP


                          AREA ||i.osEventFlagsGet||, CODE, READONLY, ALIGN=1

                  osEventFlagsGet PROC
;;;1206   
;;;1207   uint32_t osEventFlagsGet (osEventFlagsId_t ef_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;1208     EventGroupHandle_t hEventGroup = (EventGroupHandle_t)ef_id;
000004  462e              MOV      r6,r5
;;;1209     uint32_t rflags;
;;;1210   
;;;1211     if (ef_id == NULL) {
000006  b90d              CBNZ     r5,|L14.12|
;;;1212       rflags = 0U;
000008  2400              MOVS     r4,#0
00000a  e00c              B        |L14.38|
                  |L14.12|
;;;1213     }
;;;1214     else if (IS_IRQ()) {
00000c  f7fffffe          BL       __get_IPSR
000010  b120              CBZ      r0,|L14.28|
;;;1215       rflags = xEventGroupGetBitsFromISR (hEventGroup);
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       xEventGroupGetBitsFromISR
000018  4604              MOV      r4,r0
00001a  e004              B        |L14.38|
                  |L14.28|
;;;1216     }
;;;1217     else {
;;;1218       rflags = xEventGroupGetBits (hEventGroup);
00001c  2100              MOVS     r1,#0
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       xEventGroupClearBits
000024  4604              MOV      r4,r0
                  |L14.38|
;;;1219     }
;;;1220   
;;;1221     return (rflags);
000026  4620              MOV      r0,r4
;;;1222   }
000028  bd70              POP      {r4-r6,pc}
;;;1223   
                          ENDP


                          AREA ||i.osEventFlagsNew||, CODE, READONLY, ALIGN=1

                  osEventFlagsNew PROC
;;;1109   
;;;1110   osEventFlagsId_t osEventFlagsNew (const osEventFlagsAttr_t *attr) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;1111     EventGroupHandle_t hEventGroup;
;;;1112     int32_t mem;
;;;1113   
;;;1114     hEventGroup = NULL;
000004  2600              MOVS     r6,#0
;;;1115   
;;;1116     if (!IS_IRQ()) {
000006  f7fffffe          BL       __get_IPSR
00000a  b9d0              CBNZ     r0,|L15.66|
;;;1117       mem = -1;
00000c  1e75              SUBS     r5,r6,#1
;;;1118   
;;;1119       if (attr != NULL) {
00000e  b164              CBZ      r4,|L15.42|
;;;1120         if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticEventGroup_t))) {
000010  68a0              LDR      r0,[r4,#8]
000012  b120              CBZ      r0,|L15.30|
000014  68e0              LDR      r0,[r4,#0xc]
000016  2820              CMP      r0,#0x20
000018  d301              BCC      |L15.30|
;;;1121           mem = 1;
00001a  2501              MOVS     r5,#1
00001c  e006              B        |L15.44|
                  |L15.30|
;;;1122         }
;;;1123         else {
;;;1124           if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
00001e  68a0              LDR      r0,[r4,#8]
000020  b920              CBNZ     r0,|L15.44|
000022  68e0              LDR      r0,[r4,#0xc]
000024  b910              CBNZ     r0,|L15.44|
;;;1125             mem = 0;
000026  2500              MOVS     r5,#0
000028  e000              B        |L15.44|
                  |L15.42|
;;;1126           }
;;;1127         }
;;;1128       }
;;;1129       else {
;;;1130         mem = 0;
00002a  2500              MOVS     r5,#0
                  |L15.44|
;;;1131       }
;;;1132   
;;;1133       if (mem == 1) {
00002c  2d01              CMP      r5,#1
00002e  d104              BNE      |L15.58|
;;;1134         #if (configSUPPORT_STATIC_ALLOCATION == 1)
;;;1135         hEventGroup = xEventGroupCreateStatic (attr->cb_mem);
000030  68a0              LDR      r0,[r4,#8]
000032  f7fffffe          BL       xEventGroupCreateStatic
000036  4606              MOV      r6,r0
000038  e003              B        |L15.66|
                  |L15.58|
;;;1136         #endif
;;;1137       }
;;;1138       else {
;;;1139         if (mem == 0) {
00003a  b915              CBNZ     r5,|L15.66|
;;;1140           #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
;;;1141             hEventGroup = xEventGroupCreate();
00003c  f7fffffe          BL       xEventGroupCreate
000040  4606              MOV      r6,r0
                  |L15.66|
;;;1142           #endif
;;;1143         }
;;;1144       }
;;;1145     }
;;;1146   
;;;1147     return ((osEventFlagsId_t)hEventGroup);
000042  4630              MOV      r0,r6
;;;1148   }
000044  bd70              POP      {r4-r6,pc}
;;;1149   
                          ENDP


                          AREA ||i.osEventFlagsSet||, CODE, READONLY, ALIGN=2

                  osEventFlagsSet PROC
;;;1149   
;;;1150   uint32_t osEventFlagsSet (osEventFlagsId_t ef_id, uint32_t flags) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;1151     EventGroupHandle_t hEventGroup = (EventGroupHandle_t)ef_id;
000006  462f              MOV      r7,r5
;;;1152     uint32_t rflags;
;;;1153     BaseType_t yield;
;;;1154   
;;;1155     if ((hEventGroup == NULL) || ((flags & EVENT_FLAGS_INVALID_BITS) != 0U)) {
000008  b117              CBZ      r7,|L16.16|
00000a  f006407f          AND      r0,r6,#0xff000000
00000e  b110              CBZ      r0,|L16.22|
                  |L16.16|
;;;1156       rflags = (uint32_t)osErrorParameter;
000010  f06f0403          MVN      r4,#3
000014  e01e              B        |L16.84|
                  |L16.22|
;;;1157     }
;;;1158     else if (IS_IRQ()) {
000016  f7fffffe          BL       __get_IPSR
00001a  b1b0              CBZ      r0,|L16.74|
;;;1159     #if (configUSE_OS2_EVENTFLAGS_FROM_ISR == 0)
;;;1160       (void)yield;
;;;1161       /* Enable timers and xTimerPendFunctionCall function to support osEventFlagsSet from ISR */
;;;1162       rflags = (uint32_t)osErrorResource;
;;;1163     #else
;;;1164       yield = pdFALSE;
00001c  2000              MOVS     r0,#0
00001e  9000              STR      r0,[sp,#0]
;;;1165   
;;;1166       if (xEventGroupSetBitsFromISR (hEventGroup, (EventBits_t)flags, &yield) == pdFAIL) {
000020  466a              MOV      r2,sp
000022  4631              MOV      r1,r6
000024  4638              MOV      r0,r7
000026  f7fffffe          BL       xEventGroupSetBitsFromISR
00002a  b910              CBNZ     r0,|L16.50|
;;;1167         rflags = (uint32_t)osErrorResource;
00002c  f06f0402          MVN      r4,#2
000030  e010              B        |L16.84|
                  |L16.50|
;;;1168       } else {
;;;1169         rflags = flags;
000032  4634              MOV      r4,r6
;;;1170         portYIELD_FROM_ISR (yield);
000034  9800              LDR      r0,[sp,#0]
000036  b168              CBZ      r0,|L16.84|
000038  f04f5080          MOV      r0,#0x10000000
00003c  4906              LDR      r1,|L16.88|
00003e  6008              STR      r0,[r1,#0]
000040  f3bf8f4f          DSB      
000044  f3bf8f6f          ISB      
000048  e004              B        |L16.84|
                  |L16.74|
;;;1171       }
;;;1172     #endif
;;;1173     }
;;;1174     else {
;;;1175       rflags = xEventGroupSetBits (hEventGroup, (EventBits_t)flags);
00004a  4631              MOV      r1,r6
00004c  4638              MOV      r0,r7
00004e  f7fffffe          BL       xEventGroupSetBits
000052  4604              MOV      r4,r0
                  |L16.84|
;;;1176     }
;;;1177   
;;;1178     return (rflags);
000054  4620              MOV      r0,r4
;;;1179   }
000056  bdf8              POP      {r3-r7,pc}
;;;1180   
                          ENDP

                  |L16.88|
                          DCD      0xe000ed04

                          AREA ||i.osEventFlagsWait||, CODE, READONLY, ALIGN=1

                  osEventFlagsWait PROC
;;;1223   
;;;1224   uint32_t osEventFlagsWait (osEventFlagsId_t ef_id, uint32_t flags, uint32_t options, uint32_t timeout) {
000000  e92d4ff8          PUSH     {r3-r11,lr}
000004  4680              MOV      r8,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1225     EventGroupHandle_t hEventGroup = (EventGroupHandle_t)ef_id;
00000c  46c3              MOV      r11,r8
;;;1226     BaseType_t wait_all;
;;;1227     BaseType_t exit_clr;
;;;1228     uint32_t rflags;
;;;1229   
;;;1230     if ((hEventGroup == NULL) || ((flags & EVENT_FLAGS_INVALID_BITS) != 0U)) {
00000e  f1bb0f00          CMP      r11,#0
000012  d002              BEQ      |L17.26|
000014  f005407f          AND      r0,r5,#0xff000000
000018  b110              CBZ      r0,|L17.32|
                  |L17.26|
;;;1231       rflags = (uint32_t)osErrorParameter;
00001a  f06f0403          MVN      r4,#3
00001e  e034              B        |L17.138|
                  |L17.32|
;;;1232     }
;;;1233     else if (IS_IRQ()) {
000020  f7fffffe          BL       __get_IPSR
000024  b110              CBZ      r0,|L17.44|
;;;1234       rflags = (uint32_t)osErrorISR;
000026  f06f0405          MVN      r4,#5
00002a  e02e              B        |L17.138|
                  |L17.44|
;;;1235     }
;;;1236     else {
;;;1237       if (options & osFlagsWaitAll) {
00002c  f0060001          AND      r0,r6,#1
000030  b110              CBZ      r0,|L17.56|
;;;1238         wait_all = pdTRUE;
000032  f04f0901          MOV      r9,#1
000036  e001              B        |L17.60|
                  |L17.56|
;;;1239       } else {
;;;1240         wait_all = pdFAIL;
000038  f04f0900          MOV      r9,#0
                  |L17.60|
;;;1241       }
;;;1242   
;;;1243       if (options & osFlagsNoClear) {
00003c  f0060002          AND      r0,r6,#2
000040  b110              CBZ      r0,|L17.72|
;;;1244         exit_clr = pdFAIL;
000042  f04f0a00          MOV      r10,#0
000046  e001              B        |L17.76|
                  |L17.72|
;;;1245       } else {
;;;1246         exit_clr = pdTRUE;
000048  f04f0a01          MOV      r10,#1
                  |L17.76|
;;;1247       }
;;;1248   
;;;1249       rflags = xEventGroupWaitBits (hEventGroup, (EventBits_t)flags, exit_clr, wait_all, (TickType_t)timeout);
00004c  464b              MOV      r3,r9
00004e  4652              MOV      r2,r10
000050  4629              MOV      r1,r5
000052  4658              MOV      r0,r11
000054  9700              STR      r7,[sp,#0]
000056  f7fffffe          BL       xEventGroupWaitBits
00005a  4604              MOV      r4,r0
;;;1250   
;;;1251       if (options & osFlagsWaitAll) {
00005c  f0060001          AND      r0,r6,#1
000060  b150              CBZ      r0,|L17.120|
;;;1252         if ((flags & rflags) != flags) {
000062  ea050004          AND      r0,r5,r4
000066  42a8              CMP      r0,r5
000068  d00f              BEQ      |L17.138|
;;;1253           if (timeout > 0U) {
00006a  b117              CBZ      r7,|L17.114|
;;;1254             rflags = (uint32_t)osErrorTimeout;
00006c  f06f0401          MVN      r4,#1
000070  e00b              B        |L17.138|
                  |L17.114|
;;;1255           } else {
;;;1256             rflags = (uint32_t)osErrorResource;
000072  f06f0402          MVN      r4,#2
000076  e008              B        |L17.138|
                  |L17.120|
;;;1257           }
;;;1258         }
;;;1259       }
;;;1260       else {
;;;1261         if ((flags & rflags) == 0U) {
000078  ea050004          AND      r0,r5,r4
00007c  b928              CBNZ     r0,|L17.138|
;;;1262           if (timeout > 0U) {
00007e  b117              CBZ      r7,|L17.134|
;;;1263             rflags = (uint32_t)osErrorTimeout;
000080  f06f0401          MVN      r4,#1
000084  e001              B        |L17.138|
                  |L17.134|
;;;1264           } else {
;;;1265             rflags = (uint32_t)osErrorResource;
000086  f06f0402          MVN      r4,#2
                  |L17.138|
;;;1266           }
;;;1267         }
;;;1268       }
;;;1269     }
;;;1270   
;;;1271     return (rflags);
00008a  4620              MOV      r0,r4
;;;1272   }
00008c  e8bd8ff8          POP      {r3-r11,pc}
;;;1273   
                          ENDP


                          AREA ||i.osKernelGetInfo||, CODE, READONLY, ALIGN=2

                  osKernelGetInfo PROC
;;;221    
;;;222    osStatus_t osKernelGetInfo (osVersion_t *version, char *id_buf, uint32_t id_size) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;223    
;;;224      if (version != NULL) {
000008  b114              CBZ      r4,|L18.16|
;;;225        /* Version encoding is major.minor.rev: mmnnnrrrr dec */
;;;226        version->api    = KERNEL_VERSION;
00000a  4807              LDR      r0,|L18.40|
00000c  6020              STR      r0,[r4,#0]
;;;227        version->kernel = KERNEL_VERSION;
00000e  6060              STR      r0,[r4,#4]
                  |L18.16|
;;;228      }
;;;229    
;;;230      if ((id_buf != NULL) && (id_size != 0U)) {
000010  b145              CBZ      r5,|L18.36|
000012  b13e              CBZ      r6,|L18.36|
;;;231        if (id_size > sizeof(KERNEL_ID)) {
000014  2e11              CMP      r6,#0x11
000016  d900              BLS      |L18.26|
;;;232          id_size = sizeof(KERNEL_ID);
000018  2611              MOVS     r6,#0x11
                  |L18.26|
;;;233        }
;;;234        memcpy(id_buf, KERNEL_ID, id_size);
00001a  4632              MOV      r2,r6
00001c  a103              ADR      r1,|L18.44|
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       __aeabi_memcpy
                  |L18.36|
;;;235      }
;;;236    
;;;237      return (osOK);
000024  2000              MOVS     r0,#0
;;;238    }
000026  bd70              POP      {r4-r6,pc}
;;;239    
                          ENDP

                  |L18.40|
                          DCD      0x05f5f531
                  |L18.44|
00002c  46726565          DCB      "FreeRTOS V10.3.1",0
000030  52544f53
000034  20563130
000038  2e332e31
00003c  00      
00003d  00                DCB      0
00003e  00                DCB      0
00003f  00                DCB      0

                          AREA ||i.osKernelGetState||, CODE, READONLY, ALIGN=2

                  osKernelGetState PROC
;;;239    
;;;240    osKernelState_t osKernelGetState (void) {
000000  b510              PUSH     {r4,lr}
;;;241      osKernelState_t state;
;;;242    
;;;243      switch (xTaskGetSchedulerState()) {
000002  f7fffffe          BL       xTaskGetSchedulerState
000006  b128              CBZ      r0,|L19.20|
000008  2801              CMP      r0,#1
00000a  d006              BEQ      |L19.26|
00000c  2802              CMP      r0,#2
00000e  d103              BNE      |L19.24|
;;;244        case taskSCHEDULER_RUNNING:
;;;245          state = osKernelRunning;
000010  2402              MOVS     r4,#2
;;;246          break;
000012  e00a              B        |L19.42|
                  |L19.20|
;;;247    
;;;248        case taskSCHEDULER_SUSPENDED:
;;;249          state = osKernelLocked;
000014  2403              MOVS     r4,#3
;;;250          break;
000016  e008              B        |L19.42|
                  |L19.24|
;;;251    
;;;252        case taskSCHEDULER_NOT_STARTED:
000018  bf00              NOP      
                  |L19.26|
;;;253        default:
;;;254          if (KernelState == osKernelReady) {
00001a  4805              LDR      r0,|L19.48|
00001c  6800              LDR      r0,[r0,#0]  ; KernelState
00001e  2801              CMP      r0,#1
000020  d101              BNE      |L19.38|
;;;255            state = osKernelReady;
000022  2401              MOVS     r4,#1
000024  e000              B        |L19.40|
                  |L19.38|
;;;256          } else {
;;;257            state = osKernelInactive;
000026  2400              MOVS     r4,#0
                  |L19.40|
;;;258          }
;;;259          break;
000028  bf00              NOP      
                  |L19.42|
00002a  bf00              NOP                            ;246
;;;260      }
;;;261    
;;;262      return (state);
00002c  4620              MOV      r0,r4
;;;263    }
00002e  bd10              POP      {r4,pc}
;;;264    
                          ENDP

                  |L19.48|
                          DCD      KernelState

                          AREA ||i.osKernelGetSysTimerCount||, CODE, READONLY, ALIGN=1

                  osKernelGetSysTimerCount PROC
;;;414    
;;;415    uint32_t osKernelGetSysTimerCount (void) {
000000  b570              PUSH     {r4-r6,lr}
;;;416      uint32_t irqmask = IS_IRQ_MASKED();
000002  bf00              NOP      
000004  f3ef8010          MRS      r0,PRIMASK
000008  b918              CBNZ     r0,|L20.18|
00000a  bf00              NOP      
00000c  f3ef8011          MRS      r0,BASEPRI
000010  b108              CBZ      r0,|L20.22|
                  |L20.18|
000012  2001              MOVS     r0,#1
000014  e000              B        |L20.24|
                  |L20.22|
000016  2000              MOVS     r0,#0
                  |L20.24|
000018  4606              MOV      r6,r0
;;;417      TickType_t ticks;
;;;418      uint32_t val;
;;;419    
;;;420      __disable_irq();
00001a  b672              CPSID    i
;;;421    
;;;422      ticks = xTaskGetTickCount();
00001c  f7fffffe          BL       xTaskGetTickCount
000020  4604              MOV      r4,r0
;;;423      val   = OS_Tick_GetCount();
000022  f7fffffe          BL       OS_Tick_GetCount
000026  4605              MOV      r5,r0
;;;424    
;;;425      if (OS_Tick_GetOverflow() != 0U) {
000028  f7fffffe          BL       OS_Tick_GetOverflow
00002c  b118              CBZ      r0,|L20.54|
;;;426        val = OS_Tick_GetCount();
00002e  f7fffffe          BL       OS_Tick_GetCount
000032  4605              MOV      r5,r0
;;;427        ticks++;
000034  1c64              ADDS     r4,r4,#1
                  |L20.54|
;;;428      }
;;;429      val += ticks * OS_Tick_GetInterval();
000036  f7fffffe          BL       OS_Tick_GetInterval
00003a  fb045500          MLA      r5,r4,r0,r5
;;;430    
;;;431      if (irqmask == 0U) {
00003e  b906              CBNZ     r6,|L20.66|
;;;432        __enable_irq();
000040  b662              CPSIE    i
                  |L20.66|
;;;433      }
;;;434    
;;;435      return (val);
000042  4628              MOV      r0,r5
;;;436    }
000044  bd70              POP      {r4-r6,pc}
;;;437    
                          ENDP


                          AREA ||i.osKernelGetSysTimerFreq||, CODE, READONLY, ALIGN=2

                  osKernelGetSysTimerFreq PROC
;;;437    
;;;438    uint32_t osKernelGetSysTimerFreq (void) {
000000  4801              LDR      r0,|L21.8|
;;;439      return (configCPU_CLOCK_HZ);
000002  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;440    }
000004  4770              BX       lr
;;;441    
                          ENDP

000006  0000              DCW      0x0000
                  |L21.8|
                          DCD      SystemCoreClock

                          AREA ||i.osKernelGetTickCount||, CODE, READONLY, ALIGN=1

                  osKernelGetTickCount PROC
;;;382    
;;;383    uint32_t osKernelGetTickCount (void) {
000000  b510              PUSH     {r4,lr}
;;;384      TickType_t ticks;
;;;385    
;;;386      if (IS_IRQ()) {
000002  f7fffffe          BL       __get_IPSR
000006  b118              CBZ      r0,|L22.16|
;;;387        ticks = xTaskGetTickCountFromISR();
000008  f7fffffe          BL       xTaskGetTickCountFromISR
00000c  4604              MOV      r4,r0
00000e  e002              B        |L22.22|
                  |L22.16|
;;;388      } else {
;;;389        ticks = xTaskGetTickCount();
000010  f7fffffe          BL       xTaskGetTickCount
000014  4604              MOV      r4,r0
                  |L22.22|
;;;390      }
;;;391    
;;;392      return (ticks);
000016  4620              MOV      r0,r4
;;;393    }
000018  bd10              POP      {r4,pc}
;;;394    
                          ENDP


                          AREA ||i.osKernelGetTickFreq||, CODE, READONLY, ALIGN=1

                  osKernelGetTickFreq PROC
;;;394    
;;;395    uint32_t osKernelGetTickFreq (void) {
000000  f44f707a          MOV      r0,#0x3e8
;;;396      return (configTICK_RATE_HZ);
;;;397    }
000004  4770              BX       lr
;;;398    
                          ENDP


                          AREA ||i.osKernelInitialize||, CODE, READONLY, ALIGN=2

                  osKernelInitialize PROC
;;;197    
;;;198    osStatus_t osKernelInitialize (void) {
000000  b510              PUSH     {r4,lr}
;;;199      osStatus_t stat;
;;;200    
;;;201      if (IS_IRQ()) {
000002  f7fffffe          BL       __get_IPSR
000006  b110              CBZ      r0,|L24.14|
;;;202        stat = osErrorISR;
000008  f06f0405          MVN      r4,#5
00000c  e009              B        |L24.34|
                  |L24.14|
;;;203      }
;;;204      else {
;;;205        if (KernelState == osKernelInactive) {
00000e  4806              LDR      r0,|L24.40|
000010  6800              LDR      r0,[r0,#0]  ; KernelState
000012  b920              CBNZ     r0,|L24.30|
;;;206          #if defined(USE_TRACE_EVENT_RECORDER)
;;;207            EvrFreeRTOSSetup(0U);
;;;208          #endif
;;;209          #if defined(USE_FreeRTOS_HEAP_5) && (HEAP_5_REGION_SETUP == 1)
;;;210            vPortDefineHeapRegions (configHEAP_5_REGIONS);
;;;211          #endif
;;;212          KernelState = osKernelReady;
000014  2001              MOVS     r0,#1
000016  4904              LDR      r1,|L24.40|
000018  6008              STR      r0,[r1,#0]  ; KernelState
;;;213          stat = osOK;
00001a  2400              MOVS     r4,#0
00001c  e001              B        |L24.34|
                  |L24.30|
;;;214        } else {
;;;215          stat = osError;
00001e  f04f34ff          MOV      r4,#0xffffffff
                  |L24.34|
;;;216        }
;;;217      }
;;;218    
;;;219      return (stat);
000022  4620              MOV      r0,r4
;;;220    }
000024  bd10              POP      {r4,pc}
;;;221    
                          ENDP

000026  0000              DCW      0x0000
                  |L24.40|
                          DCD      KernelState

                          AREA ||i.osKernelLock||, CODE, READONLY, ALIGN=1

                  osKernelLock PROC
;;;287    
;;;288    int32_t osKernelLock (void) {
000000  b510              PUSH     {r4,lr}
;;;289      int32_t lock;
;;;290    
;;;291      if (IS_IRQ()) {
000002  f7fffffe          BL       __get_IPSR
000006  b110              CBZ      r0,|L25.14|
;;;292        lock = (int32_t)osErrorISR;
000008  f06f0405          MVN      r4,#5
00000c  e012              B        |L25.52|
                  |L25.14|
;;;293      }
;;;294      else {
;;;295        switch (xTaskGetSchedulerState()) {
00000e  f7fffffe          BL       xTaskGetSchedulerState
000012  b120              CBZ      r0,|L25.30|
000014  2801              CMP      r0,#1
000016  d009              BEQ      |L25.44|
000018  2802              CMP      r0,#2
00001a  d106              BNE      |L25.42|
00001c  e001              B        |L25.34|
                  |L25.30|
;;;296          case taskSCHEDULER_SUSPENDED:
;;;297            lock = 1;
00001e  2401              MOVS     r4,#1
;;;298            break;
000020  e007              B        |L25.50|
                  |L25.34|
;;;299    
;;;300          case taskSCHEDULER_RUNNING:
;;;301            vTaskSuspendAll();
000022  f7fffffe          BL       vTaskSuspendAll
;;;302            lock = 0;
000026  2400              MOVS     r4,#0
;;;303            break;
000028  e003              B        |L25.50|
                  |L25.42|
;;;304    
;;;305          case taskSCHEDULER_NOT_STARTED:
00002a  bf00              NOP      
                  |L25.44|
;;;306          default:
;;;307            lock = (int32_t)osError;
00002c  f04f34ff          MOV      r4,#0xffffffff
;;;308            break;
000030  bf00              NOP      
                  |L25.50|
000032  bf00              NOP                            ;298
                  |L25.52|
;;;309        }
;;;310      }
;;;311    
;;;312      return (lock);
000034  4620              MOV      r0,r4
;;;313    }
000036  bd10              POP      {r4,pc}
;;;314    
                          ENDP


                          AREA ||i.osKernelRestoreLock||, CODE, READONLY, ALIGN=1

                  osKernelRestoreLock PROC
;;;346    
;;;347    int32_t osKernelRestoreLock (int32_t lock) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;348    
;;;349      if (IS_IRQ()) {
000004  f7fffffe          BL       __get_IPSR
000008  b110              CBZ      r0,|L26.16|
;;;350        lock = (int32_t)osErrorISR;
00000a  f06f0405          MVN      r4,#5
00000e  e021              B        |L26.84|
                  |L26.16|
;;;351      }
;;;352      else {
;;;353        switch (xTaskGetSchedulerState()) {
000010  f7fffffe          BL       xTaskGetSchedulerState
000014  b120              CBZ      r0,|L26.32|
000016  2801              CMP      r0,#1
000018  d018              BEQ      |L26.76|
00001a  2802              CMP      r0,#2
00001c  d115              BNE      |L26.74|
00001e  e000              B        |L26.34|
                  |L26.32|
;;;354          case taskSCHEDULER_SUSPENDED:
;;;355          case taskSCHEDULER_RUNNING:
000020  bf00              NOP      
                  |L26.34|
;;;356            if (lock == 1) {
000022  2c01              CMP      r4,#1
000024  d102              BNE      |L26.44|
;;;357              vTaskSuspendAll();
000026  f7fffffe          BL       vTaskSuspendAll
00002a  e00d              B        |L26.72|
                  |L26.44|
;;;358            }
;;;359            else {
;;;360              if (lock != 0) {
00002c  b114              CBZ      r4,|L26.52|
;;;361                lock = (int32_t)osError;
00002e  f04f34ff          MOV      r4,#0xffffffff
000032  e009              B        |L26.72|
                  |L26.52|
;;;362              }
;;;363              else {
;;;364                if (xTaskResumeAll() != pdTRUE) {
000034  f7fffffe          BL       xTaskResumeAll
000038  2801              CMP      r0,#1
00003a  d005              BEQ      |L26.72|
;;;365                  if (xTaskGetSchedulerState() != taskSCHEDULER_RUNNING) {
00003c  f7fffffe          BL       xTaskGetSchedulerState
000040  2802              CMP      r0,#2
000042  d001              BEQ      |L26.72|
;;;366                    lock = (int32_t)osError;
000044  f04f34ff          MOV      r4,#0xffffffff
                  |L26.72|
;;;367                  }
;;;368                }
;;;369              }
;;;370            }
;;;371            break;
000048  e003              B        |L26.82|
                  |L26.74|
;;;372    
;;;373          case taskSCHEDULER_NOT_STARTED:
00004a  bf00              NOP      
                  |L26.76|
;;;374          default:
;;;375            lock = (int32_t)osError;
00004c  f04f34ff          MOV      r4,#0xffffffff
;;;376            break;
000050  bf00              NOP      
                  |L26.82|
000052  bf00              NOP                            ;371
                  |L26.84|
;;;377        }
;;;378      }
;;;379    
;;;380      return (lock);
000054  4620              MOV      r0,r4
;;;381    }
000056  bd10              POP      {r4,pc}
;;;382    
                          ENDP


                          AREA ||i.osKernelStart||, CODE, READONLY, ALIGN=2

                  osKernelStart PROC
;;;264    
;;;265    osStatus_t osKernelStart (void) {
000000  b570              PUSH     {r4-r6,lr}
;;;266      osStatus_t stat;
;;;267    
;;;268      if (IS_IRQ()) {
000002  f7fffffe          BL       __get_IPSR
000006  b110              CBZ      r0,|L27.14|
;;;269        stat = osErrorISR;
000008  f06f0405          MVN      r4,#5
00000c  e01f              B        |L27.78|
                  |L27.14|
;;;270      }
;;;271      else {
;;;272        if (KernelState == osKernelReady) {
00000e  4811              LDR      r0,|L27.84|
000010  6800              LDR      r0,[r0,#0]  ; KernelState
000012  2801              CMP      r0,#1
000014  d119              BNE      |L27.74|
;;;273          /* Ensure SVC priority is at the reset value */
;;;274          SVC_Setup();
000016  bf00              NOP      
000018  1f80              SUBS     r0,r0,#6
00001a  2100              MOVS     r1,#0
00001c  2800              CMP      r0,#0
00001e  db04              BLT      |L27.42|
000020  070a              LSLS     r2,r1,#28
000022  0e13              LSRS     r3,r2,#24
000024  4a0c              LDR      r2,|L27.88|
000026  5413              STRB     r3,[r2,r0]
000028  e006              B        |L27.56|
                  |L27.42|
00002a  070a              LSLS     r2,r1,#28
00002c  0e15              LSRS     r5,r2,#24
00002e  4a0b              LDR      r2,|L27.92|
000030  f000030f          AND      r3,r0,#0xf
000034  1f1b              SUBS     r3,r3,#4
000036  54d5              STRB     r5,[r2,r3]
                  |L27.56|
000038  bf00              NOP      
00003a  bf00              NOP      
;;;275          /* Change state to enable IRQ masking check */
;;;276          KernelState = osKernelRunning;
00003c  2002              MOVS     r0,#2
00003e  4905              LDR      r1,|L27.84|
000040  6008              STR      r0,[r1,#0]  ; KernelState
;;;277          /* Start the kernel scheduler */
;;;278          vTaskStartScheduler();
000042  f7fffffe          BL       vTaskStartScheduler
;;;279          stat = osOK;
000046  2400              MOVS     r4,#0
000048  e001              B        |L27.78|
                  |L27.74|
;;;280        } else {
;;;281          stat = osError;
00004a  f04f34ff          MOV      r4,#0xffffffff
                  |L27.78|
;;;282        }
;;;283      }
;;;284    
;;;285      return (stat);
00004e  4620              MOV      r0,r4
;;;286    }
000050  bd70              POP      {r4-r6,pc}
;;;287    
                          ENDP

000052  0000              DCW      0x0000
                  |L27.84|
                          DCD      KernelState
                  |L27.88|
                          DCD      0xe000e400
                  |L27.92|
                          DCD      0xe000ed18

                          AREA ||i.osKernelUnlock||, CODE, READONLY, ALIGN=1

                  osKernelUnlock PROC
;;;314    
;;;315    int32_t osKernelUnlock (void) {
000000  b510              PUSH     {r4,lr}
;;;316      int32_t lock;
;;;317    
;;;318      if (IS_IRQ()) {
000002  f7fffffe          BL       __get_IPSR
000006  b110              CBZ      r0,|L28.14|
;;;319        lock = (int32_t)osErrorISR;
000008  f06f0405          MVN      r4,#5
00000c  e018              B        |L28.64|
                  |L28.14|
;;;320      }
;;;321      else {
;;;322        switch (xTaskGetSchedulerState()) {
00000e  f7fffffe          BL       xTaskGetSchedulerState
000012  b120              CBZ      r0,|L28.30|
000014  2801              CMP      r0,#1
000016  d00f              BEQ      |L28.56|
000018  2802              CMP      r0,#2
00001a  d10c              BNE      |L28.54|
00001c  e009              B        |L28.50|
                  |L28.30|
;;;323          case taskSCHEDULER_SUSPENDED:
;;;324            lock = 1;
00001e  2401              MOVS     r4,#1
;;;325    
;;;326            if (xTaskResumeAll() != pdTRUE) {
000020  f7fffffe          BL       xTaskResumeAll
000024  2801              CMP      r0,#1
000026  d003              BEQ      |L28.48|
;;;327              if (xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) {
000028  f7fffffe          BL       xTaskGetSchedulerState
00002c  b900              CBNZ     r0,|L28.48|
;;;328                lock = (int32_t)osError;
00002e  1ea4              SUBS     r4,r4,#2
                  |L28.48|
;;;329              }
;;;330            }
;;;331            break;
000030  e005              B        |L28.62|
                  |L28.50|
;;;332    
;;;333          case taskSCHEDULER_RUNNING:
;;;334            lock = 0;
000032  2400              MOVS     r4,#0
;;;335            break;
000034  e003              B        |L28.62|
                  |L28.54|
;;;336    
;;;337          case taskSCHEDULER_NOT_STARTED:
000036  bf00              NOP      
                  |L28.56|
;;;338          default:
;;;339            lock = (int32_t)osError;
000038  f04f34ff          MOV      r4,#0xffffffff
;;;340            break;
00003c  bf00              NOP      
                  |L28.62|
00003e  bf00              NOP                            ;331
                  |L28.64|
;;;341        }
;;;342      }
;;;343    
;;;344      return (lock);
000040  4620              MOV      r0,r4
;;;345    }
000042  bd10              POP      {r4,pc}
;;;346    
                          ENDP


                          AREA ||i.osMemoryPoolAlloc||, CODE, READONLY, ALIGN=2

                  osMemoryPoolAlloc PROC
;;;2085   
;;;2086   void *osMemoryPoolAlloc (osMemoryPoolId_t mp_id, uint32_t timeout) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
;;;2087     MemPool_t *mp;
;;;2088     void *block;
;;;2089     uint32_t isrm;
;;;2090   
;;;2091     if (mp_id == NULL) {
000008  b90f              CBNZ     r7,|L29.14|
;;;2092       /* Invalid input parameters */
;;;2093       block = NULL;
00000a  2500              MOVS     r5,#0
00000c  e04a              B        |L29.164|
                  |L29.14|
;;;2094     }
;;;2095     else {
;;;2096       block = NULL;
00000e  2500              MOVS     r5,#0
;;;2097   
;;;2098       mp = (MemPool_t *)mp_id;
000010  463c              MOV      r4,r7
;;;2099   
;;;2100       if ((mp->status & MPOOL_STATUS) == MPOOL_STATUS) {
000012  6a20              LDR      r0,[r4,#0x20]
000014  4925              LDR      r1,|L29.172|
000016  4008              ANDS     r0,r0,r1
000018  4288              CMP      r0,r1
00001a  d143              BNE      |L29.164|
;;;2101         if (IS_IRQ()) {
00001c  f7fffffe          BL       __get_IPSR
000020  b340              CBZ      r0,|L29.116|
;;;2102           if (timeout == 0U) {
000022  f1b80f00          CMP      r8,#0
000026  d13d              BNE      |L29.164|
;;;2103             if (xSemaphoreTakeFromISR (mp->sem, NULL) == pdTRUE) {
000028  2200              MOVS     r2,#0
00002a  4611              MOV      r1,r2
00002c  6860              LDR      r0,[r4,#4]
00002e  f7fffffe          BL       xQueueReceiveFromISR
000032  2801              CMP      r0,#1
000034  d136              BNE      |L29.164|
;;;2104               if ((mp->status & MPOOL_STATUS) == MPOOL_STATUS) {
000036  6a20              LDR      r0,[r4,#0x20]
000038  491c              LDR      r1,|L29.172|
00003a  4008              ANDS     r0,r0,r1
00003c  4288              CMP      r0,r1
00003e  d131              BNE      |L29.164|
;;;2105                 isrm  = taskENTER_CRITICAL_FROM_ISR();
000040  bf00              NOP      
000042  2150              MOVS     r1,#0x50
000044  f3ef8011          MRS      r0,BASEPRI
000048  f3818811          MSR      BASEPRI,r1
00004c  f3bf8f4f          DSB      
000050  f3bf8f6f          ISB      
000054  bf00              NOP      
000056  4606              MOV      r6,r0
;;;2106   
;;;2107                 /* Get a block from the free-list */
;;;2108                 block = AllocBlock(mp);
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       AllocBlock
00005e  4605              MOV      r5,r0
;;;2109   
;;;2110                 if (block == NULL) {
000060  b91d              CBNZ     r5,|L29.106|
;;;2111                   /* List of free blocks is empty, 'create' new block */
;;;2112                   block = CreateBlock(mp);
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       CreateBlock
000068  4605              MOV      r5,r0
                  |L29.106|
;;;2113                 }
;;;2114   
;;;2115                 taskEXIT_CRITICAL_FROM_ISR(isrm);
00006a  bf00              NOP      
00006c  f3868811          MSR      BASEPRI,r6
000070  bf00              NOP      
000072  e017              B        |L29.164|
                  |L29.116|
;;;2116               }
;;;2117             }
;;;2118           }
;;;2119         }
;;;2120         else {
;;;2121           if (xSemaphoreTake (mp->sem, (TickType_t)timeout) == pdTRUE) {
000074  4641              MOV      r1,r8
000076  6860              LDR      r0,[r4,#4]
000078  f7fffffe          BL       xQueueSemaphoreTake
00007c  2801              CMP      r0,#1
00007e  d111              BNE      |L29.164|
;;;2122             if ((mp->status & MPOOL_STATUS) == MPOOL_STATUS) {
000080  6a20              LDR      r0,[r4,#0x20]
000082  490a              LDR      r1,|L29.172|
000084  4008              ANDS     r0,r0,r1
000086  4288              CMP      r0,r1
000088  d10c              BNE      |L29.164|
;;;2123               taskENTER_CRITICAL();
00008a  f7fffffe          BL       vPortEnterCritical
;;;2124   
;;;2125               /* Get a block from the free-list */
;;;2126               block = AllocBlock(mp);
00008e  4620              MOV      r0,r4
000090  f7fffffe          BL       AllocBlock
000094  4605              MOV      r5,r0
;;;2127   
;;;2128               if (block == NULL) {
000096  b91d              CBNZ     r5,|L29.160|
;;;2129                 /* List of free blocks is empty, 'create' new block */
;;;2130                 block = CreateBlock(mp);
000098  4620              MOV      r0,r4
00009a  f7fffffe          BL       CreateBlock
00009e  4605              MOV      r5,r0
                  |L29.160|
;;;2131               }
;;;2132   
;;;2133               taskEXIT_CRITICAL();
0000a0  f7fffffe          BL       vPortExitCritical
                  |L29.164|
;;;2134             }
;;;2135           }
;;;2136         }
;;;2137       }
;;;2138     }
;;;2139   
;;;2140     return (block);
0000a4  4628              MOV      r0,r5
;;;2141   }
0000a6  e8bd81f0          POP      {r4-r8,pc}
;;;2142   
                          ENDP

0000aa  0000              DCW      0x0000
                  |L29.172|
                          DCD      0x5eed0000

                          AREA ||i.osMemoryPoolDelete||, CODE, READONLY, ALIGN=1

                  osMemoryPoolDelete PROC
;;;2310   
;;;2311   osStatus_t osMemoryPoolDelete (osMemoryPoolId_t mp_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;2312     MemPool_t *mp;
;;;2313     osStatus_t stat;
;;;2314   
;;;2315     if (mp_id == NULL) {
000004  b915              CBNZ     r5,|L30.12|
;;;2316       /* Invalid input parameters */
;;;2317       stat = osErrorParameter;
000006  f06f0603          MVN      r6,#3
00000a  e02a              B        |L30.98|
                  |L30.12|
;;;2318     }
;;;2319     else if (IS_IRQ()) {
00000c  f7fffffe          BL       __get_IPSR
000010  b110              CBZ      r0,|L30.24|
;;;2320       stat = osErrorISR;
000012  f06f0605          MVN      r6,#5
000016  e024              B        |L30.98|
                  |L30.24|
;;;2321     }
;;;2322     else {
;;;2323       mp = (MemPool_t *)mp_id;
000018  462c              MOV      r4,r5
;;;2324   
;;;2325       taskENTER_CRITICAL();
00001a  f7fffffe          BL       vPortEnterCritical
;;;2326   
;;;2327       /* Invalidate control block status */
;;;2328       mp->status  = mp->status & 3U;
00001e  6a20              LDR      r0,[r4,#0x20]
000020  f0000003          AND      r0,r0,#3
000024  6220              STR      r0,[r4,#0x20]
;;;2329   
;;;2330       /* Wake-up tasks waiting for pool semaphore */
;;;2331       while (xSemaphoreGive (mp->sem) == pdTRUE);
000026  bf00              NOP      
                  |L30.40|
000028  2300              MOVS     r3,#0
00002a  461a              MOV      r2,r3
00002c  4619              MOV      r1,r3
00002e  6860              LDR      r0,[r4,#4]
000030  f7fffffe          BL       xQueueGenericSend
000034  2801              CMP      r0,#1
000036  d0f7              BEQ      |L30.40|
;;;2332   
;;;2333       mp->head    = NULL;
000038  2000              MOVS     r0,#0
00003a  6020              STR      r0,[r4,#0]
;;;2334       mp->bl_sz   = 0U;
00003c  6160              STR      r0,[r4,#0x14]
;;;2335       mp->bl_cnt  = 0U;
00003e  61a0              STR      r0,[r4,#0x18]
;;;2336   
;;;2337       if ((mp->status & 2U) != 0U) {
000040  6a20              LDR      r0,[r4,#0x20]
000042  f0000002          AND      r0,r0,#2
000046  b110              CBZ      r0,|L30.78|
;;;2338         /* Memory pool array allocated on heap */
;;;2339         vPortFree (mp->mem_arr);
000048  68a0              LDR      r0,[r4,#8]
00004a  f7fffffe          BL       vPortFree
                  |L30.78|
;;;2340       }
;;;2341       if ((mp->status & 1U) != 0U) {
00004e  6a20              LDR      r0,[r4,#0x20]
000050  f0000001          AND      r0,r0,#1
000054  b110              CBZ      r0,|L30.92|
;;;2342         /* Memory pool control block allocated on heap */
;;;2343         vPortFree (mp);
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       vPortFree
                  |L30.92|
;;;2344       }
;;;2345   
;;;2346       taskEXIT_CRITICAL();
00005c  f7fffffe          BL       vPortExitCritical
;;;2347   
;;;2348       stat = osOK;
000060  2600              MOVS     r6,#0
                  |L30.98|
;;;2349     }
;;;2350   
;;;2351     return (stat);
000062  4630              MOV      r0,r6
;;;2352   }
000064  bd70              POP      {r4-r6,pc}
;;;2353   
                          ENDP


                          AREA ||i.osMemoryPoolFree||, CODE, READONLY, ALIGN=2

                  osMemoryPoolFree PROC
;;;2142   
;;;2143   osStatus_t osMemoryPoolFree (osMemoryPoolId_t mp_id, void *block) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
;;;2144     MemPool_t *mp;
;;;2145     osStatus_t stat;
;;;2146     uint32_t isrm;
;;;2147     BaseType_t yield;
;;;2148   
;;;2149     if ((mp_id == NULL) || (block == NULL)) {
000008  b117              CBZ      r7,|L31.16|
00000a  f1b80f00          CMP      r8,#0
00000e  d102              BNE      |L31.22|
                  |L31.16|
;;;2150       /* Invalid input parameters */
;;;2151       stat = osErrorParameter;
000010  f06f0503          MVN      r5,#3
000014  e05c              B        |L31.208|
                  |L31.22|
;;;2152     }
;;;2153     else {
;;;2154       mp = (MemPool_t *)mp_id;
000016  463c              MOV      r4,r7
;;;2155   
;;;2156       if ((mp->status & MPOOL_STATUS) != MPOOL_STATUS) {
000018  6a20              LDR      r0,[r4,#0x20]
00001a  492f              LDR      r1,|L31.216|
00001c  4008              ANDS     r0,r0,r1
00001e  4288              CMP      r0,r1
000020  d002              BEQ      |L31.40|
;;;2157         /* Invalid object status */
;;;2158         stat = osErrorResource;
000022  f06f0502          MVN      r5,#2
000026  e053              B        |L31.208|
                  |L31.40|
;;;2159       }
;;;2160       else if ((block < (void *)&mp->mem_arr[0]) || (block > (void*)&mp->mem_arr[mp->mem_sz-1])) {
000028  68a0              LDR      r0,[r4,#8]
00002a  4540              CMP      r0,r8
00002c  d805              BHI      |L31.58|
00002e  e9d41002          LDRD     r1,r0,[r4,#8]
000032  1e40              SUBS     r0,r0,#1
000034  4408              ADD      r0,r0,r1
000036  4540              CMP      r0,r8
000038  d202              BCS      |L31.64|
                  |L31.58|
;;;2161         /* Block pointer outside of memory array area */
;;;2162         stat = osErrorParameter;
00003a  f06f0503          MVN      r5,#3
00003e  e047              B        |L31.208|
                  |L31.64|
;;;2163       }
;;;2164       else {
;;;2165         stat = osOK;
000040  2500              MOVS     r5,#0
;;;2166   
;;;2167         if (IS_IRQ()) {
000042  f7fffffe          BL       __get_IPSR
000046  b360              CBZ      r0,|L31.162|
;;;2168           if (uxSemaphoreGetCountFromISR (mp->sem) == mp->bl_cnt) {
000048  6860              LDR      r0,[r4,#4]
00004a  f7fffffe          BL       uxQueueMessagesWaitingFromISR
00004e  69a1              LDR      r1,[r4,#0x18]
000050  4288              CMP      r0,r1
000052  d101              BNE      |L31.88|
;;;2169             stat = osErrorResource;
000054  1eed              SUBS     r5,r5,#3
000056  e03b              B        |L31.208|
                  |L31.88|
;;;2170           }
;;;2171           else {
;;;2172             isrm = taskENTER_CRITICAL_FROM_ISR();
000058  bf00              NOP      
00005a  2150              MOVS     r1,#0x50
00005c  f3ef8011          MRS      r0,BASEPRI
000060  f3818811          MSR      BASEPRI,r1
000064  f3bf8f4f          DSB      
000068  f3bf8f6f          ISB      
00006c  4606              MOV      r6,r0
00006e  bf00              NOP      
;;;2173   
;;;2174             /* Add block to the list of free blocks */
;;;2175             FreeBlock(mp, block);
000070  4641              MOV      r1,r8
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       FreeBlock
;;;2176   
;;;2177             taskEXIT_CRITICAL_FROM_ISR(isrm);
000078  bf00              NOP      
00007a  f3868811          MSR      BASEPRI,r6
00007e  bf00              NOP      
;;;2178   
;;;2179             yield = pdFALSE;
000080  2000              MOVS     r0,#0
000082  9000              STR      r0,[sp,#0]
;;;2180             xSemaphoreGiveFromISR (mp->sem, &yield);
000084  4669              MOV      r1,sp
000086  6860              LDR      r0,[r4,#4]
000088  f7fffffe          BL       xQueueGiveFromISR
;;;2181             portYIELD_FROM_ISR (yield);
00008c  9800              LDR      r0,[sp,#0]
00008e  b1f8              CBZ      r0,|L31.208|
000090  f04f5080          MOV      r0,#0x10000000
000094  4911              LDR      r1,|L31.220|
000096  6008              STR      r0,[r1,#0]
000098  f3bf8f4f          DSB      
00009c  f3bf8f6f          ISB      
0000a0  e016              B        |L31.208|
                  |L31.162|
;;;2182           }
;;;2183         }
;;;2184         else {
;;;2185           if (uxSemaphoreGetCount (mp->sem) == mp->bl_cnt) {
0000a2  6860              LDR      r0,[r4,#4]
0000a4  f7fffffe          BL       uxQueueMessagesWaiting
0000a8  69a1              LDR      r1,[r4,#0x18]
0000aa  4288              CMP      r0,r1
0000ac  d102              BNE      |L31.180|
;;;2186             stat = osErrorResource;
0000ae  f06f0502          MVN      r5,#2
0000b2  e00d              B        |L31.208|
                  |L31.180|
;;;2187           }
;;;2188           else {
;;;2189             taskENTER_CRITICAL();
0000b4  f7fffffe          BL       vPortEnterCritical
;;;2190   
;;;2191             /* Add block to the list of free blocks */
;;;2192             FreeBlock(mp, block);
0000b8  4641              MOV      r1,r8
0000ba  4620              MOV      r0,r4
0000bc  f7fffffe          BL       FreeBlock
;;;2193   
;;;2194             taskEXIT_CRITICAL();
0000c0  f7fffffe          BL       vPortExitCritical
;;;2195   
;;;2196             xSemaphoreGive (mp->sem);
0000c4  2300              MOVS     r3,#0
0000c6  461a              MOV      r2,r3
0000c8  4619              MOV      r1,r3
0000ca  6860              LDR      r0,[r4,#4]
0000cc  f7fffffe          BL       xQueueGenericSend
                  |L31.208|
;;;2197           }
;;;2198         }
;;;2199       }
;;;2200     }
;;;2201   
;;;2202     return (stat);
0000d0  4628              MOV      r0,r5
;;;2203   }
0000d2  e8bd83f8          POP      {r3-r9,pc}
;;;2204   
                          ENDP

0000d6  0000              DCW      0x0000
                  |L31.216|
                          DCD      0x5eed0000
                  |L31.220|
                          DCD      0xe000ed04

                          AREA ||i.osMemoryPoolGetBlockSize||, CODE, READONLY, ALIGN=2

                  osMemoryPoolGetBlockSize PROC
;;;2228   
;;;2229   uint32_t osMemoryPoolGetBlockSize (osMemoryPoolId_t mp_id) {
000000  b510              PUSH     {r4,lr}
000002  4601              MOV      r1,r0
;;;2230     MemPool_t *mp;
;;;2231     uint32_t  sz;
;;;2232   
;;;2233     if (mp_id == NULL) {
000004  b909              CBNZ     r1,|L32.10|
;;;2234       /* Invalid input parameters */
;;;2235       sz = 0U;
000006  2000              MOVS     r0,#0
000008  e008              B        |L32.28|
                  |L32.10|
;;;2236     }
;;;2237     else {
;;;2238       mp = (MemPool_t *)mp_id;
00000a  460a              MOV      r2,r1
;;;2239   
;;;2240       if ((mp->status & MPOOL_STATUS) != MPOOL_STATUS) {
00000c  6a13              LDR      r3,[r2,#0x20]
00000e  4c04              LDR      r4,|L32.32|
000010  4023              ANDS     r3,r3,r4
000012  42a3              CMP      r3,r4
000014  d001              BEQ      |L32.26|
;;;2241         /* Invalid object status */
;;;2242         sz = 0U;
000016  2000              MOVS     r0,#0
000018  e000              B        |L32.28|
                  |L32.26|
;;;2243       }
;;;2244       else {
;;;2245         sz = mp->bl_sz;
00001a  6950              LDR      r0,[r2,#0x14]
                  |L32.28|
;;;2246       }
;;;2247     }
;;;2248   
;;;2249     /* Return memory block size in bytes */
;;;2250     return (sz);
;;;2251   }
00001c  bd10              POP      {r4,pc}
;;;2252   
                          ENDP

00001e  0000              DCW      0x0000
                  |L32.32|
                          DCD      0x5eed0000

                          AREA ||i.osMemoryPoolGetCapacity||, CODE, READONLY, ALIGN=2

                  osMemoryPoolGetCapacity PROC
;;;2204   
;;;2205   uint32_t osMemoryPoolGetCapacity (osMemoryPoolId_t mp_id) {
000000  b510              PUSH     {r4,lr}
000002  4601              MOV      r1,r0
;;;2206     MemPool_t *mp;
;;;2207     uint32_t  n;
;;;2208   
;;;2209     if (mp_id == NULL) {
000004  b909              CBNZ     r1,|L33.10|
;;;2210       /* Invalid input parameters */
;;;2211       n = 0U;
000006  2000              MOVS     r0,#0
000008  e008              B        |L33.28|
                  |L33.10|
;;;2212     }
;;;2213     else {
;;;2214       mp = (MemPool_t *)mp_id;
00000a  460a              MOV      r2,r1
;;;2215   
;;;2216       if ((mp->status & MPOOL_STATUS) != MPOOL_STATUS) {
00000c  6a13              LDR      r3,[r2,#0x20]
00000e  4c04              LDR      r4,|L33.32|
000010  4023              ANDS     r3,r3,r4
000012  42a3              CMP      r3,r4
000014  d001              BEQ      |L33.26|
;;;2217         /* Invalid object status */
;;;2218         n = 0U;
000016  2000              MOVS     r0,#0
000018  e000              B        |L33.28|
                  |L33.26|
;;;2219       }
;;;2220       else {
;;;2221         n = mp->bl_cnt;
00001a  6990              LDR      r0,[r2,#0x18]
                  |L33.28|
;;;2222       }
;;;2223     }
;;;2224   
;;;2225     /* Return maximum number of memory blocks */
;;;2226     return (n);
;;;2227   }
00001c  bd10              POP      {r4,pc}
;;;2228   
                          ENDP

00001e  0000              DCW      0x0000
                  |L33.32|
                          DCD      0x5eed0000

                          AREA ||i.osMemoryPoolGetCount||, CODE, READONLY, ALIGN=2

                  osMemoryPoolGetCount PROC
;;;2252   
;;;2253   uint32_t osMemoryPoolGetCount (osMemoryPoolId_t mp_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
;;;2254     MemPool_t *mp;
;;;2255     uint32_t  n;
;;;2256   
;;;2257     if (mp_id == NULL) {
000004  b90e              CBNZ     r6,|L34.10|
;;;2258       /* Invalid input parameters */
;;;2259       n = 0U;
000006  2400              MOVS     r4,#0
000008  e015              B        |L34.54|
                  |L34.10|
;;;2260     }
;;;2261     else {
;;;2262       mp = (MemPool_t *)mp_id;
00000a  4635              MOV      r5,r6
;;;2263   
;;;2264       if ((mp->status & MPOOL_STATUS) != MPOOL_STATUS) {
00000c  6a28              LDR      r0,[r5,#0x20]
00000e  490b              LDR      r1,|L34.60|
000010  4008              ANDS     r0,r0,r1
000012  4288              CMP      r0,r1
000014  d001              BEQ      |L34.26|
;;;2265         /* Invalid object status */
;;;2266         n = 0U;
000016  2400              MOVS     r4,#0
000018  e00d              B        |L34.54|
                  |L34.26|
;;;2267       }
;;;2268       else {
;;;2269         if (IS_IRQ()) {
00001a  f7fffffe          BL       __get_IPSR
00001e  b120              CBZ      r0,|L34.42|
;;;2270           n = uxSemaphoreGetCountFromISR (mp->sem);
000020  6868              LDR      r0,[r5,#4]
000022  f7fffffe          BL       uxQueueMessagesWaitingFromISR
000026  4604              MOV      r4,r0
000028  e003              B        |L34.50|
                  |L34.42|
;;;2271         } else {
;;;2272           n = uxSemaphoreGetCount        (mp->sem);
00002a  6868              LDR      r0,[r5,#4]
00002c  f7fffffe          BL       uxQueueMessagesWaiting
000030  4604              MOV      r4,r0
                  |L34.50|
;;;2273         }
;;;2274   
;;;2275         n = mp->bl_cnt - n;
000032  69a8              LDR      r0,[r5,#0x18]
000034  1b04              SUBS     r4,r0,r4
                  |L34.54|
;;;2276       }
;;;2277     }
;;;2278   
;;;2279     /* Return number of memory blocks used */
;;;2280     return (n);
000036  4620              MOV      r0,r4
;;;2281   }
000038  bd70              POP      {r4-r6,pc}
;;;2282   
                          ENDP

00003a  0000              DCW      0x0000
                  |L34.60|
                          DCD      0x5eed0000

                          AREA ||i.osMemoryPoolGetName||, CODE, READONLY, ALIGN=1

                  osMemoryPoolGetName PROC
;;;2068   
;;;2069   const char *osMemoryPoolGetName (osMemoryPoolId_t mp_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;2070     MemPool_t *mp = (osMemoryPoolId_t)mp_id;
000004  462e              MOV      r6,r5
;;;2071     const char *p;
;;;2072   
;;;2073     if (IS_IRQ()) {
000006  f7fffffe          BL       __get_IPSR
00000a  b108              CBZ      r0,|L35.16|
;;;2074       p = NULL;
00000c  2400              MOVS     r4,#0
00000e  e003              B        |L35.24|
                  |L35.16|
;;;2075     }
;;;2076     else if (mp_id == NULL) {
000010  b90d              CBNZ     r5,|L35.22|
;;;2077       p = NULL;
000012  2400              MOVS     r4,#0
000014  e000              B        |L35.24|
                  |L35.22|
;;;2078     }
;;;2079     else {
;;;2080       p = mp->name;
000016  6934              LDR      r4,[r6,#0x10]
                  |L35.24|
;;;2081     }
;;;2082   
;;;2083     return (p);
000018  4620              MOV      r0,r4
;;;2084   }
00001a  bd70              POP      {r4-r6,pc}
;;;2085   
                          ENDP


                          AREA ||i.osMemoryPoolGetSpace||, CODE, READONLY, ALIGN=2

                  osMemoryPoolGetSpace PROC
;;;2282   
;;;2283   uint32_t osMemoryPoolGetSpace (osMemoryPoolId_t mp_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;2284     MemPool_t *mp;
;;;2285     uint32_t  n;
;;;2286   
;;;2287     if (mp_id == NULL) {
000004  b90d              CBNZ     r5,|L36.10|
;;;2288       /* Invalid input parameters */
;;;2289       n = 0U;
000006  2400              MOVS     r4,#0
000008  e013              B        |L36.50|
                  |L36.10|
;;;2290     }
;;;2291     else {
;;;2292       mp = (MemPool_t *)mp_id;
00000a  462e              MOV      r6,r5
;;;2293   
;;;2294       if ((mp->status & MPOOL_STATUS) != MPOOL_STATUS) {
00000c  6a30              LDR      r0,[r6,#0x20]
00000e  490a              LDR      r1,|L36.56|
000010  4008              ANDS     r0,r0,r1
000012  4288              CMP      r0,r1
000014  d001              BEQ      |L36.26|
;;;2295         /* Invalid object status */
;;;2296         n = 0U;
000016  2400              MOVS     r4,#0
000018  e00b              B        |L36.50|
                  |L36.26|
;;;2297       }
;;;2298       else {
;;;2299         if (IS_IRQ()) {
00001a  f7fffffe          BL       __get_IPSR
00001e  b120              CBZ      r0,|L36.42|
;;;2300           n = uxSemaphoreGetCountFromISR (mp->sem);
000020  6870              LDR      r0,[r6,#4]
000022  f7fffffe          BL       uxQueueMessagesWaitingFromISR
000026  4604              MOV      r4,r0
000028  e003              B        |L36.50|
                  |L36.42|
;;;2301         } else {
;;;2302           n = uxSemaphoreGetCount        (mp->sem);
00002a  6870              LDR      r0,[r6,#4]
00002c  f7fffffe          BL       uxQueueMessagesWaiting
000030  4604              MOV      r4,r0
                  |L36.50|
;;;2303         }
;;;2304       }
;;;2305     }
;;;2306   
;;;2307     /* Return number of memory blocks available */
;;;2308     return (n);
000032  4620              MOV      r0,r4
;;;2309   }
000034  bd70              POP      {r4-r6,pc}
;;;2310   
                          ENDP

000036  0000              DCW      0x0000
                  |L36.56|
                          DCD      0x5eed0000

                          AREA ||i.osMemoryPoolNew||, CODE, READONLY, ALIGN=2

                  osMemoryPoolNew PROC
;;;1951   
;;;1952   osMemoryPoolId_t osMemoryPoolNew (uint32_t block_count, uint32_t block_size, const osMemoryPoolAttr_t *attr) {
000000  e92d5ff0          PUSH     {r4-r12,lr}
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;1953     MemPool_t *mp;
;;;1954     const char *name;
;;;1955     int32_t mem_cb, mem_mp;
;;;1956     uint32_t sz;
;;;1957   
;;;1958     if (IS_IRQ()) {
00000a  f7fffffe          BL       __get_IPSR
00000e  b108              CBZ      r0,|L37.20|
;;;1959       mp = NULL;
000010  2400              MOVS     r4,#0
000012  e079              B        |L37.264|
                  |L37.20|
;;;1960     }
;;;1961     else if ((block_count == 0U) || (block_size == 0U)) {
000014  b106              CBZ      r6,|L37.24|
000016  b90f              CBNZ     r7,|L37.28|
                  |L37.24|
;;;1962       mp = NULL;
000018  2400              MOVS     r4,#0
00001a  e075              B        |L37.264|
                  |L37.28|
;;;1963     }
;;;1964     else {
;;;1965       mp = NULL;
00001c  2400              MOVS     r4,#0
;;;1966       sz = MEMPOOL_ARR_SIZE (block_count, block_size);
00001e  1cf8              ADDS     r0,r7,#3
000020  0880              LSRS     r0,r0,#2
000022  0080              LSLS     r0,r0,#2
000024  fb00f906          MUL      r9,r0,r6
;;;1967   
;;;1968       name = NULL;
000028  46a3              MOV      r11,r4
;;;1969       mem_cb = -1;
00002a  f04f38ff          MOV      r8,#0xffffffff
;;;1970       mem_mp = -1;
00002e  f04f3aff          MOV      r10,#0xffffffff
;;;1971   
;;;1972       if (attr != NULL) {
000032  b325              CBZ      r5,|L37.126|
;;;1973         if (attr->name != NULL) {
000034  6828              LDR      r0,[r5,#0]
000036  b108              CBZ      r0,|L37.60|
;;;1974           name = attr->name;
000038  f8d5b000          LDR      r11,[r5,#0]
                  |L37.60|
;;;1975         }
;;;1976   
;;;1977         if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(MemPool_t))) {
00003c  68a8              LDR      r0,[r5,#8]
00003e  b128              CBZ      r0,|L37.76|
000040  68e8              LDR      r0,[r5,#0xc]
000042  2874              CMP      r0,#0x74
000044  d302              BCC      |L37.76|
;;;1978           /* Static control block is provided */
;;;1979           mem_cb = 1;
000046  f04f0801          MOV      r8,#1
00004a  e005              B        |L37.88|
                  |L37.76|
;;;1980         }
;;;1981         else if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
00004c  68a8              LDR      r0,[r5,#8]
00004e  b918              CBNZ     r0,|L37.88|
000050  68e8              LDR      r0,[r5,#0xc]
000052  b908              CBNZ     r0,|L37.88|
;;;1982           /* Allocate control block memory on heap */
;;;1983           mem_cb = 0;
000054  f04f0800          MOV      r8,#0
                  |L37.88|
;;;1984         }
;;;1985   
;;;1986         if ((attr->mp_mem == NULL) && (attr->mp_size == 0U)) {
000058  6928              LDR      r0,[r5,#0x10]
00005a  b920              CBNZ     r0,|L37.102|
00005c  6968              LDR      r0,[r5,#0x14]
00005e  b910              CBNZ     r0,|L37.102|
;;;1987           /* Allocate memory array on heap */
;;;1988             mem_mp = 0;
000060  f04f0a00          MOV      r10,#0
000064  e00e              B        |L37.132|
                  |L37.102|
;;;1989         }
;;;1990         else {
;;;1991           if (attr->mp_mem != NULL) {
000066  6928              LDR      r0,[r5,#0x10]
000068  b160              CBZ      r0,|L37.132|
;;;1992             /* Check if array is 4-byte aligned */
;;;1993             if (((uint32_t)attr->mp_mem & 3U) == 0U) {
00006a  7c28              LDRB     r0,[r5,#0x10]
00006c  f0000003          AND      r0,r0,#3
000070  b940              CBNZ     r0,|L37.132|
;;;1994               /* Check if array big enough */
;;;1995               if (attr->mp_size >= sz) {
000072  6968              LDR      r0,[r5,#0x14]
000074  4548              CMP      r0,r9
000076  d305              BCC      |L37.132|
;;;1996                 /* Static memory pool array is provided */
;;;1997                 mem_mp = 1;
000078  f04f0a01          MOV      r10,#1
00007c  e002              B        |L37.132|
                  |L37.126|
;;;1998               }
;;;1999             }
;;;2000           }
;;;2001         }
;;;2002       }
;;;2003       else {
;;;2004         /* Attributes not provided, allocate memory on heap */
;;;2005         mem_cb = 0;
00007e  f04f0800          MOV      r8,#0
;;;2006         mem_mp = 0;
000082  46c2              MOV      r10,r8
                  |L37.132|
;;;2007       }
;;;2008   
;;;2009       if (mem_cb == 0) {
000084  f1b80f00          CMP      r8,#0
000088  d104              BNE      |L37.148|
;;;2010         mp = pvPortMalloc (sizeof(MemPool_t));
00008a  2074              MOVS     r0,#0x74
00008c  f7fffffe          BL       pvPortMalloc
000090  4604              MOV      r4,r0
000092  e000              B        |L37.150|
                  |L37.148|
;;;2011       } else {
;;;2012         mp = attr->cb_mem;
000094  68ac              LDR      r4,[r5,#8]
                  |L37.150|
;;;2013       }
;;;2014   
;;;2015       if (mp != NULL) {
000096  b194              CBZ      r4,|L37.190|
;;;2016         /* Create a semaphore (max count == initial count == block_count) */
;;;2017         #if (configSUPPORT_STATIC_ALLOCATION == 1)
;;;2018           mp->sem = xSemaphoreCreateCountingStatic (block_count, block_count, &mp->mem_sem);
000098  f1040224          ADD      r2,r4,#0x24
00009c  4631              MOV      r1,r6
00009e  4630              MOV      r0,r6
0000a0  f7fffffe          BL       xQueueCreateCountingSemaphoreStatic
0000a4  6060              STR      r0,[r4,#4]
;;;2019         #elif (configSUPPORT_DYNAMIC_ALLOCATION == 1)
;;;2020           mp->sem = xSemaphoreCreateCounting (block_count, block_count);
;;;2021         #else
;;;2022           mp->sem == NULL;
;;;2023         #endif
;;;2024   
;;;2025         if (mp->sem != NULL) {
0000a6  6860              LDR      r0,[r4,#4]
0000a8  b148              CBZ      r0,|L37.190|
;;;2026           /* Setup memory array */
;;;2027           if (mem_mp == 0) {
0000aa  f1ba0f00          CMP      r10,#0
0000ae  d104              BNE      |L37.186|
;;;2028             mp->mem_arr = pvPortMalloc (sz);
0000b0  4648              MOV      r0,r9
0000b2  f7fffffe          BL       pvPortMalloc
0000b6  60a0              STR      r0,[r4,#8]
0000b8  e001              B        |L37.190|
                  |L37.186|
;;;2029           } else {
;;;2030             mp->mem_arr = attr->mp_mem;
0000ba  6928              LDR      r0,[r5,#0x10]
0000bc  60a0              STR      r0,[r4,#8]
                  |L37.190|
;;;2031           }
;;;2032         }
;;;2033       }
;;;2034   
;;;2035       if ((mp != NULL) && (mp->mem_arr != NULL)) {
0000be  b1dc              CBZ      r4,|L37.248|
0000c0  68a0              LDR      r0,[r4,#8]
0000c2  b1c8              CBZ      r0,|L37.248|
;;;2036         /* Memory pool can be created */
;;;2037         mp->head    = NULL;
0000c4  2000              MOVS     r0,#0
0000c6  6020              STR      r0,[r4,#0]
;;;2038         mp->mem_sz  = sz;
0000c8  f8c4900c          STR      r9,[r4,#0xc]
;;;2039         mp->name    = name;
0000cc  f8c4b010          STR      r11,[r4,#0x10]
;;;2040         mp->bl_sz   = block_size;
0000d0  6167              STR      r7,[r4,#0x14]
;;;2041         mp->bl_cnt  = block_count;
0000d2  61a6              STR      r6,[r4,#0x18]
;;;2042         mp->n       = 0U;
0000d4  61e0              STR      r0,[r4,#0x1c]
;;;2043   
;;;2044         /* Set heap allocated memory flags */
;;;2045         mp->status = MPOOL_STATUS;
0000d6  480e              LDR      r0,|L37.272|
0000d8  6220              STR      r0,[r4,#0x20]
;;;2046   
;;;2047         if (mem_cb == 0) {
0000da  f1b80f00          CMP      r8,#0
0000de  d103              BNE      |L37.232|
;;;2048           /* Control block on heap */
;;;2049           mp->status |= 1U;
0000e0  6a20              LDR      r0,[r4,#0x20]
0000e2  f0400001          ORR      r0,r0,#1
0000e6  6220              STR      r0,[r4,#0x20]
                  |L37.232|
;;;2050         }
;;;2051         if (mem_mp == 0) {
0000e8  f1ba0f00          CMP      r10,#0
0000ec  d10c              BNE      |L37.264|
;;;2052           /* Memory array on heap */
;;;2053           mp->status |= 2U;
0000ee  6a20              LDR      r0,[r4,#0x20]
0000f0  f0400002          ORR      r0,r0,#2
0000f4  6220              STR      r0,[r4,#0x20]
0000f6  e007              B        |L37.264|
                  |L37.248|
;;;2054         }
;;;2055       }
;;;2056       else {
;;;2057         /* Memory pool cannot be created, release allocated resources */
;;;2058         if ((mem_cb == 0) && (mp != NULL)) {
0000f8  f1b80f00          CMP      r8,#0
0000fc  d103              BNE      |L37.262|
0000fe  b114              CBZ      r4,|L37.262|
;;;2059           /* Free control block memory */
;;;2060           vPortFree (mp);
000100  4620              MOV      r0,r4
000102  f7fffffe          BL       vPortFree
                  |L37.262|
;;;2061         }
;;;2062         mp = NULL;
000106  2400              MOVS     r4,#0
                  |L37.264|
;;;2063       }
;;;2064     }
;;;2065   
;;;2066     return (mp);
000108  4620              MOV      r0,r4
;;;2067   }
00010a  e8bd9ff0          POP      {r4-r12,pc}
;;;2068   
                          ENDP

00010e  0000              DCW      0x0000
                  |L37.272|
                          DCD      0x5eed0000

                          AREA ||i.osMessageQueueDelete||, CODE, READONLY, ALIGN=1

                  osMessageQueueDelete PROC
;;;1917   
;;;1918   osStatus_t osMessageQueueDelete (osMessageQueueId_t mq_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;1919     QueueHandle_t hQueue = (QueueHandle_t)mq_id;
000004  462e              MOV      r6,r5
;;;1920     osStatus_t stat;
;;;1921   
;;;1922   #ifndef USE_FreeRTOS_HEAP_1
;;;1923     if (IS_IRQ()) {
000006  f7fffffe          BL       __get_IPSR
00000a  b110              CBZ      r0,|L38.18|
;;;1924       stat = osErrorISR;
00000c  f06f0405          MVN      r4,#5
000010  e00a              B        |L38.40|
                  |L38.18|
;;;1925     }
;;;1926     else if (hQueue == NULL) {
000012  b916              CBNZ     r6,|L38.26|
;;;1927       stat = osErrorParameter;
000014  f06f0403          MVN      r4,#3
000018  e006              B        |L38.40|
                  |L38.26|
;;;1928     }
;;;1929     else {
;;;1930       #if (configQUEUE_REGISTRY_SIZE > 0)
;;;1931       vQueueUnregisterQueue (hQueue);
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       vQueueUnregisterQueue
;;;1932       #endif
;;;1933   
;;;1934       stat = osOK;
000020  2400              MOVS     r4,#0
;;;1935       vQueueDelete (hQueue);
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       vQueueDelete
                  |L38.40|
;;;1936     }
;;;1937   #else
;;;1938     stat = osError;
;;;1939   #endif
;;;1940   
;;;1941     return (stat);
000028  4620              MOV      r0,r4
;;;1942   }
00002a  bd70              POP      {r4-r6,pc}
;;;1943   
                          ENDP


                          AREA ||i.osMessageQueueGet||, CODE, READONLY, ALIGN=2

                  osMessageQueueGet PROC
;;;1790   
;;;1791   osStatus_t osMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t timeout) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4691              MOV      r9,r2
00000a  461c              MOV      r4,r3
;;;1792     QueueHandle_t hQueue = (QueueHandle_t)mq_id;
00000c  463e              MOV      r6,r7
;;;1793     osStatus_t stat;
;;;1794     BaseType_t yield;
;;;1795   
;;;1796     (void)msg_prio; /* Message priority is ignored */
;;;1797   
;;;1798     stat = osOK;
00000e  f04f0800          MOV      r8,#0
;;;1799   
;;;1800     if (IS_IRQ()) {
000012  f7fffffe          BL       __get_IPSR
000016  b1e0              CBZ      r0,|L39.82|
;;;1801       if ((hQueue == NULL) || (msg_ptr == NULL) || (timeout != 0U)) {
000018  b10e              CBZ      r6,|L39.30|
00001a  b105              CBZ      r5,|L39.30|
00001c  b114              CBZ      r4,|L39.36|
                  |L39.30|
;;;1802         stat = osErrorParameter;
00001e  f06f0803          MVN      r8,#3
000022  e028              B        |L39.118|
                  |L39.36|
;;;1803       }
;;;1804       else {
;;;1805         yield = pdFALSE;
000024  2000              MOVS     r0,#0
000026  9000              STR      r0,[sp,#0]
;;;1806   
;;;1807         if (xQueueReceiveFromISR (hQueue, msg_ptr, &yield) != pdPASS) {
000028  466a              MOV      r2,sp
00002a  4629              MOV      r1,r5
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       xQueueReceiveFromISR
000032  2801              CMP      r0,#1
000034  d002              BEQ      |L39.60|
;;;1808           stat = osErrorResource;
000036  f06f0802          MVN      r8,#2
00003a  e01c              B        |L39.118|
                  |L39.60|
;;;1809         } else {
;;;1810           portYIELD_FROM_ISR (yield);
00003c  9800              LDR      r0,[sp,#0]
00003e  b1d0              CBZ      r0,|L39.118|
000040  f04f5080          MOV      r0,#0x10000000
000044  490d              LDR      r1,|L39.124|
000046  6008              STR      r0,[r1,#0]
000048  f3bf8f4f          DSB      
00004c  f3bf8f6f          ISB      
000050  e011              B        |L39.118|
                  |L39.82|
;;;1811         }
;;;1812       }
;;;1813     }
;;;1814     else {
;;;1815       if ((hQueue == NULL) || (msg_ptr == NULL)) {
000052  b106              CBZ      r6,|L39.86|
000054  b915              CBNZ     r5,|L39.92|
                  |L39.86|
;;;1816         stat = osErrorParameter;
000056  f06f0803          MVN      r8,#3
00005a  e00c              B        |L39.118|
                  |L39.92|
;;;1817       }
;;;1818       else {
;;;1819         if (xQueueReceive (hQueue, msg_ptr, (TickType_t)timeout) != pdPASS) {
00005c  4622              MOV      r2,r4
00005e  4629              MOV      r1,r5
000060  4630              MOV      r0,r6
000062  f7fffffe          BL       xQueueReceive
000066  2801              CMP      r0,#1
000068  d005              BEQ      |L39.118|
;;;1820           if (timeout != 0U) {
00006a  b114              CBZ      r4,|L39.114|
;;;1821             stat = osErrorTimeout;
00006c  f06f0801          MVN      r8,#1
000070  e001              B        |L39.118|
                  |L39.114|
;;;1822           } else {
;;;1823             stat = osErrorResource;
000072  f06f0802          MVN      r8,#2
                  |L39.118|
;;;1824           }
;;;1825         }
;;;1826       }
;;;1827     }
;;;1828   
;;;1829     return (stat);
000076  4640              MOV      r0,r8
;;;1830   }
000078  e8bd83f8          POP      {r3-r9,pc}
;;;1831   
                          ENDP

                  |L39.124|
                          DCD      0xe000ed04

                          AREA ||i.osMessageQueueGetCapacity||, CODE, READONLY, ALIGN=1

                  osMessageQueueGetCapacity PROC
;;;1831   
;;;1832   uint32_t osMessageQueueGetCapacity (osMessageQueueId_t mq_id) {
000000  4601              MOV      r1,r0
;;;1833     StaticQueue_t *mq = (StaticQueue_t *)mq_id;
000002  460a              MOV      r2,r1
;;;1834     uint32_t capacity;
;;;1835   
;;;1836     if (mq == NULL) {
000004  b90a              CBNZ     r2,|L40.10|
;;;1837       capacity = 0U;
000006  2000              MOVS     r0,#0
000008  e000              B        |L40.12|
                  |L40.10|
;;;1838     } else {
;;;1839       /* capacity = pxQueue->uxLength */
;;;1840       capacity = mq->uxDummy4[1];
00000a  6bd0              LDR      r0,[r2,#0x3c]
                  |L40.12|
;;;1841     }
;;;1842   
;;;1843     return (capacity);
;;;1844   }
00000c  4770              BX       lr
;;;1845   
                          ENDP


                          AREA ||i.osMessageQueueGetCount||, CODE, READONLY, ALIGN=1

                  osMessageQueueGetCount PROC
;;;1859   
;;;1860   uint32_t osMessageQueueGetCount (osMessageQueueId_t mq_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;1861     QueueHandle_t hQueue = (QueueHandle_t)mq_id;
000004  462e              MOV      r6,r5
;;;1862     UBaseType_t count;
;;;1863   
;;;1864     if (hQueue == NULL) {
000006  b90e              CBNZ     r6,|L41.12|
;;;1865       count = 0U;
000008  2400              MOVS     r4,#0
00000a  e00b              B        |L41.36|
                  |L41.12|
;;;1866     }
;;;1867     else if (IS_IRQ()) {
00000c  f7fffffe          BL       __get_IPSR
000010  b120              CBZ      r0,|L41.28|
;;;1868       count = uxQueueMessagesWaitingFromISR (hQueue);
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       uxQueueMessagesWaitingFromISR
000018  4604              MOV      r4,r0
00001a  e003              B        |L41.36|
                  |L41.28|
;;;1869     }
;;;1870     else {
;;;1871       count = uxQueueMessagesWaiting (hQueue);
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       uxQueueMessagesWaiting
000022  4604              MOV      r4,r0
                  |L41.36|
;;;1872     }
;;;1873   
;;;1874     return ((uint32_t)count);
000024  4620              MOV      r0,r4
;;;1875   }
000026  bd70              POP      {r4-r6,pc}
;;;1876   
                          ENDP


                          AREA ||i.osMessageQueueGetMsgSize||, CODE, READONLY, ALIGN=1

                  osMessageQueueGetMsgSize PROC
;;;1845   
;;;1846   uint32_t osMessageQueueGetMsgSize (osMessageQueueId_t mq_id) {
000000  4601              MOV      r1,r0
;;;1847     StaticQueue_t *mq = (StaticQueue_t *)mq_id;
000002  460a              MOV      r2,r1
;;;1848     uint32_t size;
;;;1849   
;;;1850     if (mq == NULL) {
000004  b90a              CBNZ     r2,|L42.10|
;;;1851       size = 0U;
000006  2000              MOVS     r0,#0
000008  e000              B        |L42.12|
                  |L42.10|
;;;1852     } else {
;;;1853       /* size = pxQueue->uxItemSize */
;;;1854       size = mq->uxDummy4[2];
00000a  6c10              LDR      r0,[r2,#0x40]
                  |L42.12|
;;;1855     }
;;;1856   
;;;1857     return (size);
;;;1858   }
00000c  4770              BX       lr
;;;1859   
                          ENDP


                          AREA ||i.osMessageQueueGetSpace||, CODE, READONLY, ALIGN=1

                  osMessageQueueGetSpace PROC
;;;1876   
;;;1877   uint32_t osMessageQueueGetSpace (osMessageQueueId_t mq_id) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
;;;1878     StaticQueue_t *mq = (StaticQueue_t *)mq_id;
000006  463d              MOV      r5,r7
;;;1879     uint32_t space;
;;;1880     uint32_t isrm;
;;;1881   
;;;1882     if (mq == NULL) {
000008  b90d              CBNZ     r5,|L43.14|
;;;1883       space = 0U;
00000a  2600              MOVS     r6,#0
00000c  e01a              B        |L43.68|
                  |L43.14|
;;;1884     }
;;;1885     else if (IS_IRQ()) {
00000e  f7fffffe          BL       __get_IPSR
000012  b198              CBZ      r0,|L43.60|
;;;1886       isrm = taskENTER_CRITICAL_FROM_ISR();
000014  bf00              NOP      
000016  2150              MOVS     r1,#0x50
000018  f3ef8011          MRS      r0,BASEPRI
00001c  f3818811          MSR      BASEPRI,r1
000020  f3bf8f4f          DSB      
000024  f3bf8f6f          ISB      
000028  4604              MOV      r4,r0
00002a  bf00              NOP      
;;;1887   
;;;1888       /* space = pxQueue->uxLength - pxQueue->uxMessagesWaiting; */
;;;1889       space = mq->uxDummy4[1] - mq->uxDummy4[0];
00002c  e9d5100e          LDRD     r1,r0,[r5,#0x38]
000030  1a46              SUBS     r6,r0,r1
;;;1890   
;;;1891       taskEXIT_CRITICAL_FROM_ISR(isrm);
000032  bf00              NOP      
000034  f3848811          MSR      BASEPRI,r4
000038  bf00              NOP      
00003a  e003              B        |L43.68|
                  |L43.60|
;;;1892     }
;;;1893     else {
;;;1894       space = (uint32_t)uxQueueSpacesAvailable ((QueueHandle_t)mq);
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       uxQueueSpacesAvailable
000042  4606              MOV      r6,r0
                  |L43.68|
;;;1895     }
;;;1896   
;;;1897     return (space);
000044  4630              MOV      r0,r6
;;;1898   }
000046  e8bd81f0          POP      {r4-r8,pc}
;;;1899   
                          ENDP


                          AREA ||i.osMessageQueueNew||, CODE, READONLY, ALIGN=1

                  osMessageQueueNew PROC
;;;1692   
;;;1693   osMessageQueueId_t osMessageQueueNew (uint32_t msg_count, uint32_t msg_size, const osMessageQueueAttr_t *attr) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;1694     QueueHandle_t hQueue;
;;;1695     int32_t mem;
;;;1696     #if (configQUEUE_REGISTRY_SIZE > 0)
;;;1697     const char *name;
;;;1698     #endif
;;;1699   
;;;1700     hQueue = NULL;
00000a  f04f0900          MOV      r9,#0
;;;1701   
;;;1702     if (!IS_IRQ() && (msg_count > 0U) && (msg_size > 0U)) {
00000e  f7fffffe          BL       __get_IPSR
000012  2800              CMP      r0,#0
000014  d13e              BNE      |L44.148|
000016  2d00              CMP      r5,#0
000018  d03c              BEQ      |L44.148|
00001a  2e00              CMP      r6,#0
00001c  d03a              BEQ      |L44.148|
;;;1703       mem = -1;
00001e  1e47              SUBS     r7,r0,#1
;;;1704   
;;;1705       if (attr != NULL) {
000020  b1bc              CBZ      r4,|L44.82|
;;;1706         if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticQueue_t)) &&
000022  68a0              LDR      r0,[r4,#8]
000024  b158              CBZ      r0,|L44.62|
000026  68e0              LDR      r0,[r4,#0xc]
000028  2850              CMP      r0,#0x50
00002a  d308              BCC      |L44.62|
;;;1707             (attr->mq_mem != NULL) && (attr->mq_size >= (msg_count * msg_size))) {
00002c  6920              LDR      r0,[r4,#0x10]
00002e  b130              CBZ      r0,|L44.62|
000030  fb05f006          MUL      r0,r5,r6
000034  6961              LDR      r1,[r4,#0x14]
000036  4281              CMP      r1,r0
000038  d301              BCC      |L44.62|
;;;1708           mem = 1;
00003a  2701              MOVS     r7,#1
00003c  e00a              B        |L44.84|
                  |L44.62|
;;;1709         }
;;;1710         else {
;;;1711           if ((attr->cb_mem == NULL) && (attr->cb_size == 0U) &&
00003e  68a0              LDR      r0,[r4,#8]
000040  b940              CBNZ     r0,|L44.84|
000042  68e0              LDR      r0,[r4,#0xc]
000044  b930              CBNZ     r0,|L44.84|
;;;1712               (attr->mq_mem == NULL) && (attr->mq_size == 0U)) {
000046  6920              LDR      r0,[r4,#0x10]
000048  b920              CBNZ     r0,|L44.84|
00004a  6960              LDR      r0,[r4,#0x14]
00004c  b910              CBNZ     r0,|L44.84|
;;;1713             mem = 0;
00004e  2700              MOVS     r7,#0
000050  e000              B        |L44.84|
                  |L44.82|
;;;1714           }
;;;1715         }
;;;1716       }
;;;1717       else {
;;;1718         mem = 0;
000052  2700              MOVS     r7,#0
                  |L44.84|
;;;1719       }
;;;1720   
;;;1721       if (mem == 1) {
000054  2f01              CMP      r7,#1
000056  d109              BNE      |L44.108|
;;;1722         #if (configSUPPORT_STATIC_ALLOCATION == 1)
;;;1723           hQueue = xQueueCreateStatic (msg_count, msg_size, attr->mq_mem, attr->cb_mem);
000058  2000              MOVS     r0,#0
00005a  9000              STR      r0,[sp,#0]
00005c  4631              MOV      r1,r6
00005e  4628              MOV      r0,r5
000060  68a3              LDR      r3,[r4,#8]
000062  6922              LDR      r2,[r4,#0x10]
000064  f7fffffe          BL       xQueueGenericCreateStatic
000068  4681              MOV      r9,r0
00006a  e006              B        |L44.122|
                  |L44.108|
;;;1724         #endif
;;;1725       }
;;;1726       else {
;;;1727         if (mem == 0) {
00006c  b92f              CBNZ     r7,|L44.122|
;;;1728           #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
;;;1729             hQueue = xQueueCreate (msg_count, msg_size);
00006e  2200              MOVS     r2,#0
000070  4631              MOV      r1,r6
000072  4628              MOV      r0,r5
000074  f7fffffe          BL       xQueueGenericCreate
000078  4681              MOV      r9,r0
                  |L44.122|
;;;1730           #endif
;;;1731         }
;;;1732       }
;;;1733   
;;;1734       #if (configQUEUE_REGISTRY_SIZE > 0)
;;;1735       if (hQueue != NULL) {
00007a  f1b90f00          CMP      r9,#0
00007e  d009              BEQ      |L44.148|
;;;1736         if (attr != NULL) {
000080  b114              CBZ      r4,|L44.136|
;;;1737           name = attr->name;
000082  f8d48000          LDR      r8,[r4,#0]
000086  e001              B        |L44.140|
                  |L44.136|
;;;1738         } else {
;;;1739           name = NULL;
000088  f04f0800          MOV      r8,#0
                  |L44.140|
;;;1740         }
;;;1741         vQueueAddToRegistry (hQueue, name);
00008c  4641              MOV      r1,r8
00008e  4648              MOV      r0,r9
000090  f7fffffe          BL       vQueueAddToRegistry
                  |L44.148|
;;;1742       }
;;;1743       #endif
;;;1744   
;;;1745     }
;;;1746   
;;;1747     return ((osMessageQueueId_t)hQueue);
000094  4648              MOV      r0,r9
;;;1748   }
000096  e8bd83f8          POP      {r3-r9,pc}
;;;1749   
                          ENDP


                          AREA ||i.osMessageQueuePut||, CODE, READONLY, ALIGN=2

                  osMessageQueuePut PROC
;;;1749   
;;;1750   osStatus_t osMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t timeout) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4691              MOV      r9,r2
00000a  461c              MOV      r4,r3
;;;1751     QueueHandle_t hQueue = (QueueHandle_t)mq_id;
00000c  463e              MOV      r6,r7
;;;1752     osStatus_t stat;
;;;1753     BaseType_t yield;
;;;1754   
;;;1755     (void)msg_prio; /* Message priority is ignored */
;;;1756   
;;;1757     stat = osOK;
00000e  f04f0800          MOV      r8,#0
;;;1758   
;;;1759     if (IS_IRQ()) {
000012  f7fffffe          BL       __get_IPSR
000016  b1e8              CBZ      r0,|L45.84|
;;;1760       if ((hQueue == NULL) || (msg_ptr == NULL) || (timeout != 0U)) {
000018  b10e              CBZ      r6,|L45.30|
00001a  b105              CBZ      r5,|L45.30|
00001c  b114              CBZ      r4,|L45.36|
                  |L45.30|
;;;1761         stat = osErrorParameter;
00001e  f06f0803          MVN      r8,#3
000022  e02a              B        |L45.122|
                  |L45.36|
;;;1762       }
;;;1763       else {
;;;1764         yield = pdFALSE;
000024  2000              MOVS     r0,#0
000026  9000              STR      r0,[sp,#0]
;;;1765   
;;;1766         if (xQueueSendToBackFromISR (hQueue, msg_ptr, &yield) != pdTRUE) {
000028  2300              MOVS     r3,#0
00002a  466a              MOV      r2,sp
00002c  4629              MOV      r1,r5
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       xQueueGenericSendFromISR
000034  2801              CMP      r0,#1
000036  d002              BEQ      |L45.62|
;;;1767           stat = osErrorResource;
000038  f06f0802          MVN      r8,#2
00003c  e01d              B        |L45.122|
                  |L45.62|
;;;1768         } else {
;;;1769           portYIELD_FROM_ISR (yield);
00003e  9800              LDR      r0,[sp,#0]
000040  b1d8              CBZ      r0,|L45.122|
000042  f04f5080          MOV      r0,#0x10000000
000046  490e              LDR      r1,|L45.128|
000048  6008              STR      r0,[r1,#0]
00004a  f3bf8f4f          DSB      
00004e  f3bf8f6f          ISB      
000052  e012              B        |L45.122|
                  |L45.84|
;;;1770         }
;;;1771       }
;;;1772     }
;;;1773     else {
;;;1774       if ((hQueue == NULL) || (msg_ptr == NULL)) {
000054  b106              CBZ      r6,|L45.88|
000056  b915              CBNZ     r5,|L45.94|
                  |L45.88|
;;;1775         stat = osErrorParameter;
000058  f06f0803          MVN      r8,#3
00005c  e00d              B        |L45.122|
                  |L45.94|
;;;1776       }
;;;1777       else {
;;;1778         if (xQueueSendToBack (hQueue, msg_ptr, (TickType_t)timeout) != pdPASS) {
00005e  2300              MOVS     r3,#0
000060  4622              MOV      r2,r4
000062  4629              MOV      r1,r5
000064  4630              MOV      r0,r6
000066  f7fffffe          BL       xQueueGenericSend
00006a  2801              CMP      r0,#1
00006c  d005              BEQ      |L45.122|
;;;1779           if (timeout != 0U) {
00006e  b114              CBZ      r4,|L45.118|
;;;1780             stat = osErrorTimeout;
000070  f06f0801          MVN      r8,#1
000074  e001              B        |L45.122|
                  |L45.118|
;;;1781           } else {
;;;1782             stat = osErrorResource;
000076  f06f0802          MVN      r8,#2
                  |L45.122|
;;;1783           }
;;;1784         }
;;;1785       }
;;;1786     }
;;;1787   
;;;1788     return (stat);
00007a  4640              MOV      r0,r8
;;;1789   }
00007c  e8bd83f8          POP      {r3-r9,pc}
;;;1790   
                          ENDP

                  |L45.128|
                          DCD      0xe000ed04

                          AREA ||i.osMessageQueueReset||, CODE, READONLY, ALIGN=1

                  osMessageQueueReset PROC
;;;1899   
;;;1900   osStatus_t osMessageQueueReset (osMessageQueueId_t mq_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;1901     QueueHandle_t hQueue = (QueueHandle_t)mq_id;
000004  462e              MOV      r6,r5
;;;1902     osStatus_t stat;
;;;1903   
;;;1904     if (IS_IRQ()) {
000006  f7fffffe          BL       __get_IPSR
00000a  b110              CBZ      r0,|L46.18|
;;;1905       stat = osErrorISR;
00000c  f06f0405          MVN      r4,#5
000010  e008              B        |L46.36|
                  |L46.18|
;;;1906     }
;;;1907     else if (hQueue == NULL) {
000012  b916              CBNZ     r6,|L46.26|
;;;1908       stat = osErrorParameter;
000014  f06f0403          MVN      r4,#3
000018  e004              B        |L46.36|
                  |L46.26|
;;;1909     }
;;;1910     else {
;;;1911       stat = osOK;
00001a  2400              MOVS     r4,#0
;;;1912       (void)xQueueReset (hQueue);
00001c  2100              MOVS     r1,#0
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       xQueueGenericReset
                  |L46.36|
;;;1913     }
;;;1914   
;;;1915     return (stat);
000024  4620              MOV      r0,r4
;;;1916   }
000026  bd70              POP      {r4-r6,pc}
;;;1917   
                          ENDP


                          AREA ||i.osMutexAcquire||, CODE, READONLY, ALIGN=1

                  osMutexAcquire PROC
;;;1385   
;;;1386   osStatus_t osMutexAcquire (osMutexId_t mutex_id, uint32_t timeout) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1387     SemaphoreHandle_t hMutex;
;;;1388     osStatus_t stat;
;;;1389     uint32_t rmtx;
;;;1390   
;;;1391     hMutex = (SemaphoreHandle_t)((uint32_t)mutex_id & ~1U);
000008  f0240601          BIC      r6,r4,#1
;;;1392   
;;;1393     rmtx = (uint32_t)mutex_id & 1U;
00000c  f0040801          AND      r8,r4,#1
;;;1394   
;;;1395     stat = osOK;
000010  2700              MOVS     r7,#0
;;;1396   
;;;1397     if (IS_IRQ()) {
000012  f7fffffe          BL       __get_IPSR
000016  b108              CBZ      r0,|L47.28|
;;;1398       stat = osErrorISR;
000018  1fbf              SUBS     r7,r7,#6
00001a  e01f              B        |L47.92|
                  |L47.28|
;;;1399     }
;;;1400     else if (hMutex == NULL) {
00001c  b916              CBNZ     r6,|L47.36|
;;;1401       stat = osErrorParameter;
00001e  f06f0703          MVN      r7,#3
000022  e01b              B        |L47.92|
                  |L47.36|
;;;1402     }
;;;1403     else {
;;;1404       if (rmtx != 0U) {
000024  f1b80f00          CMP      r8,#0
000028  d00c              BEQ      |L47.68|
;;;1405         #if (configUSE_RECURSIVE_MUTEXES == 1)
;;;1406         if (xSemaphoreTakeRecursive (hMutex, timeout) != pdPASS) {
00002a  4629              MOV      r1,r5
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       xQueueTakeMutexRecursive
000032  2801              CMP      r0,#1
000034  d012              BEQ      |L47.92|
;;;1407           if (timeout != 0U) {
000036  b115              CBZ      r5,|L47.62|
;;;1408             stat = osErrorTimeout;
000038  f06f0701          MVN      r7,#1
00003c  e00e              B        |L47.92|
                  |L47.62|
;;;1409           } else {
;;;1410             stat = osErrorResource;
00003e  f06f0702          MVN      r7,#2
000042  e00b              B        |L47.92|
                  |L47.68|
;;;1411           }
;;;1412         }
;;;1413         #endif
;;;1414       }
;;;1415       else {
;;;1416         if (xSemaphoreTake (hMutex, timeout) != pdPASS) {
000044  4629              MOV      r1,r5
000046  4630              MOV      r0,r6
000048  f7fffffe          BL       xQueueSemaphoreTake
00004c  2801              CMP      r0,#1
00004e  d005              BEQ      |L47.92|
;;;1417           if (timeout != 0U) {
000050  b115              CBZ      r5,|L47.88|
;;;1418             stat = osErrorTimeout;
000052  f06f0701          MVN      r7,#1
000056  e001              B        |L47.92|
                  |L47.88|
;;;1419           } else {
;;;1420             stat = osErrorResource;
000058  f06f0702          MVN      r7,#2
                  |L47.92|
;;;1421           }
;;;1422         }
;;;1423       }
;;;1424     }
;;;1425   
;;;1426     return (stat);
00005c  4638              MOV      r0,r7
;;;1427   }
00005e  e8bd81f0          POP      {r4-r8,pc}
;;;1428   
                          ENDP


                          AREA ||i.osMutexDelete||, CODE, READONLY, ALIGN=1

                  osMutexDelete PROC
;;;1478   
;;;1479   osStatus_t osMutexDelete (osMutexId_t mutex_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;1480     osStatus_t stat;
;;;1481   #ifndef USE_FreeRTOS_HEAP_1
;;;1482     SemaphoreHandle_t hMutex;
;;;1483   
;;;1484     hMutex = (SemaphoreHandle_t)((uint32_t)mutex_id & ~1U);
000004  f0250601          BIC      r6,r5,#1
;;;1485   
;;;1486     if (IS_IRQ()) {
000008  f7fffffe          BL       __get_IPSR
00000c  b110              CBZ      r0,|L48.20|
;;;1487       stat = osErrorISR;
00000e  f06f0405          MVN      r4,#5
000012  e00a              B        |L48.42|
                  |L48.20|
;;;1488     }
;;;1489     else if (hMutex == NULL) {
000014  b916              CBNZ     r6,|L48.28|
;;;1490       stat = osErrorParameter;
000016  f06f0403          MVN      r4,#3
00001a  e006              B        |L48.42|
                  |L48.28|
;;;1491     }
;;;1492     else {
;;;1493       #if (configQUEUE_REGISTRY_SIZE > 0)
;;;1494       vQueueUnregisterQueue (hMutex);
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       vQueueUnregisterQueue
;;;1495       #endif
;;;1496       stat = osOK;
000022  2400              MOVS     r4,#0
;;;1497       vSemaphoreDelete (hMutex);
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       vQueueDelete
                  |L48.42|
;;;1498     }
;;;1499   #else
;;;1500     stat = osError;
;;;1501   #endif
;;;1502   
;;;1503     return (stat);
00002a  4620              MOV      r0,r4
;;;1504   }
00002c  bd70              POP      {r4-r6,pc}
;;;1505   #endif /* (configUSE_OS2_MUTEX == 1) */
                          ENDP


                          AREA ||i.osMutexGetOwner||, CODE, READONLY, ALIGN=1

                  osMutexGetOwner PROC
;;;1463   
;;;1464   osThreadId_t osMutexGetOwner (osMutexId_t mutex_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;1465     SemaphoreHandle_t hMutex;
;;;1466     osThreadId_t owner;
;;;1467   
;;;1468     hMutex = (SemaphoreHandle_t)((uint32_t)mutex_id & ~1U);
000004  f0250601          BIC      r6,r5,#1
;;;1469   
;;;1470     if (IS_IRQ() || (hMutex == NULL)) {
000008  f7fffffe          BL       __get_IPSR
00000c  b900              CBNZ     r0,|L49.16|
00000e  b90e              CBNZ     r6,|L49.20|
                  |L49.16|
;;;1471       owner = NULL;
000010  2400              MOVS     r4,#0
000012  e003              B        |L49.28|
                  |L49.20|
;;;1472     } else {
;;;1473       owner = (osThreadId_t)xSemaphoreGetMutexHolder (hMutex);
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       xQueueGetMutexHolder
00001a  4604              MOV      r4,r0
                  |L49.28|
;;;1474     }
;;;1475   
;;;1476     return (owner);
00001c  4620              MOV      r0,r4
;;;1477   }
00001e  bd70              POP      {r4-r6,pc}
;;;1478   
                          ENDP


                          AREA ||i.osMutexNew||, CODE, READONLY, ALIGN=1

                  osMutexNew PROC
;;;1298   
;;;1299   osMutexId_t osMutexNew (const osMutexAttr_t *attr) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
;;;1300     SemaphoreHandle_t hMutex;
;;;1301     uint32_t type;
;;;1302     uint32_t rmtx;
;;;1303     int32_t  mem;
;;;1304     #if (configQUEUE_REGISTRY_SIZE > 0)
;;;1305     const char *name;
;;;1306     #endif
;;;1307   
;;;1308     hMutex = NULL;
000006  2600              MOVS     r6,#0
;;;1309   
;;;1310     if (!IS_IRQ()) {
000008  f7fffffe          BL       __get_IPSR
00000c  2800              CMP      r0,#0
00000e  d14d              BNE      |L50.172|
;;;1311       if (attr != NULL) {
000010  b10c              CBZ      r4,|L50.22|
;;;1312         type = attr->attr_bits;
000012  6867              LDR      r7,[r4,#4]
000014  e000              B        |L50.24|
                  |L50.22|
;;;1313       } else {
;;;1314         type = 0U;
000016  2700              MOVS     r7,#0
                  |L50.24|
;;;1315       }
;;;1316   
;;;1317       if ((type & osMutexRecursive) == osMutexRecursive) {
000018  f0070001          AND      r0,r7,#1
00001c  b108              CBZ      r0,|L50.34|
;;;1318         rmtx = 1U;
00001e  2501              MOVS     r5,#1
000020  e000              B        |L50.36|
                  |L50.34|
;;;1319       } else {
;;;1320         rmtx = 0U;
000022  2500              MOVS     r5,#0
                  |L50.36|
;;;1321       }
;;;1322   
;;;1323       if ((type & osMutexRobust) != osMutexRobust) {
000024  f0070008          AND      r0,r7,#8
000028  2808              CMP      r0,#8
00002a  d03f              BEQ      |L50.172|
;;;1324         mem = -1;
00002c  f04f38ff          MOV      r8,#0xffffffff
;;;1325   
;;;1326         if (attr != NULL) {
000030  b174              CBZ      r4,|L50.80|
;;;1327           if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticSemaphore_t))) {
000032  68a0              LDR      r0,[r4,#8]
000034  b128              CBZ      r0,|L50.66|
000036  68e0              LDR      r0,[r4,#0xc]
000038  2850              CMP      r0,#0x50
00003a  d302              BCC      |L50.66|
;;;1328             mem = 1;
00003c  f04f0801          MOV      r8,#1
000040  e008              B        |L50.84|
                  |L50.66|
;;;1329           }
;;;1330           else {
;;;1331             if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
000042  68a0              LDR      r0,[r4,#8]
000044  b930              CBNZ     r0,|L50.84|
000046  68e0              LDR      r0,[r4,#0xc]
000048  b920              CBNZ     r0,|L50.84|
;;;1332               mem = 0;
00004a  f04f0800          MOV      r8,#0
00004e  e001              B        |L50.84|
                  |L50.80|
;;;1333             }
;;;1334           }
;;;1335         }
;;;1336         else {
;;;1337           mem = 0;
000050  f04f0800          MOV      r8,#0
                  |L50.84|
;;;1338         }
;;;1339   
;;;1340         if (mem == 1) {
000054  f1b80f01          CMP      r8,#1
000058  d10c              BNE      |L50.116|
;;;1341           #if (configSUPPORT_STATIC_ALLOCATION == 1)
;;;1342             if (rmtx != 0U) {
00005a  b12d              CBZ      r5,|L50.104|
;;;1343               #if (configUSE_RECURSIVE_MUTEXES == 1)
;;;1344               hMutex = xSemaphoreCreateRecursiveMutexStatic (attr->cb_mem);
00005c  2004              MOVS     r0,#4
00005e  68a1              LDR      r1,[r4,#8]
000060  f7fffffe          BL       xQueueCreateMutexStatic
000064  4606              MOV      r6,r0
000066  e012              B        |L50.142|
                  |L50.104|
;;;1345               #endif
;;;1346             }
;;;1347             else {
;;;1348               hMutex = xSemaphoreCreateMutexStatic (attr->cb_mem);
000068  2001              MOVS     r0,#1
00006a  68a1              LDR      r1,[r4,#8]
00006c  f7fffffe          BL       xQueueCreateMutexStatic
000070  4606              MOV      r6,r0
000072  e00c              B        |L50.142|
                  |L50.116|
;;;1349             }
;;;1350           #endif
;;;1351         }
;;;1352         else {
;;;1353           if (mem == 0) {
000074  f1b80f00          CMP      r8,#0
000078  d109              BNE      |L50.142|
;;;1354             #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
;;;1355               if (rmtx != 0U) {
00007a  b125              CBZ      r5,|L50.134|
;;;1356                 #if (configUSE_RECURSIVE_MUTEXES == 1)
;;;1357                 hMutex = xSemaphoreCreateRecursiveMutex ();
00007c  2004              MOVS     r0,#4
00007e  f7fffffe          BL       xQueueCreateMutex
000082  4606              MOV      r6,r0
000084  e003              B        |L50.142|
                  |L50.134|
;;;1358                 #endif
;;;1359               } else {
;;;1360                 hMutex = xSemaphoreCreateMutex ();
000086  2001              MOVS     r0,#1
000088  f7fffffe          BL       xQueueCreateMutex
00008c  4606              MOV      r6,r0
                  |L50.142|
;;;1361               }
;;;1362             #endif
;;;1363           }
;;;1364         }
;;;1365   
;;;1366         #if (configQUEUE_REGISTRY_SIZE > 0)
;;;1367         if (hMutex != NULL) {
00008e  b14e              CBZ      r6,|L50.164|
;;;1368           if (attr != NULL) {
000090  b114              CBZ      r4,|L50.152|
;;;1369             name = attr->name;
000092  f8d49000          LDR      r9,[r4,#0]
000096  e001              B        |L50.156|
                  |L50.152|
;;;1370           } else {
;;;1371             name = NULL;
000098  f04f0900          MOV      r9,#0
                  |L50.156|
;;;1372           }
;;;1373           vQueueAddToRegistry (hMutex, name);
00009c  4649              MOV      r1,r9
00009e  4630              MOV      r0,r6
0000a0  f7fffffe          BL       vQueueAddToRegistry
                  |L50.164|
;;;1374         }
;;;1375         #endif
;;;1376   
;;;1377         if ((hMutex != NULL) && (rmtx != 0U)) {
0000a4  b116              CBZ      r6,|L50.172|
0000a6  b10d              CBZ      r5,|L50.172|
;;;1378           hMutex = (SemaphoreHandle_t)((uint32_t)hMutex | 1U);
0000a8  f0460601          ORR      r6,r6,#1
                  |L50.172|
;;;1379         }
;;;1380       }
;;;1381     }
;;;1382   
;;;1383     return ((osMutexId_t)hMutex);
0000ac  4630              MOV      r0,r6
;;;1384   }
0000ae  e8bd87f0          POP      {r4-r10,pc}
;;;1385   
                          ENDP


                          AREA ||i.osMutexRelease||, CODE, READONLY, ALIGN=1

                  osMutexRelease PROC
;;;1428   
;;;1429   osStatus_t osMutexRelease (osMutexId_t mutex_id) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
;;;1430     SemaphoreHandle_t hMutex;
;;;1431     osStatus_t stat;
;;;1432     uint32_t rmtx;
;;;1433   
;;;1434     hMutex = (SemaphoreHandle_t)((uint32_t)mutex_id & ~1U);
000006  f0240501          BIC      r5,r4,#1
;;;1435   
;;;1436     rmtx = (uint32_t)mutex_id & 1U;
00000a  f0040701          AND      r7,r4,#1
;;;1437   
;;;1438     stat = osOK;
00000e  2600              MOVS     r6,#0
;;;1439   
;;;1440     if (IS_IRQ()) {
000010  f7fffffe          BL       __get_IPSR
000014  b108              CBZ      r0,|L51.26|
;;;1441       stat = osErrorISR;
000016  1fb6              SUBS     r6,r6,#6
000018  e016              B        |L51.72|
                  |L51.26|
;;;1442     }
;;;1443     else if (hMutex == NULL) {
00001a  b915              CBNZ     r5,|L51.34|
;;;1444       stat = osErrorParameter;
00001c  f06f0603          MVN      r6,#3
000020  e012              B        |L51.72|
                  |L51.34|
;;;1445     }
;;;1446     else {
;;;1447       if (rmtx != 0U) {
000022  b13f              CBZ      r7,|L51.52|
;;;1448         #if (configUSE_RECURSIVE_MUTEXES == 1)
;;;1449         if (xSemaphoreGiveRecursive (hMutex) != pdPASS) {
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       xQueueGiveMutexRecursive
00002a  2801              CMP      r0,#1
00002c  d00c              BEQ      |L51.72|
;;;1450           stat = osErrorResource;
00002e  f06f0602          MVN      r6,#2
000032  e009              B        |L51.72|
                  |L51.52|
;;;1451         }
;;;1452         #endif
;;;1453       }
;;;1454       else {
;;;1455         if (xSemaphoreGive (hMutex) != pdPASS) {
000034  2300              MOVS     r3,#0
000036  461a              MOV      r2,r3
000038  4619              MOV      r1,r3
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       xQueueGenericSend
000040  2801              CMP      r0,#1
000042  d001              BEQ      |L51.72|
;;;1456           stat = osErrorResource;
000044  f06f0602          MVN      r6,#2
                  |L51.72|
;;;1457         }
;;;1458       }
;;;1459     }
;;;1460   
;;;1461     return (stat);
000048  4630              MOV      r0,r6
;;;1462   }
00004a  e8bd81f0          POP      {r4-r8,pc}
;;;1463   
                          ENDP


                          AREA ||i.osSemaphoreAcquire||, CODE, READONLY, ALIGN=2

                  osSemaphoreAcquire PROC
;;;1583   
;;;1584   osStatus_t osSemaphoreAcquire (osSemaphoreId_t semaphore_id, uint32_t timeout) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1585     SemaphoreHandle_t hSemaphore = (SemaphoreHandle_t)semaphore_id;
000006  4626              MOV      r6,r4
;;;1586     osStatus_t stat;
;;;1587     BaseType_t yield;
;;;1588   
;;;1589     stat = osOK;
000008  2700              MOVS     r7,#0
;;;1590   
;;;1591     if (hSemaphore == NULL) {
00000a  b90e              CBNZ     r6,|L52.16|
;;;1592       stat = osErrorParameter;
00000c  1f3f              SUBS     r7,r7,#4
00000e  e029              B        |L52.100|
                  |L52.16|
;;;1593     }
;;;1594     else if (IS_IRQ()) {
000010  f7fffffe          BL       __get_IPSR
000014  b1d0              CBZ      r0,|L52.76|
;;;1595       if (timeout != 0U) {
000016  b115              CBZ      r5,|L52.30|
;;;1596         stat = osErrorParameter;
000018  f06f0703          MVN      r7,#3
00001c  e022              B        |L52.100|
                  |L52.30|
;;;1597       }
;;;1598       else {
;;;1599         yield = pdFALSE;
00001e  2000              MOVS     r0,#0
000020  9000              STR      r0,[sp,#0]
;;;1600   
;;;1601         if (xSemaphoreTakeFromISR (hSemaphore, &yield) != pdPASS) {
000022  466a              MOV      r2,sp
000024  2100              MOVS     r1,#0
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       xQueueReceiveFromISR
00002c  2801              CMP      r0,#1
00002e  d002              BEQ      |L52.54|
;;;1602           stat = osErrorResource;
000030  f06f0702          MVN      r7,#2
000034  e016              B        |L52.100|
                  |L52.54|
;;;1603         } else {
;;;1604           portYIELD_FROM_ISR (yield);
000036  9800              LDR      r0,[sp,#0]
000038  b1a0              CBZ      r0,|L52.100|
00003a  f04f5080          MOV      r0,#0x10000000
00003e  490a              LDR      r1,|L52.104|
000040  6008              STR      r0,[r1,#0]
000042  f3bf8f4f          DSB      
000046  f3bf8f6f          ISB      
00004a  e00b              B        |L52.100|
                  |L52.76|
;;;1605         }
;;;1606       }
;;;1607     }
;;;1608     else {
;;;1609       if (xSemaphoreTake (hSemaphore, (TickType_t)timeout) != pdPASS) {
00004c  4629              MOV      r1,r5
00004e  4630              MOV      r0,r6
000050  f7fffffe          BL       xQueueSemaphoreTake
000054  2801              CMP      r0,#1
000056  d005              BEQ      |L52.100|
;;;1610         if (timeout != 0U) {
000058  b115              CBZ      r5,|L52.96|
;;;1611           stat = osErrorTimeout;
00005a  f06f0701          MVN      r7,#1
00005e  e001              B        |L52.100|
                  |L52.96|
;;;1612         } else {
;;;1613           stat = osErrorResource;
000060  f06f0702          MVN      r7,#2
                  |L52.100|
;;;1614         }
;;;1615       }
;;;1616     }
;;;1617   
;;;1618     return (stat);
000064  4638              MOV      r0,r7
;;;1619   }
000066  bdf8              POP      {r3-r7,pc}
;;;1620   
                          ENDP

                  |L52.104|
                          DCD      0xe000ed04

                          AREA ||i.osSemaphoreDelete||, CODE, READONLY, ALIGN=1

                  osSemaphoreDelete PROC
;;;1664   
;;;1665   osStatus_t osSemaphoreDelete (osSemaphoreId_t semaphore_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;1666     SemaphoreHandle_t hSemaphore = (SemaphoreHandle_t)semaphore_id;
000004  462e              MOV      r6,r5
;;;1667     osStatus_t stat;
;;;1668   
;;;1669   #ifndef USE_FreeRTOS_HEAP_1
;;;1670     if (IS_IRQ()) {
000006  f7fffffe          BL       __get_IPSR
00000a  b110              CBZ      r0,|L53.18|
;;;1671       stat = osErrorISR;
00000c  f06f0405          MVN      r4,#5
000010  e00a              B        |L53.40|
                  |L53.18|
;;;1672     }
;;;1673     else if (hSemaphore == NULL) {
000012  b916              CBNZ     r6,|L53.26|
;;;1674       stat = osErrorParameter;
000014  f06f0403          MVN      r4,#3
000018  e006              B        |L53.40|
                  |L53.26|
;;;1675     }
;;;1676     else {
;;;1677       #if (configQUEUE_REGISTRY_SIZE > 0)
;;;1678       vQueueUnregisterQueue (hSemaphore);
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       vQueueUnregisterQueue
;;;1679       #endif
;;;1680   
;;;1681       stat = osOK;
000020  2400              MOVS     r4,#0
;;;1682       vSemaphoreDelete (hSemaphore);
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       vQueueDelete
                  |L53.40|
;;;1683     }
;;;1684   #else
;;;1685     stat = osError;
;;;1686   #endif
;;;1687   
;;;1688     return (stat);
000028  4620              MOV      r0,r4
;;;1689   }
00002a  bd70              POP      {r4-r6,pc}
;;;1690   
                          ENDP


                          AREA ||i.osSemaphoreGetCount||, CODE, READONLY, ALIGN=1

                  osSemaphoreGetCount PROC
;;;1648   
;;;1649   uint32_t osSemaphoreGetCount (osSemaphoreId_t semaphore_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;1650     SemaphoreHandle_t hSemaphore = (SemaphoreHandle_t)semaphore_id;
000004  462e              MOV      r6,r5
;;;1651     uint32_t count;
;;;1652   
;;;1653     if (hSemaphore == NULL) {
000006  b90e              CBNZ     r6,|L54.12|
;;;1654       count = 0U;
000008  2400              MOVS     r4,#0
00000a  e00b              B        |L54.36|
                  |L54.12|
;;;1655     }
;;;1656     else if (IS_IRQ()) {
00000c  f7fffffe          BL       __get_IPSR
000010  b120              CBZ      r0,|L54.28|
;;;1657       count = uxQueueMessagesWaitingFromISR (hSemaphore);
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       uxQueueMessagesWaitingFromISR
000018  4604              MOV      r4,r0
00001a  e003              B        |L54.36|
                  |L54.28|
;;;1658     } else {
;;;1659       count = (uint32_t)uxSemaphoreGetCount (hSemaphore);
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       uxQueueMessagesWaiting
000022  4604              MOV      r4,r0
                  |L54.36|
;;;1660     }
;;;1661   
;;;1662     return (count);
000024  4620              MOV      r0,r4
;;;1663   }
000026  bd70              POP      {r4-r6,pc}
;;;1664   
                          ENDP


                          AREA ||i.osSemaphoreNew||, CODE, READONLY, ALIGN=1

                  osSemaphoreNew PROC
;;;1508   
;;;1509   osSemaphoreId_t osSemaphoreNew (uint32_t max_count, uint32_t initial_count, const osSemaphoreAttr_t *attr) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;1510     SemaphoreHandle_t hSemaphore;
;;;1511     int32_t mem;
;;;1512     #if (configQUEUE_REGISTRY_SIZE > 0)
;;;1513     const char *name;
;;;1514     #endif
;;;1515   
;;;1516     hSemaphore = NULL;
00000a  f04f0800          MOV      r8,#0
;;;1517   
;;;1518     if (!IS_IRQ() && (max_count > 0U) && (initial_count <= max_count)) {
00000e  f7fffffe          BL       __get_IPSR
000012  2800              CMP      r0,#0
000014  d157              BNE      |L55.198|
000016  2d00              CMP      r5,#0
000018  d055              BEQ      |L55.198|
00001a  42af              CMP      r7,r5
00001c  d853              BHI      |L55.198|
;;;1519       mem = -1;
00001e  1e46              SUBS     r6,r0,#1
;;;1520   
;;;1521       if (attr != NULL) {
000020  b164              CBZ      r4,|L55.60|
;;;1522         if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticSemaphore_t))) {
000022  68a0              LDR      r0,[r4,#8]
000024  b120              CBZ      r0,|L55.48|
000026  68e0              LDR      r0,[r4,#0xc]
000028  2850              CMP      r0,#0x50
00002a  d301              BCC      |L55.48|
;;;1523           mem = 1;
00002c  2601              MOVS     r6,#1
00002e  e006              B        |L55.62|
                  |L55.48|
;;;1524         }
;;;1525         else {
;;;1526           if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
000030  68a0              LDR      r0,[r4,#8]
000032  b920              CBNZ     r0,|L55.62|
000034  68e0              LDR      r0,[r4,#0xc]
000036  b910              CBNZ     r0,|L55.62|
;;;1527             mem = 0;
000038  2600              MOVS     r6,#0
00003a  e000              B        |L55.62|
                  |L55.60|
;;;1528           }
;;;1529         }
;;;1530       }
;;;1531       else {
;;;1532         mem = 0;
00003c  2600              MOVS     r6,#0
                  |L55.62|
;;;1533       }
;;;1534   
;;;1535       if (mem != -1) {
00003e  1c70              ADDS     r0,r6,#1
000040  2800              CMP      r0,#0
000042  d040              BEQ      |L55.198|
;;;1536         if (max_count == 1U) {
000044  2d01              CMP      r5,#1
000046  d123              BNE      |L55.144|
;;;1537           if (mem == 1) {
000048  2e01              CMP      r6,#1
00004a  d109              BNE      |L55.96|
;;;1538             #if (configSUPPORT_STATIC_ALLOCATION == 1)
;;;1539               hSemaphore = xSemaphoreCreateBinaryStatic ((StaticSemaphore_t *)attr->cb_mem);
00004c  2003              MOVS     r0,#3
00004e  9000              STR      r0,[sp,#0]
000050  2200              MOVS     r2,#0
000052  4611              MOV      r1,r2
000054  2001              MOVS     r0,#1
000056  68a3              LDR      r3,[r4,#8]
000058  f7fffffe          BL       xQueueGenericCreateStatic
00005c  4680              MOV      r8,r0
00005e  e005              B        |L55.108|
                  |L55.96|
;;;1540             #endif
;;;1541           }
;;;1542           else {
;;;1543             #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
;;;1544               hSemaphore = xSemaphoreCreateBinary();
000060  2203              MOVS     r2,#3
000062  2100              MOVS     r1,#0
000064  2001              MOVS     r0,#1
000066  f7fffffe          BL       xQueueGenericCreate
00006a  4680              MOV      r8,r0
                  |L55.108|
;;;1545             #endif
;;;1546           }
;;;1547   
;;;1548           if ((hSemaphore != NULL) && (initial_count != 0U)) {
00006c  f1b80f00          CMP      r8,#0
000070  d01c              BEQ      |L55.172|
000072  b1df              CBZ      r7,|L55.172|
;;;1549             if (xSemaphoreGive (hSemaphore) != pdPASS) {
000074  2300              MOVS     r3,#0
000076  461a              MOV      r2,r3
000078  4619              MOV      r1,r3
00007a  4640              MOV      r0,r8
00007c  f7fffffe          BL       xQueueGenericSend
000080  2801              CMP      r0,#1
000082  d013              BEQ      |L55.172|
;;;1550               vSemaphoreDelete (hSemaphore);
000084  4640              MOV      r0,r8
000086  f7fffffe          BL       vQueueDelete
;;;1551               hSemaphore = NULL;
00008a  f04f0800          MOV      r8,#0
00008e  e00d              B        |L55.172|
                  |L55.144|
;;;1552             }
;;;1553           }
;;;1554         }
;;;1555         else {
;;;1556           if (mem == 1) {
000090  2e01              CMP      r6,#1
000092  d106              BNE      |L55.162|
;;;1557             #if (configSUPPORT_STATIC_ALLOCATION == 1)
;;;1558               hSemaphore = xSemaphoreCreateCountingStatic (max_count, initial_count, (StaticSemaphore_t *)attr->cb_mem);
000094  4639              MOV      r1,r7
000096  4628              MOV      r0,r5
000098  68a2              LDR      r2,[r4,#8]
00009a  f7fffffe          BL       xQueueCreateCountingSemaphoreStatic
00009e  4680              MOV      r8,r0
0000a0  e004              B        |L55.172|
                  |L55.162|
;;;1559             #endif
;;;1560           }
;;;1561           else {
;;;1562             #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
;;;1563               hSemaphore = xSemaphoreCreateCounting (max_count, initial_count);
0000a2  4639              MOV      r1,r7
0000a4  4628              MOV      r0,r5
0000a6  f7fffffe          BL       xQueueCreateCountingSemaphore
0000aa  4680              MOV      r8,r0
                  |L55.172|
;;;1564             #endif
;;;1565           }
;;;1566         }
;;;1567         
;;;1568         #if (configQUEUE_REGISTRY_SIZE > 0)
;;;1569         if (hSemaphore != NULL) {
0000ac  f1b80f00          CMP      r8,#0
0000b0  d009              BEQ      |L55.198|
;;;1570           if (attr != NULL) {
0000b2  b114              CBZ      r4,|L55.186|
;;;1571             name = attr->name;
0000b4  f8d49000          LDR      r9,[r4,#0]
0000b8  e001              B        |L55.190|
                  |L55.186|
;;;1572           } else {
;;;1573             name = NULL;
0000ba  f04f0900          MOV      r9,#0
                  |L55.190|
;;;1574           }
;;;1575           vQueueAddToRegistry (hSemaphore, name);
0000be  4649              MOV      r1,r9
0000c0  4640              MOV      r0,r8
0000c2  f7fffffe          BL       vQueueAddToRegistry
                  |L55.198|
;;;1576         }
;;;1577         #endif
;;;1578       }
;;;1579     }
;;;1580   
;;;1581     return ((osSemaphoreId_t)hSemaphore);
0000c6  4640              MOV      r0,r8
;;;1582   }
0000c8  e8bd83f8          POP      {r3-r9,pc}
;;;1583   
                          ENDP


                          AREA ||i.osSemaphoreRelease||, CODE, READONLY, ALIGN=2

                  osSemaphoreRelease PROC
;;;1620   
;;;1621   osStatus_t osSemaphoreRelease (osSemaphoreId_t semaphore_id) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4604              MOV      r4,r0
;;;1622     SemaphoreHandle_t hSemaphore = (SemaphoreHandle_t)semaphore_id;
000004  4625              MOV      r5,r4
;;;1623     osStatus_t stat;
;;;1624     BaseType_t yield;
;;;1625   
;;;1626     stat = osOK;
000006  2600              MOVS     r6,#0
;;;1627   
;;;1628     if (hSemaphore == NULL) {
000008  b90d              CBNZ     r5,|L56.14|
;;;1629       stat = osErrorParameter;
00000a  1f36              SUBS     r6,r6,#4
00000c  e022              B        |L56.84|
                  |L56.14|
;;;1630     }
;;;1631     else if (IS_IRQ()) {
00000e  f7fffffe          BL       __get_IPSR
000012  b1a8              CBZ      r0,|L56.64|
;;;1632       yield = pdFALSE;
000014  2000              MOVS     r0,#0
000016  9000              STR      r0,[sp,#0]
;;;1633   
;;;1634       if (xSemaphoreGiveFromISR (hSemaphore, &yield) != pdTRUE) {
000018  4669              MOV      r1,sp
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       xQueueGiveFromISR
000020  2801              CMP      r0,#1
000022  d002              BEQ      |L56.42|
;;;1635         stat = osErrorResource;
000024  f06f0602          MVN      r6,#2
000028  e014              B        |L56.84|
                  |L56.42|
;;;1636       } else {
;;;1637         portYIELD_FROM_ISR (yield);
00002a  9800              LDR      r0,[sp,#0]
00002c  b190              CBZ      r0,|L56.84|
00002e  f04f5080          MOV      r0,#0x10000000
000032  4909              LDR      r1,|L56.88|
000034  6008              STR      r0,[r1,#0]
000036  f3bf8f4f          DSB      
00003a  f3bf8f6f          ISB      
00003e  e009              B        |L56.84|
                  |L56.64|
;;;1638       }
;;;1639     }
;;;1640     else {
;;;1641       if (xSemaphoreGive (hSemaphore) != pdPASS) {
000040  2300              MOVS     r3,#0
000042  461a              MOV      r2,r3
000044  4619              MOV      r1,r3
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       xQueueGenericSend
00004c  2801              CMP      r0,#1
00004e  d001              BEQ      |L56.84|
;;;1642         stat = osErrorResource;
000050  f06f0602          MVN      r6,#2
                  |L56.84|
;;;1643       }
;;;1644     }
;;;1645   
;;;1646     return (stat);
000054  4630              MOV      r0,r6
;;;1647   }
000056  bdf8              POP      {r3-r7,pc}
;;;1648   
                          ENDP

                  |L56.88|
                          DCD      0xe000ed04

                          AREA ||i.osThreadEnumerate||, CODE, READONLY, ALIGN=1

                  osThreadEnumerate PROC
;;;698    #if (configUSE_OS2_THREAD_ENUMERATE == 1)
;;;699    uint32_t osThreadEnumerate (osThreadId_t *thread_array, uint32_t array_items) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
;;;700      uint32_t i, count;
;;;701      TaskStatus_t *task;
;;;702    
;;;703      if (IS_IRQ() || (thread_array == NULL) || (array_items == 0U)) {
000008  f7fffffe          BL       __get_IPSR
00000c  b918              CBNZ     r0,|L57.22|
00000e  b117              CBZ      r7,|L57.22|
000010  f1b80f00          CMP      r8,#0
000014  d101              BNE      |L57.26|
                  |L57.22|
;;;704        count = 0U;
000016  2500              MOVS     r5,#0
000018  e024              B        |L57.100|
                  |L57.26|
;;;705      } else {
;;;706        vTaskSuspendAll();
00001a  f7fffffe          BL       vTaskSuspendAll
;;;707    
;;;708        count = uxTaskGetNumberOfTasks();
00001e  f7fffffe          BL       uxTaskGetNumberOfTasks
000022  4605              MOV      r5,r0
;;;709        task  = pvPortMalloc (count * sizeof(TaskStatus_t));
000024  eb0501c5          ADD      r1,r5,r5,LSL #3
000028  0088              LSLS     r0,r1,#2
00002a  f7fffffe          BL       pvPortMalloc
00002e  4606              MOV      r6,r0
;;;710    
;;;711        if (task != NULL) {
000030  b19e              CBZ      r6,|L57.90|
;;;712          count = uxTaskGetSystemState (task, count, NULL);
000032  2200              MOVS     r2,#0
000034  4629              MOV      r1,r5
000036  4630              MOV      r0,r6
000038  f7fffffe          BL       uxTaskGetSystemState
00003c  4605              MOV      r5,r0
;;;713    
;;;714          for (i = 0U; (i < count) && (i < array_items); i++) {
00003e  2400              MOVS     r4,#0
000040  e006              B        |L57.80|
                  |L57.66|
;;;715            thread_array[i] = (osThreadId_t)task[i].xHandle;
000042  eb0400c4          ADD      r0,r4,r4,LSL #3
000046  f8560020          LDR      r0,[r6,r0,LSL #2]
00004a  f8470024          STR      r0,[r7,r4,LSL #2]
00004e  1c64              ADDS     r4,r4,#1              ;714
                  |L57.80|
000050  42ac              CMP      r4,r5                 ;714
000052  d201              BCS      |L57.88|
000054  4544              CMP      r4,r8                 ;714
000056  d3f4              BCC      |L57.66|
                  |L57.88|
;;;716          }
;;;717          count = i;
000058  4625              MOV      r5,r4
                  |L57.90|
;;;718        }
;;;719        (void)xTaskResumeAll();
00005a  f7fffffe          BL       xTaskResumeAll
;;;720    
;;;721        vPortFree (task);
00005e  4630              MOV      r0,r6
000060  f7fffffe          BL       vPortFree
                  |L57.100|
;;;722      }
;;;723    
;;;724      return (count);
000064  4628              MOV      r0,r5
;;;725    }
000066  e8bd81f0          POP      {r4-r8,pc}
;;;726    #endif /* (configUSE_OS2_THREAD_ENUMERATE == 1) */
                          ENDP


                          AREA ||i.osThreadExit||, CODE, READONLY, ALIGN=1

                  osThreadExit PROC
;;;649    
;;;650    __NO_RETURN void osThreadExit (void) {
000000  2000              MOVS     r0,#0
;;;651    #ifndef USE_FreeRTOS_HEAP_1
;;;652      vTaskDelete (NULL);
000002  f7fffffe          BL       vTaskDelete
;;;653    #endif
;;;654      for (;;);
000006  bf00              NOP      
                  |L58.8|
000008  e7fe              B        |L58.8|
;;;655    }
;;;656    
                          ENDP


                          AREA ||i.osThreadFlagsClear||, CODE, READONLY, ALIGN=1

                  osThreadFlagsClear PROC
;;;756    
;;;757    uint32_t osThreadFlagsClear (uint32_t flags) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4605              MOV      r5,r0
;;;758      TaskHandle_t hTask;
;;;759      uint32_t rflags, cflags;
;;;760    
;;;761      if (IS_IRQ()) {
000004  f7fffffe          BL       __get_IPSR
000008  b110              CBZ      r0,|L59.16|
;;;762        rflags = (uint32_t)osErrorISR;
00000a  f06f0405          MVN      r4,#5
00000e  e021              B        |L59.84|
                  |L59.16|
;;;763      }
;;;764      else if ((flags & THREAD_FLAGS_INVALID_BITS) != 0U) {
000010  f0054000          AND      r0,r5,#0x80000000
000014  b110              CBZ      r0,|L59.28|
;;;765        rflags = (uint32_t)osErrorParameter;
000016  f06f0403          MVN      r4,#3
00001a  e01b              B        |L59.84|
                  |L59.28|
;;;766      }
;;;767      else {
;;;768        hTask = xTaskGetCurrentTaskHandle();
00001c  f7fffffe          BL       xTaskGetCurrentTaskHandle
000020  4606              MOV      r6,r0
;;;769    
;;;770        if (xTaskNotifyAndQuery (hTask, 0, eNoAction, &cflags) == pdPASS) {
000022  466b              MOV      r3,sp
000024  2200              MOVS     r2,#0
000026  4611              MOV      r1,r2
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       xTaskGenericNotify
00002e  2801              CMP      r0,#1
000030  d10e              BNE      |L59.80|
;;;771          rflags = cflags;
000032  9c00              LDR      r4,[sp,#0]
;;;772          cflags &= ~flags;
000034  9800              LDR      r0,[sp,#0]
000036  43a8              BICS     r0,r0,r5
000038  9000              STR      r0,[sp,#0]
;;;773    
;;;774          if (xTaskNotify (hTask, cflags, eSetValueWithOverwrite) != pdPASS) {
00003a  2300              MOVS     r3,#0
00003c  2203              MOVS     r2,#3
00003e  4630              MOV      r0,r6
000040  9900              LDR      r1,[sp,#0]
000042  f7fffffe          BL       xTaskGenericNotify
000046  2801              CMP      r0,#1
000048  d004              BEQ      |L59.84|
;;;775            rflags = (uint32_t)osError;
00004a  f04f34ff          MOV      r4,#0xffffffff
00004e  e001              B        |L59.84|
                  |L59.80|
;;;776          }
;;;777        }
;;;778        else {
;;;779          rflags = (uint32_t)osError;
000050  f04f34ff          MOV      r4,#0xffffffff
                  |L59.84|
;;;780        }
;;;781      }
;;;782    
;;;783      /* Return flags before clearing */
;;;784      return (rflags);
000054  4620              MOV      r0,r4
;;;785    }
000056  bdf8              POP      {r3-r7,pc}
;;;786    
                          ENDP


                          AREA ||i.osThreadFlagsGet||, CODE, READONLY, ALIGN=1

                  osThreadFlagsGet PROC
;;;786    
;;;787    uint32_t osThreadFlagsGet (void) {
000000  b538              PUSH     {r3-r5,lr}
;;;788      TaskHandle_t hTask;
;;;789      uint32_t rflags;
;;;790    
;;;791      if (IS_IRQ()) {
000002  f7fffffe          BL       __get_IPSR
000006  b118              CBZ      r0,|L60.16|
;;;792        rflags = (uint32_t)osErrorISR;
000008  f06f0005          MVN      r0,#5
00000c  9000              STR      r0,[sp,#0]
00000e  e00d              B        |L60.44|
                  |L60.16|
;;;793      }
;;;794      else {
;;;795        hTask = xTaskGetCurrentTaskHandle();
000010  f7fffffe          BL       xTaskGetCurrentTaskHandle
000014  4604              MOV      r4,r0
;;;796    
;;;797        if (xTaskNotifyAndQuery (hTask, 0, eNoAction, &rflags) != pdPASS) {
000016  466b              MOV      r3,sp
000018  2200              MOVS     r2,#0
00001a  4611              MOV      r1,r2
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       xTaskGenericNotify
000022  2801              CMP      r0,#1
000024  d002              BEQ      |L60.44|
;;;798          rflags = (uint32_t)osError;
000026  f04f30ff          MOV      r0,#0xffffffff
00002a  9000              STR      r0,[sp,#0]
                  |L60.44|
;;;799        }
;;;800      }
;;;801    
;;;802      return (rflags);
00002c  9800              LDR      r0,[sp,#0]
;;;803    }
00002e  bd38              POP      {r3-r5,pc}
;;;804    
                          ENDP


                          AREA ||i.osThreadFlagsSet||, CODE, READONLY, ALIGN=2

                  osThreadFlagsSet PROC
;;;728    #if (configUSE_OS2_THREAD_FLAGS == 1)
;;;729    uint32_t osThreadFlagsSet (osThreadId_t thread_id, uint32_t flags) {
000000  b5fe              PUSH     {r1-r7,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;730      TaskHandle_t hTask = (TaskHandle_t)thread_id;
000006  4626              MOV      r6,r4
;;;731      uint32_t rflags;
;;;732      BaseType_t yield;
;;;733    
;;;734      if ((hTask == NULL) || ((flags & THREAD_FLAGS_INVALID_BITS) != 0U)) {
000008  b116              CBZ      r6,|L61.16|
00000a  f0054000          AND      r0,r5,#0x80000000
00000e  b118              CBZ      r0,|L61.24|
                  |L61.16|
;;;735        rflags = (uint32_t)osErrorParameter;
000010  f06f0003          MVN      r0,#3
000014  9002              STR      r0,[sp,#8]
000016  e02e              B        |L61.118|
                  |L61.24|
;;;736      }
;;;737      else {
;;;738        rflags = (uint32_t)osError;
000018  f04f30ff          MOV      r0,#0xffffffff
00001c  9002              STR      r0,[sp,#8]
;;;739    
;;;740        if (IS_IRQ()) {
00001e  f7fffffe          BL       __get_IPSR
000022  b1e0              CBZ      r0,|L61.94|
;;;741          yield = pdFALSE;
000024  2000              MOVS     r0,#0
000026  9001              STR      r0,[sp,#4]
;;;742    
;;;743          (void)xTaskNotifyFromISR (hTask, flags, eSetBits, &yield);
000028  a801              ADD      r0,sp,#4
00002a  2300              MOVS     r3,#0
00002c  2201              MOVS     r2,#1
00002e  4629              MOV      r1,r5
000030  9000              STR      r0,[sp,#0]
000032  4630              MOV      r0,r6
000034  f7fffffe          BL       xTaskGenericNotifyFromISR
;;;744          (void)xTaskNotifyAndQueryFromISR (hTask, 0, eNoAction, &rflags, NULL);
000038  2000              MOVS     r0,#0
00003a  ab02              ADD      r3,sp,#8
00003c  4602              MOV      r2,r0
00003e  4601              MOV      r1,r0
000040  9000              STR      r0,[sp,#0]
000042  4630              MOV      r0,r6
000044  f7fffffe          BL       xTaskGenericNotifyFromISR
;;;745    
;;;746          portYIELD_FROM_ISR (yield);
000048  9801              LDR      r0,[sp,#4]
00004a  b1a0              CBZ      r0,|L61.118|
00004c  f04f5080          MOV      r0,#0x10000000
000050  490a              LDR      r1,|L61.124|
000052  6008              STR      r0,[r1,#0]
000054  f3bf8f4f          DSB      
000058  f3bf8f6f          ISB      
00005c  e00b              B        |L61.118|
                  |L61.94|
;;;747        }
;;;748        else {
;;;749          (void)xTaskNotify (hTask, flags, eSetBits);
00005e  2300              MOVS     r3,#0
000060  2201              MOVS     r2,#1
000062  4629              MOV      r1,r5
000064  4630              MOV      r0,r6
000066  f7fffffe          BL       xTaskGenericNotify
;;;750          (void)xTaskNotifyAndQuery (hTask, 0, eNoAction, &rflags);
00006a  ab02              ADD      r3,sp,#8
00006c  2200              MOVS     r2,#0
00006e  4611              MOV      r1,r2
000070  4630              MOV      r0,r6
000072  f7fffffe          BL       xTaskGenericNotify
                  |L61.118|
;;;751        }
;;;752      }
;;;753      /* Return flags after setting */
;;;754      return (rflags);
000076  9802              LDR      r0,[sp,#8]
;;;755    }
000078  bdfe              POP      {r1-r7,pc}
;;;756    
                          ENDP

00007a  0000              DCW      0x0000
                  |L61.124|
                          DCD      0xe000ed04

                          AREA ||i.osThreadFlagsWait||, CODE, READONLY, ALIGN=1

                  osThreadFlagsWait PROC
;;;804    
;;;805    uint32_t osThreadFlagsWait (uint32_t flags, uint32_t options, uint32_t timeout) {
000000  e92d5ffc          PUSH     {r2-r12,lr}
000004  4605              MOV      r5,r0
000006  4689              MOV      r9,r1
000008  4616              MOV      r6,r2
;;;806      uint32_t rflags, nval;
;;;807      uint32_t clear;
;;;808      TickType_t t0, td, tout;
;;;809      BaseType_t rval;
;;;810    
;;;811      if (IS_IRQ()) {
00000a  f7fffffe          BL       __get_IPSR
00000e  b110              CBZ      r0,|L62.22|
;;;812        rflags = (uint32_t)osErrorISR;
000010  f06f0405          MVN      r4,#5
000014  e04a              B        |L62.172|
                  |L62.22|
;;;813      }
;;;814      else if ((flags & THREAD_FLAGS_INVALID_BITS) != 0U) {
000016  f0054000          AND      r0,r5,#0x80000000
00001a  b110              CBZ      r0,|L62.34|
;;;815        rflags = (uint32_t)osErrorParameter;
00001c  f06f0403          MVN      r4,#3
000020  e044              B        |L62.172|
                  |L62.34|
;;;816      }
;;;817      else {
;;;818        if ((options & osFlagsNoClear) == osFlagsNoClear) {
000022  f0090002          AND      r0,r9,#2
000026  2802              CMP      r0,#2
000028  d102              BNE      |L62.48|
;;;819          clear = 0U;
00002a  f04f0a00          MOV      r10,#0
00002e  e000              B        |L62.50|
                  |L62.48|
;;;820        } else {
;;;821          clear = flags;
000030  46aa              MOV      r10,r5
                  |L62.50|
;;;822        }
;;;823    
;;;824        rflags = 0U;
000032  2400              MOVS     r4,#0
;;;825        tout   = timeout;
000034  4637              MOV      r7,r6
;;;826    
;;;827        t0 = xTaskGetTickCount();
000036  f7fffffe          BL       xTaskGetTickCount
00003a  9000              STR      r0,[sp,#0]
;;;828        do {
00003c  bf00              NOP      
                  |L62.62|
;;;829          rval = xTaskNotifyWait (0, clear, &nval, tout);
00003e  463b              MOV      r3,r7
000040  aa01              ADD      r2,sp,#4
000042  4651              MOV      r1,r10
000044  2000              MOVS     r0,#0
000046  f7fffffe          BL       xTaskNotifyWait
00004a  4680              MOV      r8,r0
;;;830    
;;;831          if (rval == pdPASS) {
00004c  f1b80f01          CMP      r8,#1
000050  d122              BNE      |L62.152|
;;;832            rflags &= flags;
000052  402c              ANDS     r4,r4,r5
;;;833            rflags |= nval;
000054  9801              LDR      r0,[sp,#4]
000056  4304              ORRS     r4,r4,r0
;;;834    
;;;835            if ((options & osFlagsWaitAll) == osFlagsWaitAll) {
000058  f0090001          AND      r0,r9,#1
00005c  b140              CBZ      r0,|L62.112|
;;;836              if ((flags & rflags) == flags) {
00005e  ea050004          AND      r0,r5,r4
000062  42a8              CMP      r0,r5
000064  d100              BNE      |L62.104|
;;;837                break;
000066  e020              B        |L62.170|
                  |L62.104|
;;;838              } else {
;;;839                if (timeout == 0U) {
000068  b956              CBNZ     r6,|L62.128|
;;;840                  rflags = (uint32_t)osErrorResource;
00006a  f06f0402          MVN      r4,#2
;;;841                  break;
00006e  e01c              B        |L62.170|
                  |L62.112|
;;;842                }
;;;843              }
;;;844            }
;;;845            else {
;;;846              if ((flags & rflags) != 0) {
000070  ea050004          AND      r0,r5,r4
000074  b100              CBZ      r0,|L62.120|
;;;847                break;
000076  e018              B        |L62.170|
                  |L62.120|
;;;848              } else {
;;;849                if (timeout == 0U) {
000078  b916              CBNZ     r6,|L62.128|
;;;850                  rflags = (uint32_t)osErrorResource;
00007a  f06f0402          MVN      r4,#2
;;;851                  break;
00007e  e014              B        |L62.170|
                  |L62.128|
;;;852                }
;;;853              }
;;;854            }
;;;855    
;;;856            /* Update timeout */
;;;857            td = xTaskGetTickCount() - t0;
000080  f7fffffe          BL       xTaskGetTickCount
000084  9900              LDR      r1,[sp,#0]
000086  eba00b01          SUB      r11,r0,r1
;;;858    
;;;859            if (td > tout) {
00008a  45bb              CMP      r11,r7
00008c  d901              BLS      |L62.146|
;;;860              tout  = 0;
00008e  2700              MOVS     r7,#0
000090  e008              B        |L62.164|
                  |L62.146|
;;;861            } else {
;;;862              tout -= td;
000092  eba7070b          SUB      r7,r7,r11
000096  e005              B        |L62.164|
                  |L62.152|
;;;863            }
;;;864          }
;;;865          else {
;;;866            if (timeout == 0) {
000098  b916              CBNZ     r6,|L62.160|
;;;867              rflags = (uint32_t)osErrorResource;
00009a  f06f0402          MVN      r4,#2
00009e  e001              B        |L62.164|
                  |L62.160|
;;;868            } else {
;;;869              rflags = (uint32_t)osErrorTimeout;
0000a0  f06f0401          MVN      r4,#1
                  |L62.164|
;;;870            }
;;;871          }
;;;872        }
;;;873        while (rval != pdFAIL);
0000a4  f1b80f00          CMP      r8,#0
0000a8  d1c9              BNE      |L62.62|
                  |L62.170|
0000aa  bf00              NOP                            ;837
                  |L62.172|
;;;874      }
;;;875    
;;;876      /* Return flags before clearing */
;;;877      return (rflags);
0000ac  4620              MOV      r0,r4
;;;878    }
0000ae  e8bd9ffc          POP      {r2-r12,pc}
;;;879    #endif /* (configUSE_OS2_THREAD_FLAGS == 1) */
                          ENDP


                          AREA ||i.osThreadGetCount||, CODE, READONLY, ALIGN=1

                  osThreadGetCount PROC
;;;685    
;;;686    uint32_t osThreadGetCount (void) {
000000  b510              PUSH     {r4,lr}
;;;687      uint32_t count;
;;;688    
;;;689      if (IS_IRQ()) {
000002  f7fffffe          BL       __get_IPSR
000006  b108              CBZ      r0,|L63.12|
;;;690        count = 0U;
000008  2400              MOVS     r4,#0
00000a  e002              B        |L63.18|
                  |L63.12|
;;;691      } else {
;;;692        count = uxTaskGetNumberOfTasks();
00000c  f7fffffe          BL       uxTaskGetNumberOfTasks
000010  4604              MOV      r4,r0
                  |L63.18|
;;;693      }
;;;694    
;;;695      return (count);
000012  4620              MOV      r0,r4
;;;696    }
000014  bd10              POP      {r4,pc}
;;;697    
                          ENDP


                          AREA ||i.osThreadGetId||, CODE, READONLY, ALIGN=1

                  osThreadGetId PROC
;;;524    
;;;525    osThreadId_t osThreadGetId (void) {
000000  b510              PUSH     {r4,lr}
;;;526      osThreadId_t id;
;;;527    
;;;528      id = (osThreadId_t)xTaskGetCurrentTaskHandle();
000002  f7fffffe          BL       xTaskGetCurrentTaskHandle
000006  4604              MOV      r4,r0
;;;529    
;;;530      return (id);
000008  4620              MOV      r0,r4
;;;531    }
00000a  bd10              POP      {r4,pc}
;;;532    
                          ENDP


                          AREA ||i.osThreadGetName||, CODE, READONLY, ALIGN=1

                  osThreadGetName PROC
;;;511    
;;;512    const char *osThreadGetName (osThreadId_t thread_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;513      TaskHandle_t hTask = (TaskHandle_t)thread_id;
000004  462e              MOV      r6,r5
;;;514      const char *name;
;;;515    
;;;516      if (IS_IRQ() || (hTask == NULL)) {
000006  f7fffffe          BL       __get_IPSR
00000a  b900              CBNZ     r0,|L65.14|
00000c  b90e              CBNZ     r6,|L65.18|
                  |L65.14|
;;;517        name = NULL;
00000e  2400              MOVS     r4,#0
000010  e003              B        |L65.26|
                  |L65.18|
;;;518      } else {
;;;519        name = pcTaskGetName (hTask);
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       pcTaskGetName
000018  4604              MOV      r4,r0
                  |L65.26|
;;;520      }
;;;521    
;;;522      return (name);
00001a  4620              MOV      r0,r4
;;;523    }
00001c  bd70              POP      {r4-r6,pc}
;;;524    
                          ENDP


                          AREA ||i.osThreadGetPriority||, CODE, READONLY, ALIGN=1

                  osThreadGetPriority PROC
;;;585    
;;;586    osPriority_t osThreadGetPriority (osThreadId_t thread_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;587      TaskHandle_t hTask = (TaskHandle_t)thread_id;
000004  462e              MOV      r6,r5
;;;588      osPriority_t prio;
;;;589    
;;;590      if (IS_IRQ() || (hTask == NULL)) {
000006  f7fffffe          BL       __get_IPSR
00000a  b900              CBNZ     r0,|L66.14|
00000c  b916              CBNZ     r6,|L66.20|
                  |L66.14|
;;;591        prio = osPriorityError;
00000e  f04f34ff          MOV      r4,#0xffffffff
000012  e003              B        |L66.28|
                  |L66.20|
;;;592      } else {
;;;593        prio = (osPriority_t)((int32_t)uxTaskPriorityGet (hTask));
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       uxTaskPriorityGet
00001a  4604              MOV      r4,r0
                  |L66.28|
;;;594      }
;;;595    
;;;596      return (prio);
00001c  4620              MOV      r0,r4
;;;597    }
00001e  bd70              POP      {r4-r6,pc}
;;;598    
                          ENDP


                          AREA ||i.osThreadGetStackSpace||, CODE, READONLY, ALIGN=1

                  osThreadGetStackSpace PROC
;;;554    
;;;555    uint32_t osThreadGetStackSpace (osThreadId_t thread_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;556      TaskHandle_t hTask = (TaskHandle_t)thread_id;
000004  462e              MOV      r6,r5
;;;557      uint32_t sz;
;;;558    
;;;559      if (IS_IRQ() || (hTask == NULL)) {
000006  f7fffffe          BL       __get_IPSR
00000a  b900              CBNZ     r0,|L67.14|
00000c  b90e              CBNZ     r6,|L67.18|
                  |L67.14|
;;;560        sz = 0U;
00000e  2400              MOVS     r4,#0
000010  e003              B        |L67.26|
                  |L67.18|
;;;561      } else {
;;;562        sz = (uint32_t)(uxTaskGetStackHighWaterMark(hTask) * sizeof(StackType_t));
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       uxTaskGetStackHighWaterMark
000018  0084              LSLS     r4,r0,#2
                  |L67.26|
;;;563      }
;;;564    
;;;565      return (sz);
00001a  4620              MOV      r0,r4
;;;566    }
00001c  bd70              POP      {r4-r6,pc}
;;;567    
                          ENDP


                          AREA ||i.osThreadGetState||, CODE, READONLY, ALIGN=1

                  osThreadGetState PROC
;;;532    
;;;533    osThreadState_t osThreadGetState (osThreadId_t thread_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;534      TaskHandle_t hTask = (TaskHandle_t)thread_id;
000004  462e              MOV      r6,r5
;;;535      osThreadState_t state;
;;;536    
;;;537      if (IS_IRQ() || (hTask == NULL)) {
000006  f7fffffe          BL       __get_IPSR
00000a  b900              CBNZ     r0,|L68.14|
00000c  b916              CBNZ     r6,|L68.20|
                  |L68.14|
;;;538        state = osThreadError;
00000e  f04f34ff          MOV      r4,#0xffffffff
000012  e017              B        |L68.68|
                  |L68.20|
;;;539      }
;;;540      else {
;;;541        switch (eTaskGetState (hTask)) {
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       eTaskGetState
00001a  2806              CMP      r0,#6
00001c  d20d              BCS      |L68.58|
00001e  e8dff000          TBB      [pc,r0]
000022  0305              DCB      0x03,0x05
000024  07080a0d          DCB      0x07,0x08,0x0a,0x0d
;;;542          case eRunning:   state = osThreadRunning;    break;
000028  2402              MOVS     r4,#2
00002a  e00a              B        |L68.66|
;;;543          case eReady:     state = osThreadReady;      break;
00002c  2401              MOVS     r4,#1
00002e  e008              B        |L68.66|
;;;544          case eBlocked:
;;;545          case eSuspended: state = osThreadBlocked;    break;
000030  bf00              NOP      
000032  2403              MOVS     r4,#3
000034  e005              B        |L68.66|
;;;546          case eDeleted:   state = osThreadTerminated; break;
000036  2404              MOVS     r4,#4
000038  e003              B        |L68.66|
                  |L68.58|
;;;547          case eInvalid:
00003a  bf00              NOP      
;;;548          default:         state = osThreadError;      break;
00003c  f04f34ff          MOV      r4,#0xffffffff
000040  bf00              NOP      
                  |L68.66|
000042  bf00              NOP                            ;542
                  |L68.68|
;;;549        }
;;;550      }
;;;551    
;;;552      return (state);
000044  4620              MOV      r0,r4
;;;553    }
000046  bd70              POP      {r4-r6,pc}
;;;554    
                          ENDP


                          AREA ||i.osThreadNew||, CODE, READONLY, ALIGN=1

                  osThreadNew PROC
;;;443    
;;;444    osThreadId_t osThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr) {
000000  e92d47ff          PUSH     {r0-r10,lr}
000004  4680              MOV      r8,r0
000006  4689              MOV      r9,r1
000008  4614              MOV      r4,r2
;;;445      const char *name;
;;;446      uint32_t stack;
;;;447      TaskHandle_t hTask;
;;;448      UBaseType_t prio;
;;;449      int32_t mem;
;;;450    
;;;451      hTask = NULL;
00000a  2000              MOVS     r0,#0
00000c  9003              STR      r0,[sp,#0xc]
;;;452    
;;;453      if (!IS_IRQ() && (func != NULL)) {
00000e  f7fffffe          BL       __get_IPSR
000012  2800              CMP      r0,#0
000014  d14e              BNE      |L69.180|
000016  f1b80f00          CMP      r8,#0
00001a  d04b              BEQ      |L69.180|
;;;454        stack = configMINIMAL_STACK_SIZE;
00001c  2680              MOVS     r6,#0x80
;;;455        prio  = (UBaseType_t)osPriorityNormal;
00001e  2518              MOVS     r5,#0x18
;;;456    
;;;457        name = NULL;
000020  4682              MOV      r10,r0
;;;458        mem  = -1;
000022  1e47              SUBS     r7,r0,#1
;;;459    
;;;460        if (attr != NULL) {
000024  b344              CBZ      r4,|L69.120|
;;;461          if (attr->name != NULL) {
000026  6820              LDR      r0,[r4,#0]
000028  b108              CBZ      r0,|L69.46|
;;;462            name = attr->name;
00002a  f8d4a000          LDR      r10,[r4,#0]
                  |L69.46|
;;;463          }
;;;464          if (attr->priority != osPriorityNone) {
00002e  69a0              LDR      r0,[r4,#0x18]
000030  b100              CBZ      r0,|L69.52|
;;;465            prio = (UBaseType_t)attr->priority;
000032  69a5              LDR      r5,[r4,#0x18]
                  |L69.52|
;;;466          }
;;;467    
;;;468          if ((prio < osPriorityIdle) || (prio > osPriorityISR) || ((attr->attr_bits & osThreadJoinable) == osThreadJoinable)) {
000034  b12d              CBZ      r5,|L69.66|
000036  2d38              CMP      r5,#0x38
000038  d803              BHI      |L69.66|
00003a  7920              LDRB     r0,[r4,#4]
00003c  f0000001          AND      r0,r0,#1
000040  b118              CBZ      r0,|L69.74|
                  |L69.66|
;;;469            return (NULL);
000042  2000              MOVS     r0,#0
                  |L69.68|
;;;470          }
;;;471    
;;;472          if (attr->stack_size > 0U) {
;;;473            /* In FreeRTOS stack is not in bytes, but in sizeof(StackType_t) which is 4 on ARM ports.       */
;;;474            /* Stack size should be therefore 4 byte aligned in order to avoid division caused side effects */
;;;475            stack = attr->stack_size / sizeof(StackType_t);
;;;476          }
;;;477    
;;;478          if ((attr->cb_mem    != NULL) && (attr->cb_size    >= sizeof(StaticTask_t)) &&
;;;479              (attr->stack_mem != NULL) && (attr->stack_size >  0U)) {
;;;480            mem = 1;
;;;481          }
;;;482          else {
;;;483            if ((attr->cb_mem == NULL) && (attr->cb_size == 0U) && (attr->stack_mem == NULL)) {
;;;484              mem = 0;
;;;485            }
;;;486          }
;;;487        }
;;;488        else {
;;;489          mem = 0;
;;;490        }
;;;491    
;;;492        if (mem == 1) {
;;;493          #if (configSUPPORT_STATIC_ALLOCATION == 1)
;;;494            hTask = xTaskCreateStatic ((TaskFunction_t)func, name, stack, argument, prio, (StackType_t  *)attr->stack_mem,
;;;495                                                                                          (StaticTask_t *)attr->cb_mem);
;;;496          #endif
;;;497        }
;;;498        else {
;;;499          if (mem == 0) {
;;;500            #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
;;;501              if (xTaskCreate ((TaskFunction_t)func, name, (uint16_t)stack, argument, prio, &hTask) != pdPASS) {
;;;502                hTask = NULL;
;;;503              }
;;;504            #endif
;;;505          }
;;;506        }
;;;507      }
;;;508    
;;;509      return ((osThreadId_t)hTask);
;;;510    }
000044  b004              ADD      sp,sp,#0x10
000046  e8bd87f0          POP      {r4-r10,pc}
                  |L69.74|
00004a  6960              LDR      r0,[r4,#0x14]         ;472
00004c  b108              CBZ      r0,|L69.82|
00004e  6960              LDR      r0,[r4,#0x14]         ;475
000050  0886              LSRS     r6,r0,#2              ;475
                  |L69.82|
000052  68a0              LDR      r0,[r4,#8]            ;478
000054  b140              CBZ      r0,|L69.104|
000056  68e0              LDR      r0,[r4,#0xc]          ;478
000058  285c              CMP      r0,#0x5c              ;478
00005a  d305              BCC      |L69.104|
00005c  6920              LDR      r0,[r4,#0x10]         ;479
00005e  b118              CBZ      r0,|L69.104|
000060  6960              LDR      r0,[r4,#0x14]         ;479
000062  b108              CBZ      r0,|L69.104|
000064  2701              MOVS     r7,#1                 ;480
000066  e008              B        |L69.122|
                  |L69.104|
000068  68a0              LDR      r0,[r4,#8]            ;483
00006a  b930              CBNZ     r0,|L69.122|
00006c  68e0              LDR      r0,[r4,#0xc]          ;483
00006e  b920              CBNZ     r0,|L69.122|
000070  6920              LDR      r0,[r4,#0x10]         ;483
000072  b910              CBNZ     r0,|L69.122|
000074  2700              MOVS     r7,#0                 ;484
000076  e000              B        |L69.122|
                  |L69.120|
000078  2700              MOVS     r7,#0                 ;489
                  |L69.122|
00007a  2f01              CMP      r7,#1                 ;492
00007c  d10c              BNE      |L69.152|
00007e  6921              LDR      r1,[r4,#0x10]         ;494
000080  68a0              LDR      r0,[r4,#8]            ;494
000082  464b              MOV      r3,r9                 ;494
000084  4632              MOV      r2,r6                 ;494
000086  e9cd5100          STRD     r5,r1,[sp,#0]         ;494
00008a  9002              STR      r0,[sp,#8]            ;494
00008c  4651              MOV      r1,r10                ;494
00008e  4640              MOV      r0,r8                 ;494
000090  f7fffffe          BL       xTaskCreateStatic
000094  9003              STR      r0,[sp,#0xc]          ;494
000096  e00d              B        |L69.180|
                  |L69.152|
000098  b967              CBNZ     r7,|L69.180|
00009a  a803              ADD      r0,sp,#0xc            ;501
00009c  b2b2              UXTH     r2,r6                 ;501
00009e  464b              MOV      r3,r9                 ;501
0000a0  4651              MOV      r1,r10                ;501
0000a2  e9cd5000          STRD     r5,r0,[sp,#0]         ;501
0000a6  4640              MOV      r0,r8                 ;501
0000a8  f7fffffe          BL       xTaskCreate
0000ac  2801              CMP      r0,#1                 ;501
0000ae  d001              BEQ      |L69.180|
0000b0  2000              MOVS     r0,#0                 ;502
0000b2  9003              STR      r0,[sp,#0xc]          ;502
                  |L69.180|
0000b4  9803              LDR      r0,[sp,#0xc]          ;509
0000b6  e7c5              B        |L69.68|
;;;511    
                          ENDP


                          AREA ||i.osThreadResume||, CODE, READONLY, ALIGN=1

                  osThreadResume PROC
;;;630    
;;;631    osStatus_t osThreadResume (osThreadId_t thread_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;632      TaskHandle_t hTask = (TaskHandle_t)thread_id;
000004  462e              MOV      r6,r5
;;;633      osStatus_t stat;
;;;634    
;;;635      if (IS_IRQ()) {
000006  f7fffffe          BL       __get_IPSR
00000a  b110              CBZ      r0,|L70.18|
;;;636        stat = osErrorISR;
00000c  f06f0405          MVN      r4,#5
000010  e007              B        |L70.34|
                  |L70.18|
;;;637      }
;;;638      else if (hTask == NULL) {
000012  b916              CBNZ     r6,|L70.26|
;;;639        stat = osErrorParameter;
000014  f06f0403          MVN      r4,#3
000018  e003              B        |L70.34|
                  |L70.26|
;;;640      }
;;;641      else {
;;;642        stat = osOK;
00001a  2400              MOVS     r4,#0
;;;643        vTaskResume (hTask);
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       vTaskResume
                  |L70.34|
;;;644      }
;;;645    
;;;646      return (stat);
000022  4620              MOV      r0,r4
;;;647    }
000024  bd70              POP      {r4-r6,pc}
;;;648    #endif /* (configUSE_OS2_THREAD_SUSPEND_RESUME == 1) */
                          ENDP


                          AREA ||i.osThreadSetPriority||, CODE, READONLY, ALIGN=1

                  osThreadSetPriority PROC
;;;567    
;;;568    osStatus_t osThreadSetPriority (osThreadId_t thread_id, osPriority_t priority) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
;;;569      TaskHandle_t hTask = (TaskHandle_t)thread_id;
000008  463e              MOV      r6,r7
;;;570      osStatus_t stat;
;;;571    
;;;572      if (IS_IRQ()) {
00000a  f7fffffe          BL       __get_IPSR
00000e  b110              CBZ      r0,|L71.22|
;;;573        stat = osErrorISR;
000010  f06f0405          MVN      r4,#5
000014  e00c              B        |L71.48|
                  |L71.22|
;;;574      }
;;;575      else if ((hTask == NULL) || (priority < osPriorityIdle) || (priority > osPriorityISR)) {
000016  b11e              CBZ      r6,|L71.32|
000018  2d01              CMP      r5,#1
00001a  db01              BLT      |L71.32|
00001c  2d38              CMP      r5,#0x38
00001e  dd02              BLE      |L71.38|
                  |L71.32|
;;;576        stat = osErrorParameter;
000020  f06f0403          MVN      r4,#3
000024  e004              B        |L71.48|
                  |L71.38|
;;;577      }
;;;578      else {
;;;579        stat = osOK;
000026  2400              MOVS     r4,#0
;;;580        vTaskPrioritySet (hTask, (UBaseType_t)priority);
000028  4629              MOV      r1,r5
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       vTaskPrioritySet
                  |L71.48|
;;;581      }
;;;582    
;;;583      return (stat);
000030  4620              MOV      r0,r4
;;;584    }
000032  e8bd81f0          POP      {r4-r8,pc}
;;;585    
                          ENDP


                          AREA ||i.osThreadSuspend||, CODE, READONLY, ALIGN=1

                  osThreadSuspend PROC
;;;612    #if (configUSE_OS2_THREAD_SUSPEND_RESUME == 1)
;;;613    osStatus_t osThreadSuspend (osThreadId_t thread_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;614      TaskHandle_t hTask = (TaskHandle_t)thread_id;
000004  462e              MOV      r6,r5
;;;615      osStatus_t stat;
;;;616    
;;;617      if (IS_IRQ()) {
000006  f7fffffe          BL       __get_IPSR
00000a  b110              CBZ      r0,|L72.18|
;;;618        stat = osErrorISR;
00000c  f06f0405          MVN      r4,#5
000010  e007              B        |L72.34|
                  |L72.18|
;;;619      }
;;;620      else if (hTask == NULL) {
000012  b916              CBNZ     r6,|L72.26|
;;;621        stat = osErrorParameter;
000014  f06f0403          MVN      r4,#3
000018  e003              B        |L72.34|
                  |L72.26|
;;;622      }
;;;623      else {
;;;624        stat = osOK;
00001a  2400              MOVS     r4,#0
;;;625        vTaskSuspend (hTask);
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       vTaskSuspend
                  |L72.34|
;;;626      }
;;;627    
;;;628      return (stat);
000022  4620              MOV      r0,r4
;;;629    }
000024  bd70              POP      {r4-r6,pc}
;;;630    
                          ENDP


                          AREA ||i.osThreadTerminate||, CODE, READONLY, ALIGN=1

                  osThreadTerminate PROC
;;;656    
;;;657    osStatus_t osThreadTerminate (osThreadId_t thread_id) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4606              MOV      r6,r0
;;;658      TaskHandle_t hTask = (TaskHandle_t)thread_id;
000006  4637              MOV      r7,r6
;;;659      osStatus_t stat;
;;;660    #ifndef USE_FreeRTOS_HEAP_1
;;;661      eTaskState tstate;
;;;662    
;;;663      if (IS_IRQ()) {
000008  f7fffffe          BL       __get_IPSR
00000c  b110              CBZ      r0,|L73.20|
;;;664        stat = osErrorISR;
00000e  f06f0405          MVN      r4,#5
000012  e010              B        |L73.54|
                  |L73.20|
;;;665      }
;;;666      else if (hTask == NULL) {
000014  b917              CBNZ     r7,|L73.28|
;;;667        stat = osErrorParameter;
000016  f06f0403          MVN      r4,#3
00001a  e00c              B        |L73.54|
                  |L73.28|
;;;668      }
;;;669      else {
;;;670        tstate = eTaskGetState (hTask);
00001c  4638              MOV      r0,r7
00001e  f7fffffe          BL       eTaskGetState
000022  4605              MOV      r5,r0
;;;671    
;;;672        if (tstate != eDeleted) {
000024  2d04              CMP      r5,#4
000026  d004              BEQ      |L73.50|
;;;673          stat = osOK;
000028  2400              MOVS     r4,#0
;;;674          vTaskDelete (hTask);
00002a  4638              MOV      r0,r7
00002c  f7fffffe          BL       vTaskDelete
000030  e001              B        |L73.54|
                  |L73.50|
;;;675        } else {
;;;676          stat = osErrorResource;
000032  f06f0402          MVN      r4,#2
                  |L73.54|
;;;677        }
;;;678      }
;;;679    #else
;;;680      stat = osError;
;;;681    #endif
;;;682    
;;;683      return (stat);
000036  4620              MOV      r0,r4
;;;684    }
000038  e8bd81f0          POP      {r4-r8,pc}
;;;685    
                          ENDP


                          AREA ||i.osThreadYield||, CODE, READONLY, ALIGN=2

                  osThreadYield PROC
;;;598    
;;;599    osStatus_t osThreadYield (void) {
000000  b510              PUSH     {r4,lr}
;;;600      osStatus_t stat;
;;;601    
;;;602      if (IS_IRQ()) {
000002  f7fffffe          BL       __get_IPSR
000006  b110              CBZ      r0,|L74.14|
;;;603        stat = osErrorISR;
000008  f06f0405          MVN      r4,#5
00000c  e008              B        |L74.32|
                  |L74.14|
;;;604      } else {
;;;605        stat = osOK;
00000e  2400              MOVS     r4,#0
;;;606        taskYIELD();
000010  f04f5080          MOV      r0,#0x10000000
000014  4903              LDR      r1,|L74.36|
000016  6008              STR      r0,[r1,#0]
000018  f3bf8f4f          DSB      
00001c  f3bf8f6f          ISB      
                  |L74.32|
;;;607      }
;;;608    
;;;609      return (stat);
000020  4620              MOV      r0,r4
;;;610    }
000022  bd10              POP      {r4,pc}
;;;611    
                          ENDP

                  |L74.36|
                          DCD      0xe000ed04

                          AREA ||i.osTimerDelete||, CODE, READONLY, ALIGN=1

                  osTimerDelete PROC
;;;1077   
;;;1078   osStatus_t osTimerDelete (osTimerId_t timer_id) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4605              MOV      r5,r0
;;;1079     TimerHandle_t hTimer = (TimerHandle_t)timer_id;
000004  462e              MOV      r6,r5
;;;1080     osStatus_t stat;
;;;1081   #ifndef USE_FreeRTOS_HEAP_1
;;;1082     TimerCallback_t *callb;
;;;1083   
;;;1084     if (IS_IRQ()) {
000006  f7fffffe          BL       __get_IPSR
00000a  b110              CBZ      r0,|L75.18|
;;;1085       stat = osErrorISR;
00000c  f06f0405          MVN      r4,#5
000010  e018              B        |L75.68|
                  |L75.18|
;;;1086     }
;;;1087     else if (hTimer == NULL) {
000012  b916              CBNZ     r6,|L75.26|
;;;1088       stat = osErrorParameter;
000014  f06f0403          MVN      r4,#3
000018  e014              B        |L75.68|
                  |L75.26|
;;;1089     }
;;;1090     else {
;;;1091       callb = (TimerCallback_t *)pvTimerGetTimerID (hTimer);
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       pvTimerGetTimerID
000020  4607              MOV      r7,r0
;;;1092   
;;;1093       if (xTimerDelete (hTimer, 0) == pdPASS) {
000022  2000              MOVS     r0,#0
000024  4603              MOV      r3,r0
000026  4602              MOV      r2,r0
000028  2105              MOVS     r1,#5
00002a  9000              STR      r0,[sp,#0]
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       xTimerGenericCommand
000032  2801              CMP      r0,#1
000034  d104              BNE      |L75.64|
;;;1094         vPortFree (callb);
000036  4638              MOV      r0,r7
000038  f7fffffe          BL       vPortFree
;;;1095         stat = osOK;
00003c  2400              MOVS     r4,#0
00003e  e001              B        |L75.68|
                  |L75.64|
;;;1096       } else {
;;;1097         stat = osErrorResource;
000040  f06f0402          MVN      r4,#2
                  |L75.68|
;;;1098       }
;;;1099     }
;;;1100   #else
;;;1101     stat = osError;
;;;1102   #endif
;;;1103   
;;;1104     return (stat);
000044  4620              MOV      r0,r4
;;;1105   }
000046  bdf8              POP      {r3-r7,pc}
;;;1106   #endif /* (configUSE_OS2_TIMER == 1) */
                          ENDP


                          AREA ||i.osTimerGetName||, CODE, READONLY, ALIGN=1

                  osTimerGetName PROC
;;;1004   
;;;1005   const char *osTimerGetName (osTimerId_t timer_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;1006     TimerHandle_t hTimer = (TimerHandle_t)timer_id;
000004  462e              MOV      r6,r5
;;;1007     const char *p;
;;;1008   
;;;1009     if (IS_IRQ() || (hTimer == NULL)) {
000006  f7fffffe          BL       __get_IPSR
00000a  b900              CBNZ     r0,|L76.14|
00000c  b90e              CBNZ     r6,|L76.18|
                  |L76.14|
;;;1010       p = NULL;
00000e  2400              MOVS     r4,#0
000010  e003              B        |L76.26|
                  |L76.18|
;;;1011     } else {
;;;1012       p = pcTimerGetName (hTimer);
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       pcTimerGetName
000018  4604              MOV      r4,r0
                  |L76.26|
;;;1013     }
;;;1014   
;;;1015     return (p);
00001a  4620              MOV      r0,r4
;;;1016   }
00001c  bd70              POP      {r4-r6,pc}
;;;1017   
                          ENDP


                          AREA ||i.osTimerIsRunning||, CODE, READONLY, ALIGN=1

                  osTimerIsRunning PROC
;;;1064   
;;;1065   uint32_t osTimerIsRunning (osTimerId_t timer_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;1066     TimerHandle_t hTimer = (TimerHandle_t)timer_id;
000004  462e              MOV      r6,r5
;;;1067     uint32_t running;
;;;1068   
;;;1069     if (IS_IRQ() || (hTimer == NULL)) {
000006  f7fffffe          BL       __get_IPSR
00000a  b900              CBNZ     r0,|L77.14|
00000c  b90e              CBNZ     r6,|L77.18|
                  |L77.14|
;;;1070       running = 0U;
00000e  2400              MOVS     r4,#0
000010  e003              B        |L77.26|
                  |L77.18|
;;;1071     } else {
;;;1072       running = (uint32_t)xTimerIsTimerActive (hTimer);
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       xTimerIsTimerActive
000018  4604              MOV      r4,r0
                  |L77.26|
;;;1073     }
;;;1074   
;;;1075     return (running);
00001a  4620              MOV      r0,r4
;;;1076   }
00001c  bd70              POP      {r4-r6,pc}
;;;1077   
                          ENDP


                          AREA ||i.osTimerNew||, CODE, READONLY, ALIGN=2

                  osTimerNew PROC
;;;938    
;;;939    osTimerId_t osTimerNew (osTimerFunc_t func, osTimerType_t type, void *argument, const osTimerAttr_t *attr) {
000000  e92d4ffe          PUSH     {r1-r11,lr}
000004  4606              MOV      r6,r0
000006  4689              MOV      r9,r1
000008  4692              MOV      r10,r2
00000a  461c              MOV      r4,r3
;;;940      const char *name;
;;;941      TimerHandle_t hTimer;
;;;942      TimerCallback_t *callb;
;;;943      UBaseType_t reload;
;;;944      int32_t mem;
;;;945    
;;;946      hTimer = NULL;
00000c  2000              MOVS     r0,#0
00000e  9002              STR      r0,[sp,#8]
;;;947    
;;;948      if (!IS_IRQ() && (func != NULL)) {
000010  f7fffffe          BL       __get_IPSR
000014  2800              CMP      r0,#0
000016  d14b              BNE      |L78.176|
000018  2e00              CMP      r6,#0
00001a  d049              BEQ      |L78.176|
;;;949        /* Allocate memory to store callback function and argument */
;;;950        callb = pvPortMalloc (sizeof(TimerCallback_t));
00001c  2008              MOVS     r0,#8
00001e  f7fffffe          BL       pvPortMalloc
000022  4605              MOV      r5,r0
;;;951    
;;;952        if (callb != NULL) {
000024  2d00              CMP      r5,#0
000026  d043              BEQ      |L78.176|
;;;953          callb->func = func;
000028  602e              STR      r6,[r5,#0]
;;;954          callb->arg  = argument;
00002a  f8c5a004          STR      r10,[r5,#4]
;;;955    
;;;956          if (type == osTimerOnce) {
00002e  f1b90f00          CMP      r9,#0
000032  d101              BNE      |L78.56|
;;;957            reload = pdFALSE;
000034  2700              MOVS     r7,#0
000036  e000              B        |L78.58|
                  |L78.56|
;;;958          } else {
;;;959            reload = pdTRUE;
000038  2701              MOVS     r7,#1
                  |L78.58|
;;;960          }
;;;961    
;;;962          mem  = -1;
00003a  f04f38ff          MOV      r8,#0xffffffff
;;;963          name = NULL;
00003e  f04f0b00          MOV      r11,#0
;;;964    
;;;965          if (attr != NULL) {
000042  b194              CBZ      r4,|L78.106|
;;;966            if (attr->name != NULL) {
000044  6820              LDR      r0,[r4,#0]
000046  b108              CBZ      r0,|L78.76|
;;;967              name = attr->name;
000048  f8d4b000          LDR      r11,[r4,#0]
                  |L78.76|
;;;968            }
;;;969    
;;;970            if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticTimer_t))) {
00004c  68a0              LDR      r0,[r4,#8]
00004e  b128              CBZ      r0,|L78.92|
000050  68e0              LDR      r0,[r4,#0xc]
000052  282c              CMP      r0,#0x2c
000054  d302              BCC      |L78.92|
;;;971              mem = 1;
000056  f04f0801          MOV      r8,#1
00005a  e008              B        |L78.110|
                  |L78.92|
;;;972            }
;;;973            else {
;;;974              if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
00005c  68a0              LDR      r0,[r4,#8]
00005e  b930              CBNZ     r0,|L78.110|
000060  68e0              LDR      r0,[r4,#0xc]
000062  b920              CBNZ     r0,|L78.110|
;;;975                mem = 0;
000064  f04f0800          MOV      r8,#0
000068  e001              B        |L78.110|
                  |L78.106|
;;;976              }
;;;977            }
;;;978          }
;;;979          else {
;;;980            mem = 0;
00006a  f04f0800          MOV      r8,#0
                  |L78.110|
;;;981          }
;;;982    
;;;983          if (mem == 1) {
00006e  f1b80f01          CMP      r8,#1
000072  d10b              BNE      |L78.140|
;;;984            #if (configSUPPORT_STATIC_ALLOCATION == 1)
;;;985              hTimer = xTimerCreateStatic (name, 1, reload, callb, TimerCallback, (StaticTimer_t *)attr->cb_mem);
000074  4910              LDR      r1,|L78.184|
000076  68a0              LDR      r0,[r4,#8]
000078  462b              MOV      r3,r5
00007a  463a              MOV      r2,r7
00007c  e9cd1000          STRD     r1,r0,[sp,#0]
000080  2101              MOVS     r1,#1
000082  4658              MOV      r0,r11
000084  f7fffffe          BL       xTimerCreateStatic
000088  9002              STR      r0,[sp,#8]
00008a  e00b              B        |L78.164|
                  |L78.140|
;;;986            #endif
;;;987          }
;;;988          else {
;;;989            if (mem == 0) {
00008c  f1b80f00          CMP      r8,#0
000090  d108              BNE      |L78.164|
;;;990              #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
;;;991                hTimer = xTimerCreate (name, 1, reload, callb, TimerCallback);
000092  4809              LDR      r0,|L78.184|
000094  462b              MOV      r3,r5
000096  463a              MOV      r2,r7
000098  2101              MOVS     r1,#1
00009a  9000              STR      r0,[sp,#0]
00009c  4658              MOV      r0,r11
00009e  f7fffffe          BL       xTimerCreate
0000a2  9002              STR      r0,[sp,#8]
                  |L78.164|
;;;992              #endif
;;;993            }
;;;994          }
;;;995    
;;;996          if ((hTimer == NULL) && (callb != NULL)) {
0000a4  9802              LDR      r0,[sp,#8]
0000a6  b918              CBNZ     r0,|L78.176|
0000a8  b115              CBZ      r5,|L78.176|
;;;997            vPortFree (callb);
0000aa  4628              MOV      r0,r5
0000ac  f7fffffe          BL       vPortFree
                  |L78.176|
;;;998          }
;;;999        }
;;;1000     }
;;;1001   
;;;1002     return ((osTimerId_t)hTimer);
0000b0  9802              LDR      r0,[sp,#8]
;;;1003   }
0000b2  e8bd8ffe          POP      {r1-r11,pc}
;;;1004   
                          ENDP

0000b6  0000              DCW      0x0000
                  |L78.184|
                          DCD      TimerCallback

                          AREA ||i.osTimerStart||, CODE, READONLY, ALIGN=1

                  osTimerStart PROC
;;;1017   
;;;1018   osStatus_t osTimerStart (osTimerId_t timer_id, uint32_t ticks) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;1019     TimerHandle_t hTimer = (TimerHandle_t)timer_id;
000006  462f              MOV      r7,r5
;;;1020     osStatus_t stat;
;;;1021   
;;;1022     if (IS_IRQ()) {
000008  f7fffffe          BL       __get_IPSR
00000c  b110              CBZ      r0,|L79.20|
;;;1023       stat = osErrorISR;
00000e  f06f0405          MVN      r4,#5
000012  e011              B        |L79.56|
                  |L79.20|
;;;1024     }
;;;1025     else if (hTimer == NULL) {
000014  b917              CBNZ     r7,|L79.28|
;;;1026       stat = osErrorParameter;
000016  f06f0403          MVN      r4,#3
00001a  e00d              B        |L79.56|
                  |L79.28|
;;;1027     }
;;;1028     else {
;;;1029       if (xTimerChangePeriod (hTimer, ticks, 0) == pdPASS) {
00001c  2000              MOVS     r0,#0
00001e  4603              MOV      r3,r0
000020  4632              MOV      r2,r6
000022  2104              MOVS     r1,#4
000024  9000              STR      r0,[sp,#0]
000026  4638              MOV      r0,r7
000028  f7fffffe          BL       xTimerGenericCommand
00002c  2801              CMP      r0,#1
00002e  d101              BNE      |L79.52|
;;;1030         stat = osOK;
000030  2400              MOVS     r4,#0
000032  e001              B        |L79.56|
                  |L79.52|
;;;1031       } else {
;;;1032         stat = osErrorResource;
000034  f06f0402          MVN      r4,#2
                  |L79.56|
;;;1033       }
;;;1034     }
;;;1035   
;;;1036     return (stat);
000038  4620              MOV      r0,r4
;;;1037   }
00003a  bdf8              POP      {r3-r7,pc}
;;;1038   
                          ENDP


                          AREA ||i.osTimerStop||, CODE, READONLY, ALIGN=1

                  osTimerStop PROC
;;;1038   
;;;1039   osStatus_t osTimerStop (osTimerId_t timer_id) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4605              MOV      r5,r0
;;;1040     TimerHandle_t hTimer = (TimerHandle_t)timer_id;
000004  462e              MOV      r6,r5
;;;1041     osStatus_t stat;
;;;1042   
;;;1043     if (IS_IRQ()) {
000006  f7fffffe          BL       __get_IPSR
00000a  b110              CBZ      r0,|L80.18|
;;;1044       stat = osErrorISR;
00000c  f06f0405          MVN      r4,#5
000010  e018              B        |L80.68|
                  |L80.18|
;;;1045     }
;;;1046     else if (hTimer == NULL) {
000012  b916              CBNZ     r6,|L80.26|
;;;1047       stat = osErrorParameter;
000014  f06f0403          MVN      r4,#3
000018  e014              B        |L80.68|
                  |L80.26|
;;;1048     }
;;;1049     else {
;;;1050       if (xTimerIsTimerActive (hTimer) == pdFALSE) {
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       xTimerIsTimerActive
000020  b910              CBNZ     r0,|L80.40|
;;;1051         stat = osErrorResource;
000022  f06f0402          MVN      r4,#2
000026  e00d              B        |L80.68|
                  |L80.40|
;;;1052       }
;;;1053       else {
;;;1054         if (xTimerStop (hTimer, 0) == pdPASS) {
000028  2000              MOVS     r0,#0
00002a  4603              MOV      r3,r0
00002c  4602              MOV      r2,r0
00002e  2103              MOVS     r1,#3
000030  9000              STR      r0,[sp,#0]
000032  4630              MOV      r0,r6
000034  f7fffffe          BL       xTimerGenericCommand
000038  2801              CMP      r0,#1
00003a  d101              BNE      |L80.64|
;;;1055           stat = osOK;
00003c  2400              MOVS     r4,#0
00003e  e001              B        |L80.68|
                  |L80.64|
;;;1056         } else {
;;;1057           stat = osError;
000040  f04f34ff          MOV      r4,#0xffffffff
                  |L80.68|
;;;1058         }
;;;1059       }
;;;1060     }
;;;1061   
;;;1062     return (stat);
000044  4620              MOV      r0,r4
;;;1063   }
000046  bdf8              POP      {r3-r7,pc}
;;;1064   
                          ENDP


                          AREA ||i.vApplicationGetIdleTaskMemory||, CODE, READONLY, ALIGN=2

                  vApplicationGetIdleTaskMemory PROC
;;;2458   */
;;;2459   __WEAK void vApplicationGetIdleTaskMemory (StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize) {
000000  4b03              LDR      r3,|L81.16|
;;;2460     /* Idle task control block and stack */
;;;2461     static StaticTask_t Idle_TCB;
;;;2462     static StackType_t  Idle_Stack[configMINIMAL_STACK_SIZE];
;;;2463   
;;;2464     *ppxIdleTaskTCBBuffer   = &Idle_TCB;
000002  6003              STR      r3,[r0,#0]
;;;2465     *ppxIdleTaskStackBuffer = &Idle_Stack[0];
000004  4b03              LDR      r3,|L81.20|
000006  600b              STR      r3,[r1,#0]
;;;2466     *pulIdleTaskStackSize   = (uint32_t)configMINIMAL_STACK_SIZE;
000008  2380              MOVS     r3,#0x80
00000a  6013              STR      r3,[r2,#0]
;;;2467   }
00000c  4770              BX       lr
;;;2468   
                          ENDP

00000e  0000              DCW      0x0000
                  |L81.16|
                          DCD      Idle_TCB
                  |L81.20|
                          DCD      Idle_Stack

                          AREA ||i.vApplicationGetTimerTaskMemory||, CODE, READONLY, ALIGN=2

                  vApplicationGetTimerTaskMemory PROC
;;;2472   */
;;;2473   __WEAK void vApplicationGetTimerTaskMemory (StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize) {
000000  4b03              LDR      r3,|L82.16|
;;;2474     /* Timer task control block and stack */
;;;2475     static StaticTask_t Timer_TCB;
;;;2476     static StackType_t  Timer_Stack[configTIMER_TASK_STACK_DEPTH];
;;;2477   
;;;2478     *ppxTimerTaskTCBBuffer   = &Timer_TCB;
000002  6003              STR      r3,[r0,#0]
;;;2479     *ppxTimerTaskStackBuffer = &Timer_Stack[0];
000004  4b03              LDR      r3,|L82.20|
000006  600b              STR      r3,[r1,#0]
;;;2480     *pulTimerTaskStackSize   = (uint32_t)configTIMER_TASK_STACK_DEPTH;
000008  f44f7380          MOV      r3,#0x100
00000c  6013              STR      r3,[r2,#0]
;;;2481   }
00000e  4770              BX       lr
;;;2482   #endif
                          ENDP

                  |L82.16|
                          DCD      Timer_TCB
                  |L82.20|
                          DCD      Timer_Stack

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Idle_TCB
                          %        92
                  Idle_Stack
                          %        512
                  Timer_TCB
                          %        92
                  Timer_Stack
                          %        1024

                          AREA ||.data||, DATA, ALIGN=2

                  KernelState
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2/cmsis_os2.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_cmsis_os2_c_b672aa62____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___11_cmsis_os2_c_b672aa62____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_cmsis_os2_c_b672aa62____REVSH|
#line 478
|__asm___11_cmsis_os2_c_b672aa62____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___11_cmsis_os2_c_b672aa62____RRX|
#line 665
|__asm___11_cmsis_os2_c_b672aa62____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
