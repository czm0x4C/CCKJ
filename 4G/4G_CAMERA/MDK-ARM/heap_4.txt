; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o4gcamera\heap_4.o --asm_dir=.\ --list_dir=.\ --depend=4gcamera\heap_4.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../USB_DEVICE/App -I../USB_DEVICE/Target -I../Core/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Middlewares/ST/STM32_USB_Device_Library/Core/Inc -I../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 -I../Middlewares/Third_Party/FreeRTOS/Source/portable/RVDS/ARM_CM4F -I../HARDWARE/OV2640 -I../HARDWARE/WS2812B -I../HARDWARE/RING_BUFFER -I../HARDWARE/FLASH -I.\RTE\_4GCAMERA -IC:\Users\czm\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\czm\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=536 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F407xx --omf_browse=4gcamera\heap_4.crf ../Middlewares/Third_Party/FreeRTOS/Source/portable/MemMang/heap_4.c]
                          THUMB

                          AREA ||i.prvHeapInit||, CODE, READONLY, ALIGN=2

                  prvHeapInit PROC
;;;332    
;;;333    static void prvHeapInit( void )
000000  b530              PUSH     {r4,r5,lr}
;;;334    {
;;;335    BlockLink_t *pxFirstFreeBlock;
;;;336    uint8_t *pucAlignedHeap;
;;;337    size_t uxAddress;
;;;338    size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
000002  f44f5370          MOV      r3,#0x3c00
;;;339    
;;;340    	/* Ensure the heap starts on a correctly aligned boundary. */
;;;341    	uxAddress = ( size_t ) ucHeap;
000006  4817              LDR      r0,|L1.100|
;;;342    
;;;343    	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
000008  f0000407          AND      r4,r0,#7
00000c  b12c              CBZ      r4,|L1.26|
;;;344    	{
;;;345    		uxAddress += ( portBYTE_ALIGNMENT - 1 );
00000e  1dc0              ADDS     r0,r0,#7
;;;346    		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
000010  f0200007          BIC      r0,r0,#7
;;;347    		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
000014  4c13              LDR      r4,|L1.100|
000016  1b04              SUBS     r4,r0,r4
000018  1b1b              SUBS     r3,r3,r4
                  |L1.26|
;;;348    	}
;;;349    
;;;350    	pucAlignedHeap = ( uint8_t * ) uxAddress;
00001a  4602              MOV      r2,r0
;;;351    
;;;352    	/* xStart is used to hold a pointer to the first item in the list of free
;;;353    	blocks.  The void cast is used to prevent compiler warnings. */
;;;354    	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
00001c  4c12              LDR      r4,|L1.104|
00001e  6022              STR      r2,[r4,#0]  ; xStart
;;;355    	xStart.xBlockSize = ( size_t ) 0;
000020  2400              MOVS     r4,#0
000022  4d11              LDR      r5,|L1.104|
000024  606c              STR      r4,[r5,#4]  ; xStart
;;;356    
;;;357    	/* pxEnd is used to mark the end of the list of free blocks and is inserted
;;;358    	at the end of the heap space. */
;;;359    	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
000026  18d0              ADDS     r0,r2,r3
;;;360    	uxAddress -= xHeapStructSize;
000028  3808              SUBS     r0,r0,#8
;;;361    	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
00002a  f0200007          BIC      r0,r0,#7
;;;362    	pxEnd = ( void * ) uxAddress;
00002e  4c0f              LDR      r4,|L1.108|
000030  6020              STR      r0,[r4,#0]  ; pxEnd
;;;363    	pxEnd->xBlockSize = 0;
000032  2400              MOVS     r4,#0
000034  4d0d              LDR      r5,|L1.108|
000036  682d              LDR      r5,[r5,#0]  ; pxEnd
000038  606c              STR      r4,[r5,#4]
;;;364    	pxEnd->pxNextFreeBlock = NULL;
00003a  4d0c              LDR      r5,|L1.108|
00003c  682d              LDR      r5,[r5,#0]  ; pxEnd
00003e  602c              STR      r4,[r5,#0]
;;;365    
;;;366    	/* To start with there is a single free block that is sized to take up the
;;;367    	entire heap space, minus the space taken by pxEnd. */
;;;368    	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
000040  4611              MOV      r1,r2
;;;369    	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
000042  1a44              SUBS     r4,r0,r1
000044  604c              STR      r4,[r1,#4]
;;;370    	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
000046  4c09              LDR      r4,|L1.108|
000048  6824              LDR      r4,[r4,#0]  ; pxEnd
00004a  600c              STR      r4,[r1,#0]
;;;371    
;;;372    	/* Only one block exists - and it covers the entire usable heap space. */
;;;373    	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
00004c  4d08              LDR      r5,|L1.112|
00004e  684c              LDR      r4,[r1,#4]
000050  602c              STR      r4,[r5,#0]  ; xMinimumEverFreeBytesRemaining
;;;374    	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
000052  4d08              LDR      r5,|L1.116|
000054  684c              LDR      r4,[r1,#4]
000056  602c              STR      r4,[r5,#0]  ; xFreeBytesRemaining
;;;375    
;;;376    	/* Work out the position of the top bit in a size_t variable. */
;;;377    	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
000058  f04f4400          MOV      r4,#0x80000000
00005c  4d06              LDR      r5,|L1.120|
00005e  602c              STR      r4,[r5,#0]  ; xBlockAllocatedBit
;;;378    }
000060  bd30              POP      {r4,r5,pc}
;;;379    /*-----------------------------------------------------------*/
                          ENDP

000062  0000              DCW      0x0000
                  |L1.100|
                          DCD      ucHeap
                  |L1.104|
                          DCD      xStart
                  |L1.108|
                          DCD      pxEnd
                  |L1.112|
                          DCD      xMinimumEverFreeBytesRemaining
                  |L1.116|
                          DCD      xFreeBytesRemaining
                  |L1.120|
                          DCD      xBlockAllocatedBit

                          AREA ||i.prvInsertBlockIntoFreeList||, CODE, READONLY, ALIGN=2

                  prvInsertBlockIntoFreeList PROC
;;;380    
;;;381    static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
000000  b510              PUSH     {r4,lr}
;;;382    {
000002  4601              MOV      r1,r0
;;;383    BlockLink_t *pxIterator;
;;;384    uint8_t *puc;
;;;385    
;;;386    	/* Iterate through the list until a block is found that has a higher address
;;;387    	than the block being inserted. */
;;;388    	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
000004  4816              LDR      r0,|L2.96|
000006  e000              B        |L2.10|
                  |L2.8|
000008  6800              LDR      r0,[r0,#0]
                  |L2.10|
00000a  6803              LDR      r3,[r0,#0]
00000c  428b              CMP      r3,r1
00000e  d3fb              BCC      |L2.8|
;;;389    	{
;;;390    		/* Nothing to do here, just iterate to the right position. */
;;;391    	}
;;;392    
;;;393    	/* Do the block being inserted, and the block it is being inserted after
;;;394    	make a contiguous block of memory? */
;;;395    	puc = ( uint8_t * ) pxIterator;
000010  4602              MOV      r2,r0
;;;396    	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
000012  6843              LDR      r3,[r0,#4]
000014  4413              ADD      r3,r3,r2
000016  428b              CMP      r3,r1
000018  d104              BNE      |L2.36|
;;;397    	{
;;;398    		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
00001a  6843              LDR      r3,[r0,#4]
00001c  684c              LDR      r4,[r1,#4]
00001e  4423              ADD      r3,r3,r4
000020  6043              STR      r3,[r0,#4]
;;;399    		pxBlockToInsert = pxIterator;
000022  4601              MOV      r1,r0
                  |L2.36|
;;;400    	}
;;;401    	else
;;;402    	{
;;;403    		mtCOVERAGE_TEST_MARKER();
;;;404    	}
;;;405    
;;;406    	/* Do the block being inserted, and the block it is being inserted before
;;;407    	make a contiguous block of memory? */
;;;408    	puc = ( uint8_t * ) pxBlockToInsert;
000024  460a              MOV      r2,r1
;;;409    	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
000026  684b              LDR      r3,[r1,#4]
000028  4413              ADD      r3,r3,r2
00002a  6804              LDR      r4,[r0,#0]
00002c  42a3              CMP      r3,r4
00002e  d111              BNE      |L2.84|
;;;410    	{
;;;411    		if( pxIterator->pxNextFreeBlock != pxEnd )
000030  4c0c              LDR      r4,|L2.100|
000032  6803              LDR      r3,[r0,#0]
000034  6824              LDR      r4,[r4,#0]  ; pxEnd
000036  42a3              CMP      r3,r4
000038  d008              BEQ      |L2.76|
;;;412    		{
;;;413    			/* Form one big block from the two blocks. */
;;;414    			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
00003a  684b              LDR      r3,[r1,#4]
00003c  6804              LDR      r4,[r0,#0]
00003e  6864              LDR      r4,[r4,#4]
000040  4423              ADD      r3,r3,r4
000042  604b              STR      r3,[r1,#4]
;;;415    			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
000044  6803              LDR      r3,[r0,#0]
000046  681b              LDR      r3,[r3,#0]
000048  600b              STR      r3,[r1,#0]
00004a  e005              B        |L2.88|
                  |L2.76|
;;;416    		}
;;;417    		else
;;;418    		{
;;;419    			pxBlockToInsert->pxNextFreeBlock = pxEnd;
00004c  4b05              LDR      r3,|L2.100|
00004e  681b              LDR      r3,[r3,#0]  ; pxEnd
000050  600b              STR      r3,[r1,#0]
000052  e001              B        |L2.88|
                  |L2.84|
;;;420    		}
;;;421    	}
;;;422    	else
;;;423    	{
;;;424    		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
000054  6803              LDR      r3,[r0,#0]
000056  600b              STR      r3,[r1,#0]
                  |L2.88|
;;;425    	}
;;;426    
;;;427    	/* If the block being inserted plugged a gab, so was merged with the block
;;;428    	before and the block after, then it's pxNextFreeBlock pointer will have
;;;429    	already been set, and should not be set here as that would make it point
;;;430    	to itself. */
;;;431    	if( pxIterator != pxBlockToInsert )
000058  4288              CMP      r0,r1
00005a  d000              BEQ      |L2.94|
;;;432    	{
;;;433    		pxIterator->pxNextFreeBlock = pxBlockToInsert;
00005c  6001              STR      r1,[r0,#0]
                  |L2.94|
;;;434    	}
;;;435    	else
;;;436    	{
;;;437    		mtCOVERAGE_TEST_MARKER();
;;;438    	}
;;;439    }
00005e  bd10              POP      {r4,pc}
;;;440    /*-----------------------------------------------------------*/
                          ENDP

                  |L2.96|
                          DCD      xStart
                  |L2.100|
                          DCD      pxEnd

                          AREA ||i.pvPortMalloc||, CODE, READONLY, ALIGN=2

                  pvPortMalloc PROC
;;;114    
;;;115    void *pvPortMalloc( size_t xWantedSize )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;116    {
000004  4604              MOV      r4,r0
;;;117    BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
;;;118    void *pvReturn = NULL;
000006  f04f0800          MOV      r8,#0
;;;119    
;;;120    	vTaskSuspendAll();
00000a  f7fffffe          BL       vTaskSuspendAll
;;;121    	{
;;;122    		/* If this is the first call to malloc then the heap will require
;;;123    		initialisation to setup the list of free blocks. */
;;;124    		if( pxEnd == NULL )
00000e  4849              LDR      r0,|L3.308|
000010  6800              LDR      r0,[r0,#0]  ; pxEnd
000012  b908              CBNZ     r0,|L3.24|
;;;125    		{
;;;126    			prvHeapInit();
000014  f7fffffe          BL       prvHeapInit
                  |L3.24|
;;;127    		}
;;;128    		else
;;;129    		{
;;;130    			mtCOVERAGE_TEST_MARKER();
;;;131    		}
;;;132    
;;;133    		/* Check the requested block size is not so large that the top bit is
;;;134    		set.  The top bit of the block size member of the BlockLink_t structure
;;;135    		is used to determine who owns the block - the application or the
;;;136    		kernel, so it must be free. */
;;;137    		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
000018  4847              LDR      r0,|L3.312|
00001a  6800              LDR      r0,[r0,#0]  ; xBlockAllocatedBit
00001c  4020              ANDS     r0,r0,r4
00001e  2800              CMP      r0,#0
000020  d170              BNE      |L3.260|
;;;138    		{
;;;139    			/* The wanted size is increased so it can contain a BlockLink_t
;;;140    			structure in addition to the requested amount of bytes. */
;;;141    			if( xWantedSize > 0 )
000022  b1d4              CBZ      r4,|L3.90|
;;;142    			{
;;;143    				xWantedSize += xHeapStructSize;
000024  3408              ADDS     r4,r4,#8
;;;144    
;;;145    				/* Ensure that blocks are always aligned to the required number
;;;146    				of bytes. */
;;;147    				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
000026  f0040007          AND      r0,r4,#7
00002a  b1b0              CBZ      r0,|L3.90|
;;;148    				{
;;;149    					/* Byte alignment required. */
;;;150    					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
00002c  f0040007          AND      r0,r4,#7
000030  f1c00008          RSB      r0,r0,#8
000034  4404              ADD      r4,r4,r0
;;;151    					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
000036  f0040007          AND      r0,r4,#7
00003a  b908              CBNZ     r0,|L3.64|
00003c  2001              MOVS     r0,#1
00003e  e000              B        |L3.66|
                  |L3.64|
000040  2000              MOVS     r0,#0
                  |L3.66|
000042  b950              CBNZ     r0,|L3.90|
000044  bf00              NOP      
000046  2050              MOVS     r0,#0x50
000048  f3808811          MSR      BASEPRI,r0
00004c  f3bf8f4f          DSB      
000050  f3bf8f6f          ISB      
000054  bf00              NOP      
000056  bf00              NOP      
                  |L3.88|
000058  e7fe              B        |L3.88|
                  |L3.90|
;;;152    				}
;;;153    				else
;;;154    				{
;;;155    					mtCOVERAGE_TEST_MARKER();
;;;156    				}
;;;157    			}
;;;158    			else
;;;159    			{
;;;160    				mtCOVERAGE_TEST_MARKER();
;;;161    			}
;;;162    
;;;163    			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
00005a  2c00              CMP      r4,#0
00005c  d052              BEQ      |L3.260|
00005e  4837              LDR      r0,|L3.316|
000060  6800              LDR      r0,[r0,#0]  ; xFreeBytesRemaining
000062  4284              CMP      r4,r0
000064  d84e              BHI      |L3.260|
;;;164    			{
;;;165    				/* Traverse the list from the start	(lowest address) block until
;;;166    				one	of adequate size is found. */
;;;167    				pxPreviousBlock = &xStart;
000066  4e36              LDR      r6,|L3.320|
;;;168    				pxBlock = xStart.pxNextFreeBlock;
000068  4630              MOV      r0,r6
00006a  6805              LDR      r5,[r0,#0]  ; xStart
;;;169    				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
00006c  e001              B        |L3.114|
                  |L3.110|
;;;170    				{
;;;171    					pxPreviousBlock = pxBlock;
00006e  462e              MOV      r6,r5
;;;172    					pxBlock = pxBlock->pxNextFreeBlock;
000070  682d              LDR      r5,[r5,#0]
                  |L3.114|
000072  6868              LDR      r0,[r5,#4]            ;169
000074  42a0              CMP      r0,r4                 ;169
000076  d202              BCS      |L3.126|
000078  6828              LDR      r0,[r5,#0]            ;169
00007a  2800              CMP      r0,#0                 ;169
00007c  d1f7              BNE      |L3.110|
                  |L3.126|
;;;173    				}
;;;174    
;;;175    				/* If the end marker was reached then a block of adequate size
;;;176    				was	not found. */
;;;177    				if( pxBlock != pxEnd )
00007e  482d              LDR      r0,|L3.308|
000080  6800              LDR      r0,[r0,#0]  ; pxEnd
000082  4285              CMP      r5,r0
000084  d03e              BEQ      |L3.260|
;;;178    				{
;;;179    					/* Return the memory space pointed to - jumping over the
;;;180    					BlockLink_t structure at its start. */
;;;181    					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
000086  6830              LDR      r0,[r6,#0]
000088  f1000808          ADD      r8,r0,#8
;;;182    
;;;183    					/* This block is being returned for use so must be taken out
;;;184    					of the list of free blocks. */
;;;185    					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
00008c  6828              LDR      r0,[r5,#0]
00008e  6030              STR      r0,[r6,#0]
;;;186    
;;;187    					/* If the block is larger than required it can be split into
;;;188    					two. */
;;;189    					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
000090  6868              LDR      r0,[r5,#4]
000092  1b00              SUBS     r0,r0,r4
000094  2810              CMP      r0,#0x10
000096  d919              BLS      |L3.204|
;;;190    					{
;;;191    						/* This block is to be split into two.  Create a new
;;;192    						block following the number of bytes requested. The void
;;;193    						cast is used to prevent byte alignment warnings from the
;;;194    						compiler. */
;;;195    						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
000098  192f              ADDS     r7,r5,r4
;;;196    						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
00009a  f0070007          AND      r0,r7,#7
00009e  b908              CBNZ     r0,|L3.164|
0000a0  2001              MOVS     r0,#1
0000a2  e000              B        |L3.166|
                  |L3.164|
0000a4  2000              MOVS     r0,#0
                  |L3.166|
0000a6  b950              CBNZ     r0,|L3.190|
0000a8  bf00              NOP      
0000aa  2050              MOVS     r0,#0x50
0000ac  f3808811          MSR      BASEPRI,r0
0000b0  f3bf8f4f          DSB      
0000b4  f3bf8f6f          ISB      
0000b8  bf00              NOP      
0000ba  bf00              NOP      
                  |L3.188|
0000bc  e7fe              B        |L3.188|
                  |L3.190|
;;;197    
;;;198    						/* Calculate the sizes of two blocks split from the
;;;199    						single block. */
;;;200    						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
0000be  6868              LDR      r0,[r5,#4]
0000c0  1b00              SUBS     r0,r0,r4
0000c2  6078              STR      r0,[r7,#4]
;;;201    						pxBlock->xBlockSize = xWantedSize;
0000c4  606c              STR      r4,[r5,#4]
;;;202    
;;;203    						/* Insert the new block into the list of free blocks. */
;;;204    						prvInsertBlockIntoFreeList( pxNewBlockLink );
0000c6  4638              MOV      r0,r7
0000c8  f7fffffe          BL       prvInsertBlockIntoFreeList
                  |L3.204|
;;;205    					}
;;;206    					else
;;;207    					{
;;;208    						mtCOVERAGE_TEST_MARKER();
;;;209    					}
;;;210    
;;;211    					xFreeBytesRemaining -= pxBlock->xBlockSize;
0000cc  491b              LDR      r1,|L3.316|
0000ce  6868              LDR      r0,[r5,#4]
0000d0  6809              LDR      r1,[r1,#0]  ; xFreeBytesRemaining
0000d2  1a08              SUBS     r0,r1,r0
0000d4  4919              LDR      r1,|L3.316|
0000d6  6008              STR      r0,[r1,#0]  ; xFreeBytesRemaining
;;;212    
;;;213    					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
0000d8  4608              MOV      r0,r1
0000da  6800              LDR      r0,[r0,#0]  ; xFreeBytesRemaining
0000dc  4919              LDR      r1,|L3.324|
0000de  6809              LDR      r1,[r1,#0]  ; xMinimumEverFreeBytesRemaining
0000e0  4288              CMP      r0,r1
0000e2  d203              BCS      |L3.236|
;;;214    					{
;;;215    						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
0000e4  4815              LDR      r0,|L3.316|
0000e6  6800              LDR      r0,[r0,#0]  ; xFreeBytesRemaining
0000e8  4916              LDR      r1,|L3.324|
0000ea  6008              STR      r0,[r1,#0]  ; xMinimumEverFreeBytesRemaining
                  |L3.236|
;;;216    					}
;;;217    					else
;;;218    					{
;;;219    						mtCOVERAGE_TEST_MARKER();
;;;220    					}
;;;221    
;;;222    					/* The block is being returned - it is allocated and owned
;;;223    					by the application and has no "next" block. */
;;;224    					pxBlock->xBlockSize |= xBlockAllocatedBit;
0000ec  4912              LDR      r1,|L3.312|
0000ee  6868              LDR      r0,[r5,#4]
0000f0  6809              LDR      r1,[r1,#0]  ; xBlockAllocatedBit
0000f2  4308              ORRS     r0,r0,r1
0000f4  6068              STR      r0,[r5,#4]
;;;225    					pxBlock->pxNextFreeBlock = NULL;
0000f6  2000              MOVS     r0,#0
0000f8  6028              STR      r0,[r5,#0]
;;;226    					xNumberOfSuccessfulAllocations++;
0000fa  4813              LDR      r0,|L3.328|
0000fc  6800              LDR      r0,[r0,#0]  ; xNumberOfSuccessfulAllocations
0000fe  1c40              ADDS     r0,r0,#1
000100  4911              LDR      r1,|L3.328|
000102  6008              STR      r0,[r1,#0]  ; xNumberOfSuccessfulAllocations
                  |L3.260|
;;;227    				}
;;;228    				else
;;;229    				{
;;;230    					mtCOVERAGE_TEST_MARKER();
;;;231    				}
;;;232    			}
;;;233    			else
;;;234    			{
;;;235    				mtCOVERAGE_TEST_MARKER();
;;;236    			}
;;;237    		}
;;;238    		else
;;;239    		{
;;;240    			mtCOVERAGE_TEST_MARKER();
;;;241    		}
;;;242    
;;;243    		traceMALLOC( pvReturn, xWantedSize );
;;;244    	}
;;;245    	( void ) xTaskResumeAll();
000104  f7fffffe          BL       xTaskResumeAll
;;;246    
;;;247    	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
;;;248    	{
;;;249    		if( pvReturn == NULL )
;;;250    		{
;;;251    			extern void vApplicationMallocFailedHook( void );
;;;252    			vApplicationMallocFailedHook();
;;;253    		}
;;;254    		else
;;;255    		{
;;;256    			mtCOVERAGE_TEST_MARKER();
;;;257    		}
;;;258    	}
;;;259    	#endif
;;;260    
;;;261    	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
000108  f0080007          AND      r0,r8,#7
00010c  b908              CBNZ     r0,|L3.274|
00010e  2001              MOVS     r0,#1
000110  e000              B        |L3.276|
                  |L3.274|
000112  2000              MOVS     r0,#0
                  |L3.276|
000114  b950              CBNZ     r0,|L3.300|
000116  bf00              NOP      
000118  2050              MOVS     r0,#0x50
00011a  f3808811          MSR      BASEPRI,r0
00011e  f3bf8f4f          DSB      
000122  f3bf8f6f          ISB      
000126  bf00              NOP      
000128  bf00              NOP      
                  |L3.298|
00012a  e7fe              B        |L3.298|
                  |L3.300|
;;;262    	return pvReturn;
00012c  4640              MOV      r0,r8
;;;263    }
00012e  e8bd81f0          POP      {r4-r8,pc}
;;;264    /*-----------------------------------------------------------*/
                          ENDP

000132  0000              DCW      0x0000
                  |L3.308|
                          DCD      pxEnd
                  |L3.312|
                          DCD      xBlockAllocatedBit
                  |L3.316|
                          DCD      xFreeBytesRemaining
                  |L3.320|
                          DCD      xStart
                  |L3.324|
                          DCD      xMinimumEverFreeBytesRemaining
                  |L3.328|
                          DCD      xNumberOfSuccessfulAllocations

                          AREA ||i.vPortFree||, CODE, READONLY, ALIGN=2

                  vPortFree PROC
;;;265    
;;;266    void vPortFree( void *pv )
000000  b570              PUSH     {r4-r6,lr}
;;;267    {
000002  4606              MOV      r6,r0
;;;268    uint8_t *puc = ( uint8_t * ) pv;
000004  4635              MOV      r5,r6
;;;269    BlockLink_t *pxLink;
;;;270    
;;;271    	if( pv != NULL )
000006  2e00              CMP      r6,#0
000008  d044              BEQ      |L4.148|
;;;272    	{
;;;273    		/* The memory being freed will have an BlockLink_t structure immediately
;;;274    		before it. */
;;;275    		puc -= xHeapStructSize;
00000a  3d08              SUBS     r5,r5,#8
;;;276    
;;;277    		/* This casting is to keep the compiler from issuing warnings. */
;;;278    		pxLink = ( void * ) puc;
00000c  462c              MOV      r4,r5
;;;279    
;;;280    		/* Check the block is actually allocated. */
;;;281    		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
00000e  4922              LDR      r1,|L4.152|
000010  6860              LDR      r0,[r4,#4]
000012  6809              LDR      r1,[r1,#0]  ; xBlockAllocatedBit
000014  4008              ANDS     r0,r0,r1
000016  b108              CBZ      r0,|L4.28|
000018  2001              MOVS     r0,#1
00001a  e000              B        |L4.30|
                  |L4.28|
00001c  2000              MOVS     r0,#0
                  |L4.30|
00001e  b950              CBNZ     r0,|L4.54|
000020  bf00              NOP      
000022  2050              MOVS     r0,#0x50
000024  f3808811          MSR      BASEPRI,r0
000028  f3bf8f4f          DSB      
00002c  f3bf8f6f          ISB      
000030  bf00              NOP      
000032  bf00              NOP      
                  |L4.52|
000034  e7fe              B        |L4.52|
                  |L4.54|
;;;282    		configASSERT( pxLink->pxNextFreeBlock == NULL );
000036  6820              LDR      r0,[r4,#0]
000038  b908              CBNZ     r0,|L4.62|
00003a  2001              MOVS     r0,#1
00003c  e000              B        |L4.64|
                  |L4.62|
00003e  2000              MOVS     r0,#0
                  |L4.64|
000040  b950              CBNZ     r0,|L4.88|
000042  bf00              NOP      
000044  2050              MOVS     r0,#0x50
000046  f3808811          MSR      BASEPRI,r0
00004a  f3bf8f4f          DSB      
00004e  f3bf8f6f          ISB      
000052  bf00              NOP      
000054  bf00              NOP      
                  |L4.86|
000056  e7fe              B        |L4.86|
                  |L4.88|
;;;283    
;;;284    		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
000058  490f              LDR      r1,|L4.152|
00005a  6860              LDR      r0,[r4,#4]
00005c  6809              LDR      r1,[r1,#0]  ; xBlockAllocatedBit
00005e  4008              ANDS     r0,r0,r1
000060  b1c0              CBZ      r0,|L4.148|
;;;285    		{
;;;286    			if( pxLink->pxNextFreeBlock == NULL )
000062  6820              LDR      r0,[r4,#0]
000064  b9b0              CBNZ     r0,|L4.148|
;;;287    			{
;;;288    				/* The block is being returned to the heap - it is no longer
;;;289    				allocated. */
;;;290    				pxLink->xBlockSize &= ~xBlockAllocatedBit;
000066  490c              LDR      r1,|L4.152|
000068  6860              LDR      r0,[r4,#4]
00006a  6809              LDR      r1,[r1,#0]  ; xBlockAllocatedBit
00006c  4388              BICS     r0,r0,r1
00006e  6060              STR      r0,[r4,#4]
;;;291    
;;;292    				vTaskSuspendAll();
000070  f7fffffe          BL       vTaskSuspendAll
;;;293    				{
;;;294    					/* Add this block to the list of free blocks. */
;;;295    					xFreeBytesRemaining += pxLink->xBlockSize;
000074  4909              LDR      r1,|L4.156|
000076  6860              LDR      r0,[r4,#4]
000078  6809              LDR      r1,[r1,#0]  ; xFreeBytesRemaining
00007a  4408              ADD      r0,r0,r1
00007c  4907              LDR      r1,|L4.156|
00007e  6008              STR      r0,[r1,#0]  ; xFreeBytesRemaining
;;;296    					traceFREE( pv, pxLink->xBlockSize );
;;;297    					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
000080  4620              MOV      r0,r4
000082  f7fffffe          BL       prvInsertBlockIntoFreeList
;;;298    					xNumberOfSuccessfulFrees++;
000086  4806              LDR      r0,|L4.160|
000088  6800              LDR      r0,[r0,#0]  ; xNumberOfSuccessfulFrees
00008a  1c40              ADDS     r0,r0,#1
00008c  4904              LDR      r1,|L4.160|
00008e  6008              STR      r0,[r1,#0]  ; xNumberOfSuccessfulFrees
;;;299    				}
;;;300    				( void ) xTaskResumeAll();
000090  f7fffffe          BL       xTaskResumeAll
                  |L4.148|
;;;301    			}
;;;302    			else
;;;303    			{
;;;304    				mtCOVERAGE_TEST_MARKER();
;;;305    			}
;;;306    		}
;;;307    		else
;;;308    		{
;;;309    			mtCOVERAGE_TEST_MARKER();
;;;310    		}
;;;311    	}
;;;312    }
000094  bd70              POP      {r4-r6,pc}
;;;313    /*-----------------------------------------------------------*/
                          ENDP

000096  0000              DCW      0x0000
                  |L4.152|
                          DCD      xBlockAllocatedBit
                  |L4.156|
                          DCD      xFreeBytesRemaining
                  |L4.160|
                          DCD      xNumberOfSuccessfulFrees

                          AREA ||i.vPortGetHeapStats||, CODE, READONLY, ALIGN=2

                  vPortGetHeapStats PROC
;;;441    
;;;442    void vPortGetHeapStats( HeapStats_t *pxHeapStats )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;443    {
000004  4604              MOV      r4,r0
;;;444    BlockLink_t *pxBlock;
;;;445    size_t xBlocks = 0, xMaxSize = 0, xMinSize = portMAX_DELAY; /* portMAX_DELAY used as a portable way of getting the maximum value. */
000006  f04f0800          MOV      r8,#0
00000a  2600              MOVS     r6,#0
00000c  1e77              SUBS     r7,r6,#1
;;;446    
;;;447    	vTaskSuspendAll();
00000e  f7fffffe          BL       vTaskSuspendAll
;;;448    	{
;;;449    		pxBlock = xStart.pxNextFreeBlock;
000012  4815              LDR      r0,|L5.104|
000014  6805              LDR      r5,[r0,#0]  ; xStart
;;;450    
;;;451    		/* pxBlock will be NULL if the heap has not been initialised.  The heap
;;;452    		is initialised automatically when the first allocation is made. */
;;;453    		if( pxBlock != NULL )
000016  b17d              CBZ      r5,|L5.56|
;;;454    		{
;;;455    			do
000018  bf00              NOP      
                  |L5.26|
;;;456    			{
;;;457    				/* Increment the number of blocks and record the largest block seen
;;;458    				so far. */
;;;459    				xBlocks++;
00001a  f1080801          ADD      r8,r8,#1
;;;460    
;;;461    				if( pxBlock->xBlockSize > xMaxSize )
00001e  6868              LDR      r0,[r5,#4]
000020  42b0              CMP      r0,r6
000022  d900              BLS      |L5.38|
;;;462    				{
;;;463    					xMaxSize = pxBlock->xBlockSize;
000024  686e              LDR      r6,[r5,#4]
                  |L5.38|
;;;464    				}
;;;465    
;;;466    				if( pxBlock->xBlockSize < xMinSize )
000026  6868              LDR      r0,[r5,#4]
000028  42b8              CMP      r0,r7
00002a  d200              BCS      |L5.46|
;;;467    				{
;;;468    					xMinSize = pxBlock->xBlockSize;
00002c  686f              LDR      r7,[r5,#4]
                  |L5.46|
;;;469    				}
;;;470    
;;;471    				/* Move to the next block in the chain until the last block is
;;;472    				reached. */
;;;473    				pxBlock = pxBlock->pxNextFreeBlock;
00002e  682d              LDR      r5,[r5,#0]
;;;474    			} while( pxBlock != pxEnd );
000030  480e              LDR      r0,|L5.108|
000032  6800              LDR      r0,[r0,#0]  ; pxEnd
000034  4285              CMP      r5,r0
000036  d1f0              BNE      |L5.26|
                  |L5.56|
;;;475    		}
;;;476    	}
;;;477    	xTaskResumeAll();
000038  f7fffffe          BL       xTaskResumeAll
;;;478    
;;;479    	pxHeapStats->xSizeOfLargestFreeBlockInBytes = xMaxSize;
00003c  6066              STR      r6,[r4,#4]
;;;480    	pxHeapStats->xSizeOfSmallestFreeBlockInBytes = xMinSize;
00003e  60a7              STR      r7,[r4,#8]
;;;481    	pxHeapStats->xNumberOfFreeBlocks = xBlocks;
000040  f8c4800c          STR      r8,[r4,#0xc]
;;;482    
;;;483    	taskENTER_CRITICAL();
000044  f7fffffe          BL       vPortEnterCritical
;;;484    	{
;;;485    		pxHeapStats->xAvailableHeapSpaceInBytes = xFreeBytesRemaining;
000048  4809              LDR      r0,|L5.112|
00004a  6800              LDR      r0,[r0,#0]  ; xFreeBytesRemaining
00004c  6020              STR      r0,[r4,#0]
;;;486    		pxHeapStats->xNumberOfSuccessfulAllocations = xNumberOfSuccessfulAllocations;
00004e  4809              LDR      r0,|L5.116|
000050  6800              LDR      r0,[r0,#0]  ; xNumberOfSuccessfulAllocations
000052  6160              STR      r0,[r4,#0x14]
;;;487    		pxHeapStats->xNumberOfSuccessfulFrees = xNumberOfSuccessfulFrees;
000054  4808              LDR      r0,|L5.120|
000056  6800              LDR      r0,[r0,#0]  ; xNumberOfSuccessfulFrees
000058  61a0              STR      r0,[r4,#0x18]
;;;488    		pxHeapStats->xMinimumEverFreeBytesRemaining = xMinimumEverFreeBytesRemaining;
00005a  4808              LDR      r0,|L5.124|
00005c  6800              LDR      r0,[r0,#0]  ; xMinimumEverFreeBytesRemaining
00005e  6120              STR      r0,[r4,#0x10]
;;;489    	}
;;;490    	taskEXIT_CRITICAL();
000060  f7fffffe          BL       vPortExitCritical
;;;491    }
000064  e8bd81f0          POP      {r4-r8,pc}
;;;492    
                          ENDP

                  |L5.104|
                          DCD      xStart
                  |L5.108|
                          DCD      pxEnd
                  |L5.112|
                          DCD      xFreeBytesRemaining
                  |L5.116|
                          DCD      xNumberOfSuccessfulAllocations
                  |L5.120|
                          DCD      xNumberOfSuccessfulFrees
                  |L5.124|
                          DCD      xMinimumEverFreeBytesRemaining

                          AREA ||i.vPortInitialiseBlocks||, CODE, READONLY, ALIGN=1

                  vPortInitialiseBlocks PROC
;;;326    
;;;327    void vPortInitialiseBlocks( void )
000000  4770              BX       lr
;;;328    {
;;;329    	/* This just exists to keep the linker quiet. */
;;;330    }
;;;331    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xPortGetFreeHeapSize||, CODE, READONLY, ALIGN=2

                  xPortGetFreeHeapSize PROC
;;;314    
;;;315    size_t xPortGetFreeHeapSize( void )
000000  4801              LDR      r0,|L7.8|
;;;316    {
;;;317    	return xFreeBytesRemaining;
000002  6800              LDR      r0,[r0,#0]  ; xFreeBytesRemaining
;;;318    }
000004  4770              BX       lr
;;;319    /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      xFreeBytesRemaining

                          AREA ||i.xPortGetMinimumEverFreeHeapSize||, CODE, READONLY, ALIGN=2

                  xPortGetMinimumEverFreeHeapSize PROC
;;;320    
;;;321    size_t xPortGetMinimumEverFreeHeapSize( void )
000000  4801              LDR      r0,|L8.8|
;;;322    {
;;;323    	return xMinimumEverFreeBytesRemaining;
000002  6800              LDR      r0,[r0,#0]  ; xMinimumEverFreeBytesRemaining
;;;324    }
000004  4770              BX       lr
;;;325    /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      xMinimumEverFreeBytesRemaining

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ucHeap
                          %        15360

                          AREA ||.data||, DATA, ALIGN=2

                  xStart
                          %        8
                  pxEnd
                          DCD      0x00000000
                  xFreeBytesRemaining
                          DCD      0x00000000
                  xMinimumEverFreeBytesRemaining
                          DCD      0x00000000
                  xNumberOfSuccessfulAllocations
                          DCD      0x00000000
                  xNumberOfSuccessfulFrees
                          DCD      0x00000000
                  xBlockAllocatedBit
                          DCD      0x00000000
