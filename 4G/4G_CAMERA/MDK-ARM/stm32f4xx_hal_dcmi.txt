; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o4gcamera\stm32f4xx_hal_dcmi.o --asm_dir=.\ --list_dir=.\ --depend=4gcamera\stm32f4xx_hal_dcmi.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../USB_DEVICE/App -I../USB_DEVICE/Target -I../Core/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Middlewares/ST/STM32_USB_Device_Library/Core/Inc -I../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 -I../Middlewares/Third_Party/FreeRTOS/Source/portable/RVDS/ARM_CM4F -I../HARDWARE/OV2640 -I../HARDWARE/WS2812B -I../HARDWARE/RING_BUFFER -I../HARDWARE/FLASH -I.\RTE\_4GCAMERA -IC:\Users\czm\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\czm\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=536 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F407xx --omf_browse=4gcamera\stm32f4xx_hal_dcmi.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_dcmi.c]
                          THUMB

                          AREA ||i.DCMI_DMAError||, CODE, READONLY, ALIGN=1

                  DCMI_DMAError PROC
;;;1123     */
;;;1124   static void DCMI_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1125   {
000002  4605              MOV      r5,r0
;;;1126     DCMI_HandleTypeDef* hdcmi = ( DCMI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;1127     
;;;1128     if(hdcmi->DMA_Handle->ErrorCode != HAL_DMA_ERROR_FE)
000006  6ba0              LDR      r0,[r4,#0x38]
000008  6d40              LDR      r0,[r0,#0x54]
00000a  2802              CMP      r0,#2
00000c  d002              BEQ      |L1.20|
;;;1129     {
;;;1130       /* Initialize the DCMI state*/
;;;1131       hdcmi->State = HAL_DCMI_STATE_READY;
00000e  2001              MOVS     r0,#1
000010  f8840025          STRB     r0,[r4,#0x25]
                  |L1.20|
;;;1132     }
;;;1133   
;;;1134     /* DCMI error Callback */
;;;1135   #if (USE_HAL_DCMI_REGISTER_CALLBACKS == 1)
;;;1136       /*Call registered DCMI error callback*/
;;;1137       hdcmi->ErrorCallback(hdcmi);
;;;1138   #else  
;;;1139     HAL_DCMI_ErrorCallback(hdcmi);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       HAL_DCMI_ErrorCallback
;;;1140   #endif /* USE_HAL_DCMI_REGISTER_CALLBACKS */   
;;;1141   
;;;1142   }
00001a  bd70              POP      {r4-r6,pc}
;;;1143   
                          ENDP


                          AREA ||i.DCMI_DMAXferCplt||, CODE, READONLY, ALIGN=1

                  DCMI_DMAXferCplt PROC
;;;1066     */
;;;1067   static void DCMI_DMAXferCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1068   {
000002  4606              MOV      r6,r0
;;;1069     uint32_t tmp = 0U;
000004  2500              MOVS     r5,#0
;;;1070    
;;;1071     DCMI_HandleTypeDef* hdcmi = ( DCMI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000006  6bb4              LDR      r4,[r6,#0x38]
;;;1072     
;;;1073     if(hdcmi->XferCount != 0U)
000008  6aa0              LDR      r0,[r4,#0x28]
00000a  b368              CBZ      r0,|L2.104|
;;;1074     {
;;;1075       /* Update memory 0 address location */
;;;1076       tmp = ((hdcmi->DMA_Handle->Instance->CR) & DMA_SxCR_CT);
00000c  6ba0              LDR      r0,[r4,#0x38]
00000e  6800              LDR      r0,[r0,#0]
000010  6800              LDR      r0,[r0,#0]
000012  f4002500          AND      r5,r0,#0x80000
;;;1077       if(((hdcmi->XferCount % 2U) == 0U) && (tmp != 0U))
000016  6aa0              LDR      r0,[r4,#0x28]
000018  f0000001          AND      r0,r0,#1
00001c  b978              CBNZ     r0,|L2.62|
00001e  b175              CBZ      r5,|L2.62|
;;;1078       {
;;;1079         tmp = hdcmi->DMA_Handle->Instance->M0AR;
000020  6ba0              LDR      r0,[r4,#0x38]
000022  6800              LDR      r0,[r0,#0]
000024  68c5              LDR      r5,[r0,#0xc]
;;;1080         HAL_DMAEx_ChangeMemory(hdcmi->DMA_Handle, (tmp + (8U*hdcmi->XferSize)), MEMORY0);
000026  6ae2              LDR      r2,[r4,#0x2c]
000028  2308              MOVS     r3,#8
00002a  fb035102          MLA      r1,r3,r2,r5
00002e  2200              MOVS     r2,#0
000030  6ba0              LDR      r0,[r4,#0x38]
000032  f7fffffe          BL       HAL_DMAEx_ChangeMemory
;;;1081         hdcmi->XferCount--;
000036  6aa0              LDR      r0,[r4,#0x28]
000038  1e40              SUBS     r0,r0,#1
00003a  62a0              STR      r0,[r4,#0x28]
00003c  e02f              B        |L2.158|
                  |L2.62|
;;;1082       }
;;;1083       /* Update memory 1 address location */
;;;1084       else if((hdcmi->DMA_Handle->Instance->CR & DMA_SxCR_CT) == 0U)
00003e  6ba0              LDR      r0,[r4,#0x38]
000040  6800              LDR      r0,[r0,#0]
000042  6800              LDR      r0,[r0,#0]
000044  f4002000          AND      r0,r0,#0x80000
000048  bb48              CBNZ     r0,|L2.158|
;;;1085       {
;;;1086         tmp = hdcmi->DMA_Handle->Instance->M1AR;
00004a  6ba0              LDR      r0,[r4,#0x38]
00004c  6800              LDR      r0,[r0,#0]
00004e  6905              LDR      r5,[r0,#0x10]
;;;1087         HAL_DMAEx_ChangeMemory(hdcmi->DMA_Handle, (tmp + (8U*hdcmi->XferSize)), MEMORY1);
000050  6ae2              LDR      r2,[r4,#0x2c]
000052  2308              MOVS     r3,#8
000054  fb035102          MLA      r1,r3,r2,r5
000058  2201              MOVS     r2,#1
00005a  6ba0              LDR      r0,[r4,#0x38]
00005c  f7fffffe          BL       HAL_DMAEx_ChangeMemory
;;;1088         hdcmi->XferCount--;
000060  6aa0              LDR      r0,[r4,#0x28]
000062  1e40              SUBS     r0,r0,#1
000064  62a0              STR      r0,[r4,#0x28]
000066  e01a              B        |L2.158|
                  |L2.104|
;;;1089       }
;;;1090     }
;;;1091     /* Update memory 0 address location */
;;;1092     else if((hdcmi->DMA_Handle->Instance->CR & DMA_SxCR_CT) != 0U)
000068  6ba0              LDR      r0,[r4,#0x38]
00006a  6800              LDR      r0,[r0,#0]
00006c  6800              LDR      r0,[r0,#0]
00006e  f4002000          AND      r0,r0,#0x80000
000072  b120              CBZ      r0,|L2.126|
;;;1093     {
;;;1094       hdcmi->DMA_Handle->Instance->M0AR = hdcmi->pBuffPtr;
000074  e9d4010d          LDRD     r0,r1,[r4,#0x34]
000078  6809              LDR      r1,[r1,#0]
00007a  60c8              STR      r0,[r1,#0xc]
00007c  e00f              B        |L2.158|
                  |L2.126|
;;;1095     }
;;;1096     /* Update memory 1 address location */
;;;1097     else if((hdcmi->DMA_Handle->Instance->CR & DMA_SxCR_CT) == 0U)
00007e  6ba0              LDR      r0,[r4,#0x38]
000080  6800              LDR      r0,[r0,#0]
000082  6800              LDR      r0,[r0,#0]
000084  f4002000          AND      r0,r0,#0x80000
000088  b948              CBNZ     r0,|L2.158|
;;;1098     {
;;;1099       tmp = hdcmi->pBuffPtr;
00008a  6b65              LDR      r5,[r4,#0x34]
;;;1100       hdcmi->DMA_Handle->Instance->M1AR = (tmp + (4U*hdcmi->XferSize));
00008c  6ae0              LDR      r0,[r4,#0x2c]
00008e  2104              MOVS     r1,#4
000090  fb015000          MLA      r0,r1,r0,r5
000094  6ba1              LDR      r1,[r4,#0x38]
000096  6809              LDR      r1,[r1,#0]
000098  6108              STR      r0,[r1,#0x10]
;;;1101       hdcmi->XferCount = hdcmi->XferTransferNumber;
00009a  6b20              LDR      r0,[r4,#0x30]
00009c  62a0              STR      r0,[r4,#0x28]
                  |L2.158|
;;;1102     }
;;;1103     
;;;1104     /* Check if the frame is transferred */
;;;1105     if(hdcmi->XferCount == hdcmi->XferTransferNumber)
00009e  6aa0              LDR      r0,[r4,#0x28]
0000a0  6b21              LDR      r1,[r4,#0x30]
0000a2  4288              CMP      r0,r1
0000a4  d10e              BNE      |L2.196|
;;;1106     {
;;;1107       /* Enable the Frame interrupt */
;;;1108       __HAL_DCMI_ENABLE_IT(hdcmi, DCMI_IT_FRAME);
0000a6  6820              LDR      r0,[r4,#0]
0000a8  68c0              LDR      r0,[r0,#0xc]
0000aa  f0400001          ORR      r0,r0,#1
0000ae  6821              LDR      r1,[r4,#0]
0000b0  60c8              STR      r0,[r1,#0xc]
;;;1109       
;;;1110       /* When snapshot mode, set dcmi state to ready */
;;;1111       if((hdcmi->Instance->CR & DCMI_CR_CM) == DCMI_MODE_SNAPSHOT)
0000b2  6820              LDR      r0,[r4,#0]
0000b4  6800              LDR      r0,[r0,#0]
0000b6  f0000002          AND      r0,r0,#2
0000ba  2802              CMP      r0,#2
0000bc  d102              BNE      |L2.196|
;;;1112       {  
;;;1113         hdcmi->State= HAL_DCMI_STATE_READY;
0000be  2001              MOVS     r0,#1
0000c0  f8840025          STRB     r0,[r4,#0x25]
                  |L2.196|
;;;1114       }
;;;1115     }
;;;1116   }
0000c4  bd70              POP      {r4-r6,pc}
;;;1117   
                          ENDP


                          AREA ||i.HAL_DCMI_ConfigCrop||, CODE, READONLY, ALIGN=1

                  HAL_DCMI_ConfigCrop PROC
;;;734      */
;;;735    HAL_StatusTypeDef HAL_DCMI_ConfigCrop(DCMI_HandleTypeDef *hdcmi, uint32_t X0, uint32_t Y0, uint32_t XSize, uint32_t YSize)
000000  b570              PUSH     {r4-r6,lr}
;;;736    {
000002  4604              MOV      r4,r0
000004  9d04              LDR      r5,[sp,#0x10]
;;;737      /* Process Locked */
;;;738      __HAL_LOCK(hdcmi);
000006  bf00              NOP      
000008  f8940024          LDRB     r0,[r4,#0x24]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L3.20|
000010  2002              MOVS     r0,#2
                  |L3.18|
;;;739    
;;;740      /* Lock the DCMI peripheral state */
;;;741      hdcmi->State = HAL_DCMI_STATE_BUSY;
;;;742    
;;;743      /* Check the parameters */
;;;744      assert_param(IS_DCMI_WINDOW_COORDINATE(X0));
;;;745      assert_param(IS_DCMI_WINDOW_COORDINATE(YSize));
;;;746      assert_param(IS_DCMI_WINDOW_COORDINATE(XSize));
;;;747      assert_param(IS_DCMI_WINDOW_HEIGHT(Y0));
;;;748    
;;;749      /* Configure CROP */
;;;750      hdcmi->Instance->CWSIZER = (XSize | (YSize << DCMI_POSITION_CWSIZE_VLINE));
;;;751      hdcmi->Instance->CWSTRTR = (X0 | (Y0 << DCMI_POSITION_CWSTRT_VST));
;;;752    
;;;753      /* Initialize the DCMI state*/
;;;754      hdcmi->State  = HAL_DCMI_STATE_READY;
;;;755    
;;;756      /* Process Unlocked */
;;;757      __HAL_UNLOCK(hdcmi);
;;;758    
;;;759      return HAL_OK;
;;;760    }
000012  bd70              POP      {r4-r6,pc}
                  |L3.20|
000014  2001              MOVS     r0,#1                 ;738
000016  f8840024          STRB     r0,[r4,#0x24]         ;738
00001a  bf00              NOP                            ;738
00001c  2002              MOVS     r0,#2                 ;741
00001e  f8840025          STRB     r0,[r4,#0x25]         ;741
000022  ea434005          ORR      r0,r3,r5,LSL #16      ;750
000026  6826              LDR      r6,[r4,#0]            ;750
000028  6270              STR      r0,[r6,#0x24]         ;750
00002a  ea414002          ORR      r0,r1,r2,LSL #16      ;751
00002e  6826              LDR      r6,[r4,#0]            ;751
000030  6230              STR      r0,[r6,#0x20]         ;751
000032  2001              MOVS     r0,#1                 ;754
000034  f8840025          STRB     r0,[r4,#0x25]         ;754
000038  bf00              NOP                            ;757
00003a  2000              MOVS     r0,#0                 ;757
00003c  f8840024          STRB     r0,[r4,#0x24]         ;757
000040  bf00              NOP                            ;757
000042  bf00              NOP                            ;759
000044  e7e5              B        |L3.18|
;;;761    
                          ENDP


                          AREA ||i.HAL_DCMI_ConfigSyncUnmask||, CODE, READONLY, ALIGN=1

                  HAL_DCMI_ConfigSyncUnmask PROC
;;;821      */
;;;822    HAL_StatusTypeDef  HAL_DCMI_ConfigSyncUnmask(DCMI_HandleTypeDef *hdcmi, DCMI_SyncUnmaskTypeDef *SyncUnmask)
000000  4602              MOV      r2,r0
;;;823    {
;;;824      /* Process Locked */
;;;825      __HAL_LOCK(hdcmi);
000002  bf00              NOP      
000004  f8920024          LDRB     r0,[r2,#0x24]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L4.16|
00000c  2002              MOVS     r0,#2
                  |L4.14|
;;;826    
;;;827      /* Lock the DCMI peripheral state */
;;;828      hdcmi->State = HAL_DCMI_STATE_BUSY;
;;;829    
;;;830      /* Write DCMI embedded synchronization unmask register */
;;;831      hdcmi->Instance->ESUR = (((uint32_t)SyncUnmask->FrameStartUnmask) |\
;;;832                               ((uint32_t)SyncUnmask->LineStartUnmask << DCMI_ESUR_LSU_Pos)|\
;;;833                               ((uint32_t)SyncUnmask->LineEndUnmask << DCMI_ESUR_LEU_Pos)|\
;;;834                               ((uint32_t)SyncUnmask->FrameEndUnmask << DCMI_ESUR_FEU_Pos));
;;;835    
;;;836      /* Change the DCMI state*/
;;;837      hdcmi->State = HAL_DCMI_STATE_READY;
;;;838    
;;;839      /* Process Unlocked */
;;;840      __HAL_UNLOCK(hdcmi);
;;;841    
;;;842      return HAL_OK;
;;;843    }
00000e  4770              BX       lr
                  |L4.16|
000010  2001              MOVS     r0,#1                 ;825
000012  f8820024          STRB     r0,[r2,#0x24]         ;825
000016  bf00              NOP                            ;825
000018  2002              MOVS     r0,#2                 ;828
00001a  f8820025          STRB     r0,[r2,#0x25]         ;828
00001e  7808              LDRB     r0,[r1,#0]            ;831
000020  784b              LDRB     r3,[r1,#1]            ;831
000022  ea402003          ORR      r0,r0,r3,LSL #8       ;831
000026  788b              LDRB     r3,[r1,#2]            ;831
000028  ea404003          ORR      r0,r0,r3,LSL #16      ;831
00002c  78cb              LDRB     r3,[r1,#3]            ;831
00002e  ea406003          ORR      r0,r0,r3,LSL #24      ;831
000032  6813              LDR      r3,[r2,#0]            ;831
000034  61d8              STR      r0,[r3,#0x1c]         ;831
000036  2001              MOVS     r0,#1                 ;837
000038  f8820025          STRB     r0,[r2,#0x25]         ;837
00003c  bf00              NOP                            ;840
00003e  2000              MOVS     r0,#0                 ;840
000040  f8820024          STRB     r0,[r2,#0x24]         ;840
000044  bf00              NOP                            ;840
000046  bf00              NOP                            ;842
000048  e7e1              B        |L4.14|
;;;844    
                          ENDP


                          AREA ||i.HAL_DCMI_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_DCMI_DeInit PROC
;;;261    
;;;262    HAL_StatusTypeDef HAL_DCMI_DeInit(DCMI_HandleTypeDef *hdcmi)
000000  b510              PUSH     {r4,lr}
;;;263    {
000002  4604              MOV      r4,r0
;;;264    #if (USE_HAL_DCMI_REGISTER_CALLBACKS == 1)  
;;;265      if(hdcmi->MspDeInitCallback == NULL)  
;;;266      {
;;;267        hdcmi->MspDeInitCallback = HAL_DCMI_MspDeInit;
;;;268      }
;;;269      /* De-Initialize the low level hardware (MSP) */
;;;270      hdcmi->MspDeInitCallback(hdcmi);
;;;271    #else
;;;272      /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;273      HAL_DCMI_MspDeInit(hdcmi);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       HAL_DCMI_MspDeInit
;;;274    #endif /* (USE_HAL_DCMI_REGISTER_CALLBACKS) */
;;;275    
;;;276      /* Update error code */
;;;277      hdcmi->ErrorCode = HAL_DCMI_ERROR_NONE;
00000a  2000              MOVS     r0,#0
00000c  63e0              STR      r0,[r4,#0x3c]
;;;278    
;;;279      /* Initialize the DCMI state*/
;;;280      hdcmi->State = HAL_DCMI_STATE_RESET;
00000e  f8840025          STRB     r0,[r4,#0x25]
;;;281    
;;;282      /* Release Lock */
;;;283      __HAL_UNLOCK(hdcmi);
000012  bf00              NOP      
000014  f8840024          STRB     r0,[r4,#0x24]
000018  bf00              NOP      
;;;284    
;;;285      return HAL_OK;
;;;286    }
00001a  bd10              POP      {r4,pc}
;;;287    
                          ENDP


                          AREA ||i.HAL_DCMI_DisableCrop||, CODE, READONLY, ALIGN=1

                  HAL_DCMI_DisableCrop PROC
;;;767      */
;;;768    HAL_StatusTypeDef HAL_DCMI_DisableCrop(DCMI_HandleTypeDef *hdcmi)
000000  4601              MOV      r1,r0
;;;769    {
;;;770      /* Process Locked */
;;;771      __HAL_LOCK(hdcmi);
000002  bf00              NOP      
000004  f8910024          LDRB     r0,[r1,#0x24]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L6.16|
00000c  2002              MOVS     r0,#2
                  |L6.14|
;;;772    
;;;773      /* Lock the DCMI peripheral state */
;;;774      hdcmi->State = HAL_DCMI_STATE_BUSY;
;;;775    
;;;776      /* Disable DCMI Crop feature */
;;;777      hdcmi->Instance->CR &= ~(uint32_t)DCMI_CR_CROP;
;;;778    
;;;779      /* Change the DCMI state*/
;;;780      hdcmi->State = HAL_DCMI_STATE_READY;
;;;781    
;;;782      /* Process Unlocked */
;;;783      __HAL_UNLOCK(hdcmi);
;;;784    
;;;785      return HAL_OK;
;;;786    }
00000e  4770              BX       lr
                  |L6.16|
000010  2001              MOVS     r0,#1                 ;771
000012  f8810024          STRB     r0,[r1,#0x24]         ;771
000016  bf00              NOP                            ;771
000018  2002              MOVS     r0,#2                 ;774
00001a  f8810025          STRB     r0,[r1,#0x25]         ;774
00001e  6808              LDR      r0,[r1,#0]            ;777
000020  6800              LDR      r0,[r0,#0]            ;777
000022  f0200004          BIC      r0,r0,#4              ;777
000026  680a              LDR      r2,[r1,#0]            ;777
000028  6010              STR      r0,[r2,#0]            ;777
00002a  2001              MOVS     r0,#1                 ;780
00002c  f8810025          STRB     r0,[r1,#0x25]         ;780
000030  bf00              NOP                            ;783
000032  2000              MOVS     r0,#0                 ;783
000034  f8810024          STRB     r0,[r1,#0x24]         ;783
000038  bf00              NOP                            ;783
00003a  bf00              NOP                            ;785
00003c  e7e7              B        |L6.14|
;;;787    
                          ENDP


                          AREA ||i.HAL_DCMI_EnableCrop||, CODE, READONLY, ALIGN=1

                  HAL_DCMI_EnableCrop PROC
;;;793      */
;;;794    HAL_StatusTypeDef HAL_DCMI_EnableCrop(DCMI_HandleTypeDef *hdcmi)
000000  4601              MOV      r1,r0
;;;795    {
;;;796      /* Process Locked */
;;;797      __HAL_LOCK(hdcmi);
000002  bf00              NOP      
000004  f8910024          LDRB     r0,[r1,#0x24]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L7.16|
00000c  2002              MOVS     r0,#2
                  |L7.14|
;;;798    
;;;799      /* Lock the DCMI peripheral state */
;;;800      hdcmi->State = HAL_DCMI_STATE_BUSY;
;;;801    
;;;802      /* Enable DCMI Crop feature */
;;;803      hdcmi->Instance->CR |= (uint32_t)DCMI_CR_CROP;
;;;804    
;;;805      /* Change the DCMI state*/
;;;806      hdcmi->State = HAL_DCMI_STATE_READY;
;;;807    
;;;808      /* Process Unlocked */
;;;809      __HAL_UNLOCK(hdcmi);
;;;810    
;;;811      return HAL_OK;
;;;812    }
00000e  4770              BX       lr
                  |L7.16|
000010  2001              MOVS     r0,#1                 ;797
000012  f8810024          STRB     r0,[r1,#0x24]         ;797
000016  bf00              NOP                            ;797
000018  2002              MOVS     r0,#2                 ;800
00001a  f8810025          STRB     r0,[r1,#0x25]         ;800
00001e  6808              LDR      r0,[r1,#0]            ;803
000020  6800              LDR      r0,[r0,#0]            ;803
000022  f0400004          ORR      r0,r0,#4              ;803
000026  680a              LDR      r2,[r1,#0]            ;803
000028  6010              STR      r0,[r2,#0]            ;803
00002a  2001              MOVS     r0,#1                 ;806
00002c  f8810025          STRB     r0,[r1,#0x25]         ;806
000030  bf00              NOP                            ;809
000032  2000              MOVS     r0,#0                 ;809
000034  f8810024          STRB     r0,[r1,#0x24]         ;809
000038  bf00              NOP                            ;809
00003a  bf00              NOP                            ;811
00003c  e7e7              B        |L7.14|
;;;813    
                          ENDP


                          AREA ||i.HAL_DCMI_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_DCMI_ErrorCallback PROC
;;;651      */
;;;652    __weak void HAL_DCMI_ErrorCallback(DCMI_HandleTypeDef *hdcmi)
000000  4770              BX       lr
;;;653    {
;;;654      /* Prevent unused argument(s) compilation warning */
;;;655      UNUSED(hdcmi);
;;;656      /* NOTE : This function Should not be modified, when the callback is needed,
;;;657                the HAL_DCMI_ErrorCallback could be implemented in the user file
;;;658       */
;;;659    }
;;;660    
                          ENDP


                          AREA ||i.HAL_DCMI_FrameEventCallback||, CODE, READONLY, ALIGN=1

                  HAL_DCMI_FrameEventCallback PROC
;;;696      */
;;;697    __weak void HAL_DCMI_FrameEventCallback(DCMI_HandleTypeDef *hdcmi)
000000  4770              BX       lr
;;;698    {
;;;699      /* Prevent unused argument(s) compilation warning */
;;;700      UNUSED(hdcmi);
;;;701      /* NOTE : This function Should not be modified, when the callback is needed,
;;;702                the HAL_DCMI_FrameEventCallback could be implemented in the user file
;;;703       */
;;;704    }
;;;705    
                          ENDP


                          AREA ||i.HAL_DCMI_GetError||, CODE, READONLY, ALIGN=1

                  HAL_DCMI_GetError PROC
;;;881      */
;;;882    uint32_t HAL_DCMI_GetError(DCMI_HandleTypeDef *hdcmi)
000000  4601              MOV      r1,r0
;;;883    {
;;;884      return hdcmi->ErrorCode;
000002  6bc8              LDR      r0,[r1,#0x3c]
;;;885    }
000004  4770              BX       lr
;;;886    
                          ENDP


                          AREA ||i.HAL_DCMI_GetState||, CODE, READONLY, ALIGN=1

                  HAL_DCMI_GetState PROC
;;;870      */
;;;871    HAL_DCMI_StateTypeDef HAL_DCMI_GetState(DCMI_HandleTypeDef *hdcmi)
000000  4601              MOV      r1,r0
;;;872    {
;;;873      return hdcmi->State;
000002  f8910025          LDRB     r0,[r1,#0x25]
;;;874    }
000006  4770              BX       lr
;;;875    
                          ENDP


                          AREA ||i.HAL_DCMI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_DCMI_IRQHandler PROC
;;;554      */
;;;555    void HAL_DCMI_IRQHandler(DCMI_HandleTypeDef *hdcmi)
000000  b570              PUSH     {r4-r6,lr}
;;;556    {
000002  4604              MOV      r4,r0
;;;557      uint32_t isr_value = READ_REG(hdcmi->Instance->MISR);
000004  6820              LDR      r0,[r4,#0]
000006  6905              LDR      r5,[r0,#0x10]
;;;558    
;;;559      /* Synchronization error interrupt management *******************************/
;;;560      if((isr_value & DCMI_FLAG_ERRRI) == DCMI_FLAG_ERRRI)
000008  f0050004          AND      r0,r5,#4
00000c  2804              CMP      r0,#4
00000e  d10e              BNE      |L12.46|
;;;561      {
;;;562        /* Clear the Synchronization error flag */
;;;563        __HAL_DCMI_CLEAR_FLAG(hdcmi, DCMI_FLAG_ERRRI);
000010  6821              LDR      r1,[r4,#0]
000012  6148              STR      r0,[r1,#0x14]
;;;564    
;;;565        /* Update error code */
;;;566        hdcmi->ErrorCode |= HAL_DCMI_ERROR_SYNC;
000014  6be0              LDR      r0,[r4,#0x3c]
000016  f0400002          ORR      r0,r0,#2
00001a  63e0              STR      r0,[r4,#0x3c]
;;;567    
;;;568        /* Change DCMI state */
;;;569        hdcmi->State = HAL_DCMI_STATE_ERROR;
00001c  2004              MOVS     r0,#4
00001e  f8840025          STRB     r0,[r4,#0x25]
;;;570        
;;;571        /* Set the synchronization error callback */
;;;572        hdcmi->DMA_Handle->XferAbortCallback = DCMI_DMAError;
000022  4822              LDR      r0,|L12.172|
000024  6ba1              LDR      r1,[r4,#0x38]
000026  6508              STR      r0,[r1,#0x50]
;;;573    
;;;574        /* Abort the DMA Transfer */
;;;575        HAL_DMA_Abort_IT(hdcmi->DMA_Handle);
000028  6ba0              LDR      r0,[r4,#0x38]
00002a  f7fffffe          BL       HAL_DMA_Abort_IT
                  |L12.46|
;;;576      }
;;;577      /* Overflow interrupt management ********************************************/
;;;578      if((isr_value & DCMI_FLAG_OVRRI) == DCMI_FLAG_OVRRI)
00002e  f0050002          AND      r0,r5,#2
000032  2802              CMP      r0,#2
000034  d10e              BNE      |L12.84|
;;;579      {
;;;580        /* Clear the Overflow flag */
;;;581        __HAL_DCMI_CLEAR_FLAG(hdcmi, DCMI_FLAG_OVRRI);
000036  6821              LDR      r1,[r4,#0]
000038  6148              STR      r0,[r1,#0x14]
;;;582    
;;;583        /* Update error code */
;;;584        hdcmi->ErrorCode |= HAL_DCMI_ERROR_OVR;
00003a  6be0              LDR      r0,[r4,#0x3c]
00003c  f0400001          ORR      r0,r0,#1
000040  63e0              STR      r0,[r4,#0x3c]
;;;585    
;;;586        /* Change DCMI state */
;;;587        hdcmi->State = HAL_DCMI_STATE_ERROR;
000042  2004              MOVS     r0,#4
000044  f8840025          STRB     r0,[r4,#0x25]
;;;588        
;;;589        /* Set the overflow callback */
;;;590        hdcmi->DMA_Handle->XferAbortCallback = DCMI_DMAError;
000048  4818              LDR      r0,|L12.172|
00004a  6ba1              LDR      r1,[r4,#0x38]
00004c  6508              STR      r0,[r1,#0x50]
;;;591    
;;;592        /* Abort the DMA Transfer */
;;;593        HAL_DMA_Abort_IT(hdcmi->DMA_Handle);
00004e  6ba0              LDR      r0,[r4,#0x38]
000050  f7fffffe          BL       HAL_DMA_Abort_IT
                  |L12.84|
;;;594      }
;;;595      /* Line Interrupt management ************************************************/
;;;596      if((isr_value & DCMI_FLAG_LINERI) == DCMI_FLAG_LINERI)
000054  f0050010          AND      r0,r5,#0x10
000058  2810              CMP      r0,#0x10
00005a  d104              BNE      |L12.102|
;;;597      {
;;;598        /* Clear the Line interrupt flag */
;;;599        __HAL_DCMI_CLEAR_FLAG(hdcmi, DCMI_FLAG_LINERI);
00005c  6821              LDR      r1,[r4,#0]
00005e  6148              STR      r0,[r1,#0x14]
;;;600        
;;;601        /* Line interrupt Callback */
;;;602    #if (USE_HAL_DCMI_REGISTER_CALLBACKS == 1)
;;;603        /*Call registered DCMI line event callback*/
;;;604        hdcmi->LineEventCallback(hdcmi);
;;;605    #else  
;;;606        HAL_DCMI_LineEventCallback(hdcmi);
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       HAL_DCMI_LineEventCallback
                  |L12.102|
;;;607    #endif /* USE_HAL_DCMI_REGISTER_CALLBACKS */     
;;;608      }
;;;609      /* VSYNC interrupt management ***********************************************/
;;;610      if((isr_value & DCMI_FLAG_VSYNCRI) == DCMI_FLAG_VSYNCRI)
000066  f0050008          AND      r0,r5,#8
00006a  2808              CMP      r0,#8
00006c  d104              BNE      |L12.120|
;;;611      {
;;;612        /* Clear the VSYNC flag */
;;;613        __HAL_DCMI_CLEAR_FLAG(hdcmi, DCMI_FLAG_VSYNCRI);
00006e  6821              LDR      r1,[r4,#0]
000070  6148              STR      r0,[r1,#0x14]
;;;614        
;;;615        /* VSYNC Callback */
;;;616    #if (USE_HAL_DCMI_REGISTER_CALLBACKS == 1)
;;;617        /*Call registered DCMI vsync event callback*/
;;;618        hdcmi->VsyncEventCallback(hdcmi);
;;;619    #else  
;;;620        HAL_DCMI_VsyncEventCallback(hdcmi);
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       HAL_DCMI_VsyncEventCallback
                  |L12.120|
;;;621    #endif /* USE_HAL_DCMI_REGISTER_CALLBACKS */ 
;;;622      }
;;;623      /* FRAME interrupt management ***********************************************/
;;;624      if((isr_value & DCMI_FLAG_FRAMERI) == DCMI_FLAG_FRAMERI)
000078  f0050001          AND      r0,r5,#1
00007c  b1a0              CBZ      r0,|L12.168|
;;;625      {
;;;626        /* When snapshot mode, disable Vsync, Error and Overrun interrupts */
;;;627        if((hdcmi->Instance->CR & DCMI_CR_CM) == DCMI_MODE_SNAPSHOT)
00007e  6820              LDR      r0,[r4,#0]
000080  6800              LDR      r0,[r0,#0]
000082  f0000002          AND      r0,r0,#2
000086  2802              CMP      r0,#2
000088  d105              BNE      |L12.150|
;;;628        { 
;;;629          /* Disable the Line, Vsync, Error and Overrun interrupts */
;;;630          __HAL_DCMI_DISABLE_IT(hdcmi, DCMI_IT_LINE | DCMI_IT_VSYNC | DCMI_IT_ERR | DCMI_IT_OVR);
00008a  6820              LDR      r0,[r4,#0]
00008c  68c0              LDR      r0,[r0,#0xc]
00008e  f020001e          BIC      r0,r0,#0x1e
000092  6821              LDR      r1,[r4,#0]
000094  60c8              STR      r0,[r1,#0xc]
                  |L12.150|
;;;631        }
;;;632    
;;;633        /* Disable the Frame interrupt */
;;;634        __HAL_DCMI_DISABLE_IT(hdcmi, DCMI_IT_FRAME);
000096  6820              LDR      r0,[r4,#0]
000098  68c0              LDR      r0,[r0,#0xc]
00009a  f0200001          BIC      r0,r0,#1
00009e  6821              LDR      r1,[r4,#0]
0000a0  60c8              STR      r0,[r1,#0xc]
;;;635    
;;;636        /* Frame Callback */
;;;637    #if (USE_HAL_DCMI_REGISTER_CALLBACKS == 1)
;;;638        /*Call registered DCMI frame event callback*/
;;;639        hdcmi->FrameEventCallback(hdcmi);
;;;640    #else  
;;;641        HAL_DCMI_FrameEventCallback(hdcmi);
0000a2  4620              MOV      r0,r4
0000a4  f7fffffe          BL       HAL_DCMI_FrameEventCallback
                  |L12.168|
;;;642    #endif /* USE_HAL_DCMI_REGISTER_CALLBACKS */      
;;;643      }
;;;644    }
0000a8  bd70              POP      {r4-r6,pc}
;;;645    
                          ENDP

0000aa  0000              DCW      0x0000
                  |L12.172|
                          DCD      DCMI_DMAError

                          AREA ||i.HAL_DCMI_Init||, CODE, READONLY, ALIGN=1

                  HAL_DCMI_Init PROC
;;;176      */
;;;177    __weak HAL_StatusTypeDef HAL_DCMI_Init(DCMI_HandleTypeDef *hdcmi)
000000  b510              PUSH     {r4,lr}
;;;178    {
000002  4604              MOV      r4,r0
;;;179      /* Check the DCMI peripheral state */
;;;180      if(hdcmi == NULL)
000004  b90c              CBNZ     r4,|L13.10|
;;;181      {
;;;182         return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L13.8|
;;;183      }
;;;184    
;;;185      /* Check function parameters */
;;;186      assert_param(IS_DCMI_ALL_INSTANCE(hdcmi->Instance));
;;;187      assert_param(IS_DCMI_PCKPOLARITY(hdcmi->Init.PCKPolarity));
;;;188      assert_param(IS_DCMI_VSPOLARITY(hdcmi->Init.VSPolarity));
;;;189      assert_param(IS_DCMI_HSPOLARITY(hdcmi->Init.HSPolarity));
;;;190      assert_param(IS_DCMI_SYNCHRO(hdcmi->Init.SynchroMode));
;;;191      assert_param(IS_DCMI_CAPTURE_RATE(hdcmi->Init.CaptureRate));
;;;192      assert_param(IS_DCMI_EXTENDED_DATA(hdcmi->Init.ExtendedDataMode));
;;;193      assert_param(IS_DCMI_MODE_JPEG(hdcmi->Init.JPEGMode));
;;;194    
;;;195      if(hdcmi->State == HAL_DCMI_STATE_RESET)
;;;196      {
;;;197        /* Allocate lock resource and initialize it */
;;;198        hdcmi->Lock = HAL_UNLOCKED;
;;;199        /* Init the low level hardware */
;;;200      /* Init the DCMI Callback settings */
;;;201    #if (USE_HAL_DCMI_REGISTER_CALLBACKS == 1)
;;;202        hdcmi->FrameEventCallback = HAL_DCMI_FrameEventCallback; /* Legacy weak FrameEventCallback  */ 
;;;203        hdcmi->VsyncEventCallback = HAL_DCMI_VsyncEventCallback; /* Legacy weak VsyncEventCallback  */ 
;;;204        hdcmi->LineEventCallback  = HAL_DCMI_LineEventCallback;  /* Legacy weak LineEventCallback   */  
;;;205        hdcmi->ErrorCallback      = HAL_DCMI_ErrorCallback;      /* Legacy weak ErrorCallback       */ 
;;;206        
;;;207        if(hdcmi->MspInitCallback == NULL)  
;;;208        {
;;;209          /* Legacy weak MspInit Callback        */
;;;210          hdcmi->MspInitCallback = HAL_DCMI_MspInit;
;;;211        }
;;;212        /* Initialize the low level hardware (MSP) */
;;;213        hdcmi->MspInitCallback(hdcmi);
;;;214    #else  
;;;215        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;216        HAL_DCMI_MspInit(hdcmi);
;;;217    #endif /* (USE_HAL_DCMI_REGISTER_CALLBACKS) */
;;;218        HAL_DCMI_MspInit(hdcmi);
;;;219      }
;;;220    
;;;221      /* Change the DCMI state */
;;;222      hdcmi->State = HAL_DCMI_STATE_BUSY;
;;;223    
;;;224      /* Set DCMI parameters */
;;;225      /* Configures the HS, VS, DE and PC polarity */
;;;226      hdcmi->Instance->CR &= ~(DCMI_CR_PCKPOL | DCMI_CR_HSPOL  | DCMI_CR_VSPOL  | DCMI_CR_EDM_0 |
;;;227                               DCMI_CR_EDM_1  | DCMI_CR_FCRC_0 | DCMI_CR_FCRC_1 | DCMI_CR_JPEG  |
;;;228                               DCMI_CR_ESS);
;;;229      hdcmi->Instance->CR |=  (uint32_t)(hdcmi->Init.SynchroMode | hdcmi->Init.CaptureRate | \
;;;230                                         hdcmi->Init.VSPolarity  | hdcmi->Init.HSPolarity  | \
;;;231                                         hdcmi->Init.PCKPolarity | hdcmi->Init.ExtendedDataMode | \
;;;232                                         hdcmi->Init.JPEGMode);
;;;233    
;;;234      if(hdcmi->Init.SynchroMode == DCMI_SYNCHRO_EMBEDDED)
;;;235      {
;;;236        hdcmi->Instance->ESCR = (((uint32_t)hdcmi->Init.SyncroCode.FrameStartCode)    |
;;;237                                 ((uint32_t)hdcmi->Init.SyncroCode.LineStartCode << DCMI_POSITION_ESCR_LSC)|
;;;238                                 ((uint32_t)hdcmi->Init.SyncroCode.LineEndCode << DCMI_POSITION_ESCR_LEC) |
;;;239                                 ((uint32_t)hdcmi->Init.SyncroCode.FrameEndCode << DCMI_POSITION_ESCR_FEC));
;;;240      }
;;;241    
;;;242      /* Enable the Line, Vsync, Error and Overrun interrupts */
;;;243      __HAL_DCMI_ENABLE_IT(hdcmi, DCMI_IT_LINE | DCMI_IT_VSYNC | DCMI_IT_ERR | DCMI_IT_OVR);
;;;244    
;;;245      /* Update error code */
;;;246      hdcmi->ErrorCode = HAL_DCMI_ERROR_NONE;
;;;247    
;;;248      /* Initialize the DCMI state*/
;;;249      hdcmi->State  = HAL_DCMI_STATE_READY;
;;;250    
;;;251      return HAL_OK;
;;;252    }
000008  bd10              POP      {r4,pc}
                  |L13.10|
00000a  f8940025          LDRB     r0,[r4,#0x25]         ;195
00000e  b940              CBNZ     r0,|L13.34|
000010  2000              MOVS     r0,#0                 ;198
000012  f8840024          STRB     r0,[r4,#0x24]         ;198
000016  4620              MOV      r0,r4                 ;216
000018  f7fffffe          BL       HAL_DCMI_MspInit
00001c  4620              MOV      r0,r4                 ;218
00001e  f7fffffe          BL       HAL_DCMI_MspInit
                  |L13.34|
000022  2002              MOVS     r0,#2                 ;222
000024  f8840025          STRB     r0,[r4,#0x25]         ;222
000028  6820              LDR      r0,[r4,#0]            ;226
00002a  6800              LDR      r0,[r0,#0]            ;226
00002c  f64071f8          MOV      r1,#0xff8             ;226
000030  4388              BICS     r0,r0,r1              ;226
000032  6821              LDR      r1,[r4,#0]            ;226
000034  6008              STR      r0,[r1,#0]            ;226
000036  6961              LDR      r1,[r4,#0x14]         ;229
000038  6860              LDR      r0,[r4,#4]            ;229
00003a  4308              ORRS     r0,r0,r1              ;229
00003c  68e1              LDR      r1,[r4,#0xc]          ;229
00003e  4308              ORRS     r0,r0,r1              ;229
000040  6921              LDR      r1,[r4,#0x10]         ;229
000042  4308              ORRS     r0,r0,r1              ;229
000044  68a1              LDR      r1,[r4,#8]            ;229
000046  4308              ORRS     r0,r0,r1              ;229
000048  69a1              LDR      r1,[r4,#0x18]         ;229
00004a  4308              ORRS     r0,r0,r1              ;229
00004c  6a21              LDR      r1,[r4,#0x20]         ;229
00004e  4308              ORRS     r0,r0,r1              ;229
000050  6821              LDR      r1,[r4,#0]            ;229
000052  6809              LDR      r1,[r1,#0]            ;229
000054  4308              ORRS     r0,r0,r1              ;229
000056  6821              LDR      r1,[r4,#0]            ;229
000058  6008              STR      r0,[r1,#0]            ;229
00005a  6860              LDR      r0,[r4,#4]            ;234
00005c  2810              CMP      r0,#0x10              ;234
00005e  d10b              BNE      |L13.120|
000060  7f21              LDRB     r1,[r4,#0x1c]         ;236
000062  7f60              LDRB     r0,[r4,#0x1d]         ;236
000064  ea412100          ORR      r1,r1,r0,LSL #8       ;236
000068  7fa0              LDRB     r0,[r4,#0x1e]         ;236
00006a  ea414100          ORR      r1,r1,r0,LSL #16      ;236
00006e  7fe0              LDRB     r0,[r4,#0x1f]         ;236
000070  ea416000          ORR      r0,r1,r0,LSL #24      ;236
000074  6821              LDR      r1,[r4,#0]            ;236
000076  6188              STR      r0,[r1,#0x18]         ;236
                  |L13.120|
000078  6820              LDR      r0,[r4,#0]            ;243
00007a  68c0              LDR      r0,[r0,#0xc]          ;243
00007c  f040001e          ORR      r0,r0,#0x1e           ;243
000080  6821              LDR      r1,[r4,#0]            ;243
000082  60c8              STR      r0,[r1,#0xc]          ;243
000084  2000              MOVS     r0,#0                 ;246
000086  63e0              STR      r0,[r4,#0x3c]         ;246
000088  2001              MOVS     r0,#1                 ;249
00008a  f8840025          STRB     r0,[r4,#0x25]         ;249
00008e  2000              MOVS     r0,#0                 ;251
000090  e7ba              B        |L13.8|
;;;253    
                          ENDP


                          AREA ||i.HAL_DCMI_LineEventCallback||, CODE, READONLY, ALIGN=1

                  HAL_DCMI_LineEventCallback PROC
;;;666      */
;;;667    __weak void HAL_DCMI_LineEventCallback(DCMI_HandleTypeDef *hdcmi)
000000  4770              BX       lr
;;;668    {
;;;669      /* Prevent unused argument(s) compilation warning */
;;;670      UNUSED(hdcmi);
;;;671      /* NOTE : This function Should not be modified, when the callback is needed,
;;;672                the HAL_DCMI_LineEventCallback could be implemented in the user file
;;;673       */
;;;674    }
;;;675    
                          ENDP


                          AREA ||i.HAL_DCMI_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_DCMI_MspDeInit PROC
;;;308      */
;;;309    __weak void HAL_DCMI_MspDeInit(DCMI_HandleTypeDef* hdcmi)
000000  4770              BX       lr
;;;310    {
;;;311      /* Prevent unused argument(s) compilation warning */
;;;312      UNUSED(hdcmi);
;;;313      /* NOTE : This function Should not be modified, when the callback is needed,
;;;314                the HAL_DCMI_MspDeInit could be implemented in the user file
;;;315       */
;;;316    }
;;;317    
                          ENDP


                          AREA ||i.HAL_DCMI_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_DCMI_MspInit PROC
;;;293      */
;;;294    __weak void HAL_DCMI_MspInit(DCMI_HandleTypeDef* hdcmi)
000000  4770              BX       lr
;;;295    {
;;;296      /* Prevent unused argument(s) compilation warning */
;;;297      UNUSED(hdcmi);
;;;298      /* NOTE : This function Should not be modified, when the callback is needed,
;;;299                the HAL_DCMI_MspInit could be implemented in the user file
;;;300       */ 
;;;301    }
;;;302    
                          ENDP


                          AREA ||i.HAL_DCMI_Resume||, CODE, READONLY, ALIGN=1

                  HAL_DCMI_Resume PROC
;;;528      */
;;;529    HAL_StatusTypeDef HAL_DCMI_Resume(DCMI_HandleTypeDef* hdcmi)
000000  4601              MOV      r1,r0
;;;530    {
;;;531      /* Process locked */
;;;532      __HAL_LOCK(hdcmi);
000002  bf00              NOP      
000004  f8910024          LDRB     r0,[r1,#0x24]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L17.16|
00000c  2002              MOVS     r0,#2
                  |L17.14|
;;;533      
;;;534      if(hdcmi->State == HAL_DCMI_STATE_SUSPENDED)
;;;535      {
;;;536        /* Change DCMI state */
;;;537        hdcmi->State = HAL_DCMI_STATE_BUSY;
;;;538        
;;;539        /* Disable Capture */
;;;540        hdcmi->Instance->CR |= DCMI_CR_CAPTURE;
;;;541      } 
;;;542      /* Process Unlocked */
;;;543      __HAL_UNLOCK(hdcmi);
;;;544      
;;;545      /* Return function status */
;;;546      return HAL_OK;
;;;547    }
00000e  4770              BX       lr
                  |L17.16|
000010  2001              MOVS     r0,#1                 ;532
000012  f8810024          STRB     r0,[r1,#0x24]         ;532
000016  bf00              NOP                            ;532
000018  f8910025          LDRB     r0,[r1,#0x25]         ;534
00001c  2805              CMP      r0,#5                 ;534
00001e  d108              BNE      |L17.50|
000020  2002              MOVS     r0,#2                 ;537
000022  f8810025          STRB     r0,[r1,#0x25]         ;537
000026  6808              LDR      r0,[r1,#0]            ;540
000028  6800              LDR      r0,[r0,#0]            ;540
00002a  f0400001          ORR      r0,r0,#1              ;540
00002e  680a              LDR      r2,[r1,#0]            ;540
000030  6010              STR      r0,[r2,#0]            ;540
                  |L17.50|
000032  bf00              NOP                            ;543
000034  2000              MOVS     r0,#0                 ;543
000036  f8810024          STRB     r0,[r1,#0x24]         ;543
00003a  bf00              NOP                            ;543
00003c  bf00              NOP                            ;546
00003e  e7e6              B        |L17.14|
;;;548    
                          ENDP


                          AREA ||i.HAL_DCMI_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_DCMI_Start_DMA PROC
;;;346      */
;;;347    HAL_StatusTypeDef HAL_DCMI_Start_DMA(DCMI_HandleTypeDef* hdcmi, uint32_t DCMI_Mode, uint32_t pData, uint32_t Length)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;348    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;349      /* Initialize the second memory address */
;;;350      uint32_t SecondMemAddress = 0U;
00000c  f04f0800          MOV      r8,#0
;;;351    
;;;352      /* Check function parameters */
;;;353      assert_param(IS_DCMI_CAPTURE_MODE(DCMI_Mode));
;;;354    
;;;355      /* Process Locked */
;;;356      __HAL_LOCK(hdcmi);
000010  bf00              NOP      
000012  f8940024          LDRB     r0,[r4,#0x24]
000016  2801              CMP      r0,#1
000018  d102              BNE      |L18.32|
00001a  2002              MOVS     r0,#2
                  |L18.28|
;;;357    
;;;358      /* Lock the DCMI peripheral state */
;;;359      hdcmi->State = HAL_DCMI_STATE_BUSY;
;;;360      
;;;361      /* Enable DCMI by setting DCMIEN bit */
;;;362      __HAL_DCMI_ENABLE(hdcmi);
;;;363    
;;;364      /* Configure the DCMI Mode */
;;;365      hdcmi->Instance->CR &= ~(DCMI_CR_CM);
;;;366      hdcmi->Instance->CR |=  (uint32_t)(DCMI_Mode);
;;;367    
;;;368      /* Set the DMA memory0 conversion complete callback */
;;;369      hdcmi->DMA_Handle->XferCpltCallback = DCMI_DMAXferCplt;
;;;370    
;;;371      /* Set the DMA error callback */
;;;372      hdcmi->DMA_Handle->XferErrorCallback = DCMI_DMAError;
;;;373    
;;;374      /* Set the dma abort callback */
;;;375      hdcmi->DMA_Handle->XferAbortCallback = NULL;
;;;376      
;;;377      /* Reset transfer counters value */ 
;;;378      hdcmi->XferCount = 0U;
;;;379      hdcmi->XferTransferNumber = 0U;
;;;380    
;;;381      if(Length <= 0xFFFFU)
;;;382      {
;;;383        /* Enable the DMA Stream */
;;;384        HAL_DMA_Start_IT(hdcmi->DMA_Handle, (uint32_t)&hdcmi->Instance->DR, (uint32_t)pData, Length);
;;;385      }
;;;386      else /* DCMI_DOUBLE_BUFFER Mode */
;;;387      {
;;;388        /* Set the DMA memory1 conversion complete callback */
;;;389        hdcmi->DMA_Handle->XferM1CpltCallback = DCMI_DMAXferCplt;
;;;390    
;;;391        /* Initialize transfer parameters */
;;;392        hdcmi->XferCount = 1U;
;;;393        hdcmi->XferSize = Length;
;;;394        hdcmi->pBuffPtr = pData;
;;;395    
;;;396        /* Get the number of buffer */
;;;397        while(hdcmi->XferSize > 0xFFFFU)
;;;398        {
;;;399          hdcmi->XferSize = (hdcmi->XferSize/2U);
;;;400          hdcmi->XferCount = hdcmi->XferCount*2U;
;;;401        }
;;;402    
;;;403        /* Update DCMI counter  and transfer number*/
;;;404        hdcmi->XferCount = (hdcmi->XferCount - 2U);
;;;405        hdcmi->XferTransferNumber = hdcmi->XferCount;
;;;406    
;;;407        /* Update second memory address */
;;;408        SecondMemAddress = (uint32_t)(pData + (4U*hdcmi->XferSize));
;;;409    
;;;410        /* Start DMA multi buffer transfer */
;;;411        HAL_DMAEx_MultiBufferStart_IT(hdcmi->DMA_Handle, (uint32_t)&hdcmi->Instance->DR, (uint32_t)pData, SecondMemAddress, hdcmi->XferSize);
;;;412      }
;;;413    
;;;414      /* Enable Capture */
;;;415      hdcmi->Instance->CR |= DCMI_CR_CAPTURE;
;;;416    
;;;417      /* Release Lock */
;;;418      __HAL_UNLOCK(hdcmi);
;;;419    
;;;420      /* Return function status */
;;;421      return HAL_OK;
;;;422    }
00001c  e8bd83f8          POP      {r3-r9,pc}
                  |L18.32|
000020  2001              MOVS     r0,#1                 ;356
000022  f8840024          STRB     r0,[r4,#0x24]         ;356
000026  bf00              NOP                            ;356
000028  2002              MOVS     r0,#2                 ;359
00002a  f8840025          STRB     r0,[r4,#0x25]         ;359
00002e  6820              LDR      r0,[r4,#0]            ;362
000030  6800              LDR      r0,[r0,#0]            ;362
000032  f4404080          ORR      r0,r0,#0x4000         ;362
000036  6821              LDR      r1,[r4,#0]            ;362
000038  6008              STR      r0,[r1,#0]            ;362
00003a  6820              LDR      r0,[r4,#0]            ;365
00003c  6800              LDR      r0,[r0,#0]            ;365
00003e  f0200002          BIC      r0,r0,#2              ;365
000042  6821              LDR      r1,[r4,#0]            ;365
000044  6008              STR      r0,[r1,#0]            ;365
000046  6820              LDR      r0,[r4,#0]            ;366
000048  6800              LDR      r0,[r0,#0]            ;366
00004a  4338              ORRS     r0,r0,r7              ;366
00004c  6821              LDR      r1,[r4,#0]            ;366
00004e  6008              STR      r0,[r1,#0]            ;366
000050  4824              LDR      r0,|L18.228|
000052  6ba1              LDR      r1,[r4,#0x38]         ;369
000054  63c8              STR      r0,[r1,#0x3c]         ;369
000056  4824              LDR      r0,|L18.232|
000058  6ba1              LDR      r1,[r4,#0x38]         ;372
00005a  64c8              STR      r0,[r1,#0x4c]         ;372
00005c  2000              MOVS     r0,#0                 ;375
00005e  6ba1              LDR      r1,[r4,#0x38]         ;375
000060  6508              STR      r0,[r1,#0x50]         ;375
000062  62a0              STR      r0,[r4,#0x28]         ;378
000064  6320              STR      r0,[r4,#0x30]         ;379
000066  f5b63f80          CMP      r6,#0x10000           ;381
00006a  d208              BCS      |L18.126|
00006c  6822              LDR      r2,[r4,#0]            ;384
00006e  f1020128          ADD      r1,r2,#0x28           ;384
000072  4633              MOV      r3,r6                 ;384
000074  462a              MOV      r2,r5                 ;384
000076  6ba0              LDR      r0,[r4,#0x38]         ;384
000078  f7fffffe          BL       HAL_DMA_Start_IT
00007c  e024              B        |L18.200|
                  |L18.126|
00007e  4819              LDR      r0,|L18.228|
000080  6ba1              LDR      r1,[r4,#0x38]         ;389
000082  6448              STR      r0,[r1,#0x44]         ;389
000084  2001              MOVS     r0,#1                 ;392
000086  62a0              STR      r0,[r4,#0x28]         ;392
000088  62e6              STR      r6,[r4,#0x2c]         ;393
00008a  6365              STR      r5,[r4,#0x34]         ;394
00008c  e005              B        |L18.154|
                  |L18.142|
00008e  6ae0              LDR      r0,[r4,#0x2c]         ;399
000090  0840              LSRS     r0,r0,#1              ;399
000092  62e0              STR      r0,[r4,#0x2c]         ;399
000094  6aa0              LDR      r0,[r4,#0x28]         ;400
000096  0040              LSLS     r0,r0,#1              ;400
000098  62a0              STR      r0,[r4,#0x28]         ;400
                  |L18.154|
00009a  6ae0              LDR      r0,[r4,#0x2c]         ;397
00009c  f5b03f80          CMP      r0,#0x10000           ;397
0000a0  d2f5              BCS      |L18.142|
0000a2  6aa0              LDR      r0,[r4,#0x28]         ;404
0000a4  1e80              SUBS     r0,r0,#2              ;404
0000a6  62a0              STR      r0,[r4,#0x28]         ;404
0000a8  6aa0              LDR      r0,[r4,#0x28]         ;405
0000aa  6320              STR      r0,[r4,#0x30]         ;405
0000ac  6ae0              LDR      r0,[r4,#0x2c]         ;408
0000ae  2104              MOVS     r1,#4                 ;408
0000b0  fb015800          MLA      r8,r1,r0,r5           ;408
0000b4  6ae0              LDR      r0,[r4,#0x2c]         ;411
0000b6  9000              STR      r0,[sp,#0]            ;411
0000b8  6822              LDR      r2,[r4,#0]            ;411
0000ba  f1020128          ADD      r1,r2,#0x28           ;411
0000be  4643              MOV      r3,r8                 ;411
0000c0  462a              MOV      r2,r5                 ;411
0000c2  6ba0              LDR      r0,[r4,#0x38]         ;411
0000c4  f7fffffe          BL       HAL_DMAEx_MultiBufferStart_IT
                  |L18.200|
0000c8  6820              LDR      r0,[r4,#0]            ;415
0000ca  6800              LDR      r0,[r0,#0]            ;415
0000cc  f0400001          ORR      r0,r0,#1              ;415
0000d0  6821              LDR      r1,[r4,#0]            ;415
0000d2  6008              STR      r0,[r1,#0]            ;415
0000d4  bf00              NOP                            ;418
0000d6  2000              MOVS     r0,#0                 ;418
0000d8  f8840024          STRB     r0,[r4,#0x24]         ;418
0000dc  bf00              NOP                            ;418
0000de  bf00              NOP                            ;421
0000e0  e79c              B        |L18.28|
;;;423    
                          ENDP

0000e2  0000              DCW      0x0000
                  |L18.228|
                          DCD      DCMI_DMAXferCplt
                  |L18.232|
                          DCD      DCMI_DMAError

                          AREA ||i.HAL_DCMI_Stop||, CODE, READONLY, ALIGN=2

                  HAL_DCMI_Stop PROC
;;;429      */
;;;430    HAL_StatusTypeDef HAL_DCMI_Stop(DCMI_HandleTypeDef* hdcmi)
000000  b538              PUSH     {r3-r5,lr}
;;;431    {
000002  4604              MOV      r4,r0
;;;432      __IO uint32_t count = SystemCoreClock / HAL_TIMEOUT_DCMI_STOP;
000004  4820              LDR      r0,|L19.136|
000006  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000008  210e              MOVS     r1,#0xe
00000a  fbb0f0f1          UDIV     r0,r0,r1
00000e  9000              STR      r0,[sp,#0]
;;;433      HAL_StatusTypeDef status = HAL_OK;
000010  2500              MOVS     r5,#0
;;;434    
;;;435      /* Process locked */
;;;436      __HAL_LOCK(hdcmi);
000012  bf00              NOP      
000014  f8940024          LDRB     r0,[r4,#0x24]
000018  2801              CMP      r0,#1
00001a  d101              BNE      |L19.32|
00001c  2002              MOVS     r0,#2
                  |L19.30|
;;;437      
;;;438      /* Lock the DCMI peripheral state */
;;;439      hdcmi->State = HAL_DCMI_STATE_BUSY;
;;;440    
;;;441      /* Disable Capture */
;;;442      hdcmi->Instance->CR &= ~(DCMI_CR_CAPTURE);
;;;443    
;;;444      /* Check if the DCMI capture effectively disabled */
;;;445      do
;;;446      {
;;;447        if (count-- == 0U)
;;;448        {
;;;449          /* Update error code */
;;;450          hdcmi->ErrorCode |= HAL_DCMI_ERROR_TIMEOUT;
;;;451    
;;;452          status = HAL_TIMEOUT;
;;;453          break;
;;;454        }
;;;455      }
;;;456      while((hdcmi->Instance->CR & DCMI_CR_CAPTURE) != 0U);
;;;457    
;;;458      /* Disable the DCMI */
;;;459      __HAL_DCMI_DISABLE(hdcmi);
;;;460    
;;;461      /* Disable the DMA */
;;;462      HAL_DMA_Abort(hdcmi->DMA_Handle);
;;;463    
;;;464      /* Update error code */
;;;465      hdcmi->ErrorCode |= HAL_DCMI_ERROR_NONE;
;;;466    
;;;467      /* Change DCMI state */
;;;468      hdcmi->State = HAL_DCMI_STATE_READY;
;;;469    
;;;470      /* Process Unlocked */
;;;471      __HAL_UNLOCK(hdcmi);
;;;472    
;;;473      /* Return function status */
;;;474      return status;
;;;475    }
00001e  bd38              POP      {r3-r5,pc}
                  |L19.32|
000020  2001              MOVS     r0,#1                 ;436
000022  f8840024          STRB     r0,[r4,#0x24]         ;436
000026  bf00              NOP                            ;436
000028  2002              MOVS     r0,#2                 ;439
00002a  f8840025          STRB     r0,[r4,#0x25]         ;439
00002e  6820              LDR      r0,[r4,#0]            ;442
000030  6800              LDR      r0,[r0,#0]            ;442
000032  f0200001          BIC      r0,r0,#1              ;442
000036  6821              LDR      r1,[r4,#0]            ;442
000038  6008              STR      r0,[r1,#0]            ;442
00003a  bf00              NOP                            ;445
                  |L19.60|
00003c  9800              LDR      r0,[sp,#0]            ;447
00003e  1e41              SUBS     r1,r0,#1              ;447
000040  9100              STR      r1,[sp,#0]            ;447
000042  b928              CBNZ     r0,|L19.80|
000044  6be0              LDR      r0,[r4,#0x3c]         ;450
000046  f0400020          ORR      r0,r0,#0x20           ;450
00004a  63e0              STR      r0,[r4,#0x3c]         ;450
00004c  2503              MOVS     r5,#3                 ;452
00004e  e005              B        |L19.92|
                  |L19.80|
000050  6820              LDR      r0,[r4,#0]            ;456
000052  6800              LDR      r0,[r0,#0]            ;456
000054  f0000001          AND      r0,r0,#1              ;456
000058  2800              CMP      r0,#0                 ;456
00005a  d1ef              BNE      |L19.60|
                  |L19.92|
00005c  bf00              NOP                            ;453
00005e  6820              LDR      r0,[r4,#0]            ;459
000060  6800              LDR      r0,[r0,#0]            ;459
000062  f4204080          BIC      r0,r0,#0x4000         ;459
000066  6821              LDR      r1,[r4,#0]            ;459
000068  6008              STR      r0,[r1,#0]            ;459
00006a  6ba0              LDR      r0,[r4,#0x38]         ;462
00006c  f7fffffe          BL       HAL_DMA_Abort
000070  6be0              LDR      r0,[r4,#0x3c]         ;465
000072  63e0              STR      r0,[r4,#0x3c]         ;465
000074  2001              MOVS     r0,#1                 ;468
000076  f8840025          STRB     r0,[r4,#0x25]         ;468
00007a  bf00              NOP                            ;471
00007c  2000              MOVS     r0,#0                 ;471
00007e  f8840024          STRB     r0,[r4,#0x24]         ;471
000082  bf00              NOP                            ;471
000084  4628              MOV      r0,r5                 ;474
000086  e7ca              B        |L19.30|
;;;476    
                          ENDP

                  |L19.136|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_DCMI_Suspend||, CODE, READONLY, ALIGN=2

                  HAL_DCMI_Suspend PROC
;;;482      */
;;;483    HAL_StatusTypeDef HAL_DCMI_Suspend(DCMI_HandleTypeDef* hdcmi)
000000  b508              PUSH     {r3,lr}
;;;484    {
000002  4601              MOV      r1,r0
;;;485      __IO uint32_t count = SystemCoreClock / HAL_TIMEOUT_DCMI_STOP;
000004  481d              LDR      r0,|L20.124|
000006  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000008  230e              MOVS     r3,#0xe
00000a  fbb0f0f3          UDIV     r0,r0,r3
00000e  9000              STR      r0,[sp,#0]
;;;486      HAL_StatusTypeDef status = HAL_OK;
000010  2200              MOVS     r2,#0
;;;487    
;;;488      /* Process locked */
;;;489      __HAL_LOCK(hdcmi);
000012  bf00              NOP      
000014  f8910024          LDRB     r0,[r1,#0x24]
000018  2801              CMP      r0,#1
00001a  d101              BNE      |L20.32|
00001c  2002              MOVS     r0,#2
                  |L20.30|
;;;490    
;;;491      if(hdcmi->State == HAL_DCMI_STATE_BUSY)
;;;492      {
;;;493        /* Change DCMI state */
;;;494        hdcmi->State = HAL_DCMI_STATE_SUSPENDED;
;;;495    
;;;496        /* Disable Capture */
;;;497        hdcmi->Instance->CR &= ~(DCMI_CR_CAPTURE);
;;;498    
;;;499        /* Check if the DCMI capture effectively disabled */
;;;500        do
;;;501        {
;;;502          if (count-- == 0U)
;;;503          {        
;;;504            /* Update error code */
;;;505            hdcmi->ErrorCode |= HAL_DCMI_ERROR_TIMEOUT;
;;;506            
;;;507            /* Change DCMI state */
;;;508            hdcmi->State = HAL_DCMI_STATE_READY;
;;;509            
;;;510            status = HAL_TIMEOUT;
;;;511            break;
;;;512          }
;;;513        }
;;;514        while((hdcmi->Instance->CR & DCMI_CR_CAPTURE) != 0);
;;;515      }    
;;;516      /* Process Unlocked */
;;;517      __HAL_UNLOCK(hdcmi);
;;;518      
;;;519      /* Return function status */
;;;520      return status;
;;;521    }
00001e  bd08              POP      {r3,pc}
                  |L20.32|
000020  2001              MOVS     r0,#1                 ;489
000022  f8810024          STRB     r0,[r1,#0x24]         ;489
000026  bf00              NOP                            ;489
000028  f8910025          LDRB     r0,[r1,#0x25]         ;491
00002c  2802              CMP      r0,#2                 ;491
00002e  d11d              BNE      |L20.108|
000030  2005              MOVS     r0,#5                 ;494
000032  f8810025          STRB     r0,[r1,#0x25]         ;494
000036  6808              LDR      r0,[r1,#0]            ;497
000038  6800              LDR      r0,[r0,#0]            ;497
00003a  f0200001          BIC      r0,r0,#1              ;497
00003e  680b              LDR      r3,[r1,#0]            ;497
000040  6018              STR      r0,[r3,#0]            ;497
000042  bf00              NOP                            ;500
                  |L20.68|
000044  9800              LDR      r0,[sp,#0]            ;502
000046  1e43              SUBS     r3,r0,#1              ;502
000048  9300              STR      r3,[sp,#0]            ;502
00004a  b940              CBNZ     r0,|L20.94|
00004c  6bc8              LDR      r0,[r1,#0x3c]         ;505
00004e  f0400020          ORR      r0,r0,#0x20           ;505
000052  63c8              STR      r0,[r1,#0x3c]         ;505
000054  2001              MOVS     r0,#1                 ;508
000056  f8810025          STRB     r0,[r1,#0x25]         ;508
00005a  2203              MOVS     r2,#3                 ;510
00005c  e005              B        |L20.106|
                  |L20.94|
00005e  6808              LDR      r0,[r1,#0]            ;514
000060  6800              LDR      r0,[r0,#0]            ;514
000062  f0000001          AND      r0,r0,#1              ;514
000066  2800              CMP      r0,#0                 ;514
000068  d1ec              BNE      |L20.68|
                  |L20.106|
00006a  bf00              NOP                            ;511
                  |L20.108|
00006c  bf00              NOP                            ;517
00006e  2000              MOVS     r0,#0                 ;517
000070  f8810024          STRB     r0,[r1,#0x24]         ;517
000074  bf00              NOP                            ;517
000076  4610              MOV      r0,r2                 ;520
000078  e7d1              B        |L20.30|
;;;522    
                          ENDP

00007a  0000              DCW      0x0000
                  |L20.124|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_DCMI_VsyncEventCallback||, CODE, READONLY, ALIGN=1

                  HAL_DCMI_VsyncEventCallback PROC
;;;681      */
;;;682    __weak void HAL_DCMI_VsyncEventCallback(DCMI_HandleTypeDef *hdcmi)
000000  4770              BX       lr
;;;683    {
;;;684      /* Prevent unused argument(s) compilation warning */
;;;685      UNUSED(hdcmi);
;;;686      /* NOTE : This function Should not be modified, when the callback is needed,
;;;687                the HAL_DCMI_VsyncEventCallback could be implemented in the user file
;;;688       */
;;;689    }
;;;690    
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_dcmi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_dcmi_c_03d7bd62____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___20_stm32f4xx_hal_dcmi_c_03d7bd62____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_dcmi_c_03d7bd62____REVSH|
#line 478
|__asm___20_stm32f4xx_hal_dcmi_c_03d7bd62____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_dcmi_c_03d7bd62____RRX|
#line 665
|__asm___20_stm32f4xx_hal_dcmi_c_03d7bd62____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
