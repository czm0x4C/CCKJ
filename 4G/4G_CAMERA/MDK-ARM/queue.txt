; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o4gcamera\queue.o --asm_dir=.\ --list_dir=.\ --depend=4gcamera\queue.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../USB_DEVICE/App -I../USB_DEVICE/Target -I../Core/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Middlewares/ST/STM32_USB_Device_Library/Core/Inc -I../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 -I../Middlewares/Third_Party/FreeRTOS/Source/portable/RVDS/ARM_CM4F -I../HARDWARE/OV2640 -I../HARDWARE/WS2812B -I../HARDWARE/RING_BUFFER -I../HARDWARE/FLASH -I.\RTE\_4GCAMERA -IC:\Users\czm\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\czm\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=536 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F407xx --omf_browse=4gcamera\queue.crf ../Middlewares/Third_Party/FreeRTOS/Source/queue.c]
                          THUMB

                          AREA ||i.pcQueueGetName||, CODE, READONLY, ALIGN=2

                  pcQueueGetName PROC
;;;2676   
;;;2677   	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  4602              MOV      r2,r0
;;;2678   	{
;;;2679   	UBaseType_t ux;
;;;2680   	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000002  2000              MOVS     r0,#0
;;;2681   
;;;2682   		/* Note there is nothing here to protect against another task adding or
;;;2683   		removing entries from the registry while it is being searched. */
;;;2684   		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
000004  2100              MOVS     r1,#0
000006  e00a              B        |L1.30|
                  |L1.8|
;;;2685   		{
;;;2686   			if( xQueueRegistry[ ux ].xHandle == xQueue )
000008  4b07              LDR      r3,|L1.40|
00000a  eb0303c1          ADD      r3,r3,r1,LSL #3
00000e  685b              LDR      r3,[r3,#4]
000010  4293              CMP      r3,r2
000012  d103              BNE      |L1.28|
;;;2687   			{
;;;2688   				pcReturn = xQueueRegistry[ ux ].pcQueueName;
000014  4b04              LDR      r3,|L1.40|
000016  f8530031          LDR      r0,[r3,r1,LSL #3]
;;;2689   				break;
00001a  e002              B        |L1.34|
                  |L1.28|
00001c  1c49              ADDS     r1,r1,#1              ;2684
                  |L1.30|
00001e  2908              CMP      r1,#8                 ;2684
000020  d3f2              BCC      |L1.8|
                  |L1.34|
000022  bf00              NOP      
;;;2690   			}
;;;2691   			else
;;;2692   			{
;;;2693   				mtCOVERAGE_TEST_MARKER();
;;;2694   			}
;;;2695   		}
;;;2696   
;;;2697   		return pcReturn;
;;;2698   	} /*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */
000024  4770              BX       lr
;;;2699   
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      xQueueRegistry

                          AREA ||i.prvCopyDataFromQueue||, CODE, READONLY, ALIGN=1

                  prvCopyDataFromQueue PROC
;;;2152   
;;;2153   static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
000000  b570              PUSH     {r4-r6,lr}
;;;2154   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2155   	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
000006  6c20              LDR      r0,[r4,#0x40]
000008  b170              CBZ      r0,|L2.40|
;;;2156   	{
;;;2157   		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
00000a  6c21              LDR      r1,[r4,#0x40]
00000c  68e0              LDR      r0,[r4,#0xc]
00000e  4401              ADD      r1,r1,r0
000010  60e1              STR      r1,[r4,#0xc]
;;;2158   		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
000012  e9d41002          LDRD     r1,r0,[r4,#8]
000016  4288              CMP      r0,r1
000018  d301              BCC      |L2.30|
;;;2159   		{
;;;2160   			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
00001a  6821              LDR      r1,[r4,#0]
00001c  60e1              STR      r1,[r4,#0xc]
                  |L2.30|
;;;2161   		}
;;;2162   		else
;;;2163   		{
;;;2164   			mtCOVERAGE_TEST_MARKER();
;;;2165   		}
;;;2166   		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
00001e  4628              MOV      r0,r5
000020  6c22              LDR      r2,[r4,#0x40]
000022  68e1              LDR      r1,[r4,#0xc]
000024  f7fffffe          BL       __aeabi_memcpy
                  |L2.40|
;;;2167   	}
;;;2168   }
000028  bd70              POP      {r4-r6,pc}
;;;2169   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvCopyDataToQueue||, CODE, READONLY, ALIGN=1

                  prvCopyDataToQueue PROC
;;;2073   
;;;2074   static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2075   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;2076   BaseType_t xReturn = pdFALSE;
00000a  f04f0800          MOV      r8,#0
;;;2077   UBaseType_t uxMessagesWaiting;
;;;2078   
;;;2079   	/* This function is called from a critical section. */
;;;2080   
;;;2081   	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
00000e  6ba6              LDR      r6,[r4,#0x38]
;;;2082   
;;;2083   	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
000010  6c20              LDR      r0,[r4,#0x40]
000012  b948              CBNZ     r0,|L3.40|
;;;2084   	{
;;;2085   		#if ( configUSE_MUTEXES == 1 )
;;;2086   		{
;;;2087   			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
000014  6820              LDR      r0,[r4,#0]
000016  2800              CMP      r0,#0
000018  d12c              BNE      |L3.116|
;;;2088   			{
;;;2089   				/* The mutex is no longer being held. */
;;;2090   				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
00001a  68a0              LDR      r0,[r4,#8]
00001c  f7fffffe          BL       xTaskPriorityDisinherit
000020  4680              MOV      r8,r0
;;;2091   				pxQueue->u.xSemaphore.xMutexHolder = NULL;
000022  2000              MOVS     r0,#0
000024  60a0              STR      r0,[r4,#8]
000026  e025              B        |L3.116|
                  |L3.40|
;;;2092   			}
;;;2093   			else
;;;2094   			{
;;;2095   				mtCOVERAGE_TEST_MARKER();
;;;2096   			}
;;;2097   		}
;;;2098   		#endif /* configUSE_MUTEXES */
;;;2099   	}
;;;2100   	else if( xPosition == queueSEND_TO_BACK )
000028  b97d              CBNZ     r5,|L3.74|
;;;2101   	{
;;;2102   		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
00002a  4639              MOV      r1,r7
00002c  6c22              LDR      r2,[r4,#0x40]
00002e  6860              LDR      r0,[r4,#4]
000030  f7fffffe          BL       __aeabi_memcpy
;;;2103   		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
000034  6c21              LDR      r1,[r4,#0x40]
000036  6860              LDR      r0,[r4,#4]
000038  4408              ADD      r0,r0,r1
00003a  6060              STR      r0,[r4,#4]
;;;2104   		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
00003c  e9d40101          LDRD     r0,r1,[r4,#4]
000040  4288              CMP      r0,r1
000042  d317              BCC      |L3.116|
;;;2105   		{
;;;2106   			pxQueue->pcWriteTo = pxQueue->pcHead;
000044  6820              LDR      r0,[r4,#0]
000046  6060              STR      r0,[r4,#4]
000048  e014              B        |L3.116|
                  |L3.74|
;;;2107   		}
;;;2108   		else
;;;2109   		{
;;;2110   			mtCOVERAGE_TEST_MARKER();
;;;2111   		}
;;;2112   	}
;;;2113   	else
;;;2114   	{
;;;2115   		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
00004a  4639              MOV      r1,r7
00004c  6c22              LDR      r2,[r4,#0x40]
00004e  68e0              LDR      r0,[r4,#0xc]
000050  f7fffffe          BL       __aeabi_memcpy
;;;2116   		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
000054  6c21              LDR      r1,[r4,#0x40]
000056  68e0              LDR      r0,[r4,#0xc]
000058  1a41              SUBS     r1,r0,r1
00005a  60e1              STR      r1,[r4,#0xc]
;;;2117   		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
00005c  6821              LDR      r1,[r4,#0]
00005e  68e0              LDR      r0,[r4,#0xc]
000060  4288              CMP      r0,r1
000062  d203              BCS      |L3.108|
;;;2118   		{
;;;2119   			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
000064  6c21              LDR      r1,[r4,#0x40]
000066  68a0              LDR      r0,[r4,#8]
000068  1a41              SUBS     r1,r0,r1
00006a  60e1              STR      r1,[r4,#0xc]
                  |L3.108|
;;;2120   		}
;;;2121   		else
;;;2122   		{
;;;2123   			mtCOVERAGE_TEST_MARKER();
;;;2124   		}
;;;2125   
;;;2126   		if( xPosition == queueOVERWRITE )
00006c  2d02              CMP      r5,#2
00006e  d101              BNE      |L3.116|
;;;2127   		{
;;;2128   			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
000070  b106              CBZ      r6,|L3.116|
;;;2129   			{
;;;2130   				/* An item is not being added but overwritten, so subtract
;;;2131   				one from the recorded number of items in the queue so when
;;;2132   				one is added again below the number of recorded items remains
;;;2133   				correct. */
;;;2134   				--uxMessagesWaiting;
000072  1e76              SUBS     r6,r6,#1
                  |L3.116|
;;;2135   			}
;;;2136   			else
;;;2137   			{
;;;2138   				mtCOVERAGE_TEST_MARKER();
;;;2139   			}
;;;2140   		}
;;;2141   		else
;;;2142   		{
;;;2143   			mtCOVERAGE_TEST_MARKER();
;;;2144   		}
;;;2145   	}
;;;2146   
;;;2147   	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
000074  1c70              ADDS     r0,r6,#1
000076  63a0              STR      r0,[r4,#0x38]
;;;2148   
;;;2149   	return xReturn;
000078  4640              MOV      r0,r8
;;;2150   }
00007a  e8bd81f0          POP      {r4-r8,pc}
;;;2151   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvGetDisinheritPriorityAfterTimeout||, CODE, READONLY, ALIGN=1

                  prvGetDisinheritPriorityAfterTimeout PROC
;;;2048   
;;;2049   	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
000000  4601              MOV      r1,r0
;;;2050   	{
;;;2051   	UBaseType_t uxHighestPriorityOfWaitingTasks;
;;;2052   
;;;2053   		/* If a task waiting for a mutex causes the mutex holder to inherit a
;;;2054   		priority, but the waiting task times out, then the holder should
;;;2055   		disinherit the priority - but only down to the highest priority of any
;;;2056   		other tasks that are waiting for the same mutex.  For this purpose,
;;;2057   		return the priority of the highest priority task that is waiting for the
;;;2058   		mutex. */
;;;2059   		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
000002  6a4a              LDR      r2,[r1,#0x24]
000004  b122              CBZ      r2,|L4.16|
;;;2060   		{
;;;2061   			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
000006  6b0a              LDR      r2,[r1,#0x30]
000008  6812              LDR      r2,[r2,#0]
00000a  f1c20038          RSB      r0,r2,#0x38
00000e  e000              B        |L4.18|
                  |L4.16|
;;;2062   		}
;;;2063   		else
;;;2064   		{
;;;2065   			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
000010  2000              MOVS     r0,#0
                  |L4.18|
;;;2066   		}
;;;2067   
;;;2068   		return uxHighestPriorityOfWaitingTasks;
;;;2069   	}
000012  4770              BX       lr
;;;2070   
                          ENDP


                          AREA ||i.prvInitialiseMutex||, CODE, READONLY, ALIGN=1

                  prvInitialiseMutex PROC
;;;465    
;;;466    	static void prvInitialiseMutex( Queue_t *pxNewQueue )
000000  b510              PUSH     {r4,lr}
;;;467    	{
000002  4604              MOV      r4,r0
;;;468    		if( pxNewQueue != NULL )
000004  b154              CBZ      r4,|L5.28|
;;;469    		{
;;;470    			/* The queue create function will set all the queue structure members
;;;471    			correctly for a generic queue, but this function is creating a
;;;472    			mutex.  Overwrite those members that need to be set differently -
;;;473    			in particular the information required for priority inheritance. */
;;;474    			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
000006  2000              MOVS     r0,#0
000008  60a0              STR      r0,[r4,#8]
;;;475    			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
00000a  6020              STR      r0,[r4,#0]
;;;476    
;;;477    			/* In case this is a recursive mutex. */
;;;478    			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
00000c  2100              MOVS     r1,#0
00000e  60e1              STR      r1,[r4,#0xc]
;;;479    
;;;480    			traceCREATE_MUTEX( pxNewQueue );
;;;481    
;;;482    			/* Start with the semaphore in the expected state. */
;;;483    			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
000010  2300              MOVS     r3,#0
000012  461a              MOV      r2,r3
000014  4619              MOV      r1,r3
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       xQueueGenericSend
                  |L5.28|
;;;484    		}
;;;485    		else
;;;486    		{
;;;487    			traceCREATE_MUTEX_FAILED();
;;;488    		}
;;;489    	}
00001c  bd10              POP      {r4,pc}
;;;490    
                          ENDP


                          AREA ||i.prvInitialiseNewQueue||, CODE, READONLY, ALIGN=1

                  prvInitialiseNewQueue PROC
;;;421    
;;;422    static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;423    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  9c06              LDR      r4,[sp,#0x18]
;;;424    	/* Remove compiler warnings about unused parameters should
;;;425    	configUSE_TRACE_FACILITY not be set to 1. */
;;;426    	( void ) ucQueueType;
;;;427    
;;;428    	if( uxItemSize == ( UBaseType_t ) 0 )
00000e  b90d              CBNZ     r5,|L6.20|
;;;429    	{
;;;430    		/* No RAM was allocated for the queue storage area, but PC head cannot
;;;431    		be set to NULL because NULL is used as a key to say the queue is used as
;;;432    		a mutex.  Therefore just set pcHead to point to the queue as a benign
;;;433    		value that is known to be within the memory map. */
;;;434    		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
000010  6024              STR      r4,[r4,#0]
000012  e000              B        |L6.22|
                  |L6.20|
;;;435    	}
;;;436    	else
;;;437    	{
;;;438    		/* Set the head to the start of the queue storage area. */
;;;439    		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
000014  6027              STR      r7,[r4,#0]
                  |L6.22|
;;;440    	}
;;;441    
;;;442    	/* Initialise the queue members as described where the queue type is
;;;443    	defined. */
;;;444    	pxNewQueue->uxLength = uxQueueLength;
000016  63e6              STR      r6,[r4,#0x3c]
;;;445    	pxNewQueue->uxItemSize = uxItemSize;
000018  6425              STR      r5,[r4,#0x40]
;;;446    	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
00001a  2101              MOVS     r1,#1
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       xQueueGenericReset
;;;447    
;;;448    	#if ( configUSE_TRACE_FACILITY == 1 )
;;;449    	{
;;;450    		pxNewQueue->ucQueueType = ucQueueType;
000022  f884804c          STRB     r8,[r4,#0x4c]
;;;451    	}
;;;452    	#endif /* configUSE_TRACE_FACILITY */
;;;453    
;;;454    	#if( configUSE_QUEUE_SETS == 1 )
;;;455    	{
;;;456    		pxNewQueue->pxQueueSetContainer = NULL;
;;;457    	}
;;;458    	#endif /* configUSE_QUEUE_SETS */
;;;459    
;;;460    	traceQUEUE_CREATE( pxNewQueue );
;;;461    }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;462    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvIsQueueEmpty||, CODE, READONLY, ALIGN=1

                  prvIsQueueEmpty PROC
;;;2290   
;;;2291   static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;2292   {
000002  4605              MOV      r5,r0
;;;2293   BaseType_t xReturn;
;;;2294   
;;;2295   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;2296   	{
;;;2297   		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
000008  6ba8              LDR      r0,[r5,#0x38]
00000a  b908              CBNZ     r0,|L7.16|
;;;2298   		{
;;;2299   			xReturn = pdTRUE;
00000c  2401              MOVS     r4,#1
00000e  e000              B        |L7.18|
                  |L7.16|
;;;2300   		}
;;;2301   		else
;;;2302   		{
;;;2303   			xReturn = pdFALSE;
000010  2400              MOVS     r4,#0
                  |L7.18|
;;;2304   		}
;;;2305   	}
;;;2306   	taskEXIT_CRITICAL();
000012  f7fffffe          BL       vPortExitCritical
;;;2307   
;;;2308   	return xReturn;
000016  4620              MOV      r0,r4
;;;2309   }
000018  bd70              POP      {r4-r6,pc}
;;;2310   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvIsQueueFull||, CODE, READONLY, ALIGN=1

                  prvIsQueueFull PROC
;;;2330   
;;;2331   static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;2332   {
000002  4605              MOV      r5,r0
;;;2333   BaseType_t xReturn;
;;;2334   
;;;2335   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;2336   	{
;;;2337   		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
000008  6ba8              LDR      r0,[r5,#0x38]
00000a  6be9              LDR      r1,[r5,#0x3c]
00000c  4288              CMP      r0,r1
00000e  d101              BNE      |L8.20|
;;;2338   		{
;;;2339   			xReturn = pdTRUE;
000010  2401              MOVS     r4,#1
000012  e000              B        |L8.22|
                  |L8.20|
;;;2340   		}
;;;2341   		else
;;;2342   		{
;;;2343   			xReturn = pdFALSE;
000014  2400              MOVS     r4,#0
                  |L8.22|
;;;2344   		}
;;;2345   	}
;;;2346   	taskEXIT_CRITICAL();
000016  f7fffffe          BL       vPortExitCritical
;;;2347   
;;;2348   	return xReturn;
00001a  4620              MOV      r0,r4
;;;2349   }
00001c  bd70              POP      {r4-r6,pc}
;;;2350   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvUnlockQueue||, CODE, READONLY, ALIGN=1

                  prvUnlockQueue PROC
;;;2170   
;;;2171   static void prvUnlockQueue( Queue_t * const pxQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;2172   {
000002  4604              MOV      r4,r0
;;;2173   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
;;;2174   
;;;2175   	/* The lock counts contains the number of extra data items placed or
;;;2176   	removed from the queue while the queue was locked.  When a queue is
;;;2177   	locked items can be added or removed, but the event lists cannot be
;;;2178   	updated. */
;;;2179   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;2180   	{
;;;2181   		int8_t cTxLock = pxQueue->cTxLock;
000008  f9945045          LDRSB    r5,[r4,#0x45]
;;;2182   
;;;2183   		/* See if data was added to the queue while it was locked. */
;;;2184   		while( cTxLock > queueLOCKED_UNMODIFIED )
00000c  e010              B        |L9.48|
                  |L9.14|
;;;2185   		{
;;;2186   			/* Data was posted while the queue was locked.  Are any tasks
;;;2187   			blocked waiting for data to become available? */
;;;2188   			#if ( configUSE_QUEUE_SETS == 1 )
;;;2189   			{
;;;2190   				if( pxQueue->pxQueueSetContainer != NULL )
;;;2191   				{
;;;2192   					if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
;;;2193   					{
;;;2194   						/* The queue is a member of a queue set, and posting to
;;;2195   						the queue set caused a higher priority task to unblock.
;;;2196   						A context switch is required. */
;;;2197   						vTaskMissedYield();
;;;2198   					}
;;;2199   					else
;;;2200   					{
;;;2201   						mtCOVERAGE_TEST_MARKER();
;;;2202   					}
;;;2203   				}
;;;2204   				else
;;;2205   				{
;;;2206   					/* Tasks that are removed from the event list will get
;;;2207   					added to the pending ready list as the scheduler is still
;;;2208   					suspended. */
;;;2209   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;2210   					{
;;;2211   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;2212   						{
;;;2213   							/* The task waiting has a higher priority so record that a
;;;2214   							context	switch is required. */
;;;2215   							vTaskMissedYield();
;;;2216   						}
;;;2217   						else
;;;2218   						{
;;;2219   							mtCOVERAGE_TEST_MARKER();
;;;2220   						}
;;;2221   					}
;;;2222   					else
;;;2223   					{
;;;2224   						break;
;;;2225   					}
;;;2226   				}
;;;2227   			}
;;;2228   			#else /* configUSE_QUEUE_SETS */
;;;2229   			{
;;;2230   				/* Tasks that are removed from the event list will get added to
;;;2231   				the pending ready list as the scheduler is still suspended. */
;;;2232   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
00000e  6a60              LDR      r0,[r4,#0x24]
000010  b908              CBNZ     r0,|L9.22|
000012  2001              MOVS     r0,#1
000014  e000              B        |L9.24|
                  |L9.22|
000016  2000              MOVS     r0,#0
                  |L9.24|
000018  b938              CBNZ     r0,|L9.42|
;;;2233   				{
;;;2234   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
00001a  f1040024          ADD      r0,r4,#0x24
00001e  f7fffffe          BL       xTaskRemoveFromEventList
000022  b118              CBZ      r0,|L9.44|
;;;2235   					{
;;;2236   						/* The task waiting has a higher priority so record that
;;;2237   						a context switch is required. */
;;;2238   						vTaskMissedYield();
000024  f7fffffe          BL       vTaskMissedYield
000028  e000              B        |L9.44|
                  |L9.42|
;;;2239   					}
;;;2240   					else
;;;2241   					{
;;;2242   						mtCOVERAGE_TEST_MARKER();
;;;2243   					}
;;;2244   				}
;;;2245   				else
;;;2246   				{
;;;2247   					break;
00002a  e003              B        |L9.52|
                  |L9.44|
;;;2248   				}
;;;2249   			}
;;;2250   			#endif /* configUSE_QUEUE_SETS */
;;;2251   
;;;2252   			--cTxLock;
00002c  1e68              SUBS     r0,r5,#1
00002e  b245              SXTB     r5,r0
                  |L9.48|
000030  2d00              CMP      r5,#0                 ;2184
000032  dcec              BGT      |L9.14|
                  |L9.52|
000034  bf00              NOP                            ;2247
;;;2253   		}
;;;2254   
;;;2255   		pxQueue->cTxLock = queueUNLOCKED;
000036  20ff              MOVS     r0,#0xff
000038  f8840045          STRB     r0,[r4,#0x45]
;;;2256   	}
;;;2257   	taskEXIT_CRITICAL();
00003c  f7fffffe          BL       vPortExitCritical
;;;2258   
;;;2259   	/* Do the same for the Rx lock. */
;;;2260   	taskENTER_CRITICAL();
000040  f7fffffe          BL       vPortEnterCritical
;;;2261   	{
;;;2262   		int8_t cRxLock = pxQueue->cRxLock;
000044  f9945044          LDRSB    r5,[r4,#0x44]
;;;2263   
;;;2264   		while( cRxLock > queueLOCKED_UNMODIFIED )
000048  e010              B        |L9.108|
                  |L9.74|
;;;2265   		{
;;;2266   			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
00004a  6920              LDR      r0,[r4,#0x10]
00004c  b908              CBNZ     r0,|L9.82|
00004e  2001              MOVS     r0,#1
000050  e000              B        |L9.84|
                  |L9.82|
000052  2000              MOVS     r0,#0
                  |L9.84|
000054  b948              CBNZ     r0,|L9.106|
;;;2267   			{
;;;2268   				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000056  f1040010          ADD      r0,r4,#0x10
00005a  f7fffffe          BL       xTaskRemoveFromEventList
00005e  b108              CBZ      r0,|L9.100|
;;;2269   				{
;;;2270   					vTaskMissedYield();
000060  f7fffffe          BL       vTaskMissedYield
                  |L9.100|
;;;2271   				}
;;;2272   				else
;;;2273   				{
;;;2274   					mtCOVERAGE_TEST_MARKER();
;;;2275   				}
;;;2276   
;;;2277   				--cRxLock;
000064  1e68              SUBS     r0,r5,#1
000066  b245              SXTB     r5,r0
000068  e000              B        |L9.108|
                  |L9.106|
;;;2278   			}
;;;2279   			else
;;;2280   			{
;;;2281   				break;
00006a  e001              B        |L9.112|
                  |L9.108|
00006c  2d00              CMP      r5,#0                 ;2264
00006e  dcec              BGT      |L9.74|
                  |L9.112|
000070  bf00              NOP      
;;;2282   			}
;;;2283   		}
;;;2284   
;;;2285   		pxQueue->cRxLock = queueUNLOCKED;
000072  20ff              MOVS     r0,#0xff
000074  f8840044          STRB     r0,[r4,#0x44]
;;;2286   	}
;;;2287   	taskEXIT_CRITICAL();
000078  f7fffffe          BL       vPortExitCritical
;;;2288   }
00007c  bd70              POP      {r4-r6,pc}
;;;2289   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.ucQueueGetQueueType||, CODE, READONLY, ALIGN=1

                  ucQueueGetQueueType PROC
;;;2038   
;;;2039   	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
000000  4601              MOV      r1,r0
;;;2040   	{
;;;2041   		return ( ( Queue_t * ) xQueue )->ucQueueType;
000002  f891004c          LDRB     r0,[r1,#0x4c]
;;;2042   	}
000006  4770              BX       lr
;;;2043   
                          ENDP


                          AREA ||i.uxQueueGetQueueNumber||, CODE, READONLY, ALIGN=1

                  uxQueueGetQueueNumber PROC
;;;2018   
;;;2019   	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
000000  4601              MOV      r1,r0
;;;2020   	{
;;;2021   		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
000002  6c88              LDR      r0,[r1,#0x48]
;;;2022   	}
000004  4770              BX       lr
;;;2023   
                          ENDP


                          AREA ||i.uxQueueMessagesWaiting||, CODE, READONLY, ALIGN=1

                  uxQueueMessagesWaiting PROC
;;;1929   
;;;1930   UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1931   {
000002  4604              MOV      r4,r0
;;;1932   UBaseType_t uxReturn;
;;;1933   
;;;1934   	configASSERT( xQueue );
000004  b954              CBNZ     r4,|L12.28|
000006  bf00              NOP      
000008  2050              MOVS     r0,#0x50
00000a  f3808811          MSR      BASEPRI,r0
00000e  f3bf8f4f          DSB      
000012  f3bf8f6f          ISB      
000016  bf00              NOP      
000018  bf00              NOP      
                  |L12.26|
00001a  e7fe              B        |L12.26|
                  |L12.28|
;;;1935   
;;;1936   	taskENTER_CRITICAL();
00001c  f7fffffe          BL       vPortEnterCritical
;;;1937   	{
;;;1938   		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
000020  6ba5              LDR      r5,[r4,#0x38]
;;;1939   	}
;;;1940   	taskEXIT_CRITICAL();
000022  f7fffffe          BL       vPortExitCritical
;;;1941   
;;;1942   	return uxReturn;
000026  4628              MOV      r0,r5
;;;1943   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000028  bd70              POP      {r4-r6,pc}
;;;1944   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxQueueMessagesWaitingFromISR||, CODE, READONLY, ALIGN=1

                  uxQueueMessagesWaitingFromISR PROC
;;;1962   
;;;1963   UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
000000  b510              PUSH     {r4,lr}
;;;1964   {
000002  4601              MOV      r1,r0
;;;1965   UBaseType_t uxReturn;
;;;1966   Queue_t * const pxQueue = xQueue;
000004  460a              MOV      r2,r1
;;;1967   
;;;1968   	configASSERT( pxQueue );
000006  b952              CBNZ     r2,|L13.30|
000008  bf00              NOP      
00000a  2350              MOVS     r3,#0x50
00000c  f3838811          MSR      BASEPRI,r3
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L13.28|
00001c  e7fe              B        |L13.28|
                  |L13.30|
;;;1969   	uxReturn = pxQueue->uxMessagesWaiting;
00001e  6b90              LDR      r0,[r2,#0x38]
;;;1970   
;;;1971   	return uxReturn;
;;;1972   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000020  bd10              POP      {r4,pc}
;;;1973   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxQueueSpacesAvailable||, CODE, READONLY, ALIGN=1

                  uxQueueSpacesAvailable PROC
;;;1945   
;;;1946   UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1947   {
000002  4604              MOV      r4,r0
;;;1948   UBaseType_t uxReturn;
;;;1949   Queue_t * const pxQueue = xQueue;
000004  4625              MOV      r5,r4
;;;1950   
;;;1951   	configASSERT( pxQueue );
000006  b955              CBNZ     r5,|L14.30|
000008  bf00              NOP      
00000a  2050              MOVS     r0,#0x50
00000c  f3808811          MSR      BASEPRI,r0
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L14.28|
00001c  e7fe              B        |L14.28|
                  |L14.30|
;;;1952   
;;;1953   	taskENTER_CRITICAL();
00001e  f7fffffe          BL       vPortEnterCritical
;;;1954   	{
;;;1955   		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
000022  e9d5100e          LDRD     r1,r0,[r5,#0x38]
000026  1a46              SUBS     r6,r0,r1
;;;1956   	}
;;;1957   	taskEXIT_CRITICAL();
000028  f7fffffe          BL       vPortExitCritical
;;;1958   
;;;1959   	return uxReturn;
00002c  4630              MOV      r0,r6
;;;1960   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
00002e  bd70              POP      {r4-r6,pc}
;;;1961   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vQueueAddToRegistry||, CODE, READONLY, ALIGN=2

                  vQueueAddToRegistry PROC
;;;2647   
;;;2648   	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  4602              MOV      r2,r0
;;;2649   	{
;;;2650   	UBaseType_t ux;
;;;2651   
;;;2652   		/* See if there is an empty space in the registry.  A NULL name denotes
;;;2653   		a free slot. */
;;;2654   		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
000002  2000              MOVS     r0,#0
000004  e00b              B        |L15.30|
                  |L15.6|
;;;2655   		{
;;;2656   			if( xQueueRegistry[ ux ].pcQueueName == NULL )
000006  4b08              LDR      r3,|L15.40|
000008  f8533030          LDR      r3,[r3,r0,LSL #3]
00000c  b933              CBNZ     r3,|L15.28|
;;;2657   			{
;;;2658   				/* Store the information on this queue. */
;;;2659   				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
00000e  4b06              LDR      r3,|L15.40|
000010  f8431030          STR      r1,[r3,r0,LSL #3]
;;;2660   				xQueueRegistry[ ux ].xHandle = xQueue;
000014  eb0303c0          ADD      r3,r3,r0,LSL #3
000018  605a              STR      r2,[r3,#4]
;;;2661   
;;;2662   				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
;;;2663   				break;
00001a  e002              B        |L15.34|
                  |L15.28|
00001c  1c40              ADDS     r0,r0,#1              ;2654
                  |L15.30|
00001e  2808              CMP      r0,#8                 ;2654
000020  d3f1              BCC      |L15.6|
                  |L15.34|
000022  bf00              NOP      
;;;2664   			}
;;;2665   			else
;;;2666   			{
;;;2667   				mtCOVERAGE_TEST_MARKER();
;;;2668   			}
;;;2669   		}
;;;2670   	}
000024  4770              BX       lr
;;;2671   
                          ENDP

000026  0000              DCW      0x0000
                  |L15.40|
                          DCD      xQueueRegistry

                          AREA ||i.vQueueDelete||, CODE, READONLY, ALIGN=1

                  vQueueDelete PROC
;;;1974   
;;;1975   void vQueueDelete( QueueHandle_t xQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1976   {
000002  4604              MOV      r4,r0
;;;1977   Queue_t * const pxQueue = xQueue;
000004  4625              MOV      r5,r4
;;;1978   
;;;1979   	configASSERT( pxQueue );
000006  b955              CBNZ     r5,|L16.30|
000008  bf00              NOP      
00000a  2050              MOVS     r0,#0x50
00000c  f3808811          MSR      BASEPRI,r0
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L16.28|
00001c  e7fe              B        |L16.28|
                  |L16.30|
;;;1980   	traceQUEUE_DELETE( pxQueue );
;;;1981   
;;;1982   	#if ( configQUEUE_REGISTRY_SIZE > 0 )
;;;1983   	{
;;;1984   		vQueueUnregisterQueue( pxQueue );
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       vQueueUnregisterQueue
;;;1985   	}
;;;1986   	#endif
;;;1987   
;;;1988   	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
;;;1989   	{
;;;1990   		/* The queue can only have been allocated dynamically - free it
;;;1991   		again. */
;;;1992   		vPortFree( pxQueue );
;;;1993   	}
;;;1994   	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
;;;1995   	{
;;;1996   		/* The queue could have been allocated statically or dynamically, so
;;;1997   		check before attempting to free the memory. */
;;;1998   		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
000024  f8950046          LDRB     r0,[r5,#0x46]
000028  b910              CBNZ     r0,|L16.48|
;;;1999   		{
;;;2000   			vPortFree( pxQueue );
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       vPortFree
                  |L16.48|
;;;2001   		}
;;;2002   		else
;;;2003   		{
;;;2004   			mtCOVERAGE_TEST_MARKER();
;;;2005   		}
;;;2006   	}
;;;2007   	#else
;;;2008   	{
;;;2009   		/* The queue must have been statically allocated, so is not going to be
;;;2010   		deleted.  Avoid compiler warnings about the unused parameter. */
;;;2011   		( void ) pxQueue;
;;;2012   	}
;;;2013   	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;2014   }
000030  bd70              POP      {r4-r6,pc}
;;;2015   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vQueueSetQueueNumber||, CODE, READONLY, ALIGN=1

                  vQueueSetQueueNumber PROC
;;;2028   
;;;2029   	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
000000  6481              STR      r1,[r0,#0x48]
;;;2030   	{
;;;2031   		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
;;;2032   	}
000002  4770              BX       lr
;;;2033   
                          ENDP


                          AREA ||i.vQueueUnregisterQueue||, CODE, READONLY, ALIGN=2

                  vQueueUnregisterQueue PROC
;;;2704   
;;;2705   	void vQueueUnregisterQueue( QueueHandle_t xQueue )
000000  4601              MOV      r1,r0
;;;2706   	{
;;;2707   	UBaseType_t ux;
;;;2708   
;;;2709   		/* See if the handle of the queue being unregistered in actually in the
;;;2710   		registry. */
;;;2711   		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
000002  2000              MOVS     r0,#0
000004  e00e              B        |L18.36|
                  |L18.6|
;;;2712   		{
;;;2713   			if( xQueueRegistry[ ux ].xHandle == xQueue )
000006  4a09              LDR      r2,|L18.44|
000008  eb0202c0          ADD      r2,r2,r0,LSL #3
00000c  6852              LDR      r2,[r2,#4]
00000e  428a              CMP      r2,r1
000010  d107              BNE      |L18.34|
;;;2714   			{
;;;2715   				/* Set the name to NULL to show that this slot if free again. */
;;;2716   				xQueueRegistry[ ux ].pcQueueName = NULL;
000012  2200              MOVS     r2,#0
000014  4b05              LDR      r3,|L18.44|
000016  f8432030          STR      r2,[r3,r0,LSL #3]
;;;2717   
;;;2718   				/* Set the handle to NULL to ensure the same queue handle cannot
;;;2719   				appear in the registry twice if it is added, removed, then
;;;2720   				added again. */
;;;2721   				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
00001a  eb0303c0          ADD      r3,r3,r0,LSL #3
00001e  605a              STR      r2,[r3,#4]
;;;2722   				break;
000020  e002              B        |L18.40|
                  |L18.34|
000022  1c40              ADDS     r0,r0,#1              ;2711
                  |L18.36|
000024  2808              CMP      r0,#8                 ;2711
000026  d3ee              BCC      |L18.6|
                  |L18.40|
000028  bf00              NOP      
;;;2723   			}
;;;2724   			else
;;;2725   			{
;;;2726   				mtCOVERAGE_TEST_MARKER();
;;;2727   			}
;;;2728   		}
;;;2729   
;;;2730   	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
00002a  4770              BX       lr
;;;2731   
                          ENDP

                  |L18.44|
                          DCD      xQueueRegistry

                          AREA ||i.vQueueWaitForMessageRestricted||, CODE, READONLY, ALIGN=1

                  vQueueWaitForMessageRestricted PROC
;;;2736   
;;;2737   	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2738   	{
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;2739   	Queue_t * const pxQueue = xQueue;
00000a  462c              MOV      r4,r5
;;;2740   
;;;2741   		/* This function should not be called by application code hence the
;;;2742   		'Restricted' in its name.  It is not part of the public API.  It is
;;;2743   		designed for use by kernel code, and has special calling requirements.
;;;2744   		It can result in vListInsert() being called on a list that can only
;;;2745   		possibly ever have one item in it, so the list will be fast, but even
;;;2746   		so it should be called with the scheduler locked and not from a critical
;;;2747   		section. */
;;;2748   
;;;2749   		/* Only do anything if there are no messages in the queue.  This function
;;;2750   		will not actually cause the task to block, just place it on a blocked
;;;2751   		list.  It will not block until the scheduler is unlocked - at which
;;;2752   		time a yield will be performed.  If an item is added to the queue while
;;;2753   		the queue is locked, and the calling task blocks on the queue, then the
;;;2754   		calling task will be immediately unblocked when the queue is unlocked. */
;;;2755   		prvLockQueue( pxQueue );
00000c  f7fffffe          BL       vPortEnterCritical
000010  f9940044          LDRSB    r0,[r4,#0x44]
000014  1c40              ADDS     r0,r0,#1
000016  b910              CBNZ     r0,|L19.30|
000018  2000              MOVS     r0,#0
00001a  f8840044          STRB     r0,[r4,#0x44]
                  |L19.30|
00001e  f9940045          LDRSB    r0,[r4,#0x45]
000022  1c40              ADDS     r0,r0,#1
000024  b910              CBNZ     r0,|L19.44|
000026  2000              MOVS     r0,#0
000028  f8840045          STRB     r0,[r4,#0x45]
                  |L19.44|
00002c  f7fffffe          BL       vPortExitCritical
;;;2756   		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
000030  6ba0              LDR      r0,[r4,#0x38]
000032  b928              CBNZ     r0,|L19.64|
;;;2757   		{
;;;2758   			/* There is nothing in the queue, block for the specified period. */
;;;2759   			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
000034  463a              MOV      r2,r7
000036  4631              MOV      r1,r6
000038  f1040024          ADD      r0,r4,#0x24
00003c  f7fffffe          BL       vTaskPlaceOnEventListRestricted
                  |L19.64|
;;;2760   		}
;;;2761   		else
;;;2762   		{
;;;2763   			mtCOVERAGE_TEST_MARKER();
;;;2764   		}
;;;2765   		prvUnlockQueue( pxQueue );
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       prvUnlockQueue
;;;2766   	}
000046  e8bd81f0          POP      {r4-r8,pc}
;;;2767   
                          ENDP


                          AREA ||i.xQueueCreateCountingSemaphore||, CODE, READONLY, ALIGN=1

                  xQueueCreateCountingSemaphore PROC
;;;713    
;;;714    	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
000000  b570              PUSH     {r4-r6,lr}
;;;715    	{
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;716    	QueueHandle_t xHandle;
;;;717    
;;;718    		configASSERT( uxMaxCount != 0 );
000006  b10d              CBZ      r5,|L20.12|
000008  2001              MOVS     r0,#1
00000a  e000              B        |L20.14|
                  |L20.12|
00000c  2000              MOVS     r0,#0
                  |L20.14|
00000e  b950              CBNZ     r0,|L20.38|
000010  bf00              NOP      
000012  2050              MOVS     r0,#0x50
000014  f3808811          MSR      BASEPRI,r0
000018  f3bf8f4f          DSB      
00001c  f3bf8f6f          ISB      
000020  bf00              NOP      
000022  bf00              NOP      
                  |L20.36|
000024  e7fe              B        |L20.36|
                  |L20.38|
;;;719    		configASSERT( uxInitialCount <= uxMaxCount );
000026  42ae              CMP      r6,r5
000028  d801              BHI      |L20.46|
00002a  2001              MOVS     r0,#1
00002c  e000              B        |L20.48|
                  |L20.46|
00002e  2000              MOVS     r0,#0
                  |L20.48|
000030  b950              CBNZ     r0,|L20.72|
000032  bf00              NOP      
000034  2050              MOVS     r0,#0x50
000036  f3808811          MSR      BASEPRI,r0
00003a  f3bf8f4f          DSB      
00003e  f3bf8f6f          ISB      
000042  bf00              NOP      
000044  bf00              NOP      
                  |L20.70|
000046  e7fe              B        |L20.70|
                  |L20.72|
;;;720    
;;;721    		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
000048  2202              MOVS     r2,#2
00004a  2100              MOVS     r1,#0
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       xQueueGenericCreate
000052  4604              MOV      r4,r0
;;;722    
;;;723    		if( xHandle != NULL )
000054  b104              CBZ      r4,|L20.88|
;;;724    		{
;;;725    			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
000056  63a6              STR      r6,[r4,#0x38]
                  |L20.88|
;;;726    
;;;727    			traceCREATE_COUNTING_SEMAPHORE();
;;;728    		}
;;;729    		else
;;;730    		{
;;;731    			traceCREATE_COUNTING_SEMAPHORE_FAILED();
;;;732    		}
;;;733    
;;;734    		return xHandle;
000058  4620              MOV      r0,r4
;;;735    	}
00005a  bd70              POP      {r4-r6,pc}
;;;736    
                          ENDP


                          AREA ||i.xQueueCreateCountingSemaphoreStatic||, CODE, READONLY, ALIGN=1

                  xQueueCreateCountingSemaphoreStatic PROC
;;;685    
;;;686    	QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue )
000000  b5f8              PUSH     {r3-r7,lr}
;;;687    	{
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;688    	QueueHandle_t xHandle;
;;;689    
;;;690    		configASSERT( uxMaxCount != 0 );
000008  b10d              CBZ      r5,|L21.14|
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L21.16|
                  |L21.14|
00000e  2000              MOVS     r0,#0
                  |L21.16|
000010  b950              CBNZ     r0,|L21.40|
000012  bf00              NOP      
000014  2050              MOVS     r0,#0x50
000016  f3808811          MSR      BASEPRI,r0
00001a  f3bf8f4f          DSB      
00001e  f3bf8f6f          ISB      
000022  bf00              NOP      
000024  bf00              NOP      
                  |L21.38|
000026  e7fe              B        |L21.38|
                  |L21.40|
;;;691    		configASSERT( uxInitialCount <= uxMaxCount );
000028  42ae              CMP      r6,r5
00002a  d801              BHI      |L21.48|
00002c  2001              MOVS     r0,#1
00002e  e000              B        |L21.50|
                  |L21.48|
000030  2000              MOVS     r0,#0
                  |L21.50|
000032  b950              CBNZ     r0,|L21.74|
000034  bf00              NOP      
000036  2050              MOVS     r0,#0x50
000038  f3808811          MSR      BASEPRI,r0
00003c  f3bf8f4f          DSB      
000040  f3bf8f6f          ISB      
000044  bf00              NOP      
000046  bf00              NOP      
                  |L21.72|
000048  e7fe              B        |L21.72|
                  |L21.74|
;;;692    
;;;693    		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStaticQueue, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
00004a  2002              MOVS     r0,#2
00004c  463b              MOV      r3,r7
00004e  2200              MOVS     r2,#0
000050  4611              MOV      r1,r2
000052  9000              STR      r0,[sp,#0]
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       xQueueGenericCreateStatic
00005a  4604              MOV      r4,r0
;;;694    
;;;695    		if( xHandle != NULL )
00005c  b104              CBZ      r4,|L21.96|
;;;696    		{
;;;697    			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
00005e  63a6              STR      r6,[r4,#0x38]
                  |L21.96|
;;;698    
;;;699    			traceCREATE_COUNTING_SEMAPHORE();
;;;700    		}
;;;701    		else
;;;702    		{
;;;703    			traceCREATE_COUNTING_SEMAPHORE_FAILED();
;;;704    		}
;;;705    
;;;706    		return xHandle;
000060  4620              MOV      r0,r4
;;;707    	}
000062  bdf8              POP      {r3-r7,pc}
;;;708    
                          ENDP


                          AREA ||i.xQueueCreateMutex||, CODE, READONLY, ALIGN=1

                  xQueueCreateMutex PROC
;;;495    
;;;496    	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;497    	{
000004  4604              MOV      r4,r0
;;;498    	QueueHandle_t xNewQueue;
;;;499    	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
000006  2601              MOVS     r6,#1
000008  2700              MOVS     r7,#0
;;;500    
;;;501    		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
00000a  4622              MOV      r2,r4
00000c  2100              MOVS     r1,#0
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       xQueueGenericCreate
000014  4605              MOV      r5,r0
;;;502    		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       prvInitialiseMutex
;;;503    
;;;504    		return xNewQueue;
00001c  4628              MOV      r0,r5
;;;505    	}
00001e  e8bd81f0          POP      {r4-r8,pc}
;;;506    
                          ENDP


                          AREA ||i.xQueueCreateMutexStatic||, CODE, READONLY, ALIGN=1

                  xQueueCreateMutexStatic PROC
;;;511    
;;;512    	QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue )
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;513    	{
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;514    	QueueHandle_t xNewQueue;
;;;515    	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
000008  2701              MOVS     r7,#1
00000a  f04f0800          MOV      r8,#0
;;;516    
;;;517    		/* Prevent compiler warnings about unused parameters if
;;;518    		configUSE_TRACE_FACILITY does not equal 1. */
;;;519    		( void ) ucQueueType;
;;;520    
;;;521    		xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );
00000e  462b              MOV      r3,r5
000010  2200              MOVS     r2,#0
000012  4611              MOV      r1,r2
000014  2001              MOVS     r0,#1
000016  9400              STR      r4,[sp,#0]
000018  f7fffffe          BL       xQueueGenericCreateStatic
00001c  4606              MOV      r6,r0
;;;522    		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       prvInitialiseMutex
;;;523    
;;;524    		return xNewQueue;
000024  4630              MOV      r0,r6
;;;525    	}
000026  e8bd83f8          POP      {r3-r9,pc}
;;;526    
                          ENDP


                          AREA ||i.xQueueGenericCreate||, CODE, READONLY, ALIGN=1

                  xQueueGenericCreate PROC
;;;367    
;;;368    	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;369    	{
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;370    	Queue_t *pxNewQueue;
;;;371    	size_t xQueueSizeInBytes;
;;;372    	uint8_t *pucQueueStorage;
;;;373    
;;;374    		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
00000a  b10d              CBZ      r5,|L24.16|
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L24.18|
                  |L24.16|
000010  2000              MOVS     r0,#0
                  |L24.18|
000012  b950              CBNZ     r0,|L24.42|
000014  bf00              NOP      
000016  2050              MOVS     r0,#0x50
000018  f3808811          MSR      BASEPRI,r0
00001c  f3bf8f4f          DSB      
000020  f3bf8f6f          ISB      
000024  bf00              NOP      
000026  bf00              NOP      
                  |L24.40|
000028  e7fe              B        |L24.40|
                  |L24.42|
;;;375    
;;;376    		/* Allocate enough space to hold the maximum number of items that
;;;377    		can be in the queue at any time.  It is valid for uxItemSize to be
;;;378    		zero in the case the queue is used as a semaphore. */
;;;379    		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00002a  fb05f806          MUL      r8,r5,r6
;;;380    
;;;381    		/* Allocate the queue and storage area.  Justification for MISRA
;;;382    		deviation as follows:  pvPortMalloc() always ensures returned memory
;;;383    		blocks are aligned per the requirements of the MCU stack.  In this case
;;;384    		pvPortMalloc() must return a pointer that is guaranteed to meet the
;;;385    		alignment requirements of the Queue_t structure - which in this case
;;;386    		is an int8_t *.  Therefore, whenever the stack alignment requirements
;;;387    		are greater than or equal to the pointer to char requirements the cast
;;;388    		is safe.  In other cases alignment requirements are not strict (one or
;;;389    		two bytes). */
;;;390    		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
00002e  f1080050          ADD      r0,r8,#0x50
000032  f7fffffe          BL       pvPortMalloc
000036  4604              MOV      r4,r0
;;;391    
;;;392    		if( pxNewQueue != NULL )
000038  b164              CBZ      r4,|L24.84|
;;;393    		{
;;;394    			/* Jump past the queue structure to find the location of the queue
;;;395    			storage area. */
;;;396    			pucQueueStorage = ( uint8_t * ) pxNewQueue;
00003a  46a1              MOV      r9,r4
;;;397    			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
00003c  f1090950          ADD      r9,r9,#0x50
;;;398    
;;;399    			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;400    			{
;;;401    				/* Queues can be created either statically or dynamically, so
;;;402    				note this task was created dynamically in case it is later
;;;403    				deleted. */
;;;404    				pxNewQueue->ucStaticallyAllocated = pdFALSE;
000040  2000              MOVS     r0,#0
000042  f8840046          STRB     r0,[r4,#0x46]
;;;405    			}
;;;406    			#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;407    
;;;408    			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
000046  463b              MOV      r3,r7
000048  464a              MOV      r2,r9
00004a  4631              MOV      r1,r6
00004c  4628              MOV      r0,r5
00004e  9400              STR      r4,[sp,#0]
000050  f7fffffe          BL       prvInitialiseNewQueue
                  |L24.84|
;;;409    		}
;;;410    		else
;;;411    		{
;;;412    			traceQUEUE_CREATE_FAILED( ucQueueType );
;;;413    			mtCOVERAGE_TEST_MARKER();
;;;414    		}
;;;415    
;;;416    		return pxNewQueue;
000054  4620              MOV      r0,r4
;;;417    	}
000056  e8bd83f8          POP      {r3-r9,pc}
;;;418    
                          ENDP


                          AREA ||i.xQueueGenericCreateStatic||, CODE, READONLY, ALIGN=1

                  xQueueGenericCreateStatic PROC
;;;309    
;;;310    	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType )
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;311    	{
000004  4680              MOV      r8,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
00000c  f8dd9020          LDR      r9,[sp,#0x20]
;;;312    	Queue_t *pxNewQueue;
;;;313    
;;;314    		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
000010  f1b80f00          CMP      r8,#0
000014  d001              BEQ      |L25.26|
000016  2001              MOVS     r0,#1
000018  e000              B        |L25.28|
                  |L25.26|
00001a  2000              MOVS     r0,#0
                  |L25.28|
00001c  b950              CBNZ     r0,|L25.52|
00001e  bf00              NOP      
000020  2050              MOVS     r0,#0x50
000022  f3808811          MSR      BASEPRI,r0
000026  f3bf8f4f          DSB      
00002a  f3bf8f6f          ISB      
00002e  bf00              NOP      
000030  bf00              NOP      
                  |L25.50|
000032  e7fe              B        |L25.50|
                  |L25.52|
;;;315    
;;;316    		/* The StaticQueue_t structure and the queue storage area must be
;;;317    		supplied. */
;;;318    		configASSERT( pxStaticQueue != NULL );
000034  b10d              CBZ      r5,|L25.58|
000036  2001              MOVS     r0,#1
000038  e000              B        |L25.60|
                  |L25.58|
00003a  2000              MOVS     r0,#0
                  |L25.60|
00003c  b950              CBNZ     r0,|L25.84|
00003e  bf00              NOP      
000040  2050              MOVS     r0,#0x50
000042  f3808811          MSR      BASEPRI,r0
000046  f3bf8f4f          DSB      
00004a  f3bf8f6f          ISB      
00004e  bf00              NOP      
000050  bf00              NOP      
                  |L25.82|
000052  e7fe              B        |L25.82|
                  |L25.84|
;;;319    
;;;320    		/* A queue storage area should be provided if the item size is not 0, and
;;;321    		should not be provided if the item size is 0. */
;;;322    		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
000054  b107              CBZ      r7,|L25.88|
000056  b10e              CBZ      r6,|L25.92|
                  |L25.88|
000058  2001              MOVS     r0,#1
00005a  e000              B        |L25.94|
                  |L25.92|
00005c  2000              MOVS     r0,#0
                  |L25.94|
00005e  b950              CBNZ     r0,|L25.118|
000060  bf00              NOP      
000062  2050              MOVS     r0,#0x50
000064  f3808811          MSR      BASEPRI,r0
000068  f3bf8f4f          DSB      
00006c  f3bf8f6f          ISB      
000070  bf00              NOP      
000072  bf00              NOP      
                  |L25.116|
000074  e7fe              B        |L25.116|
                  |L25.118|
;;;323    		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
000076  b907              CBNZ     r7,|L25.122|
000078  b90e              CBNZ     r6,|L25.126|
                  |L25.122|
00007a  2001              MOVS     r0,#1
00007c  e000              B        |L25.128|
                  |L25.126|
00007e  2000              MOVS     r0,#0
                  |L25.128|
000080  b950              CBNZ     r0,|L25.152|
000082  bf00              NOP      
000084  2050              MOVS     r0,#0x50
000086  f3808811          MSR      BASEPRI,r0
00008a  f3bf8f4f          DSB      
00008e  f3bf8f6f          ISB      
000092  bf00              NOP      
000094  bf00              NOP      
                  |L25.150|
000096  e7fe              B        |L25.150|
                  |L25.152|
;;;324    
;;;325    		#if( configASSERT_DEFINED == 1 )
;;;326    		{
;;;327    			/* Sanity check that the size of the structure used to declare a
;;;328    			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
;;;329    			the real queue and semaphore structures. */
;;;330    			volatile size_t xSize = sizeof( StaticQueue_t );
000098  2050              MOVS     r0,#0x50
00009a  9000              STR      r0,[sp,#0]
;;;331    			configASSERT( xSize == sizeof( Queue_t ) );
00009c  9800              LDR      r0,[sp,#0]
00009e  2850              CMP      r0,#0x50
0000a0  d101              BNE      |L25.166|
0000a2  2001              MOVS     r0,#1
0000a4  e000              B        |L25.168|
                  |L25.166|
0000a6  2000              MOVS     r0,#0
                  |L25.168|
0000a8  b950              CBNZ     r0,|L25.192|
0000aa  bf00              NOP      
0000ac  2050              MOVS     r0,#0x50
0000ae  f3808811          MSR      BASEPRI,r0
0000b2  f3bf8f4f          DSB      
0000b6  f3bf8f6f          ISB      
0000ba  bf00              NOP      
0000bc  bf00              NOP      
                  |L25.190|
0000be  e7fe              B        |L25.190|
                  |L25.192|
;;;332    			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
0000c0  bf00              NOP      
;;;333    		}
;;;334    		#endif /* configASSERT_DEFINED */
;;;335    
;;;336    		/* The address of a statically allocated queue was passed in, use it.
;;;337    		The address of a statically allocated storage area was also passed in
;;;338    		but is already set. */
;;;339    		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
0000c2  462c              MOV      r4,r5
;;;340    
;;;341    		if( pxNewQueue != NULL )
0000c4  b14c              CBZ      r4,|L25.218|
;;;342    		{
;;;343    			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
;;;344    			{
;;;345    				/* Queues can be allocated wither statically or dynamically, so
;;;346    				note this queue was allocated statically in case the queue is
;;;347    				later deleted. */
;;;348    				pxNewQueue->ucStaticallyAllocated = pdTRUE;
0000c6  2001              MOVS     r0,#1
0000c8  f8840046          STRB     r0,[r4,#0x46]
;;;349    			}
;;;350    			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;351    
;;;352    			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
0000cc  464b              MOV      r3,r9
0000ce  463a              MOV      r2,r7
0000d0  4631              MOV      r1,r6
0000d2  4640              MOV      r0,r8
0000d4  9400              STR      r4,[sp,#0]
0000d6  f7fffffe          BL       prvInitialiseNewQueue
                  |L25.218|
;;;353    		}
;;;354    		else
;;;355    		{
;;;356    			traceQUEUE_CREATE_FAILED( ucQueueType );
;;;357    			mtCOVERAGE_TEST_MARKER();
;;;358    		}
;;;359    
;;;360    		return pxNewQueue;
0000da  4620              MOV      r0,r4
;;;361    	}
0000dc  e8bd83f8          POP      {r3-r9,pc}
;;;362    
                          ENDP


                          AREA ||i.xQueueGenericReset||, CODE, READONLY, ALIGN=2

                  xQueueGenericReset PROC
;;;254    
;;;255    BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;256    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;257    Queue_t * const pxQueue = xQueue;
000006  462c              MOV      r4,r5
;;;258    
;;;259    	configASSERT( pxQueue );
000008  b954              CBNZ     r4,|L26.32|
00000a  bf00              NOP      
00000c  2050              MOVS     r0,#0x50
00000e  f3808811          MSR      BASEPRI,r0
000012  f3bf8f4f          DSB      
000016  f3bf8f6f          ISB      
00001a  bf00              NOP      
00001c  bf00              NOP      
                  |L26.30|
00001e  e7fe              B        |L26.30|
                  |L26.32|
;;;260    
;;;261    	taskENTER_CRITICAL();
000020  f7fffffe          BL       vPortEnterCritical
;;;262    	{
;;;263    		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
000024  e9d4120f          LDRD     r1,r2,[r4,#0x3c]
000028  6820              LDR      r0,[r4,#0]
00002a  fb010002          MLA      r0,r1,r2,r0
00002e  60a0              STR      r0,[r4,#8]
;;;264    		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
000030  2000              MOVS     r0,#0
000032  63a0              STR      r0,[r4,#0x38]
;;;265    		pxQueue->pcWriteTo = pxQueue->pcHead;
000034  6820              LDR      r0,[r4,#0]
000036  6060              STR      r0,[r4,#4]
;;;266    		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
000038  6be0              LDR      r0,[r4,#0x3c]
00003a  1e40              SUBS     r0,r0,#1
00003c  6c22              LDR      r2,[r4,#0x40]
00003e  6821              LDR      r1,[r4,#0]
000040  fb001102          MLA      r1,r0,r2,r1
000044  60e1              STR      r1,[r4,#0xc]
;;;267    		pxQueue->cRxLock = queueUNLOCKED;
000046  20ff              MOVS     r0,#0xff
000048  f8840044          STRB     r0,[r4,#0x44]
;;;268    		pxQueue->cTxLock = queueUNLOCKED;
00004c  f8840045          STRB     r0,[r4,#0x45]
;;;269    
;;;270    		if( xNewQueue == pdFALSE )
000050  b99e              CBNZ     r6,|L26.122|
;;;271    		{
;;;272    			/* If there are tasks blocked waiting to read from the queue, then
;;;273    			the tasks will remain blocked as after this function exits the queue
;;;274    			will still be empty.  If there are tasks blocked waiting to write to
;;;275    			the queue, then one should be unblocked as after this function exits
;;;276    			it will be possible to write to it. */
;;;277    			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
000052  6920              LDR      r0,[r4,#0x10]
000054  b908              CBNZ     r0,|L26.90|
000056  2001              MOVS     r0,#1
000058  e000              B        |L26.92|
                  |L26.90|
00005a  2000              MOVS     r0,#0
                  |L26.92|
00005c  b9a8              CBNZ     r0,|L26.138|
;;;278    			{
;;;279    				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
00005e  f1040010          ADD      r0,r4,#0x10
000062  f7fffffe          BL       xTaskRemoveFromEventList
000066  b180              CBZ      r0,|L26.138|
;;;280    				{
;;;281    					queueYIELD_IF_USING_PREEMPTION();
000068  f04f5080          MOV      r0,#0x10000000
00006c  4909              LDR      r1,|L26.148|
00006e  6008              STR      r0,[r1,#0]
000070  f3bf8f4f          DSB      
000074  f3bf8f6f          ISB      
000078  e007              B        |L26.138|
                  |L26.122|
;;;282    				}
;;;283    				else
;;;284    				{
;;;285    					mtCOVERAGE_TEST_MARKER();
;;;286    				}
;;;287    			}
;;;288    			else
;;;289    			{
;;;290    				mtCOVERAGE_TEST_MARKER();
;;;291    			}
;;;292    		}
;;;293    		else
;;;294    		{
;;;295    			/* Ensure the event queues start in the correct state. */
;;;296    			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
00007a  f1040010          ADD      r0,r4,#0x10
00007e  f7fffffe          BL       vListInitialise
;;;297    			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
000082  f1040024          ADD      r0,r4,#0x24
000086  f7fffffe          BL       vListInitialise
                  |L26.138|
;;;298    		}
;;;299    	}
;;;300    	taskEXIT_CRITICAL();
00008a  f7fffffe          BL       vPortExitCritical
;;;301    
;;;302    	/* A value is returned for calling semantic consistency with previous
;;;303    	versions. */
;;;304    	return pdPASS;
00008e  2001              MOVS     r0,#1
;;;305    }
000090  bd70              POP      {r4-r6,pc}
;;;306    /*-----------------------------------------------------------*/
                          ENDP

000092  0000              DCW      0x0000
                  |L26.148|
                          DCD      0xe000ed04

                          AREA ||i.xQueueGenericSend||, CODE, READONLY, ALIGN=2

                  xQueueGenericSend PROC
;;;739    
;;;740    BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
000000  e92d43ff          PUSH     {r0-r9,lr}
;;;741    {
000004  b083              SUB      sp,sp,#0xc
000006  4606              MOV      r6,r0
000008  4688              MOV      r8,r1
00000a  461d              MOV      r5,r3
;;;742    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
00000c  f04f0900          MOV      r9,#0
;;;743    TimeOut_t xTimeOut;
;;;744    Queue_t * const pxQueue = xQueue;
000010  4634              MOV      r4,r6
;;;745    
;;;746    	configASSERT( pxQueue );
000012  b954              CBNZ     r4,|L27.42|
000014  bf00              NOP      
000016  2050              MOVS     r0,#0x50
000018  f3808811          MSR      BASEPRI,r0
00001c  f3bf8f4f          DSB      
000020  f3bf8f6f          ISB      
000024  bf00              NOP      
000026  bf00              NOP      
                  |L27.40|
000028  e7fe              B        |L27.40|
                  |L27.42|
;;;747    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
00002a  f1b80f00          CMP      r8,#0
00002e  d101              BNE      |L27.52|
000030  6c20              LDR      r0,[r4,#0x40]
000032  b908              CBNZ     r0,|L27.56|
                  |L27.52|
000034  2001              MOVS     r0,#1
000036  e000              B        |L27.58|
                  |L27.56|
000038  2000              MOVS     r0,#0
                  |L27.58|
00003a  b950              CBNZ     r0,|L27.82|
00003c  bf00              NOP      
00003e  2050              MOVS     r0,#0x50
000040  f3808811          MSR      BASEPRI,r0
000044  f3bf8f4f          DSB      
000048  f3bf8f6f          ISB      
00004c  bf00              NOP      
00004e  bf00              NOP      
                  |L27.80|
000050  e7fe              B        |L27.80|
                  |L27.82|
;;;748    	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
000052  2d02              CMP      r5,#2
000054  d102              BNE      |L27.92|
000056  6be0              LDR      r0,[r4,#0x3c]
000058  2801              CMP      r0,#1
00005a  d101              BNE      |L27.96|
                  |L27.92|
00005c  2001              MOVS     r0,#1
00005e  e000              B        |L27.98|
                  |L27.96|
000060  2000              MOVS     r0,#0
                  |L27.98|
000062  b950              CBNZ     r0,|L27.122|
000064  bf00              NOP      
000066  2050              MOVS     r0,#0x50
000068  f3808811          MSR      BASEPRI,r0
00006c  f3bf8f4f          DSB      
000070  f3bf8f6f          ISB      
000074  bf00              NOP      
000076  bf00              NOP      
                  |L27.120|
000078  e7fe              B        |L27.120|
                  |L27.122|
;;;749    	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;750    	{
;;;751    		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
00007a  f7fffffe          BL       xTaskGetSchedulerState
00007e  b908              CBNZ     r0,|L27.132|
000080  9805              LDR      r0,[sp,#0x14]
000082  b908              CBNZ     r0,|L27.136|
                  |L27.132|
000084  2001              MOVS     r0,#1
000086  e000              B        |L27.138|
                  |L27.136|
000088  2000              MOVS     r0,#0
                  |L27.138|
00008a  b950              CBNZ     r0,|L27.162|
00008c  bf00              NOP      
00008e  2050              MOVS     r0,#0x50
000090  f3808811          MSR      BASEPRI,r0
000094  f3bf8f4f          DSB      
000098  f3bf8f6f          ISB      
00009c  bf00              NOP      
00009e  bf00              NOP      
                  |L27.160|
0000a0  e7fe              B        |L27.160|
                  |L27.162|
;;;752    	}
;;;753    	#endif
;;;754    
;;;755    
;;;756    	/*lint -save -e904 This function relaxes the coding standard somewhat to
;;;757    	allow return statements within the function itself.  This is done in the
;;;758    	interest of execution time efficiency. */
;;;759    	for( ;; )
0000a2  bf00              NOP      
                  |L27.164|
;;;760    	{
;;;761    		taskENTER_CRITICAL();
0000a4  f7fffffe          BL       vPortEnterCritical
;;;762    		{
;;;763    			/* Is there room on the queue now?  The running task must be the
;;;764    			highest priority task wanting to access the queue.  If the head item
;;;765    			in the queue is to be overwritten then it does not matter if the
;;;766    			queue is full. */
;;;767    			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
0000a8  6ba0              LDR      r0,[r4,#0x38]
0000aa  6be1              LDR      r1,[r4,#0x3c]
0000ac  4288              CMP      r0,r1
0000ae  d301              BCC      |L27.180|
0000b0  2d02              CMP      r5,#2
0000b2  d128              BNE      |L27.262|
                  |L27.180|
;;;768    			{
;;;769    				traceQUEUE_SEND( pxQueue );
;;;770    
;;;771    				#if ( configUSE_QUEUE_SETS == 1 )
;;;772    				{
;;;773    				const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
;;;774    
;;;775    					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
;;;776    
;;;777    					if( pxQueue->pxQueueSetContainer != NULL )
;;;778    					{
;;;779    						if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
;;;780    						{
;;;781    							/* Do not notify the queue set as an existing item
;;;782    							was overwritten in the queue so the number of items
;;;783    							in the queue has not changed. */
;;;784    							mtCOVERAGE_TEST_MARKER();
;;;785    						}
;;;786    						else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
;;;787    						{
;;;788    							/* The queue is a member of a queue set, and posting
;;;789    							to the queue set caused a higher priority task to
;;;790    							unblock. A context switch is required. */
;;;791    							queueYIELD_IF_USING_PREEMPTION();
;;;792    						}
;;;793    						else
;;;794    						{
;;;795    							mtCOVERAGE_TEST_MARKER();
;;;796    						}
;;;797    					}
;;;798    					else
;;;799    					{
;;;800    						/* If there was a task waiting for data to arrive on the
;;;801    						queue then unblock it now. */
;;;802    						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;803    						{
;;;804    							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;805    							{
;;;806    								/* The unblocked task has a priority higher than
;;;807    								our own so yield immediately.  Yes it is ok to
;;;808    								do this from within the critical section - the
;;;809    								kernel takes care of that. */
;;;810    								queueYIELD_IF_USING_PREEMPTION();
;;;811    							}
;;;812    							else
;;;813    							{
;;;814    								mtCOVERAGE_TEST_MARKER();
;;;815    							}
;;;816    						}
;;;817    						else if( xYieldRequired != pdFALSE )
;;;818    						{
;;;819    							/* This path is a special case that will only get
;;;820    							executed if the task was holding multiple mutexes
;;;821    							and the mutexes were given back in an order that is
;;;822    							different to that in which they were taken. */
;;;823    							queueYIELD_IF_USING_PREEMPTION();
;;;824    						}
;;;825    						else
;;;826    						{
;;;827    							mtCOVERAGE_TEST_MARKER();
;;;828    						}
;;;829    					}
;;;830    				}
;;;831    				#else /* configUSE_QUEUE_SETS */
;;;832    				{
;;;833    					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
0000b4  462a              MOV      r2,r5
0000b6  4641              MOV      r1,r8
0000b8  4620              MOV      r0,r4
0000ba  f7fffffe          BL       prvCopyDataToQueue
0000be  4607              MOV      r7,r0
;;;834    
;;;835    					/* If there was a task waiting for data to arrive on the
;;;836    					queue then unblock it now. */
;;;837    					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
0000c0  6a60              LDR      r0,[r4,#0x24]
0000c2  b908              CBNZ     r0,|L27.200|
0000c4  2001              MOVS     r0,#1
0000c6  e000              B        |L27.202|
                  |L27.200|
0000c8  2000              MOVS     r0,#0
                  |L27.202|
0000ca  b968              CBNZ     r0,|L27.232|
;;;838    					{
;;;839    						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
0000cc  f1040024          ADD      r0,r4,#0x24
0000d0  f7fffffe          BL       xTaskRemoveFromEventList
0000d4  b188              CBZ      r0,|L27.250|
;;;840    						{
;;;841    							/* The unblocked task has a priority higher than
;;;842    							our own so yield immediately.  Yes it is ok to do
;;;843    							this from within the critical section - the kernel
;;;844    							takes care of that. */
;;;845    							queueYIELD_IF_USING_PREEMPTION();
0000d6  f04f5080          MOV      r0,#0x10000000
0000da  4932              LDR      r1,|L27.420|
0000dc  6008              STR      r0,[r1,#0]
0000de  f3bf8f4f          DSB      
0000e2  f3bf8f6f          ISB      
0000e6  e008              B        |L27.250|
                  |L27.232|
;;;846    						}
;;;847    						else
;;;848    						{
;;;849    							mtCOVERAGE_TEST_MARKER();
;;;850    						}
;;;851    					}
;;;852    					else if( xYieldRequired != pdFALSE )
0000e8  b13f              CBZ      r7,|L27.250|
;;;853    					{
;;;854    						/* This path is a special case that will only get
;;;855    						executed if the task was holding multiple mutexes and
;;;856    						the mutexes were given back in an order that is
;;;857    						different to that in which they were taken. */
;;;858    						queueYIELD_IF_USING_PREEMPTION();
0000ea  f04f5080          MOV      r0,#0x10000000
0000ee  492d              LDR      r1,|L27.420|
0000f0  6008              STR      r0,[r1,#0]
0000f2  f3bf8f4f          DSB      
0000f6  f3bf8f6f          ISB      
                  |L27.250|
;;;859    					}
;;;860    					else
;;;861    					{
;;;862    						mtCOVERAGE_TEST_MARKER();
;;;863    					}
;;;864    				}
;;;865    				#endif /* configUSE_QUEUE_SETS */
;;;866    
;;;867    				taskEXIT_CRITICAL();
0000fa  f7fffffe          BL       vPortExitCritical
;;;868    				return pdPASS;
0000fe  2001              MOVS     r0,#1
                  |L27.256|
;;;869    			}
;;;870    			else
;;;871    			{
;;;872    				if( xTicksToWait == ( TickType_t ) 0 )
;;;873    				{
;;;874    					/* The queue was full and no block time is specified (or
;;;875    					the block time has expired) so leave now. */
;;;876    					taskEXIT_CRITICAL();
;;;877    
;;;878    					/* Return to the original privilege level before exiting
;;;879    					the function. */
;;;880    					traceQUEUE_SEND_FAILED( pxQueue );
;;;881    					return errQUEUE_FULL;
;;;882    				}
;;;883    				else if( xEntryTimeSet == pdFALSE )
;;;884    				{
;;;885    					/* The queue was full and a block time was specified so
;;;886    					configure the timeout structure. */
;;;887    					vTaskInternalSetTimeOutState( &xTimeOut );
;;;888    					xEntryTimeSet = pdTRUE;
;;;889    				}
;;;890    				else
;;;891    				{
;;;892    					/* Entry time was already set. */
;;;893    					mtCOVERAGE_TEST_MARKER();
;;;894    				}
;;;895    			}
;;;896    		}
;;;897    		taskEXIT_CRITICAL();
;;;898    
;;;899    		/* Interrupts and other tasks can send to and receive from the queue
;;;900    		now the critical section has been exited. */
;;;901    
;;;902    		vTaskSuspendAll();
;;;903    		prvLockQueue( pxQueue );
;;;904    
;;;905    		/* Update the timeout state to see if it has expired yet. */
;;;906    		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;907    		{
;;;908    			if( prvIsQueueFull( pxQueue ) != pdFALSE )
;;;909    			{
;;;910    				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
;;;911    				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
;;;912    
;;;913    				/* Unlocking the queue means queue events can effect the
;;;914    				event list.  It is possible that interrupts occurring now
;;;915    				remove this task from the event list again - but as the
;;;916    				scheduler is suspended the task will go onto the pending
;;;917    				ready last instead of the actual ready list. */
;;;918    				prvUnlockQueue( pxQueue );
;;;919    
;;;920    				/* Resuming the scheduler will move tasks from the pending
;;;921    				ready list into the ready list - so it is feasible that this
;;;922    				task is already in a ready list before it yields - in which
;;;923    				case the yield will not cause a context switch unless there
;;;924    				is also a higher priority task in the pending ready list. */
;;;925    				if( xTaskResumeAll() == pdFALSE )
;;;926    				{
;;;927    					portYIELD_WITHIN_API();
;;;928    				}
;;;929    			}
;;;930    			else
;;;931    			{
;;;932    				/* Try again. */
;;;933    				prvUnlockQueue( pxQueue );
;;;934    				( void ) xTaskResumeAll();
;;;935    			}
;;;936    		}
;;;937    		else
;;;938    		{
;;;939    			/* The timeout has expired. */
;;;940    			prvUnlockQueue( pxQueue );
;;;941    			( void ) xTaskResumeAll();
;;;942    
;;;943    			traceQUEUE_SEND_FAILED( pxQueue );
;;;944    			return errQUEUE_FULL;
;;;945    		}
;;;946    	} /*lint -restore */
;;;947    }
000100  b007              ADD      sp,sp,#0x1c
000102  e8bd83f0          POP      {r4-r9,pc}
                  |L27.262|
000106  9805              LDR      r0,[sp,#0x14]         ;872
000108  b918              CBNZ     r0,|L27.274|
00010a  f7fffffe          BL       vPortExitCritical
00010e  2000              MOVS     r0,#0                 ;881
000110  e7f6              B        |L27.256|
                  |L27.274|
000112  f1b90f00          CMP      r9,#0                 ;883
000116  d104              BNE      |L27.290|
000118  a801              ADD      r0,sp,#4              ;887
00011a  f7fffffe          BL       vTaskInternalSetTimeOutState
00011e  f04f0901          MOV      r9,#1                 ;888
                  |L27.290|
000122  f7fffffe          BL       vPortExitCritical
000126  f7fffffe          BL       vTaskSuspendAll
00012a  f7fffffe          BL       vPortEnterCritical
00012e  f9940044          LDRSB    r0,[r4,#0x44]         ;903
000132  1c40              ADDS     r0,r0,#1              ;903
000134  b910              CBNZ     r0,|L27.316|
000136  2000              MOVS     r0,#0                 ;903
000138  f8840044          STRB     r0,[r4,#0x44]         ;903
                  |L27.316|
00013c  f9940045          LDRSB    r0,[r4,#0x45]         ;903
000140  1c40              ADDS     r0,r0,#1              ;903
000142  b910              CBNZ     r0,|L27.330|
000144  2000              MOVS     r0,#0                 ;903
000146  f8840045          STRB     r0,[r4,#0x45]         ;903
                  |L27.330|
00014a  f7fffffe          BL       vPortExitCritical
00014e  a905              ADD      r1,sp,#0x14           ;906
000150  a801              ADD      r0,sp,#4              ;906
000152  f7fffffe          BL       xTaskCheckForTimeOut
000156  b9f0              CBNZ     r0,|L27.406|
000158  4620              MOV      r0,r4                 ;908
00015a  f7fffffe          BL       prvIsQueueFull
00015e  b1a0              CBZ      r0,|L27.394|
000160  f1040010          ADD      r0,r4,#0x10           ;911
000164  9905              LDR      r1,[sp,#0x14]         ;911
000166  f7fffffe          BL       vTaskPlaceOnEventList
00016a  4620              MOV      r0,r4                 ;918
00016c  f7fffffe          BL       prvUnlockQueue
000170  f7fffffe          BL       xTaskResumeAll
000174  2800              CMP      r0,#0                 ;925
000176  d195              BNE      |L27.164|
000178  f04f5080          MOV      r0,#0x10000000        ;927
00017c  4909              LDR      r1,|L27.420|
00017e  6008              STR      r0,[r1,#0]            ;927
000180  f3bf8f4f          DSB                            ;927
000184  f3bf8f6f          ISB                            ;927
000188  e78c              B        |L27.164|
                  |L27.394|
00018a  4620              MOV      r0,r4                 ;933
00018c  f7fffffe          BL       prvUnlockQueue
000190  f7fffffe          BL       xTaskResumeAll
000194  e786              B        |L27.164|
                  |L27.406|
000196  4620              MOV      r0,r4                 ;940
000198  f7fffffe          BL       prvUnlockQueue
00019c  f7fffffe          BL       xTaskResumeAll
0001a0  2000              MOVS     r0,#0                 ;944
0001a2  e7ad              B        |L27.256|
;;;948    /*-----------------------------------------------------------*/
                          ENDP

                  |L27.420|
                          DCD      0xe000ed04

                          AREA ||i.xQueueGenericSendFromISR||, CODE, READONLY, ALIGN=1

                  xQueueGenericSendFromISR PROC
;;;949    
;;;950    BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;951    {
000004  4607              MOV      r7,r0
000006  468a              MOV      r10,r1
000008  4690              MOV      r8,r2
00000a  461e              MOV      r6,r3
;;;952    BaseType_t xReturn;
;;;953    UBaseType_t uxSavedInterruptStatus;
;;;954    Queue_t * const pxQueue = xQueue;
00000c  463c              MOV      r4,r7
;;;955    
;;;956    	configASSERT( pxQueue );
00000e  b954              CBNZ     r4,|L28.38|
000010  bf00              NOP      
000012  2050              MOVS     r0,#0x50
000014  f3808811          MSR      BASEPRI,r0
000018  f3bf8f4f          DSB      
00001c  f3bf8f6f          ISB      
000020  bf00              NOP      
000022  bf00              NOP      
                  |L28.36|
000024  e7fe              B        |L28.36|
                  |L28.38|
;;;957    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
000026  f1ba0f00          CMP      r10,#0
00002a  d101              BNE      |L28.48|
00002c  6c20              LDR      r0,[r4,#0x40]
00002e  b908              CBNZ     r0,|L28.52|
                  |L28.48|
000030  2001              MOVS     r0,#1
000032  e000              B        |L28.54|
                  |L28.52|
000034  2000              MOVS     r0,#0
                  |L28.54|
000036  b950              CBNZ     r0,|L28.78|
000038  bf00              NOP      
00003a  2050              MOVS     r0,#0x50
00003c  f3808811          MSR      BASEPRI,r0
000040  f3bf8f4f          DSB      
000044  f3bf8f6f          ISB      
000048  bf00              NOP      
00004a  bf00              NOP      
                  |L28.76|
00004c  e7fe              B        |L28.76|
                  |L28.78|
;;;958    	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
00004e  2e02              CMP      r6,#2
000050  d102              BNE      |L28.88|
000052  6be0              LDR      r0,[r4,#0x3c]
000054  2801              CMP      r0,#1
000056  d101              BNE      |L28.92|
                  |L28.88|
000058  2001              MOVS     r0,#1
00005a  e000              B        |L28.94|
                  |L28.92|
00005c  2000              MOVS     r0,#0
                  |L28.94|
00005e  b950              CBNZ     r0,|L28.118|
000060  bf00              NOP      
000062  2050              MOVS     r0,#0x50
000064  f3808811          MSR      BASEPRI,r0
000068  f3bf8f4f          DSB      
00006c  f3bf8f6f          ISB      
000070  bf00              NOP      
000072  bf00              NOP      
                  |L28.116|
000074  e7fe              B        |L28.116|
                  |L28.118|
;;;959    
;;;960    	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;961    	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;962    	above the maximum system call priority are kept permanently enabled, even
;;;963    	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;964    	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;965    	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;966    	failure if a FreeRTOS API function is called from an interrupt that has been
;;;967    	assigned a priority above the configured maximum system call priority.
;;;968    	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;969    	that have been assigned a priority at or (logically) below the maximum
;;;970    	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;971    	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;972    	More information (albeit Cortex-M specific) is provided on the following
;;;973    	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;974    	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000076  f7fffffe          BL       vPortValidateInterruptPriority
;;;975    
;;;976    	/* Similar to xQueueGenericSend, except without blocking if there is no room
;;;977    	in the queue.  Also don't directly wake a task that was blocked on a queue
;;;978    	read, instead return a flag to say whether a context switch is required or
;;;979    	not (i.e. has a task with a higher priority than us been woken by this
;;;980    	post). */
;;;981    	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00007a  bf00              NOP      
00007c  2150              MOVS     r1,#0x50
00007e  f3ef8011          MRS      r0,BASEPRI
000082  f3818811          MSR      BASEPRI,r1
000086  f3bf8f4f          DSB      
00008a  f3bf8f6f          ISB      
00008e  bf00              NOP      
000090  4605              MOV      r5,r0
;;;982    	{
;;;983    		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
000092  6ba0              LDR      r0,[r4,#0x38]
000094  6be1              LDR      r1,[r4,#0x3c]
000096  4288              CMP      r0,r1
000098  d301              BCC      |L28.158|
00009a  2e02              CMP      r6,#2
00009c  d125              BNE      |L28.234|
                  |L28.158|
;;;984    		{
;;;985    			const int8_t cTxLock = pxQueue->cTxLock;
00009e  f994b045          LDRSB    r11,[r4,#0x45]
;;;986    			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
0000a2  6ba0              LDR      r0,[r4,#0x38]
0000a4  9000              STR      r0,[sp,#0]
;;;987    
;;;988    			traceQUEUE_SEND_FROM_ISR( pxQueue );
;;;989    
;;;990    			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
;;;991    			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
;;;992    			in a task disinheriting a priority and prvCopyDataToQueue() can be
;;;993    			called here even though the disinherit function does not check if
;;;994    			the scheduler is suspended before accessing the ready lists. */
;;;995    			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
0000a6  4632              MOV      r2,r6
0000a8  4651              MOV      r1,r10
0000aa  4620              MOV      r0,r4
0000ac  f7fffffe          BL       prvCopyDataToQueue
;;;996    
;;;997    			/* The event list is not altered if the queue is locked.  This will
;;;998    			be done when the queue is unlocked later. */
;;;999    			if( cTxLock == queueUNLOCKED )
0000b0  f10b0001          ADD      r0,r11,#1
0000b4  b988              CBNZ     r0,|L28.218|
;;;1000   			{
;;;1001   				#if ( configUSE_QUEUE_SETS == 1 )
;;;1002   				{
;;;1003   					if( pxQueue->pxQueueSetContainer != NULL )
;;;1004   					{
;;;1005   						if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
;;;1006   						{
;;;1007   							/* Do not notify the queue set as an existing item
;;;1008   							was overwritten in the queue so the number of items
;;;1009   							in the queue has not changed. */
;;;1010   							mtCOVERAGE_TEST_MARKER();
;;;1011   						}
;;;1012   						else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
;;;1013   						{
;;;1014   							/* The queue is a member of a queue set, and posting
;;;1015   							to the queue set caused a higher priority task to
;;;1016   							unblock.  A context switch is required. */
;;;1017   							if( pxHigherPriorityTaskWoken != NULL )
;;;1018   							{
;;;1019   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1020   							}
;;;1021   							else
;;;1022   							{
;;;1023   								mtCOVERAGE_TEST_MARKER();
;;;1024   							}
;;;1025   						}
;;;1026   						else
;;;1027   						{
;;;1028   							mtCOVERAGE_TEST_MARKER();
;;;1029   						}
;;;1030   					}
;;;1031   					else
;;;1032   					{
;;;1033   						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1034   						{
;;;1035   							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1036   							{
;;;1037   								/* The task waiting has a higher priority so
;;;1038   								record that a context switch is required. */
;;;1039   								if( pxHigherPriorityTaskWoken != NULL )
;;;1040   								{
;;;1041   									*pxHigherPriorityTaskWoken = pdTRUE;
;;;1042   								}
;;;1043   								else
;;;1044   								{
;;;1045   									mtCOVERAGE_TEST_MARKER();
;;;1046   								}
;;;1047   							}
;;;1048   							else
;;;1049   							{
;;;1050   								mtCOVERAGE_TEST_MARKER();
;;;1051   							}
;;;1052   						}
;;;1053   						else
;;;1054   						{
;;;1055   							mtCOVERAGE_TEST_MARKER();
;;;1056   						}
;;;1057   					}
;;;1058   				}
;;;1059   				#else /* configUSE_QUEUE_SETS */
;;;1060   				{
;;;1061   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
0000b6  6a60              LDR      r0,[r4,#0x24]
0000b8  b908              CBNZ     r0,|L28.190|
0000ba  2001              MOVS     r0,#1
0000bc  e000              B        |L28.192|
                  |L28.190|
0000be  2000              MOVS     r0,#0
                  |L28.192|
0000c0  b950              CBNZ     r0,|L28.216|
;;;1062   					{
;;;1063   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
0000c2  f1040024          ADD      r0,r4,#0x24
0000c6  f7fffffe          BL       xTaskRemoveFromEventList
0000ca  b128              CBZ      r0,|L28.216|
;;;1064   						{
;;;1065   							/* The task waiting has a higher priority so record that a
;;;1066   							context	switch is required. */
;;;1067   							if( pxHigherPriorityTaskWoken != NULL )
0000cc  f1b80f00          CMP      r8,#0
0000d0  d002              BEQ      |L28.216|
;;;1068   							{
;;;1069   								*pxHigherPriorityTaskWoken = pdTRUE;
0000d2  2001              MOVS     r0,#1
0000d4  f8c80000          STR      r0,[r8,#0]
                  |L28.216|
;;;1070   							}
;;;1071   							else
;;;1072   							{
;;;1073   								mtCOVERAGE_TEST_MARKER();
;;;1074   							}
;;;1075   						}
;;;1076   						else
;;;1077   						{
;;;1078   							mtCOVERAGE_TEST_MARKER();
;;;1079   						}
;;;1080   					}
;;;1081   					else
;;;1082   					{
;;;1083   						mtCOVERAGE_TEST_MARKER();
;;;1084   					}
;;;1085   					
;;;1086   					/* Not used in this path. */
;;;1087   					( void ) uxPreviousMessagesWaiting;
0000d8  e004              B        |L28.228|
                  |L28.218|
;;;1088   				}
;;;1089   				#endif /* configUSE_QUEUE_SETS */
;;;1090   			}
;;;1091   			else
;;;1092   			{
;;;1093   				/* Increment the lock count so the task that unlocks the queue
;;;1094   				knows that data was posted while it was locked. */
;;;1095   				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
0000da  f10b0001          ADD      r0,r11,#1
0000de  b240              SXTB     r0,r0
0000e0  f8840045          STRB     r0,[r4,#0x45]
                  |L28.228|
;;;1096   			}
;;;1097   
;;;1098   			xReturn = pdPASS;
0000e4  f04f0901          MOV      r9,#1
;;;1099   		}
0000e8  e001              B        |L28.238|
                  |L28.234|
;;;1100   		else
;;;1101   		{
;;;1102   			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
;;;1103   			xReturn = errQUEUE_FULL;
0000ea  f04f0900          MOV      r9,#0
                  |L28.238|
;;;1104   		}
;;;1105   	}
;;;1106   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0000ee  bf00              NOP      
0000f0  f3858811          MSR      BASEPRI,r5
0000f4  bf00              NOP      
;;;1107   
;;;1108   	return xReturn;
0000f6  4648              MOV      r0,r9
;;;1109   }
0000f8  e8bd8ff8          POP      {r3-r11,pc}
;;;1110   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueGetMutexHolder||, CODE, READONLY, ALIGN=1

                  xQueueGetMutexHolder PROC
;;;531    
;;;532    	TaskHandle_t xQueueGetMutexHolder( QueueHandle_t xSemaphore )
000000  b570              PUSH     {r4-r6,lr}
;;;533    	{
000002  4604              MOV      r4,r0
;;;534    	TaskHandle_t pxReturn;
;;;535    	Queue_t * const pxSemaphore = ( Queue_t * ) xSemaphore;
000004  4626              MOV      r6,r4
;;;536    
;;;537    		/* This function is called by xSemaphoreGetMutexHolder(), and should not
;;;538    		be called directly.  Note:  This is a good way of determining if the
;;;539    		calling task is the mutex holder, but not a good way of determining the
;;;540    		identity of the mutex holder, as the holder may change between the
;;;541    		following critical section exiting and the function returning. */
;;;542    		taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;543    		{
;;;544    			if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
00000a  6830              LDR      r0,[r6,#0]
00000c  b908              CBNZ     r0,|L29.18|
;;;545    			{
;;;546    				pxReturn = pxSemaphore->u.xSemaphore.xMutexHolder;
00000e  68b5              LDR      r5,[r6,#8]
000010  e000              B        |L29.20|
                  |L29.18|
;;;547    			}
;;;548    			else
;;;549    			{
;;;550    				pxReturn = NULL;
000012  2500              MOVS     r5,#0
                  |L29.20|
;;;551    			}
;;;552    		}
;;;553    		taskEXIT_CRITICAL();
000014  f7fffffe          BL       vPortExitCritical
;;;554    
;;;555    		return pxReturn;
000018  4628              MOV      r0,r5
;;;556    	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
00001a  bd70              POP      {r4-r6,pc}
;;;557    
                          ENDP


                          AREA ||i.xQueueGetMutexHolderFromISR||, CODE, READONLY, ALIGN=1

                  xQueueGetMutexHolderFromISR PROC
;;;562    
;;;563    	TaskHandle_t xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )
000000  4601              MOV      r1,r0
;;;564    	{
;;;565    	TaskHandle_t pxReturn;
;;;566    
;;;567    		configASSERT( xSemaphore );
000002  b951              CBNZ     r1,|L30.26|
000004  bf00              NOP      
000006  2250              MOVS     r2,#0x50
000008  f3828811          MSR      BASEPRI,r2
00000c  f3bf8f4f          DSB      
000010  f3bf8f6f          ISB      
000014  bf00              NOP      
000016  bf00              NOP      
                  |L30.24|
000018  e7fe              B        |L30.24|
                  |L30.26|
;;;568    
;;;569    		/* Mutexes cannot be used in interrupt service routines, so the mutex
;;;570    		holder should not change in an ISR, and therefore a critical section is
;;;571    		not required here. */
;;;572    		if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
00001a  680a              LDR      r2,[r1,#0]
00001c  b90a              CBNZ     r2,|L30.34|
;;;573    		{
;;;574    			pxReturn = ( ( Queue_t * ) xSemaphore )->u.xSemaphore.xMutexHolder;
00001e  6888              LDR      r0,[r1,#8]
000020  e000              B        |L30.36|
                  |L30.34|
;;;575    		}
;;;576    		else
;;;577    		{
;;;578    			pxReturn = NULL;
000022  2000              MOVS     r0,#0
                  |L30.36|
;;;579    		}
;;;580    
;;;581    		return pxReturn;
;;;582    	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
000024  4770              BX       lr
;;;583    
                          ENDP


                          AREA ||i.xQueueGiveFromISR||, CODE, READONLY, ALIGN=1

                  xQueueGiveFromISR PROC
;;;1111   
;;;1112   BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1113   {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;1114   BaseType_t xReturn;
;;;1115   UBaseType_t uxSavedInterruptStatus;
;;;1116   Queue_t * const pxQueue = xQueue;
000008  4634              MOV      r4,r6
;;;1117   
;;;1118   	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
;;;1119   	item size is 0.  Don't directly wake a task that was blocked on a queue
;;;1120   	read, instead return a flag to say whether a context switch is required or
;;;1121   	not (i.e. has a task with a higher priority than us been woken by this
;;;1122   	post). */
;;;1123   
;;;1124   	configASSERT( pxQueue );
00000a  b954              CBNZ     r4,|L31.34|
00000c  bf00              NOP      
00000e  2050              MOVS     r0,#0x50
000010  f3808811          MSR      BASEPRI,r0
000014  f3bf8f4f          DSB      
000018  f3bf8f6f          ISB      
00001c  bf00              NOP      
00001e  bf00              NOP      
                  |L31.32|
000020  e7fe              B        |L31.32|
                  |L31.34|
;;;1125   
;;;1126   	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
;;;1127   	if the item size is not 0. */
;;;1128   	configASSERT( pxQueue->uxItemSize == 0 );
000022  6c20              LDR      r0,[r4,#0x40]
000024  b908              CBNZ     r0,|L31.42|
000026  2001              MOVS     r0,#1
000028  e000              B        |L31.44|
                  |L31.42|
00002a  2000              MOVS     r0,#0
                  |L31.44|
00002c  b950              CBNZ     r0,|L31.68|
00002e  bf00              NOP      
000030  2050              MOVS     r0,#0x50
000032  f3808811          MSR      BASEPRI,r0
000036  f3bf8f4f          DSB      
00003a  f3bf8f6f          ISB      
00003e  bf00              NOP      
000040  bf00              NOP      
                  |L31.66|
000042  e7fe              B        |L31.66|
                  |L31.68|
;;;1129   
;;;1130   	/* Normally a mutex would not be given from an interrupt, especially if
;;;1131   	there is a mutex holder, as priority inheritance makes no sense for an
;;;1132   	interrupts, only tasks. */
;;;1133   	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
000044  6820              LDR      r0,[r4,#0]
000046  b908              CBNZ     r0,|L31.76|
000048  68a0              LDR      r0,[r4,#8]
00004a  b908              CBNZ     r0,|L31.80|
                  |L31.76|
00004c  2001              MOVS     r0,#1
00004e  e000              B        |L31.82|
                  |L31.80|
000050  2000              MOVS     r0,#0
                  |L31.82|
000052  b950              CBNZ     r0,|L31.106|
000054  bf00              NOP      
000056  2050              MOVS     r0,#0x50
000058  f3808811          MSR      BASEPRI,r0
00005c  f3bf8f4f          DSB      
000060  f3bf8f6f          ISB      
000064  bf00              NOP      
000066  bf00              NOP      
                  |L31.104|
000068  e7fe              B        |L31.104|
                  |L31.106|
;;;1134   
;;;1135   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1136   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1137   	above the maximum system call priority are kept permanently enabled, even
;;;1138   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1139   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1140   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1141   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1142   	assigned a priority above the configured maximum system call priority.
;;;1143   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1144   	that have been assigned a priority at or (logically) below the maximum
;;;1145   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1146   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1147   	More information (albeit Cortex-M specific) is provided on the following
;;;1148   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1149   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
00006a  f7fffffe          BL       vPortValidateInterruptPriority
;;;1150   
;;;1151   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00006e  bf00              NOP      
000070  2150              MOVS     r1,#0x50
000072  f3ef8011          MRS      r0,BASEPRI
000076  f3818811          MSR      BASEPRI,r1
00007a  f3bf8f4f          DSB      
00007e  f3bf8f6f          ISB      
000082  bf00              NOP      
000084  4605              MOV      r5,r0
;;;1152   	{
;;;1153   		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
000086  f8d49038          LDR      r9,[r4,#0x38]
;;;1154   
;;;1155   		/* When the queue is used to implement a semaphore no data is ever
;;;1156   		moved through the queue but it is still valid to see if the queue 'has
;;;1157   		space'. */
;;;1158   		if( uxMessagesWaiting < pxQueue->uxLength )
00008a  6be0              LDR      r0,[r4,#0x3c]
00008c  4548              CMP      r0,r9
00008e  d91e              BLS      |L31.206|
;;;1159   		{
;;;1160   			const int8_t cTxLock = pxQueue->cTxLock;
000090  f994a045          LDRSB    r10,[r4,#0x45]
;;;1161   
;;;1162   			traceQUEUE_SEND_FROM_ISR( pxQueue );
;;;1163   
;;;1164   			/* A task can only have an inherited priority if it is a mutex
;;;1165   			holder - and if there is a mutex holder then the mutex cannot be
;;;1166   			given from an ISR.  As this is the ISR version of the function it
;;;1167   			can be assumed there is no mutex holder and no need to determine if
;;;1168   			priority disinheritance is needed.  Simply increase the count of
;;;1169   			messages (semaphores) available. */
;;;1170   			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
000094  f1090001          ADD      r0,r9,#1
000098  63a0              STR      r0,[r4,#0x38]
;;;1171   
;;;1172   			/* The event list is not altered if the queue is locked.  This will
;;;1173   			be done when the queue is unlocked later. */
;;;1174   			if( cTxLock == queueUNLOCKED )
00009a  f10a0001          ADD      r0,r10,#1
00009e  b970              CBNZ     r0,|L31.190|
;;;1175   			{
;;;1176   				#if ( configUSE_QUEUE_SETS == 1 )
;;;1177   				{
;;;1178   					if( pxQueue->pxQueueSetContainer != NULL )
;;;1179   					{
;;;1180   						if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
;;;1181   						{
;;;1182   							/* The semaphore is a member of a queue set, and
;;;1183   							posting	to the queue set caused a higher priority
;;;1184   							task to	unblock.  A context switch is required. */
;;;1185   							if( pxHigherPriorityTaskWoken != NULL )
;;;1186   							{
;;;1187   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1188   							}
;;;1189   							else
;;;1190   							{
;;;1191   								mtCOVERAGE_TEST_MARKER();
;;;1192   							}
;;;1193   						}
;;;1194   						else
;;;1195   						{
;;;1196   							mtCOVERAGE_TEST_MARKER();
;;;1197   						}
;;;1198   					}
;;;1199   					else
;;;1200   					{
;;;1201   						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1202   						{
;;;1203   							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1204   							{
;;;1205   								/* The task waiting has a higher priority so
;;;1206   								record that a context switch is required. */
;;;1207   								if( pxHigherPriorityTaskWoken != NULL )
;;;1208   								{
;;;1209   									*pxHigherPriorityTaskWoken = pdTRUE;
;;;1210   								}
;;;1211   								else
;;;1212   								{
;;;1213   									mtCOVERAGE_TEST_MARKER();
;;;1214   								}
;;;1215   							}
;;;1216   							else
;;;1217   							{
;;;1218   								mtCOVERAGE_TEST_MARKER();
;;;1219   							}
;;;1220   						}
;;;1221   						else
;;;1222   						{
;;;1223   							mtCOVERAGE_TEST_MARKER();
;;;1224   						}
;;;1225   					}
;;;1226   				}
;;;1227   				#else /* configUSE_QUEUE_SETS */
;;;1228   				{
;;;1229   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
0000a0  6a60              LDR      r0,[r4,#0x24]
0000a2  b908              CBNZ     r0,|L31.168|
0000a4  2001              MOVS     r0,#1
0000a6  e000              B        |L31.170|
                  |L31.168|
0000a8  2000              MOVS     r0,#0
                  |L31.170|
0000aa  b968              CBNZ     r0,|L31.200|
;;;1230   					{
;;;1231   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
0000ac  f1040024          ADD      r0,r4,#0x24
0000b0  f7fffffe          BL       xTaskRemoveFromEventList
0000b4  b140              CBZ      r0,|L31.200|
;;;1232   						{
;;;1233   							/* The task waiting has a higher priority so record that a
;;;1234   							context	switch is required. */
;;;1235   							if( pxHigherPriorityTaskWoken != NULL )
0000b6  b13f              CBZ      r7,|L31.200|
;;;1236   							{
;;;1237   								*pxHigherPriorityTaskWoken = pdTRUE;
0000b8  2001              MOVS     r0,#1
0000ba  6038              STR      r0,[r7,#0]
0000bc  e004              B        |L31.200|
                  |L31.190|
;;;1238   							}
;;;1239   							else
;;;1240   							{
;;;1241   								mtCOVERAGE_TEST_MARKER();
;;;1242   							}
;;;1243   						}
;;;1244   						else
;;;1245   						{
;;;1246   							mtCOVERAGE_TEST_MARKER();
;;;1247   						}
;;;1248   					}
;;;1249   					else
;;;1250   					{
;;;1251   						mtCOVERAGE_TEST_MARKER();
;;;1252   					}
;;;1253   				}
;;;1254   				#endif /* configUSE_QUEUE_SETS */
;;;1255   			}
;;;1256   			else
;;;1257   			{
;;;1258   				/* Increment the lock count so the task that unlocks the queue
;;;1259   				knows that data was posted while it was locked. */
;;;1260   				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
0000be  f10a0001          ADD      r0,r10,#1
0000c2  b240              SXTB     r0,r0
0000c4  f8840045          STRB     r0,[r4,#0x45]
                  |L31.200|
;;;1261   			}
;;;1262   
;;;1263   			xReturn = pdPASS;
0000c8  f04f0801          MOV      r8,#1
;;;1264   		}
0000cc  e001              B        |L31.210|
                  |L31.206|
;;;1265   		else
;;;1266   		{
;;;1267   			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
;;;1268   			xReturn = errQUEUE_FULL;
0000ce  f04f0800          MOV      r8,#0
                  |L31.210|
;;;1269   		}
;;;1270   	}
;;;1271   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0000d2  bf00              NOP      
0000d4  f3858811          MSR      BASEPRI,r5
0000d8  bf00              NOP      
;;;1272   
;;;1273   	return xReturn;
0000da  4640              MOV      r0,r8
;;;1274   }
0000dc  e8bd87f0          POP      {r4-r10,pc}
;;;1275   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueGiveMutexRecursive||, CODE, READONLY, ALIGN=1

                  xQueueGiveMutexRecursive PROC
;;;588    
;;;589    	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
000000  b570              PUSH     {r4-r6,lr}
;;;590    	{
000002  4605              MOV      r5,r0
;;;591    	BaseType_t xReturn;
;;;592    	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
000004  462c              MOV      r4,r5
;;;593    
;;;594    		configASSERT( pxMutex );
000006  b954              CBNZ     r4,|L32.30|
000008  bf00              NOP      
00000a  2050              MOVS     r0,#0x50
00000c  f3808811          MSR      BASEPRI,r0
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L32.28|
00001c  e7fe              B        |L32.28|
                  |L32.30|
;;;595    
;;;596    		/* If this is the task that holds the mutex then xMutexHolder will not
;;;597    		change outside of this task.  If this task does not hold the mutex then
;;;598    		pxMutexHolder can never coincidentally equal the tasks handle, and as
;;;599    		this is the only condition we are interested in it does not matter if
;;;600    		pxMutexHolder is accessed simultaneously by another task.  Therefore no
;;;601    		mutual exclusion is required to test the pxMutexHolder variable. */
;;;602    		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
00001e  f7fffffe          BL       xTaskGetCurrentTaskHandle
000022  68a1              LDR      r1,[r4,#8]
000024  4288              CMP      r0,r1
000026  d10c              BNE      |L32.66|
;;;603    		{
;;;604    			traceGIVE_MUTEX_RECURSIVE( pxMutex );
;;;605    
;;;606    			/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
;;;607    			the task handle, therefore no underflow check is required.  Also,
;;;608    			uxRecursiveCallCount is only modified by the mutex holder, and as
;;;609    			there can only be one, no mutual exclusion is required to modify the
;;;610    			uxRecursiveCallCount member. */
;;;611    			( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
000028  68e0              LDR      r0,[r4,#0xc]
00002a  1e40              SUBS     r0,r0,#1
00002c  60e0              STR      r0,[r4,#0xc]
;;;612    
;;;613    			/* Has the recursive call count unwound to 0? */
;;;614    			if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
00002e  68e0              LDR      r0,[r4,#0xc]
000030  b928              CBNZ     r0,|L32.62|
;;;615    			{
;;;616    				/* Return the mutex.  This will automatically unblock any other
;;;617    				task that might be waiting to access the mutex. */
;;;618    				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
000032  2300              MOVS     r3,#0
000034  461a              MOV      r2,r3
000036  4619              MOV      r1,r3
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       xQueueGenericSend
                  |L32.62|
;;;619    			}
;;;620    			else
;;;621    			{
;;;622    				mtCOVERAGE_TEST_MARKER();
;;;623    			}
;;;624    
;;;625    			xReturn = pdPASS;
00003e  2601              MOVS     r6,#1
000040  e000              B        |L32.68|
                  |L32.66|
;;;626    		}
;;;627    		else
;;;628    		{
;;;629    			/* The mutex cannot be given because the calling task is not the
;;;630    			holder. */
;;;631    			xReturn = pdFAIL;
000042  2600              MOVS     r6,#0
                  |L32.68|
;;;632    
;;;633    			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
;;;634    		}
;;;635    
;;;636    		return xReturn;
000044  4630              MOV      r0,r6
;;;637    	}
000046  bd70              POP      {r4-r6,pc}
;;;638    
                          ENDP


                          AREA ||i.xQueueIsQueueEmptyFromISR||, CODE, READONLY, ALIGN=1

                  xQueueIsQueueEmptyFromISR PROC
;;;2311   
;;;2312   BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
000000  b510              PUSH     {r4,lr}
;;;2313   {
000002  4601              MOV      r1,r0
;;;2314   BaseType_t xReturn;
;;;2315   Queue_t * const pxQueue = xQueue;
000004  460a              MOV      r2,r1
;;;2316   
;;;2317   	configASSERT( pxQueue );
000006  b952              CBNZ     r2,|L33.30|
000008  bf00              NOP      
00000a  2350              MOVS     r3,#0x50
00000c  f3838811          MSR      BASEPRI,r3
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L33.28|
00001c  e7fe              B        |L33.28|
                  |L33.30|
;;;2318   	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
00001e  6b93              LDR      r3,[r2,#0x38]
000020  b90b              CBNZ     r3,|L33.38|
;;;2319   	{
;;;2320   		xReturn = pdTRUE;
000022  2001              MOVS     r0,#1
000024  e000              B        |L33.40|
                  |L33.38|
;;;2321   	}
;;;2322   	else
;;;2323   	{
;;;2324   		xReturn = pdFALSE;
000026  2000              MOVS     r0,#0
                  |L33.40|
;;;2325   	}
;;;2326   
;;;2327   	return xReturn;
;;;2328   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
000028  bd10              POP      {r4,pc}
;;;2329   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueIsQueueFullFromISR||, CODE, READONLY, ALIGN=1

                  xQueueIsQueueFullFromISR PROC
;;;2351   
;;;2352   BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
000000  b510              PUSH     {r4,lr}
;;;2353   {
000002  4601              MOV      r1,r0
;;;2354   BaseType_t xReturn;
;;;2355   Queue_t * const pxQueue = xQueue;
000004  460a              MOV      r2,r1
;;;2356   
;;;2357   	configASSERT( pxQueue );
000006  b952              CBNZ     r2,|L34.30|
000008  bf00              NOP      
00000a  2350              MOVS     r3,#0x50
00000c  f3838811          MSR      BASEPRI,r3
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L34.28|
00001c  e7fe              B        |L34.28|
                  |L34.30|
;;;2358   	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
00001e  6b93              LDR      r3,[r2,#0x38]
000020  6bd4              LDR      r4,[r2,#0x3c]
000022  42a3              CMP      r3,r4
000024  d101              BNE      |L34.42|
;;;2359   	{
;;;2360   		xReturn = pdTRUE;
000026  2001              MOVS     r0,#1
000028  e000              B        |L34.44|
                  |L34.42|
;;;2361   	}
;;;2362   	else
;;;2363   	{
;;;2364   		xReturn = pdFALSE;
00002a  2000              MOVS     r0,#0
                  |L34.44|
;;;2365   	}
;;;2366   
;;;2367   	return xReturn;
;;;2368   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
00002c  bd10              POP      {r4,pc}
;;;2369   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueuePeek||, CODE, READONLY, ALIGN=2

                  xQueuePeek PROC
;;;1635   
;;;1636   BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
000000  e92d43f7          PUSH     {r0-r2,r4-r9,lr}
;;;1637   {
000004  b082              SUB      sp,sp,#8
000006  4605              MOV      r5,r0
000008  460e              MOV      r6,r1
;;;1638   BaseType_t xEntryTimeSet = pdFALSE;
00000a  f04f0800          MOV      r8,#0
;;;1639   TimeOut_t xTimeOut;
;;;1640   int8_t *pcOriginalReadPosition;
;;;1641   Queue_t * const pxQueue = xQueue;
00000e  462c              MOV      r4,r5
;;;1642   
;;;1643   	/* Check the pointer is not NULL. */
;;;1644   	configASSERT( ( pxQueue ) );
000010  b954              CBNZ     r4,|L35.40|
000012  bf00              NOP      
000014  2050              MOVS     r0,#0x50
000016  f3808811          MSR      BASEPRI,r0
00001a  f3bf8f4f          DSB      
00001e  f3bf8f6f          ISB      
000022  bf00              NOP      
000024  bf00              NOP      
                  |L35.38|
000026  e7fe              B        |L35.38|
                  |L35.40|
;;;1645   
;;;1646   	/* The buffer into which data is received can only be NULL if the data size
;;;1647   	is zero (so no data is copied into the buffer. */
;;;1648   	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
000028  b90e              CBNZ     r6,|L35.46|
00002a  6c20              LDR      r0,[r4,#0x40]
00002c  b908              CBNZ     r0,|L35.50|
                  |L35.46|
00002e  2001              MOVS     r0,#1
000030  e000              B        |L35.52|
                  |L35.50|
000032  2000              MOVS     r0,#0
                  |L35.52|
000034  b950              CBNZ     r0,|L35.76|
000036  bf00              NOP      
000038  2050              MOVS     r0,#0x50
00003a  f3808811          MSR      BASEPRI,r0
00003e  f3bf8f4f          DSB      
000042  f3bf8f6f          ISB      
000046  bf00              NOP      
000048  bf00              NOP      
                  |L35.74|
00004a  e7fe              B        |L35.74|
                  |L35.76|
;;;1649   
;;;1650   	/* Cannot block if the scheduler is suspended. */
;;;1651   	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;1652   	{
;;;1653   		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
00004c  f7fffffe          BL       xTaskGetSchedulerState
000050  b908              CBNZ     r0,|L35.86|
000052  9804              LDR      r0,[sp,#0x10]
000054  b908              CBNZ     r0,|L35.90|
                  |L35.86|
000056  2001              MOVS     r0,#1
000058  e000              B        |L35.92|
                  |L35.90|
00005a  2000              MOVS     r0,#0
                  |L35.92|
00005c  b950              CBNZ     r0,|L35.116|
00005e  bf00              NOP      
000060  2050              MOVS     r0,#0x50
000062  f3808811          MSR      BASEPRI,r0
000066  f3bf8f4f          DSB      
00006a  f3bf8f6f          ISB      
00006e  bf00              NOP      
000070  bf00              NOP      
                  |L35.114|
000072  e7fe              B        |L35.114|
                  |L35.116|
;;;1654   	}
;;;1655   	#endif
;;;1656   
;;;1657   
;;;1658   	/*lint -save -e904  This function relaxes the coding standard somewhat to
;;;1659   	allow return statements within the function itself.  This is done in the
;;;1660   	interest of execution time efficiency. */
;;;1661   	for( ;; )
000074  bf00              NOP      
                  |L35.118|
;;;1662   	{
;;;1663   		taskENTER_CRITICAL();
000076  f7fffffe          BL       vPortEnterCritical
;;;1664   		{
;;;1665   			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
00007a  f8d49038          LDR      r9,[r4,#0x38]
;;;1666   
;;;1667   			/* Is there data in the queue now?  To be running the calling task
;;;1668   			must be the highest priority task wanting to access the queue. */
;;;1669   			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
00007e  f1b90f00          CMP      r9,#0
000082  d01e              BEQ      |L35.194|
;;;1670   			{
;;;1671   				/* Remember the read position so it can be reset after the data
;;;1672   				is read from the queue as this function is only peeking the
;;;1673   				data, not removing it. */
;;;1674   				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
000084  68e7              LDR      r7,[r4,#0xc]
;;;1675   
;;;1676   				prvCopyDataFromQueue( pxQueue, pvBuffer );
000086  4631              MOV      r1,r6
000088  4620              MOV      r0,r4
00008a  f7fffffe          BL       prvCopyDataFromQueue
;;;1677   				traceQUEUE_PEEK( pxQueue );
;;;1678   
;;;1679   				/* The data is not being removed, so reset the read pointer. */
;;;1680   				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
00008e  60e7              STR      r7,[r4,#0xc]
;;;1681   
;;;1682   				/* The data is being left in the queue, so see if there are
;;;1683   				any other tasks waiting for the data. */
;;;1684   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
000090  6a60              LDR      r0,[r4,#0x24]
000092  b908              CBNZ     r0,|L35.152|
000094  2001              MOVS     r0,#1
000096  e000              B        |L35.154|
                  |L35.152|
000098  2000              MOVS     r0,#0
                  |L35.154|
00009a  b960              CBNZ     r0,|L35.182|
;;;1685   				{
;;;1686   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
00009c  f1040024          ADD      r0,r4,#0x24
0000a0  f7fffffe          BL       xTaskRemoveFromEventList
0000a4  b138              CBZ      r0,|L35.182|
;;;1687   					{
;;;1688   						/* The task waiting has a higher priority than this task. */
;;;1689   						queueYIELD_IF_USING_PREEMPTION();
0000a6  f04f5080          MOV      r0,#0x10000000
0000aa  4930              LDR      r1,|L35.364|
0000ac  6008              STR      r0,[r1,#0]
0000ae  f3bf8f4f          DSB      
0000b2  f3bf8f6f          ISB      
                  |L35.182|
;;;1690   					}
;;;1691   					else
;;;1692   					{
;;;1693   						mtCOVERAGE_TEST_MARKER();
;;;1694   					}
;;;1695   				}
;;;1696   				else
;;;1697   				{
;;;1698   					mtCOVERAGE_TEST_MARKER();
;;;1699   				}
;;;1700   
;;;1701   				taskEXIT_CRITICAL();
0000b6  f7fffffe          BL       vPortExitCritical
;;;1702   				return pdPASS;
0000ba  2001              MOVS     r0,#1
                  |L35.188|
;;;1703   			}
;;;1704   			else
;;;1705   			{
;;;1706   				if( xTicksToWait == ( TickType_t ) 0 )
;;;1707   				{
;;;1708   					/* The queue was empty and no block time is specified (or
;;;1709   					the block time has expired) so leave now. */
;;;1710   					taskEXIT_CRITICAL();
;;;1711   					traceQUEUE_PEEK_FAILED( pxQueue );
;;;1712   					return errQUEUE_EMPTY;
;;;1713   				}
;;;1714   				else if( xEntryTimeSet == pdFALSE )
;;;1715   				{
;;;1716   					/* The queue was empty and a block time was specified so
;;;1717   					configure the timeout structure ready to enter the blocked
;;;1718   					state. */
;;;1719   					vTaskInternalSetTimeOutState( &xTimeOut );
;;;1720   					xEntryTimeSet = pdTRUE;
;;;1721   				}
;;;1722   				else
;;;1723   				{
;;;1724   					/* Entry time was already set. */
;;;1725   					mtCOVERAGE_TEST_MARKER();
;;;1726   				}
;;;1727   			}
;;;1728   		}
;;;1729   		taskEXIT_CRITICAL();
;;;1730   
;;;1731   		/* Interrupts and other tasks can send to and receive from the queue
;;;1732   		now the critical section has been exited. */
;;;1733   
;;;1734   		vTaskSuspendAll();
;;;1735   		prvLockQueue( pxQueue );
;;;1736   
;;;1737   		/* Update the timeout state to see if it has expired yet. */
;;;1738   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1739   		{
;;;1740   			/* Timeout has not expired yet, check to see if there is data in the
;;;1741   			queue now, and if not enter the Blocked state to wait for data. */
;;;1742   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1743   			{
;;;1744   				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
;;;1745   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1746   				prvUnlockQueue( pxQueue );
;;;1747   				if( xTaskResumeAll() == pdFALSE )
;;;1748   				{
;;;1749   					portYIELD_WITHIN_API();
;;;1750   				}
;;;1751   				else
;;;1752   				{
;;;1753   					mtCOVERAGE_TEST_MARKER();
;;;1754   				}
;;;1755   			}
;;;1756   			else
;;;1757   			{
;;;1758   				/* There is data in the queue now, so don't enter the blocked
;;;1759   				state, instead return to try and obtain the data. */
;;;1760   				prvUnlockQueue( pxQueue );
;;;1761   				( void ) xTaskResumeAll();
;;;1762   			}
;;;1763   		}
;;;1764   		else
;;;1765   		{
;;;1766   			/* The timeout has expired.  If there is still no data in the queue
;;;1767   			exit, otherwise go back and try to read the data again. */
;;;1768   			prvUnlockQueue( pxQueue );
;;;1769   			( void ) xTaskResumeAll();
;;;1770   
;;;1771   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1772   			{
;;;1773   				traceQUEUE_PEEK_FAILED( pxQueue );
;;;1774   				return errQUEUE_EMPTY;
;;;1775   			}
;;;1776   			else
;;;1777   			{
;;;1778   				mtCOVERAGE_TEST_MARKER();
;;;1779   			}
;;;1780   		}
;;;1781   	} /*lint -restore */
;;;1782   }
0000bc  b005              ADD      sp,sp,#0x14
0000be  e8bd83f0          POP      {r4-r9,pc}
                  |L35.194|
0000c2  9804              LDR      r0,[sp,#0x10]         ;1706
0000c4  b918              CBNZ     r0,|L35.206|
0000c6  f7fffffe          BL       vPortExitCritical
0000ca  2000              MOVS     r0,#0                 ;1712
0000cc  e7f6              B        |L35.188|
                  |L35.206|
0000ce  f1b80f00          CMP      r8,#0                 ;1714
0000d2  d104              BNE      |L35.222|
0000d4  4668              MOV      r0,sp                 ;1719
0000d6  f7fffffe          BL       vTaskInternalSetTimeOutState
0000da  f04f0801          MOV      r8,#1                 ;1720
                  |L35.222|
0000de  f7fffffe          BL       vPortExitCritical
0000e2  f7fffffe          BL       vTaskSuspendAll
0000e6  f7fffffe          BL       vPortEnterCritical
0000ea  f9940044          LDRSB    r0,[r4,#0x44]         ;1735
0000ee  1c40              ADDS     r0,r0,#1              ;1735
0000f0  b910              CBNZ     r0,|L35.248|
0000f2  2000              MOVS     r0,#0                 ;1735
0000f4  f8840044          STRB     r0,[r4,#0x44]         ;1735
                  |L35.248|
0000f8  f9940045          LDRSB    r0,[r4,#0x45]         ;1735
0000fc  1c40              ADDS     r0,r0,#1              ;1735
0000fe  b910              CBNZ     r0,|L35.262|
000100  2000              MOVS     r0,#0                 ;1735
000102  f8840045          STRB     r0,[r4,#0x45]         ;1735
                  |L35.262|
000106  f7fffffe          BL       vPortExitCritical
00010a  a904              ADD      r1,sp,#0x10           ;1738
00010c  4668              MOV      r0,sp                 ;1738
00010e  f7fffffe          BL       xTaskCheckForTimeOut
000112  b9f0              CBNZ     r0,|L35.338|
000114  4620              MOV      r0,r4                 ;1742
000116  f7fffffe          BL       prvIsQueueEmpty
00011a  b1a0              CBZ      r0,|L35.326|
00011c  f1040024          ADD      r0,r4,#0x24           ;1745
000120  9904              LDR      r1,[sp,#0x10]         ;1745
000122  f7fffffe          BL       vTaskPlaceOnEventList
000126  4620              MOV      r0,r4                 ;1746
000128  f7fffffe          BL       prvUnlockQueue
00012c  f7fffffe          BL       xTaskResumeAll
000130  2800              CMP      r0,#0                 ;1747
000132  d1a0              BNE      |L35.118|
000134  f04f5080          MOV      r0,#0x10000000        ;1749
000138  490c              LDR      r1,|L35.364|
00013a  6008              STR      r0,[r1,#0]            ;1749
00013c  f3bf8f4f          DSB                            ;1749
000140  f3bf8f6f          ISB                            ;1749
000144  e797              B        |L35.118|
                  |L35.326|
000146  4620              MOV      r0,r4                 ;1760
000148  f7fffffe          BL       prvUnlockQueue
00014c  f7fffffe          BL       xTaskResumeAll
000150  e791              B        |L35.118|
                  |L35.338|
000152  4620              MOV      r0,r4                 ;1768
000154  f7fffffe          BL       prvUnlockQueue
000158  f7fffffe          BL       xTaskResumeAll
00015c  4620              MOV      r0,r4                 ;1771
00015e  f7fffffe          BL       prvIsQueueEmpty
000162  2800              CMP      r0,#0                 ;1771
000164  d087              BEQ      |L35.118|
000166  2000              MOVS     r0,#0                 ;1774
000168  e7a8              B        |L35.188|
;;;1783   /*-----------------------------------------------------------*/
                          ENDP

00016a  0000              DCW      0x0000
                  |L35.364|
                          DCD      0xe000ed04

                          AREA ||i.xQueuePeekFromISR||, CODE, READONLY, ALIGN=1

                  xQueuePeekFromISR PROC
;;;1875   
;;;1876   BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1877   {
000004  4606              MOV      r6,r0
000006  4688              MOV      r8,r1
;;;1878   BaseType_t xReturn;
;;;1879   UBaseType_t uxSavedInterruptStatus;
;;;1880   int8_t *pcOriginalReadPosition;
;;;1881   Queue_t * const pxQueue = xQueue;
000008  4634              MOV      r4,r6
;;;1882   
;;;1883   	configASSERT( pxQueue );
00000a  b954              CBNZ     r4,|L36.34|
00000c  bf00              NOP      
00000e  2050              MOVS     r0,#0x50
000010  f3808811          MSR      BASEPRI,r0
000014  f3bf8f4f          DSB      
000018  f3bf8f6f          ISB      
00001c  bf00              NOP      
00001e  bf00              NOP      
                  |L36.32|
000020  e7fe              B        |L36.32|
                  |L36.34|
;;;1884   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
000022  f1b80f00          CMP      r8,#0
000026  d101              BNE      |L36.44|
000028  6c20              LDR      r0,[r4,#0x40]
00002a  b908              CBNZ     r0,|L36.48|
                  |L36.44|
00002c  2001              MOVS     r0,#1
00002e  e000              B        |L36.50|
                  |L36.48|
000030  2000              MOVS     r0,#0
                  |L36.50|
000032  b950              CBNZ     r0,|L36.74|
000034  bf00              NOP      
000036  2050              MOVS     r0,#0x50
000038  f3808811          MSR      BASEPRI,r0
00003c  f3bf8f4f          DSB      
000040  f3bf8f6f          ISB      
000044  bf00              NOP      
000046  bf00              NOP      
                  |L36.72|
000048  e7fe              B        |L36.72|
                  |L36.74|
;;;1885   	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
00004a  6c20              LDR      r0,[r4,#0x40]
00004c  b108              CBZ      r0,|L36.82|
00004e  2001              MOVS     r0,#1
000050  e000              B        |L36.84|
                  |L36.82|
000052  2000              MOVS     r0,#0
                  |L36.84|
000054  b950              CBNZ     r0,|L36.108|
000056  bf00              NOP      
000058  2050              MOVS     r0,#0x50
00005a  f3808811          MSR      BASEPRI,r0
00005e  f3bf8f4f          DSB      
000062  f3bf8f6f          ISB      
000066  bf00              NOP      
000068  bf00              NOP      
                  |L36.106|
00006a  e7fe              B        |L36.106|
                  |L36.108|
;;;1886   
;;;1887   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1888   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1889   	above the maximum system call priority are kept permanently enabled, even
;;;1890   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1891   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1892   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1893   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1894   	assigned a priority above the configured maximum system call priority.
;;;1895   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1896   	that have been assigned a priority at or (logically) below the maximum
;;;1897   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1898   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1899   	More information (albeit Cortex-M specific) is provided on the following
;;;1900   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1901   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
00006c  f7fffffe          BL       vPortValidateInterruptPriority
;;;1902   
;;;1903   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000070  bf00              NOP      
000072  2150              MOVS     r1,#0x50
000074  f3ef8011          MRS      r0,BASEPRI
000078  f3818811          MSR      BASEPRI,r1
00007c  f3bf8f4f          DSB      
000080  f3bf8f6f          ISB      
000084  bf00              NOP      
000086  4605              MOV      r5,r0
;;;1904   	{
;;;1905   		/* Cannot block in an ISR, so check there is data available. */
;;;1906   		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
000088  6ba0              LDR      r0,[r4,#0x38]
00008a  b148              CBZ      r0,|L36.160|
;;;1907   		{
;;;1908   			traceQUEUE_PEEK_FROM_ISR( pxQueue );
;;;1909   
;;;1910   			/* Remember the read position so it can be reset as nothing is
;;;1911   			actually being removed from the queue. */
;;;1912   			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
00008c  f8d4900c          LDR      r9,[r4,#0xc]
;;;1913   			prvCopyDataFromQueue( pxQueue, pvBuffer );
000090  4641              MOV      r1,r8
000092  4620              MOV      r0,r4
000094  f7fffffe          BL       prvCopyDataFromQueue
;;;1914   			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
000098  f8c4900c          STR      r9,[r4,#0xc]
;;;1915   
;;;1916   			xReturn = pdPASS;
00009c  2701              MOVS     r7,#1
00009e  e000              B        |L36.162|
                  |L36.160|
;;;1917   		}
;;;1918   		else
;;;1919   		{
;;;1920   			xReturn = pdFAIL;
0000a0  2700              MOVS     r7,#0
                  |L36.162|
;;;1921   			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
;;;1922   		}
;;;1923   	}
;;;1924   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0000a2  bf00              NOP      
0000a4  f3858811          MSR      BASEPRI,r5
0000a8  bf00              NOP      
;;;1925   
;;;1926   	return xReturn;
0000aa  4638              MOV      r0,r7
;;;1927   }
0000ac  e8bd87f0          POP      {r4-r10,pc}
;;;1928   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueReceive||, CODE, READONLY, ALIGN=2

                  xQueueReceive PROC
;;;1276   
;;;1277   BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
000000  e92d41f7          PUSH     {r0-r2,r4-r8,lr}
;;;1278   {
000004  b083              SUB      sp,sp,#0xc
000006  4605              MOV      r5,r0
000008  460e              MOV      r6,r1
;;;1279   BaseType_t xEntryTimeSet = pdFALSE;
00000a  f04f0800          MOV      r8,#0
;;;1280   TimeOut_t xTimeOut;
;;;1281   Queue_t * const pxQueue = xQueue;
00000e  462c              MOV      r4,r5
;;;1282   
;;;1283   	/* Check the pointer is not NULL. */
;;;1284   	configASSERT( ( pxQueue ) );
000010  b954              CBNZ     r4,|L37.40|
000012  bf00              NOP      
000014  2050              MOVS     r0,#0x50
000016  f3808811          MSR      BASEPRI,r0
00001a  f3bf8f4f          DSB      
00001e  f3bf8f6f          ISB      
000022  bf00              NOP      
000024  bf00              NOP      
                  |L37.38|
000026  e7fe              B        |L37.38|
                  |L37.40|
;;;1285   
;;;1286   	/* The buffer into which data is received can only be NULL if the data size
;;;1287   	is zero (so no data is copied into the buffer. */
;;;1288   	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
000028  b90e              CBNZ     r6,|L37.46|
00002a  6c20              LDR      r0,[r4,#0x40]
00002c  b908              CBNZ     r0,|L37.50|
                  |L37.46|
00002e  2001              MOVS     r0,#1
000030  e000              B        |L37.52|
                  |L37.50|
000032  2000              MOVS     r0,#0
                  |L37.52|
000034  b950              CBNZ     r0,|L37.76|
000036  bf00              NOP      
000038  2050              MOVS     r0,#0x50
00003a  f3808811          MSR      BASEPRI,r0
00003e  f3bf8f4f          DSB      
000042  f3bf8f6f          ISB      
000046  bf00              NOP      
000048  bf00              NOP      
                  |L37.74|
00004a  e7fe              B        |L37.74|
                  |L37.76|
;;;1289   
;;;1290   	/* Cannot block if the scheduler is suspended. */
;;;1291   	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;1292   	{
;;;1293   		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
00004c  f7fffffe          BL       xTaskGetSchedulerState
000050  b908              CBNZ     r0,|L37.86|
000052  9805              LDR      r0,[sp,#0x14]
000054  b908              CBNZ     r0,|L37.90|
                  |L37.86|
000056  2001              MOVS     r0,#1
000058  e000              B        |L37.92|
                  |L37.90|
00005a  2000              MOVS     r0,#0
                  |L37.92|
00005c  b950              CBNZ     r0,|L37.116|
00005e  bf00              NOP      
000060  2050              MOVS     r0,#0x50
000062  f3808811          MSR      BASEPRI,r0
000066  f3bf8f4f          DSB      
00006a  f3bf8f6f          ISB      
00006e  bf00              NOP      
000070  bf00              NOP      
                  |L37.114|
000072  e7fe              B        |L37.114|
                  |L37.116|
;;;1294   	}
;;;1295   	#endif
;;;1296   
;;;1297   
;;;1298   	/*lint -save -e904  This function relaxes the coding standard somewhat to
;;;1299   	allow return statements within the function itself.  This is done in the
;;;1300   	interest of execution time efficiency. */
;;;1301   	for( ;; )
000074  bf00              NOP      
                  |L37.118|
;;;1302   	{
;;;1303   		taskENTER_CRITICAL();
000076  f7fffffe          BL       vPortEnterCritical
;;;1304   		{
;;;1305   			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
00007a  6ba7              LDR      r7,[r4,#0x38]
;;;1306   
;;;1307   			/* Is there data in the queue now?  To be running the calling task
;;;1308   			must be the highest priority task wanting to access the queue. */
;;;1309   			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
00007c  b1f7              CBZ      r7,|L37.188|
;;;1310   			{
;;;1311   				/* Data available, remove one item. */
;;;1312   				prvCopyDataFromQueue( pxQueue, pvBuffer );
00007e  4631              MOV      r1,r6
000080  4620              MOV      r0,r4
000082  f7fffffe          BL       prvCopyDataFromQueue
;;;1313   				traceQUEUE_RECEIVE( pxQueue );
;;;1314   				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
000086  1e78              SUBS     r0,r7,#1
000088  63a0              STR      r0,[r4,#0x38]
;;;1315   
;;;1316   				/* There is now space in the queue, were any tasks waiting to
;;;1317   				post to the queue?  If so, unblock the highest priority waiting
;;;1318   				task. */
;;;1319   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
00008a  6920              LDR      r0,[r4,#0x10]
00008c  b908              CBNZ     r0,|L37.146|
00008e  2001              MOVS     r0,#1
000090  e000              B        |L37.148|
                  |L37.146|
000092  2000              MOVS     r0,#0
                  |L37.148|
000094  b960              CBNZ     r0,|L37.176|
;;;1320   				{
;;;1321   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000096  f1040010          ADD      r0,r4,#0x10
00009a  f7fffffe          BL       xTaskRemoveFromEventList
00009e  b138              CBZ      r0,|L37.176|
;;;1322   					{
;;;1323   						queueYIELD_IF_USING_PREEMPTION();
0000a0  f04f5080          MOV      r0,#0x10000000
0000a4  492f              LDR      r1,|L37.356|
0000a6  6008              STR      r0,[r1,#0]
0000a8  f3bf8f4f          DSB      
0000ac  f3bf8f6f          ISB      
                  |L37.176|
;;;1324   					}
;;;1325   					else
;;;1326   					{
;;;1327   						mtCOVERAGE_TEST_MARKER();
;;;1328   					}
;;;1329   				}
;;;1330   				else
;;;1331   				{
;;;1332   					mtCOVERAGE_TEST_MARKER();
;;;1333   				}
;;;1334   
;;;1335   				taskEXIT_CRITICAL();
0000b0  f7fffffe          BL       vPortExitCritical
;;;1336   				return pdPASS;
0000b4  2001              MOVS     r0,#1
                  |L37.182|
;;;1337   			}
;;;1338   			else
;;;1339   			{
;;;1340   				if( xTicksToWait == ( TickType_t ) 0 )
;;;1341   				{
;;;1342   					/* The queue was empty and no block time is specified (or
;;;1343   					the block time has expired) so leave now. */
;;;1344   					taskEXIT_CRITICAL();
;;;1345   					traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1346   					return errQUEUE_EMPTY;
;;;1347   				}
;;;1348   				else if( xEntryTimeSet == pdFALSE )
;;;1349   				{
;;;1350   					/* The queue was empty and a block time was specified so
;;;1351   					configure the timeout structure. */
;;;1352   					vTaskInternalSetTimeOutState( &xTimeOut );
;;;1353   					xEntryTimeSet = pdTRUE;
;;;1354   				}
;;;1355   				else
;;;1356   				{
;;;1357   					/* Entry time was already set. */
;;;1358   					mtCOVERAGE_TEST_MARKER();
;;;1359   				}
;;;1360   			}
;;;1361   		}
;;;1362   		taskEXIT_CRITICAL();
;;;1363   
;;;1364   		/* Interrupts and other tasks can send to and receive from the queue
;;;1365   		now the critical section has been exited. */
;;;1366   
;;;1367   		vTaskSuspendAll();
;;;1368   		prvLockQueue( pxQueue );
;;;1369   
;;;1370   		/* Update the timeout state to see if it has expired yet. */
;;;1371   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1372   		{
;;;1373   			/* The timeout has not expired.  If the queue is still empty place
;;;1374   			the task on the list of tasks waiting to receive from the queue. */
;;;1375   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1376   			{
;;;1377   				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
;;;1378   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1379   				prvUnlockQueue( pxQueue );
;;;1380   				if( xTaskResumeAll() == pdFALSE )
;;;1381   				{
;;;1382   					portYIELD_WITHIN_API();
;;;1383   				}
;;;1384   				else
;;;1385   				{
;;;1386   					mtCOVERAGE_TEST_MARKER();
;;;1387   				}
;;;1388   			}
;;;1389   			else
;;;1390   			{
;;;1391   				/* The queue contains data again.  Loop back to try and read the
;;;1392   				data. */
;;;1393   				prvUnlockQueue( pxQueue );
;;;1394   				( void ) xTaskResumeAll();
;;;1395   			}
;;;1396   		}
;;;1397   		else
;;;1398   		{
;;;1399   			/* Timed out.  If there is no data in the queue exit, otherwise loop
;;;1400   			back and attempt to read the data. */
;;;1401   			prvUnlockQueue( pxQueue );
;;;1402   			( void ) xTaskResumeAll();
;;;1403   
;;;1404   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1405   			{
;;;1406   				traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1407   				return errQUEUE_EMPTY;
;;;1408   			}
;;;1409   			else
;;;1410   			{
;;;1411   				mtCOVERAGE_TEST_MARKER();
;;;1412   			}
;;;1413   		}
;;;1414   	} /*lint -restore */
;;;1415   }
0000b6  b006              ADD      sp,sp,#0x18
0000b8  e8bd81f0          POP      {r4-r8,pc}
                  |L37.188|
0000bc  9805              LDR      r0,[sp,#0x14]         ;1340
0000be  b918              CBNZ     r0,|L37.200|
0000c0  f7fffffe          BL       vPortExitCritical
0000c4  2000              MOVS     r0,#0                 ;1346
0000c6  e7f6              B        |L37.182|
                  |L37.200|
0000c8  f1b80f00          CMP      r8,#0                 ;1348
0000cc  d104              BNE      |L37.216|
0000ce  a801              ADD      r0,sp,#4              ;1352
0000d0  f7fffffe          BL       vTaskInternalSetTimeOutState
0000d4  f04f0801          MOV      r8,#1                 ;1353
                  |L37.216|
0000d8  f7fffffe          BL       vPortExitCritical
0000dc  f7fffffe          BL       vTaskSuspendAll
0000e0  f7fffffe          BL       vPortEnterCritical
0000e4  f9940044          LDRSB    r0,[r4,#0x44]         ;1368
0000e8  1c40              ADDS     r0,r0,#1              ;1368
0000ea  b910              CBNZ     r0,|L37.242|
0000ec  2000              MOVS     r0,#0                 ;1368
0000ee  f8840044          STRB     r0,[r4,#0x44]         ;1368
                  |L37.242|
0000f2  f9940045          LDRSB    r0,[r4,#0x45]         ;1368
0000f6  1c40              ADDS     r0,r0,#1              ;1368
0000f8  b910              CBNZ     r0,|L37.256|
0000fa  2000              MOVS     r0,#0                 ;1368
0000fc  f8840045          STRB     r0,[r4,#0x45]         ;1368
                  |L37.256|
000100  f7fffffe          BL       vPortExitCritical
000104  a905              ADD      r1,sp,#0x14           ;1371
000106  a801              ADD      r0,sp,#4              ;1371
000108  f7fffffe          BL       xTaskCheckForTimeOut
00010c  b9f0              CBNZ     r0,|L37.332|
00010e  4620              MOV      r0,r4                 ;1375
000110  f7fffffe          BL       prvIsQueueEmpty
000114  b1a0              CBZ      r0,|L37.320|
000116  f1040024          ADD      r0,r4,#0x24           ;1378
00011a  9905              LDR      r1,[sp,#0x14]         ;1378
00011c  f7fffffe          BL       vTaskPlaceOnEventList
000120  4620              MOV      r0,r4                 ;1379
000122  f7fffffe          BL       prvUnlockQueue
000126  f7fffffe          BL       xTaskResumeAll
00012a  2800              CMP      r0,#0                 ;1380
00012c  d1a3              BNE      |L37.118|
00012e  f04f5080          MOV      r0,#0x10000000        ;1382
000132  490c              LDR      r1,|L37.356|
000134  6008              STR      r0,[r1,#0]            ;1382
000136  f3bf8f4f          DSB                            ;1382
00013a  f3bf8f6f          ISB                            ;1382
00013e  e79a              B        |L37.118|
                  |L37.320|
000140  4620              MOV      r0,r4                 ;1393
000142  f7fffffe          BL       prvUnlockQueue
000146  f7fffffe          BL       xTaskResumeAll
00014a  e794              B        |L37.118|
                  |L37.332|
00014c  4620              MOV      r0,r4                 ;1401
00014e  f7fffffe          BL       prvUnlockQueue
000152  f7fffffe          BL       xTaskResumeAll
000156  4620              MOV      r0,r4                 ;1404
000158  f7fffffe          BL       prvIsQueueEmpty
00015c  2800              CMP      r0,#0                 ;1404
00015e  d08a              BEQ      |L37.118|
000160  2000              MOVS     r0,#0                 ;1407
000162  e7a8              B        |L37.182|
;;;1416   /*-----------------------------------------------------------*/
                          ENDP

                  |L37.356|
                          DCD      0xe000ed04

                          AREA ||i.xQueueReceiveFromISR||, CODE, READONLY, ALIGN=1

                  xQueueReceiveFromISR PROC
;;;1784   
;;;1785   BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1786   {
000004  4606              MOV      r6,r0
000006  4689              MOV      r9,r1
000008  4617              MOV      r7,r2
;;;1787   BaseType_t xReturn;
;;;1788   UBaseType_t uxSavedInterruptStatus;
;;;1789   Queue_t * const pxQueue = xQueue;
00000a  4634              MOV      r4,r6
;;;1790   
;;;1791   	configASSERT( pxQueue );
00000c  b954              CBNZ     r4,|L38.36|
00000e  bf00              NOP      
000010  2050              MOVS     r0,#0x50
000012  f3808811          MSR      BASEPRI,r0
000016  f3bf8f4f          DSB      
00001a  f3bf8f6f          ISB      
00001e  bf00              NOP      
000020  bf00              NOP      
                  |L38.34|
000022  e7fe              B        |L38.34|
                  |L38.36|
;;;1792   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
000024  f1b90f00          CMP      r9,#0
000028  d101              BNE      |L38.46|
00002a  6c20              LDR      r0,[r4,#0x40]
00002c  b908              CBNZ     r0,|L38.50|
                  |L38.46|
00002e  2001              MOVS     r0,#1
000030  e000              B        |L38.52|
                  |L38.50|
000032  2000              MOVS     r0,#0
                  |L38.52|
000034  b950              CBNZ     r0,|L38.76|
000036  bf00              NOP      
000038  2050              MOVS     r0,#0x50
00003a  f3808811          MSR      BASEPRI,r0
00003e  f3bf8f4f          DSB      
000042  f3bf8f6f          ISB      
000046  bf00              NOP      
000048  bf00              NOP      
                  |L38.74|
00004a  e7fe              B        |L38.74|
                  |L38.76|
;;;1793   
;;;1794   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1795   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1796   	above the maximum system call priority are kept permanently enabled, even
;;;1797   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1798   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1799   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1800   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1801   	assigned a priority above the configured maximum system call priority.
;;;1802   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1803   	that have been assigned a priority at or (logically) below the maximum
;;;1804   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1805   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1806   	More information (albeit Cortex-M specific) is provided on the following
;;;1807   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1808   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
00004c  f7fffffe          BL       vPortValidateInterruptPriority
;;;1809   
;;;1810   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000050  bf00              NOP      
000052  2150              MOVS     r1,#0x50
000054  f3ef8011          MRS      r0,BASEPRI
000058  f3818811          MSR      BASEPRI,r1
00005c  f3bf8f4f          DSB      
000060  f3bf8f6f          ISB      
000064  bf00              NOP      
000066  4605              MOV      r5,r0
;;;1811   	{
;;;1812   		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
000068  f8d4a038          LDR      r10,[r4,#0x38]
;;;1813   
;;;1814   		/* Cannot block in an ISR, so check there is data available. */
;;;1815   		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
00006c  f1ba0f00          CMP      r10,#0
000070  d022              BEQ      |L38.184|
;;;1816   		{
;;;1817   			const int8_t cRxLock = pxQueue->cRxLock;
000072  f994b044          LDRSB    r11,[r4,#0x44]
;;;1818   
;;;1819   			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
;;;1820   
;;;1821   			prvCopyDataFromQueue( pxQueue, pvBuffer );
000076  4649              MOV      r1,r9
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       prvCopyDataFromQueue
;;;1822   			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
00007e  f1aa0001          SUB      r0,r10,#1
000082  63a0              STR      r0,[r4,#0x38]
;;;1823   
;;;1824   			/* If the queue is locked the event list will not be modified.
;;;1825   			Instead update the lock count so the task that unlocks the queue
;;;1826   			will know that an ISR has removed data while the queue was
;;;1827   			locked. */
;;;1828   			if( cRxLock == queueUNLOCKED )
000084  f10b0001          ADD      r0,r11,#1
000088  b970              CBNZ     r0,|L38.168|
;;;1829   			{
;;;1830   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
00008a  6920              LDR      r0,[r4,#0x10]
00008c  b908              CBNZ     r0,|L38.146|
00008e  2001              MOVS     r0,#1
000090  e000              B        |L38.148|
                  |L38.146|
000092  2000              MOVS     r0,#0
                  |L38.148|
000094  b968              CBNZ     r0,|L38.178|
;;;1831   				{
;;;1832   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000096  f1040010          ADD      r0,r4,#0x10
00009a  f7fffffe          BL       xTaskRemoveFromEventList
00009e  b140              CBZ      r0,|L38.178|
;;;1833   					{
;;;1834   						/* The task waiting has a higher priority than us so
;;;1835   						force a context switch. */
;;;1836   						if( pxHigherPriorityTaskWoken != NULL )
0000a0  b13f              CBZ      r7,|L38.178|
;;;1837   						{
;;;1838   							*pxHigherPriorityTaskWoken = pdTRUE;
0000a2  2001              MOVS     r0,#1
0000a4  6038              STR      r0,[r7,#0]
0000a6  e004              B        |L38.178|
                  |L38.168|
;;;1839   						}
;;;1840   						else
;;;1841   						{
;;;1842   							mtCOVERAGE_TEST_MARKER();
;;;1843   						}
;;;1844   					}
;;;1845   					else
;;;1846   					{
;;;1847   						mtCOVERAGE_TEST_MARKER();
;;;1848   					}
;;;1849   				}
;;;1850   				else
;;;1851   				{
;;;1852   					mtCOVERAGE_TEST_MARKER();
;;;1853   				}
;;;1854   			}
;;;1855   			else
;;;1856   			{
;;;1857   				/* Increment the lock count so the task that unlocks the queue
;;;1858   				knows that data was removed while it was locked. */
;;;1859   				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
0000a8  f10b0001          ADD      r0,r11,#1
0000ac  b240              SXTB     r0,r0
0000ae  f8840044          STRB     r0,[r4,#0x44]
                  |L38.178|
;;;1860   			}
;;;1861   
;;;1862   			xReturn = pdPASS;
0000b2  f04f0801          MOV      r8,#1
;;;1863   		}
0000b6  e001              B        |L38.188|
                  |L38.184|
;;;1864   		else
;;;1865   		{
;;;1866   			xReturn = pdFAIL;
0000b8  f04f0800          MOV      r8,#0
                  |L38.188|
;;;1867   			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
;;;1868   		}
;;;1869   	}
;;;1870   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0000bc  bf00              NOP      
0000be  f3858811          MSR      BASEPRI,r5
0000c2  bf00              NOP      
;;;1871   
;;;1872   	return xReturn;
0000c4  4640              MOV      r0,r8
;;;1873   }
0000c6  e8bd9ff0          POP      {r4-r12,pc}
;;;1874   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueSemaphoreTake||, CODE, READONLY, ALIGN=2

                  xQueueSemaphoreTake PROC
;;;1417   
;;;1418   BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
000000  e92d41f3          PUSH     {r0,r1,r4-r8,lr}
;;;1419   {
000004  b082              SUB      sp,sp,#8
000006  4605              MOV      r5,r0
;;;1420   BaseType_t xEntryTimeSet = pdFALSE;
000008  f04f0800          MOV      r8,#0
;;;1421   TimeOut_t xTimeOut;
;;;1422   Queue_t * const pxQueue = xQueue;
00000c  462c              MOV      r4,r5
;;;1423   
;;;1424   #if( configUSE_MUTEXES == 1 )
;;;1425   	BaseType_t xInheritanceOccurred = pdFALSE;
00000e  2600              MOVS     r6,#0
;;;1426   #endif
;;;1427   
;;;1428   	/* Check the queue pointer is not NULL. */
;;;1429   	configASSERT( ( pxQueue ) );
000010  b954              CBNZ     r4,|L39.40|
000012  bf00              NOP      
000014  2050              MOVS     r0,#0x50
000016  f3808811          MSR      BASEPRI,r0
00001a  f3bf8f4f          DSB      
00001e  f3bf8f6f          ISB      
000022  bf00              NOP      
000024  bf00              NOP      
                  |L39.38|
000026  e7fe              B        |L39.38|
                  |L39.40|
;;;1430   
;;;1431   	/* Check this really is a semaphore, in which case the item size will be
;;;1432   	0. */
;;;1433   	configASSERT( pxQueue->uxItemSize == 0 );
000028  6c20              LDR      r0,[r4,#0x40]
00002a  b908              CBNZ     r0,|L39.48|
00002c  2001              MOVS     r0,#1
00002e  e000              B        |L39.50|
                  |L39.48|
000030  2000              MOVS     r0,#0
                  |L39.50|
000032  b950              CBNZ     r0,|L39.74|
000034  bf00              NOP      
000036  2050              MOVS     r0,#0x50
000038  f3808811          MSR      BASEPRI,r0
00003c  f3bf8f4f          DSB      
000040  f3bf8f6f          ISB      
000044  bf00              NOP      
000046  bf00              NOP      
                  |L39.72|
000048  e7fe              B        |L39.72|
                  |L39.74|
;;;1434   
;;;1435   	/* Cannot block if the scheduler is suspended. */
;;;1436   	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;1437   	{
;;;1438   		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
00004a  f7fffffe          BL       xTaskGetSchedulerState
00004e  b908              CBNZ     r0,|L39.84|
000050  9803              LDR      r0,[sp,#0xc]
000052  b908              CBNZ     r0,|L39.88|
                  |L39.84|
000054  2001              MOVS     r0,#1
000056  e000              B        |L39.90|
                  |L39.88|
000058  2000              MOVS     r0,#0
                  |L39.90|
00005a  b950              CBNZ     r0,|L39.114|
00005c  bf00              NOP      
00005e  2050              MOVS     r0,#0x50
000060  f3808811          MSR      BASEPRI,r0
000064  f3bf8f4f          DSB      
000068  f3bf8f6f          ISB      
00006c  bf00              NOP      
00006e  bf00              NOP      
                  |L39.112|
000070  e7fe              B        |L39.112|
                  |L39.114|
;;;1439   	}
;;;1440   	#endif
;;;1441   
;;;1442   
;;;1443   	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
;;;1444   	statements within the function itself.  This is done in the interest
;;;1445   	of execution time efficiency. */
;;;1446   	for( ;; )
000072  bf00              NOP      
                  |L39.116|
;;;1447   	{
;;;1448   		taskENTER_CRITICAL();
000074  f7fffffe          BL       vPortEnterCritical
;;;1449   		{
;;;1450   			/* Semaphores are queues with an item size of 0, and where the
;;;1451   			number of messages in the queue is the semaphore's count value. */
;;;1452   			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
000078  6ba7              LDR      r7,[r4,#0x38]
;;;1453   
;;;1454   			/* Is there data in the queue now?  To be running the calling task
;;;1455   			must be the highest priority task wanting to access the queue. */
;;;1456   			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
00007a  b1ff              CBZ      r7,|L39.188|
;;;1457   			{
;;;1458   				traceQUEUE_RECEIVE( pxQueue );
;;;1459   
;;;1460   				/* Semaphores are queues with a data size of zero and where the
;;;1461   				messages waiting is the semaphore's count.  Reduce the count. */
;;;1462   				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
00007c  1e78              SUBS     r0,r7,#1
00007e  63a0              STR      r0,[r4,#0x38]
;;;1463   
;;;1464   				#if ( configUSE_MUTEXES == 1 )
;;;1465   				{
;;;1466   					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
000080  6820              LDR      r0,[r4,#0]
000082  b910              CBNZ     r0,|L39.138|
;;;1467   					{
;;;1468   						/* Record the information required to implement
;;;1469   						priority inheritance should it become necessary. */
;;;1470   						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
000084  f7fffffe          BL       pvTaskIncrementMutexHeldCount
000088  60a0              STR      r0,[r4,#8]
                  |L39.138|
;;;1471   					}
;;;1472   					else
;;;1473   					{
;;;1474   						mtCOVERAGE_TEST_MARKER();
;;;1475   					}
;;;1476   				}
;;;1477   				#endif /* configUSE_MUTEXES */
;;;1478   
;;;1479   				/* Check to see if other tasks are blocked waiting to give the
;;;1480   				semaphore, and if so, unblock the highest priority such task. */
;;;1481   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
00008a  6920              LDR      r0,[r4,#0x10]
00008c  b908              CBNZ     r0,|L39.146|
00008e  2001              MOVS     r0,#1
000090  e000              B        |L39.148|
                  |L39.146|
000092  2000              MOVS     r0,#0
                  |L39.148|
000094  b960              CBNZ     r0,|L39.176|
;;;1482   				{
;;;1483   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000096  f1040010          ADD      r0,r4,#0x10
00009a  f7fffffe          BL       xTaskRemoveFromEventList
00009e  b138              CBZ      r0,|L39.176|
;;;1484   					{
;;;1485   						queueYIELD_IF_USING_PREEMPTION();
0000a0  f04f5080          MOV      r0,#0x10000000
0000a4  4943              LDR      r1,|L39.436|
0000a6  6008              STR      r0,[r1,#0]
0000a8  f3bf8f4f          DSB      
0000ac  f3bf8f6f          ISB      
                  |L39.176|
;;;1486   					}
;;;1487   					else
;;;1488   					{
;;;1489   						mtCOVERAGE_TEST_MARKER();
;;;1490   					}
;;;1491   				}
;;;1492   				else
;;;1493   				{
;;;1494   					mtCOVERAGE_TEST_MARKER();
;;;1495   				}
;;;1496   
;;;1497   				taskEXIT_CRITICAL();
0000b0  f7fffffe          BL       vPortExitCritical
;;;1498   				return pdPASS;
0000b4  2001              MOVS     r0,#1
                  |L39.182|
;;;1499   			}
;;;1500   			else
;;;1501   			{
;;;1502   				if( xTicksToWait == ( TickType_t ) 0 )
;;;1503   				{
;;;1504   					/* For inheritance to have occurred there must have been an
;;;1505   					initial timeout, and an adjusted timeout cannot become 0, as
;;;1506   					if it were 0 the function would have exited. */
;;;1507   					#if( configUSE_MUTEXES == 1 )
;;;1508   					{
;;;1509   						configASSERT( xInheritanceOccurred == pdFALSE );
;;;1510   					}
;;;1511   					#endif /* configUSE_MUTEXES */
;;;1512   
;;;1513   					/* The semaphore count was 0 and no block time is specified
;;;1514   					(or the block time has expired) so exit now. */
;;;1515   					taskEXIT_CRITICAL();
;;;1516   					traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1517   					return errQUEUE_EMPTY;
;;;1518   				}
;;;1519   				else if( xEntryTimeSet == pdFALSE )
;;;1520   				{
;;;1521   					/* The semaphore count was 0 and a block time was specified
;;;1522   					so configure the timeout structure ready to block. */
;;;1523   					vTaskInternalSetTimeOutState( &xTimeOut );
;;;1524   					xEntryTimeSet = pdTRUE;
;;;1525   				}
;;;1526   				else
;;;1527   				{
;;;1528   					/* Entry time was already set. */
;;;1529   					mtCOVERAGE_TEST_MARKER();
;;;1530   				}
;;;1531   			}
;;;1532   		}
;;;1533   		taskEXIT_CRITICAL();
;;;1534   
;;;1535   		/* Interrupts and other tasks can give to and take from the semaphore
;;;1536   		now the critical section has been exited. */
;;;1537   
;;;1538   		vTaskSuspendAll();
;;;1539   		prvLockQueue( pxQueue );
;;;1540   
;;;1541   		/* Update the timeout state to see if it has expired yet. */
;;;1542   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1543   		{
;;;1544   			/* A block time is specified and not expired.  If the semaphore
;;;1545   			count is 0 then enter the Blocked state to wait for a semaphore to
;;;1546   			become available.  As semaphores are implemented with queues the
;;;1547   			queue being empty is equivalent to the semaphore count being 0. */
;;;1548   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1549   			{
;;;1550   				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
;;;1551   
;;;1552   				#if ( configUSE_MUTEXES == 1 )
;;;1553   				{
;;;1554   					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1555   					{
;;;1556   						taskENTER_CRITICAL();
;;;1557   						{
;;;1558   							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
;;;1559   						}
;;;1560   						taskEXIT_CRITICAL();
;;;1561   					}
;;;1562   					else
;;;1563   					{
;;;1564   						mtCOVERAGE_TEST_MARKER();
;;;1565   					}
;;;1566   				}
;;;1567   				#endif
;;;1568   
;;;1569   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1570   				prvUnlockQueue( pxQueue );
;;;1571   				if( xTaskResumeAll() == pdFALSE )
;;;1572   				{
;;;1573   					portYIELD_WITHIN_API();
;;;1574   				}
;;;1575   				else
;;;1576   				{
;;;1577   					mtCOVERAGE_TEST_MARKER();
;;;1578   				}
;;;1579   			}
;;;1580   			else
;;;1581   			{
;;;1582   				/* There was no timeout and the semaphore count was not 0, so
;;;1583   				attempt to take the semaphore again. */
;;;1584   				prvUnlockQueue( pxQueue );
;;;1585   				( void ) xTaskResumeAll();
;;;1586   			}
;;;1587   		}
;;;1588   		else
;;;1589   		{
;;;1590   			/* Timed out. */
;;;1591   			prvUnlockQueue( pxQueue );
;;;1592   			( void ) xTaskResumeAll();
;;;1593   
;;;1594   			/* If the semaphore count is 0 exit now as the timeout has
;;;1595   			expired.  Otherwise return to attempt to take the semaphore that is
;;;1596   			known to be available.  As semaphores are implemented by queues the
;;;1597   			queue being empty is equivalent to the semaphore count being 0. */
;;;1598   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1599   			{
;;;1600   				#if ( configUSE_MUTEXES == 1 )
;;;1601   				{
;;;1602   					/* xInheritanceOccurred could only have be set if
;;;1603   					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
;;;1604   					test the mutex type again to check it is actually a mutex. */
;;;1605   					if( xInheritanceOccurred != pdFALSE )
;;;1606   					{
;;;1607   						taskENTER_CRITICAL();
;;;1608   						{
;;;1609   							UBaseType_t uxHighestWaitingPriority;
;;;1610   
;;;1611   							/* This task blocking on the mutex caused another
;;;1612   							task to inherit this task's priority.  Now this task
;;;1613   							has timed out the priority should be disinherited
;;;1614   							again, but only as low as the next highest priority
;;;1615   							task that is waiting for the same mutex. */
;;;1616   							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
;;;1617   							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
;;;1618   						}
;;;1619   						taskEXIT_CRITICAL();
;;;1620   					}
;;;1621   				}
;;;1622   				#endif /* configUSE_MUTEXES */
;;;1623   
;;;1624   				traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1625   				return errQUEUE_EMPTY;
;;;1626   			}
;;;1627   			else
;;;1628   			{
;;;1629   				mtCOVERAGE_TEST_MARKER();
;;;1630   			}
;;;1631   		}
;;;1632   	} /*lint -restore */
;;;1633   }
0000b6  b004              ADD      sp,sp,#0x10
0000b8  e8bd81f0          POP      {r4-r8,pc}
                  |L39.188|
0000bc  9803              LDR      r0,[sp,#0xc]          ;1502
0000be  b998              CBNZ     r0,|L39.232|
0000c0  b90e              CBNZ     r6,|L39.198|
0000c2  2001              MOVS     r0,#1                 ;1509
0000c4  e000              B        |L39.200|
                  |L39.198|
0000c6  2000              MOVS     r0,#0                 ;1509
                  |L39.200|
0000c8  b950              CBNZ     r0,|L39.224|
0000ca  bf00              NOP                            ;1509
0000cc  2050              MOVS     r0,#0x50              ;1509
0000ce  f3808811          MSR      BASEPRI,r0            ;1509
0000d2  f3bf8f4f          DSB                            ;1509
0000d6  f3bf8f6f          ISB                            ;1509
0000da  bf00              NOP                            ;1509
0000dc  bf00              NOP                            ;1509
                  |L39.222|
0000de  e7fe              B        |L39.222|
                  |L39.224|
0000e0  f7fffffe          BL       vPortExitCritical
0000e4  2000              MOVS     r0,#0                 ;1517
0000e6  e7e6              B        |L39.182|
                  |L39.232|
0000e8  f1b80f00          CMP      r8,#0                 ;1519
0000ec  d104              BNE      |L39.248|
0000ee  4668              MOV      r0,sp                 ;1523
0000f0  f7fffffe          BL       vTaskInternalSetTimeOutState
0000f4  f04f0801          MOV      r8,#1                 ;1524
                  |L39.248|
0000f8  f7fffffe          BL       vPortExitCritical
0000fc  f7fffffe          BL       vTaskSuspendAll
000100  f7fffffe          BL       vPortEnterCritical
000104  f9940044          LDRSB    r0,[r4,#0x44]         ;1539
000108  1c40              ADDS     r0,r0,#1              ;1539
00010a  b910              CBNZ     r0,|L39.274|
00010c  2000              MOVS     r0,#0                 ;1539
00010e  f8840044          STRB     r0,[r4,#0x44]         ;1539
                  |L39.274|
000112  f9940045          LDRSB    r0,[r4,#0x45]         ;1539
000116  1c40              ADDS     r0,r0,#1              ;1539
000118  b910              CBNZ     r0,|L39.288|
00011a  2000              MOVS     r0,#0                 ;1539
00011c  f8840045          STRB     r0,[r4,#0x45]         ;1539
                  |L39.288|
000120  f7fffffe          BL       vPortExitCritical
000124  a903              ADD      r1,sp,#0xc            ;1542
000126  4668              MOV      r0,sp                 ;1542
000128  f7fffffe          BL       xTaskCheckForTimeOut
00012c  bb40              CBNZ     r0,|L39.384|
00012e  4620              MOV      r0,r4                 ;1548
000130  f7fffffe          BL       prvIsQueueEmpty
000134  b1f0              CBZ      r0,|L39.372|
000136  6820              LDR      r0,[r4,#0]            ;1554
000138  b938              CBNZ     r0,|L39.330|
00013a  f7fffffe          BL       vPortEnterCritical
00013e  68a0              LDR      r0,[r4,#8]            ;1558
000140  f7fffffe          BL       xTaskPriorityInherit
000144  4606              MOV      r6,r0                 ;1558
000146  f7fffffe          BL       vPortExitCritical
                  |L39.330|
00014a  f1040024          ADD      r0,r4,#0x24           ;1569
00014e  9903              LDR      r1,[sp,#0xc]          ;1569
000150  f7fffffe          BL       vTaskPlaceOnEventList
000154  4620              MOV      r0,r4                 ;1570
000156  f7fffffe          BL       prvUnlockQueue
00015a  f7fffffe          BL       xTaskResumeAll
00015e  2800              CMP      r0,#0                 ;1571
000160  d188              BNE      |L39.116|
000162  f04f5080          MOV      r0,#0x10000000        ;1573
000166  4913              LDR      r1,|L39.436|
000168  6008              STR      r0,[r1,#0]            ;1573
00016a  f3bf8f4f          DSB                            ;1573
00016e  f3bf8f6f          ISB                            ;1573
                  |L39.370|
000172  e77f              B        |L39.116|
                  |L39.372|
000174  4620              MOV      r0,r4                 ;1584
000176  f7fffffe          BL       prvUnlockQueue
00017a  f7fffffe          BL       xTaskResumeAll
00017e  e779              B        |L39.116|
                  |L39.384|
000180  4620              MOV      r0,r4                 ;1591
000182  f7fffffe          BL       prvUnlockQueue
000186  f7fffffe          BL       xTaskResumeAll
00018a  4620              MOV      r0,r4                 ;1598
00018c  f7fffffe          BL       prvIsQueueEmpty
000190  2800              CMP      r0,#0                 ;1598
000192  d0ee              BEQ      |L39.370|
000194  b15e              CBZ      r6,|L39.430|
000196  f7fffffe          BL       vPortEnterCritical
00019a  4620              MOV      r0,r4                 ;1616
00019c  f7fffffe          BL       prvGetDisinheritPriorityAfterTimeout
0001a0  4607              MOV      r7,r0                 ;1616
0001a2  4639              MOV      r1,r7                 ;1617
0001a4  68a0              LDR      r0,[r4,#8]            ;1617
0001a6  f7fffffe          BL       vTaskPriorityDisinheritAfterTimeout
0001aa  f7fffffe          BL       vPortExitCritical
                  |L39.430|
0001ae  2000              MOVS     r0,#0                 ;1625
0001b0  e781              B        |L39.182|
;;;1634   /*-----------------------------------------------------------*/
                          ENDP

0001b2  0000              DCW      0x0000
                  |L39.436|
                          DCD      0xe000ed04

                          AREA ||i.xQueueTakeMutexRecursive||, CODE, READONLY, ALIGN=1

                  xQueueTakeMutexRecursive PROC
;;;643    
;;;644    	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;645    	{
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;646    	BaseType_t xReturn;
;;;647    	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
000008  4634              MOV      r4,r6
;;;648    
;;;649    		configASSERT( pxMutex );
00000a  b954              CBNZ     r4,|L40.34|
00000c  bf00              NOP      
00000e  2050              MOVS     r0,#0x50
000010  f3808811          MSR      BASEPRI,r0
000014  f3bf8f4f          DSB      
000018  f3bf8f6f          ISB      
00001c  bf00              NOP      
00001e  bf00              NOP      
                  |L40.32|
000020  e7fe              B        |L40.32|
                  |L40.34|
;;;650    
;;;651    		/* Comments regarding mutual exclusion as per those within
;;;652    		xQueueGiveMutexRecursive(). */
;;;653    
;;;654    		traceTAKE_MUTEX_RECURSIVE( pxMutex );
;;;655    
;;;656    		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
000022  f7fffffe          BL       xTaskGetCurrentTaskHandle
000026  68a1              LDR      r1,[r4,#8]
000028  4288              CMP      r0,r1
00002a  d104              BNE      |L40.54|
;;;657    		{
;;;658    			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
00002c  68e0              LDR      r0,[r4,#0xc]
00002e  1c40              ADDS     r0,r0,#1
000030  60e0              STR      r0,[r4,#0xc]
;;;659    			xReturn = pdPASS;
000032  2501              MOVS     r5,#1
000034  e008              B        |L40.72|
                  |L40.54|
;;;660    		}
;;;661    		else
;;;662    		{
;;;663    			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
000036  4639              MOV      r1,r7
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       xQueueSemaphoreTake
00003e  4605              MOV      r5,r0
;;;664    
;;;665    			/* pdPASS will only be returned if the mutex was successfully
;;;666    			obtained.  The calling task may have entered the Blocked state
;;;667    			before reaching here. */
;;;668    			if( xReturn != pdFAIL )
000040  b115              CBZ      r5,|L40.72|
;;;669    			{
;;;670    				( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
000042  68e0              LDR      r0,[r4,#0xc]
000044  1c40              ADDS     r0,r0,#1
000046  60e0              STR      r0,[r4,#0xc]
                  |L40.72|
;;;671    			}
;;;672    			else
;;;673    			{
;;;674    				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
;;;675    			}
;;;676    		}
;;;677    
;;;678    		return xReturn;
000048  4628              MOV      r0,r5
;;;679    	}
00004a  e8bd81f0          POP      {r4-r8,pc}
;;;680    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  xQueueRegistry
                          %        64
