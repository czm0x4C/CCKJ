; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o4gcamera\ringbuffer.o --asm_dir=.\ --list_dir=.\ --depend=4gcamera\ringbuffer.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../USB_DEVICE/App -I../USB_DEVICE/Target -I../Core/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Middlewares/ST/STM32_USB_Device_Library/Core/Inc -I../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 -I../Middlewares/Third_Party/FreeRTOS/Source/portable/RVDS/ARM_CM4F -I../HARDWARE/OV2640 -I../HARDWARE/WS2812B -I../HARDWARE/RING_BUFFER -I../HARDWARE/FLASH -I.\RTE\_4GCAMERA -IC:\Users\czm\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\czm\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=536 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F407xx --omf_browse=4gcamera\ringbuffer.crf ..\HARDWARE\RING_BUFFER\ringBuffer.c]
                          THUMB

                          AREA ||i.FrameDataCheck||, CODE, READONLY, ALIGN=1

                  FrameDataCheck PROC
;;;86     /*帧校验*/
;;;87     unsigned char FrameDataCheck(unsigned char* OneFrameData)
000000  b530              PUSH     {r4,r5,lr}
;;;88     {
000002  4601              MOV      r1,r0
;;;89     	unsigned char sumcheck = 0;
000004  2200              MOVS     r2,#0
;;;90     	unsigned char addcheck = 0;
000006  2400              MOVS     r4,#0
;;;91     	unsigned char Len = OneFrameData[3];
000008  78cb              LDRB     r3,[r1,#3]
;;;92     	
;;;93     	for(unsigned char i=0; i < Len + 4 ; i++)
00000a  2000              MOVS     r0,#0
00000c  e006              B        |L1.28|
                  |L1.14|
;;;94     	{
;;;95     			sumcheck += OneFrameData[i]; //从帧头开始，对每一字节进行求和，直到DATA区结束
00000e  5c0d              LDRB     r5,[r1,r0]
000010  4415              ADD      r5,r5,r2
000012  b2ea              UXTB     r2,r5
;;;96     			addcheck += sumcheck; //每一字节的求和操作，进行一次sumcheck的累加
000014  18a5              ADDS     r5,r4,r2
000016  b2ec              UXTB     r4,r5
000018  1c45              ADDS     r5,r0,#1              ;93
00001a  b2e8              UXTB     r0,r5                 ;93
                  |L1.28|
00001c  1d1d              ADDS     r5,r3,#4              ;93
00001e  42a8              CMP      r0,r5                 ;93
000020  dbf5              BLT      |L1.14|
;;;97     	}
;;;98     	
;;;99     	if(sumcheck == OneFrameData[Len + 4] && addcheck == OneFrameData[Len + 5])
000022  1d18              ADDS     r0,r3,#4
000024  5c08              LDRB     r0,[r1,r0]
000026  4290              CMP      r0,r2
000028  d105              BNE      |L1.54|
00002a  1d58              ADDS     r0,r3,#5
00002c  5c08              LDRB     r0,[r1,r0]
00002e  42a0              CMP      r0,r4
000030  d101              BNE      |L1.54|
;;;100    	{
;;;101    			return 1; //校验通过
000032  2001              MOVS     r0,#1
                  |L1.52|
;;;102    	}
;;;103    	else
;;;104    	{
;;;105    			return 0; //校验失败
;;;106    	}
;;;107    }
000034  bd30              POP      {r4,r5,pc}
                  |L1.54|
000036  2000              MOVS     r0,#0                 ;105
000038  e7fc              B        |L1.52|
                          ENDP


                          AREA ||i.GetDataLength||, CODE, READONLY, ALIGN=1

                  GetDataLength PROC
;;;76     
;;;77     unsigned short GetDataLength(unsigned char *DataBuffer)
000000  4601              MOV      r1,r0
;;;78     {
;;;79     	unsigned short DataLen = 0;
000002  2000              MOVS     r0,#0
;;;80     	while(DataBuffer[DataLen] != '\0')
000004  e001              B        |L2.10|
                  |L2.6|
;;;81     	{
;;;82     		DataLen++;
000006  1c42              ADDS     r2,r0,#1
000008  b290              UXTH     r0,r2
                  |L2.10|
00000a  5c0a              LDRB     r2,[r1,r0]            ;80
00000c  2a00              CMP      r2,#0                 ;80
00000e  d1fa              BNE      |L2.6|
;;;83     	}
;;;84     	return DataLen;
;;;85     }
000010  4770              BX       lr
;;;86     /*帧校验*/
                          ENDP


                          AREA ||i.ReadBytes||, CODE, READONLY, ALIGN=1

                  ReadBytes PROC
;;;62     
;;;63     unsigned char ReadBytes(_RingBuffer *ringbuffer,unsigned char *ReadBuffer, unsigned short Len)
000000  b5f0              PUSH     {r4-r7,lr}
;;;64     {
000002  4604              MOV      r4,r0
000004  460f              MOV      r7,r1
000006  4615              MOV      r5,r2
;;;65         if(Len > ringbuffer->Lenght || ringbuffer->Lenght == 0)
000008  88a0              LDRH     r0,[r4,#4]
00000a  42a8              CMP      r0,r5
00000c  db01              BLT      |L3.18|
00000e  88a0              LDRH     r0,[r4,#4]
000010  b908              CBNZ     r0,|L3.22|
                  |L3.18|
;;;66         {
;;;67             return 0;           /*读取的数据大于缓冲区的数据,或者缓冲区无数据，返回空数据*/
000012  2000              MOVS     r0,#0
                  |L3.20|
;;;68         }
;;;69     
;;;70         for(int i=0;i<Len;i++)
;;;71         {
;;;72             ReadOneByte_RingBuffer(ringbuffer,&ReadBuffer[i]);
;;;73         }
;;;74     		return 1;
;;;75     }
000014  bdf0              POP      {r4-r7,pc}
                  |L3.22|
000016  2600              MOVS     r6,#0                 ;70
000018  e004              B        |L3.36|
                  |L3.26|
00001a  19b9              ADDS     r1,r7,r6              ;72
00001c  4620              MOV      r0,r4                 ;72
00001e  f7fffffe          BL       ReadOneByte_RingBuffer
000022  1c76              ADDS     r6,r6,#1              ;70
                  |L3.36|
000024  42ae              CMP      r6,r5                 ;70
000026  dbf8              BLT      |L3.26|
000028  2001              MOVS     r0,#1                 ;74
00002a  e7f3              B        |L3.20|
;;;76     
                          ENDP


                          AREA ||i.ReadOneByte_RingBuffer||, CODE, READONLY, ALIGN=1

                  ReadOneByte_RingBuffer PROC
;;;47     
;;;48     unsigned char ReadOneByte_RingBuffer(_RingBuffer *ringbuffer,unsigned char *OneByteData)
000000  4602              MOV      r2,r0
;;;49     {
;;;50         if(ringbuffer->Lenght == 0)
000002  8890              LDRH     r0,[r2,#4]
000004  b908              CBNZ     r0,|L4.10|
;;;51         {
;;;52             return RINGBUFF_ERR;/*缓冲区为空*/
000006  2000              MOVS     r0,#0
                  |L4.8|
;;;53         }
;;;54         *OneByteData = ringbuffer->RingBufferData[ringbuffer->Head];/*缓冲区读取一个字节*/
;;;55     
;;;56         ringbuffer->Head = (ringbuffer->Head + 1) % RINGBUFF_LEN;
;;;57     
;;;58         ringbuffer->Lenght -= 1;
;;;59     
;;;60         return RINGBUFF_OK;
;;;61     }
000008  4770              BX       lr
                  |L4.10|
00000a  8813              LDRH     r3,[r2,#0]            ;54
00000c  1d90              ADDS     r0,r2,#6              ;54
00000e  5cc0              LDRB     r0,[r0,r3]            ;54
000010  7008              STRB     r0,[r1,#0]            ;54
000012  8813              LDRH     r3,[r2,#0]            ;56
000014  1c58              ADDS     r0,r3,#1              ;56
000016  17c3              ASRS     r3,r0,#31             ;56
000018  eb005393          ADD      r3,r0,r3,LSR #22      ;56
00001c  129b              ASRS     r3,r3,#10             ;56
00001e  eba02383          SUB      r3,r0,r3,LSL #10      ;56
000022  8013              STRH     r3,[r2,#0]            ;56
000024  8890              LDRH     r0,[r2,#4]            ;58
000026  1e40              SUBS     r0,r0,#1              ;58
000028  8090              STRH     r0,[r2,#4]            ;58
00002a  2001              MOVS     r0,#1                 ;60
00002c  e7ec              B        |L4.8|
;;;62     
                          ENDP


                          AREA ||i.RingBuffer_Init||, CODE, READONLY, ALIGN=1

                  RingBuffer_Init PROC
;;;7      /*初始化环形缓冲区*/
;;;8      void RingBuffer_Init(_RingBuffer *ringbuffer)
000000  2100              MOVS     r1,#0
;;;9      {
;;;10     	ringbuffer->Head   = 0;
000002  8001              STRH     r1,[r0,#0]
;;;11     	ringbuffer->Tail   = 0;
000004  8041              STRH     r1,[r0,#2]
;;;12     	ringbuffer->Lenght = 0;
000006  8081              STRH     r1,[r0,#4]
;;;13     	for(int i=0;i<RINGBUFF_LEN;i++)
000008  bf00              NOP      
00000a  e003              B        |L5.20|
                  |L5.12|
;;;14     	{
;;;15     		ringbuffer->RingBufferData[i] = '\0';
00000c  2300              MOVS     r3,#0
00000e  1d82              ADDS     r2,r0,#6
000010  5453              STRB     r3,[r2,r1]
000012  1c49              ADDS     r1,r1,#1              ;13
                  |L5.20|
000014  f5b16f80          CMP      r1,#0x400             ;13
000018  dbf8              BLT      |L5.12|
;;;16     	}
;;;17     }
00001a  4770              BX       lr
;;;18     /*缓冲区写入一个字节*/
                          ENDP


                          AREA ||i.WriteBytes||, CODE, READONLY, ALIGN=1

                  WriteBytes PROC
;;;33     /*缓冲区写入多个字节*/
;;;34     unsigned char WriteBytes(_RingBuffer *ringbuffer, unsigned char *Bytes,unsigned short DataLen)
000000  b5f0              PUSH     {r4-r7,lr}
;;;35     {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;36         if(ringbuffer->Lenght >= RINGBUFF_LEN)
000008  88a8              LDRH     r0,[r5,#4]
00000a  f5b06f80          CMP      r0,#0x400
00000e  db01              BLT      |L6.20|
;;;37         {
;;;38             return RINGBUFF_ERR;/*缓冲区数据满了*/
000010  2000              MOVS     r0,#0
                  |L6.18|
;;;39         }
;;;40     
;;;41         for (int i = 0; i < DataLen; i++)
;;;42         {
;;;43             WriteOneByte_RingBuffer(ringbuffer,Bytes[i]);
;;;44         }
;;;45         return RINGBUFF_OK;
;;;46     }
000012  bdf0              POP      {r4-r7,pc}
                  |L6.20|
000014  2400              MOVS     r4,#0                 ;41
000016  e004              B        |L6.34|
                  |L6.24|
000018  5d31              LDRB     r1,[r6,r4]            ;43
00001a  4628              MOV      r0,r5                 ;43
00001c  f7fffffe          BL       WriteOneByte_RingBuffer
000020  1c64              ADDS     r4,r4,#1              ;41
                  |L6.34|
000022  42bc              CMP      r4,r7                 ;41
000024  dbf8              BLT      |L6.24|
000026  2001              MOVS     r0,#1                 ;45
000028  e7f3              B        |L6.18|
;;;47     
                          ENDP


                          AREA ||i.WriteOneByte_RingBuffer||, CODE, READONLY, ALIGN=1

                  WriteOneByte_RingBuffer PROC
;;;18     /*缓冲区写入一个字节*/
;;;19     unsigned char WriteOneByte_RingBuffer(_RingBuffer *ringbuffer, unsigned char OneByteData)
000000  4602              MOV      r2,r0
;;;20     {
;;;21         if(ringbuffer->Lenght >= RINGBUFF_LEN)
000002  8890              LDRH     r0,[r2,#4]
000004  f5b06f80          CMP      r0,#0x400
000008  db01              BLT      |L7.14|
;;;22         {
;;;23             return RINGBUFF_ERR;/*缓冲区数据满了*/
00000a  2000              MOVS     r0,#0
                  |L7.12|
;;;24         }
;;;25         ringbuffer->RingBufferData[ringbuffer->Tail] = OneByteData;/*缓冲区写入一个数据*/
;;;26     
;;;27         ringbuffer->Tail = (ringbuffer->Tail +1) % RINGBUFF_LEN;
;;;28     
;;;29         ringbuffer->Lenght += 1;
;;;30     
;;;31         return RINGBUFF_OK;
;;;32     }
00000c  4770              BX       lr
                  |L7.14|
00000e  8853              LDRH     r3,[r2,#2]            ;25
000010  1d90              ADDS     r0,r2,#6              ;25
000012  54c1              STRB     r1,[r0,r3]            ;25
000014  8853              LDRH     r3,[r2,#2]            ;27
000016  1c58              ADDS     r0,r3,#1              ;27
000018  17c3              ASRS     r3,r0,#31             ;27
00001a  eb005393          ADD      r3,r0,r3,LSR #22      ;27
00001e  129b              ASRS     r3,r3,#10             ;27
000020  eba02383          SUB      r3,r0,r3,LSL #10      ;27
000024  8053              STRH     r3,[r2,#2]            ;27
000026  8890              LDRH     r0,[r2,#4]            ;29
000028  1c40              ADDS     r0,r0,#1              ;29
00002a  8090              STRH     r0,[r2,#4]            ;29
00002c  2001              MOVS     r0,#1                 ;31
00002e  e7ed              B        |L7.12|
;;;33     /*缓冲区写入多个字节*/
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  UART_RxRingBuffer
                          %        1030
                  VCP_RxRingBuffer
                          %        1030
