; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o4gcamera\tasks.o --asm_dir=.\ --list_dir=.\ --depend=4gcamera\tasks.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../USB_DEVICE/App -I../USB_DEVICE/Target -I../Core/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Middlewares/ST/STM32_USB_Device_Library/Core/Inc -I../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 -I../Middlewares/Third_Party/FreeRTOS/Source/portable/RVDS/ARM_CM4F -I../HARDWARE/OV2640 -I../HARDWARE/WS2812B -I../HARDWARE/RING_BUFFER -I../HARDWARE/FLASH -I.\RTE\_4GCAMERA -IC:\Users\czm\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\czm\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=536 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F407xx --omf_browse=4gcamera\tasks.crf ../Middlewares/Third_Party/FreeRTOS/Source/tasks.c]
                          THUMB

                          AREA ||i.eTaskGetState||, CODE, READONLY, ALIGN=2

                  eTaskGetState PROC
;;;1385   
;;;1386   	eTaskState eTaskGetState( TaskHandle_t xTask )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1387   	{
000004  4607              MOV      r7,r0
;;;1388   	eTaskState eReturn;
;;;1389   	List_t const * pxStateList, *pxDelayedList, *pxOverflowedDelayedList;
;;;1390   	const TCB_t * const pxTCB = xTask;
000006  463e              MOV      r6,r7
;;;1391   
;;;1392   		configASSERT( pxTCB );
000008  b956              CBNZ     r6,|L1.32|
00000a  bf00              NOP      
00000c  2050              MOVS     r0,#0x50
00000e  f3808811          MSR      BASEPRI,r0
000012  f3bf8f4f          DSB      
000016  f3bf8f6f          ISB      
00001a  bf00              NOP      
00001c  bf00              NOP      
                  |L1.30|
00001e  e7fe              B        |L1.30|
                  |L1.32|
;;;1393   
;;;1394   		if( pxTCB == pxCurrentTCB )
000020  4817              LDR      r0,|L1.128|
000022  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000024  4286              CMP      r6,r0
000026  d101              BNE      |L1.44|
;;;1395   		{
;;;1396   			/* The task calling this function is querying its own state. */
;;;1397   			eReturn = eRunning;
000028  2400              MOVS     r4,#0
00002a  e026              B        |L1.122|
                  |L1.44|
;;;1398   		}
;;;1399   		else
;;;1400   		{
;;;1401   			taskENTER_CRITICAL();
00002c  f7fffffe          BL       vPortEnterCritical
;;;1402   			{
;;;1403   				pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
000030  6975              LDR      r5,[r6,#0x14]
;;;1404   				pxDelayedList = pxDelayedTaskList;
000032  4814              LDR      r0,|L1.132|
000034  f8d08000          LDR      r8,[r0,#0]  ; pxDelayedTaskList
;;;1405   				pxOverflowedDelayedList = pxOverflowDelayedTaskList;
000038  4813              LDR      r0,|L1.136|
00003a  f8d09000          LDR      r9,[r0,#0]  ; pxOverflowDelayedTaskList
;;;1406   			}
;;;1407   			taskEXIT_CRITICAL();
00003e  f7fffffe          BL       vPortExitCritical
;;;1408   
;;;1409   			if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
000042  4545              CMP      r5,r8
000044  d001              BEQ      |L1.74|
000046  454d              CMP      r5,r9
000048  d101              BNE      |L1.78|
                  |L1.74|
;;;1410   			{
;;;1411   				/* The task being queried is referenced from one of the Blocked
;;;1412   				lists. */
;;;1413   				eReturn = eBlocked;
00004a  2402              MOVS     r4,#2
00004c  e015              B        |L1.122|
                  |L1.78|
;;;1414   			}
;;;1415   
;;;1416   			#if ( INCLUDE_vTaskSuspend == 1 )
;;;1417   				else if( pxStateList == &xSuspendedTaskList )
00004e  480f              LDR      r0,|L1.140|
000050  4285              CMP      r5,r0
000052  d10b              BNE      |L1.108|
;;;1418   				{
;;;1419   					/* The task being queried is referenced from the suspended
;;;1420   					list.  Is it genuinely suspended or is it blocked
;;;1421   					indefinitely? */
;;;1422   					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
000054  6ab0              LDR      r0,[r6,#0x28]
000056  b938              CBNZ     r0,|L1.104|
;;;1423   					{
;;;1424   						#if( configUSE_TASK_NOTIFICATIONS == 1 )
;;;1425   						{
;;;1426   							/* The task does not appear on the event list item of
;;;1427   							and of the RTOS objects, but could still be in the
;;;1428   							blocked state if it is waiting on its notification
;;;1429   							rather than waiting on an object. */
;;;1430   							if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
000058  f8960058          LDRB     r0,[r6,#0x58]
00005c  2801              CMP      r0,#1
00005e  d101              BNE      |L1.100|
;;;1431   							{
;;;1432   								eReturn = eBlocked;
000060  2402              MOVS     r4,#2
000062  e00a              B        |L1.122|
                  |L1.100|
;;;1433   							}
;;;1434   							else
;;;1435   							{
;;;1436   								eReturn = eSuspended;
000064  2403              MOVS     r4,#3
000066  e008              B        |L1.122|
                  |L1.104|
;;;1437   							}
;;;1438   						}
;;;1439   						#else
;;;1440   						{
;;;1441   							eReturn = eSuspended;
;;;1442   						}
;;;1443   						#endif
;;;1444   					}
;;;1445   					else
;;;1446   					{
;;;1447   						eReturn = eBlocked;
000068  2402              MOVS     r4,#2
00006a  e006              B        |L1.122|
                  |L1.108|
;;;1448   					}
;;;1449   				}
;;;1450   			#endif
;;;1451   
;;;1452   			#if ( INCLUDE_vTaskDelete == 1 )
;;;1453   				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
00006c  4808              LDR      r0,|L1.144|
00006e  4285              CMP      r5,r0
000070  d000              BEQ      |L1.116|
000072  b90d              CBNZ     r5,|L1.120|
                  |L1.116|
;;;1454   				{
;;;1455   					/* The task being queried is referenced from the deleted
;;;1456   					tasks list, or it is not referenced from any lists at
;;;1457   					all. */
;;;1458   					eReturn = eDeleted;
000074  2404              MOVS     r4,#4
000076  e000              B        |L1.122|
                  |L1.120|
;;;1459   				}
;;;1460   			#endif
;;;1461   
;;;1462   			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
;;;1463   			{
;;;1464   				/* If the task is not in any other state, it must be in the
;;;1465   				Ready (including pending ready) state. */
;;;1466   				eReturn = eReady;
000078  2401              MOVS     r4,#1
                  |L1.122|
;;;1467   			}
;;;1468   		}
;;;1469   
;;;1470   		return eReturn;
00007a  4620              MOV      r0,r4
;;;1471   	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
00007c  e8bd87f0          POP      {r4-r10,pc}
;;;1472   
                          ENDP

                  |L1.128|
                          DCD      pxCurrentTCB
                  |L1.132|
                          DCD      pxDelayedTaskList
                  |L1.136|
                          DCD      pxOverflowDelayedTaskList
                  |L1.140|
                          DCD      xSuspendedTaskList
                  |L1.144|
                          DCD      xTasksWaitingTermination

                          AREA ||i.pcTaskGetName||, CODE, READONLY, ALIGN=2

                  pcTaskGetName PROC
;;;2357   
;;;2358   char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  4601              MOV      r1,r0
;;;2359   {
;;;2360   TCB_t *pxTCB;
;;;2361   
;;;2362   	/* If null is passed in here then the name of the calling task is being
;;;2363   	queried. */
;;;2364   	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
000002  b911              CBNZ     r1,|L2.10|
000004  4809              LDR      r0,|L2.44|
000006  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000008  e000              B        |L2.12|
                  |L2.10|
00000a  4608              MOV      r0,r1
                  |L2.12|
00000c  4602              MOV      r2,r0
;;;2365   	configASSERT( pxTCB );
00000e  b952              CBNZ     r2,|L2.38|
000010  bf00              NOP      
000012  2050              MOVS     r0,#0x50
000014  f3808811          MSR      BASEPRI,r0
000018  f3bf8f4f          DSB      
00001c  f3bf8f6f          ISB      
000020  bf00              NOP      
000022  bf00              NOP      
                  |L2.36|
000024  e7fe              B        |L2.36|
                  |L2.38|
;;;2366   	return &( pxTCB->pcTaskName[ 0 ] );
000026  f1020034          ADD      r0,r2,#0x34
;;;2367   }
00002a  4770              BX       lr
;;;2368   /*-----------------------------------------------------------*/
                          ENDP

                  |L2.44|
                          DCD      pxCurrentTCB

                          AREA ||i.prvAddCurrentTaskToDelayedList||, CODE, READONLY, ALIGN=2

                  prvAddCurrentTaskToDelayedList PROC
;;;5176   
;;;5177   static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;5178   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;5179   TickType_t xTimeToWake;
;;;5180   const TickType_t xConstTickCount = xTickCount;
000008  4816              LDR      r0,|L3.100|
00000a  6807              LDR      r7,[r0,#0]  ; xTickCount
;;;5181   
;;;5182   	#if( INCLUDE_xTaskAbortDelay == 1 )
;;;5183   	{
;;;5184   		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
;;;5185   		reset to pdFALSE so it can be detected as having been set to pdTRUE
;;;5186   		when the task leaves the Blocked state. */
;;;5187   		pxCurrentTCB->ucDelayAborted = pdFALSE;
;;;5188   	}
;;;5189   	#endif
;;;5190   
;;;5191   	/* Remove the task from the ready list before adding it to the blocked list
;;;5192   	as the same list item is used for both lists. */
;;;5193   	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
00000c  4816              LDR      r0,|L3.104|
00000e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000010  1d00              ADDS     r0,r0,#4
000012  f7fffffe          BL       uxListRemove
;;;5194   	{
;;;5195   		/* The current task must be in a ready list, so there is no need to
;;;5196   		check, and the port reset macro can be called directly. */
;;;5197   		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
;;;5198   	}
;;;5199   	else
;;;5200   	{
;;;5201   		mtCOVERAGE_TEST_MARKER();
;;;5202   	}
;;;5203   
;;;5204   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;5205   	{
;;;5206   		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
000016  1c68              ADDS     r0,r5,#1
000018  b938              CBNZ     r0,|L3.42|
00001a  b136              CBZ      r6,|L3.42|
;;;5207   		{
;;;5208   			/* Add the task to the suspended task list instead of a delayed task
;;;5209   			list to ensure it is not woken by a timing event.  It will block
;;;5210   			indefinitely. */
;;;5211   			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
00001c  4812              LDR      r0,|L3.104|
00001e  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000020  1d09              ADDS     r1,r1,#4
000022  4812              LDR      r0,|L3.108|
000024  f7fffffe          BL       vListInsertEnd
000028  e01a              B        |L3.96|
                  |L3.42|
;;;5212   		}
;;;5213   		else
;;;5214   		{
;;;5215   			/* Calculate the time at which the task should be woken if the event
;;;5216   			does not occur.  This may overflow but this doesn't matter, the
;;;5217   			kernel will manage it correctly. */
;;;5218   			xTimeToWake = xConstTickCount + xTicksToWait;
00002a  197c              ADDS     r4,r7,r5
;;;5219   
;;;5220   			/* The list item will be inserted in wake time order. */
;;;5221   			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
00002c  480e              LDR      r0,|L3.104|
00002e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000030  6044              STR      r4,[r0,#4]
;;;5222   
;;;5223   			if( xTimeToWake < xConstTickCount )
000032  42bc              CMP      r4,r7
000034  d207              BCS      |L3.70|
;;;5224   			{
;;;5225   				/* Wake time has overflowed.  Place this item in the overflow
;;;5226   				list. */
;;;5227   				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
000036  480c              LDR      r0,|L3.104|
000038  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
00003a  1d09              ADDS     r1,r1,#4
00003c  480c              LDR      r0,|L3.112|
00003e  6800              LDR      r0,[r0,#0]  ; pxOverflowDelayedTaskList
000040  f7fffffe          BL       vListInsert
000044  e00c              B        |L3.96|
                  |L3.70|
;;;5228   			}
;;;5229   			else
;;;5230   			{
;;;5231   				/* The wake time has not overflowed, so the current block list
;;;5232   				is used. */
;;;5233   				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
000046  4808              LDR      r0,|L3.104|
000048  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
00004a  1d09              ADDS     r1,r1,#4
00004c  4809              LDR      r0,|L3.116|
00004e  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
000050  f7fffffe          BL       vListInsert
;;;5234   
;;;5235   				/* If the task entering the blocked state was placed at the
;;;5236   				head of the list of blocked tasks then xNextTaskUnblockTime
;;;5237   				needs to be updated too. */
;;;5238   				if( xTimeToWake < xNextTaskUnblockTime )
000054  4808              LDR      r0,|L3.120|
000056  6800              LDR      r0,[r0,#0]  ; xNextTaskUnblockTime
000058  4284              CMP      r4,r0
00005a  d201              BCS      |L3.96|
;;;5239   				{
;;;5240   					xNextTaskUnblockTime = xTimeToWake;
00005c  4806              LDR      r0,|L3.120|
00005e  6004              STR      r4,[r0,#0]  ; xNextTaskUnblockTime
                  |L3.96|
;;;5241   				}
;;;5242   				else
;;;5243   				{
;;;5244   					mtCOVERAGE_TEST_MARKER();
;;;5245   				}
;;;5246   			}
;;;5247   		}
;;;5248   	}
;;;5249   	#else /* INCLUDE_vTaskSuspend */
;;;5250   	{
;;;5251   		/* Calculate the time at which the task should be woken if the event
;;;5252   		does not occur.  This may overflow but this doesn't matter, the kernel
;;;5253   		will manage it correctly. */
;;;5254   		xTimeToWake = xConstTickCount + xTicksToWait;
;;;5255   
;;;5256   		/* The list item will be inserted in wake time order. */
;;;5257   		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
;;;5258   
;;;5259   		if( xTimeToWake < xConstTickCount )
;;;5260   		{
;;;5261   			/* Wake time has overflowed.  Place this item in the overflow list. */
;;;5262   			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
;;;5263   		}
;;;5264   		else
;;;5265   		{
;;;5266   			/* The wake time has not overflowed, so the current block list is used. */
;;;5267   			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
;;;5268   
;;;5269   			/* If the task entering the blocked state was placed at the head of the
;;;5270   			list of blocked tasks then xNextTaskUnblockTime needs to be updated
;;;5271   			too. */
;;;5272   			if( xTimeToWake < xNextTaskUnblockTime )
;;;5273   			{
;;;5274   				xNextTaskUnblockTime = xTimeToWake;
;;;5275   			}
;;;5276   			else
;;;5277   			{
;;;5278   				mtCOVERAGE_TEST_MARKER();
;;;5279   			}
;;;5280   		}
;;;5281   
;;;5282   		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
;;;5283   		( void ) xCanBlockIndefinitely;
;;;5284   	}
;;;5285   	#endif /* INCLUDE_vTaskSuspend */
;;;5286   }
000060  e8bd81f0          POP      {r4-r8,pc}
;;;5287   
                          ENDP

                  |L3.100|
                          DCD      xTickCount
                  |L3.104|
                          DCD      pxCurrentTCB
                  |L3.108|
                          DCD      xSuspendedTaskList
                  |L3.112|
                          DCD      pxOverflowDelayedTaskList
                  |L3.116|
                          DCD      pxDelayedTaskList
                  |L3.120|
                          DCD      xNextTaskUnblockTime

                          AREA ||i.prvAddNewTaskToReadyList||, CODE, READONLY, ALIGN=2

                  prvAddNewTaskToReadyList PROC
;;;1076   
;;;1077   static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
000000  b510              PUSH     {r4,lr}
;;;1078   {
000002  4604              MOV      r4,r0
;;;1079   	/* Ensure interrupts don't access the task lists while the lists are being
;;;1080   	updated. */
;;;1081   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1082   	{
;;;1083   		uxCurrentNumberOfTasks++;
000008  4824              LDR      r0,|L4.156|
00000a  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
00000c  1c40              ADDS     r0,r0,#1
00000e  4923              LDR      r1,|L4.156|
000010  6008              STR      r0,[r1,#0]  ; uxCurrentNumberOfTasks
;;;1084   		if( pxCurrentTCB == NULL )
000012  4823              LDR      r0,|L4.160|
000014  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000016  b940              CBNZ     r0,|L4.42|
;;;1085   		{
;;;1086   			/* There are no other tasks, or all the other tasks are in
;;;1087   			the suspended state - make this the current task. */
;;;1088   			pxCurrentTCB = pxNewTCB;
000018  4821              LDR      r0,|L4.160|
00001a  6004              STR      r4,[r0,#0]  ; pxCurrentTCB
;;;1089   
;;;1090   			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
00001c  4608              MOV      r0,r1
00001e  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000020  2801              CMP      r0,#1
000022  d10d              BNE      |L4.64|
;;;1091   			{
;;;1092   				/* This is the first task to be created so do the preliminary
;;;1093   				initialisation required.  We will not recover if this call
;;;1094   				fails, but we will report the failure. */
;;;1095   				prvInitialiseTaskLists();
000024  f7fffffe          BL       prvInitialiseTaskLists
000028  e00a              B        |L4.64|
                  |L4.42|
;;;1096   			}
;;;1097   			else
;;;1098   			{
;;;1099   				mtCOVERAGE_TEST_MARKER();
;;;1100   			}
;;;1101   		}
;;;1102   		else
;;;1103   		{
;;;1104   			/* If the scheduler is not already running, make this task the
;;;1105   			current task if it is the highest priority task to be created
;;;1106   			so far. */
;;;1107   			if( xSchedulerRunning == pdFALSE )
00002a  481e              LDR      r0,|L4.164|
00002c  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
00002e  b938              CBNZ     r0,|L4.64|
;;;1108   			{
;;;1109   				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
000030  481b              LDR      r0,|L4.160|
000032  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000034  6ac0              LDR      r0,[r0,#0x2c]
000036  6ae1              LDR      r1,[r4,#0x2c]
000038  4288              CMP      r0,r1
00003a  d801              BHI      |L4.64|
;;;1110   				{
;;;1111   					pxCurrentTCB = pxNewTCB;
00003c  4818              LDR      r0,|L4.160|
00003e  6004              STR      r4,[r0,#0]  ; pxCurrentTCB
                  |L4.64|
;;;1112   				}
;;;1113   				else
;;;1114   				{
;;;1115   					mtCOVERAGE_TEST_MARKER();
;;;1116   				}
;;;1117   			}
;;;1118   			else
;;;1119   			{
;;;1120   				mtCOVERAGE_TEST_MARKER();
;;;1121   			}
;;;1122   		}
;;;1123   
;;;1124   		uxTaskNumber++;
000040  4819              LDR      r0,|L4.168|
000042  6800              LDR      r0,[r0,#0]  ; uxTaskNumber
000044  1c40              ADDS     r0,r0,#1
000046  4918              LDR      r1,|L4.168|
000048  6008              STR      r0,[r1,#0]  ; uxTaskNumber
;;;1125   
;;;1126   		#if ( configUSE_TRACE_FACILITY == 1 )
;;;1127   		{
;;;1128   			/* Add a counter into the TCB for tracing only. */
;;;1129   			pxNewTCB->uxTCBNumber = uxTaskNumber;
00004a  4608              MOV      r0,r1
00004c  6800              LDR      r0,[r0,#0]  ; uxTaskNumber
00004e  6460              STR      r0,[r4,#0x44]
;;;1130   		}
;;;1131   		#endif /* configUSE_TRACE_FACILITY */
;;;1132   		traceTASK_CREATE( pxNewTCB );
;;;1133   
;;;1134   		prvAddTaskToReadyList( pxNewTCB );
000050  4916              LDR      r1,|L4.172|
000052  6ae0              LDR      r0,[r4,#0x2c]
000054  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000056  4288              CMP      r0,r1
000058  d902              BLS      |L4.96|
00005a  4914              LDR      r1,|L4.172|
00005c  6ae0              LDR      r0,[r4,#0x2c]
00005e  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L4.96|
000060  6ae1              LDR      r1,[r4,#0x2c]
000062  eb010181          ADD      r1,r1,r1,LSL #2
000066  4a12              LDR      r2,|L4.176|
000068  eb020081          ADD      r0,r2,r1,LSL #2
00006c  1d21              ADDS     r1,r4,#4
00006e  f7fffffe          BL       vListInsertEnd
;;;1135   
;;;1136   		portSETUP_TCB( pxNewTCB );
;;;1137   	}
;;;1138   	taskEXIT_CRITICAL();
000072  f7fffffe          BL       vPortExitCritical
;;;1139   
;;;1140   	if( xSchedulerRunning != pdFALSE )
000076  480b              LDR      r0,|L4.164|
000078  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
00007a  b168              CBZ      r0,|L4.152|
;;;1141   	{
;;;1142   		/* If the created task is of a higher priority than the current task
;;;1143   		then it should run now. */
;;;1144   		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
00007c  4808              LDR      r0,|L4.160|
00007e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000080  6ac0              LDR      r0,[r0,#0x2c]
000082  6ae1              LDR      r1,[r4,#0x2c]
000084  4288              CMP      r0,r1
000086  d207              BCS      |L4.152|
;;;1145   		{
;;;1146   			taskYIELD_IF_USING_PREEMPTION();
000088  f04f5080          MOV      r0,#0x10000000
00008c  4909              LDR      r1,|L4.180|
00008e  6008              STR      r0,[r1,#0]
000090  f3bf8f4f          DSB      
000094  f3bf8f6f          ISB      
                  |L4.152|
;;;1147   		}
;;;1148   		else
;;;1149   		{
;;;1150   			mtCOVERAGE_TEST_MARKER();
;;;1151   		}
;;;1152   	}
;;;1153   	else
;;;1154   	{
;;;1155   		mtCOVERAGE_TEST_MARKER();
;;;1156   	}
;;;1157   }
000098  bd10              POP      {r4,pc}
;;;1158   /*-----------------------------------------------------------*/
                          ENDP

00009a  0000              DCW      0x0000
                  |L4.156|
                          DCD      uxCurrentNumberOfTasks
                  |L4.160|
                          DCD      pxCurrentTCB
                  |L4.164|
                          DCD      xSchedulerRunning
                  |L4.168|
                          DCD      uxTaskNumber
                  |L4.172|
                          DCD      uxTopReadyPriority
                  |L4.176|
                          DCD      pxReadyTasksLists
                  |L4.180|
                          DCD      0xe000ed04

                          AREA ||i.prvCheckTasksWaitingTermination||, CODE, READONLY, ALIGN=2

                  prvCheckTasksWaitingTermination PROC
;;;3638   
;;;3639   static void prvCheckTasksWaitingTermination( void )
000000  b510              PUSH     {r4,lr}
;;;3640   {
;;;3641   
;;;3642   	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
;;;3643   
;;;3644   	#if ( INCLUDE_vTaskDelete == 1 )
;;;3645   	{
;;;3646   		TCB_t *pxTCB;
;;;3647   
;;;3648   		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
;;;3649   		being called too often in the idle task. */
;;;3650   		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
000002  e016              B        |L5.50|
                  |L5.4|
;;;3651   		{
;;;3652   			taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;3653   			{
;;;3654   				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000008  480c              LDR      r0,|L5.60|
00000a  68c0              LDR      r0,[r0,#0xc]
00000c  68c4              LDR      r4,[r0,#0xc]
;;;3655   				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
00000e  1d20              ADDS     r0,r4,#4
000010  f7fffffe          BL       uxListRemove
;;;3656   				--uxCurrentNumberOfTasks;
000014  480a              LDR      r0,|L5.64|
000016  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000018  1e40              SUBS     r0,r0,#1
00001a  4909              LDR      r1,|L5.64|
00001c  6008              STR      r0,[r1,#0]  ; uxCurrentNumberOfTasks
;;;3657   				--uxDeletedTasksWaitingCleanUp;
00001e  4809              LDR      r0,|L5.68|
000020  6800              LDR      r0,[r0,#0]  ; uxDeletedTasksWaitingCleanUp
000022  1e40              SUBS     r0,r0,#1
000024  4907              LDR      r1,|L5.68|
000026  6008              STR      r0,[r1,#0]  ; uxDeletedTasksWaitingCleanUp
;;;3658   			}
;;;3659   			taskEXIT_CRITICAL();
000028  f7fffffe          BL       vPortExitCritical
;;;3660   
;;;3661   			prvDeleteTCB( pxTCB );
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       prvDeleteTCB
                  |L5.50|
000032  4804              LDR      r0,|L5.68|
000034  6800              LDR      r0,[r0,#0]            ;3650  ; uxDeletedTasksWaitingCleanUp
000036  2800              CMP      r0,#0                 ;3650
000038  d1e4              BNE      |L5.4|
;;;3662   		}
;;;3663   	}
;;;3664   	#endif /* INCLUDE_vTaskDelete */
;;;3665   }
00003a  bd10              POP      {r4,pc}
;;;3666   /*-----------------------------------------------------------*/
                          ENDP

                  |L5.60|
                          DCD      xTasksWaitingTermination
                  |L5.64|
                          DCD      uxCurrentNumberOfTasks
                  |L5.68|
                          DCD      uxDeletedTasksWaitingCleanUp

                          AREA ||i.prvDeleteTCB||, CODE, READONLY, ALIGN=1

                  prvDeleteTCB PROC
;;;3886   
;;;3887   	static void prvDeleteTCB( TCB_t *pxTCB )
000000  b510              PUSH     {r4,lr}
;;;3888   	{
000002  4604              MOV      r4,r0
;;;3889   		/* This call is required specifically for the TriCore port.  It must be
;;;3890   		above the vPortFree() calls.  The call is also used by ports/demos that
;;;3891   		want to allocate and clean RAM statically. */
;;;3892   		portCLEAN_UP_TCB( pxTCB );
;;;3893   
;;;3894   		/* Free up the memory allocated by the scheduler for the task.  It is up
;;;3895   		to the task to free any memory allocated at the application level.
;;;3896   		See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
;;;3897   		for additional information. */
;;;3898   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;3899   		{
;;;3900   			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
;;;3901   		}
;;;3902   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;3903   
;;;3904   		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
;;;3905   		{
;;;3906   			/* The task can only have been allocated dynamically - free both
;;;3907   			the stack and TCB. */
;;;3908   			vPortFree( pxTCB->pxStack );
;;;3909   			vPortFree( pxTCB );
;;;3910   		}
;;;3911   		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
;;;3912   		{
;;;3913   			/* The task could have been allocated statically or dynamically, so
;;;3914   			check what was statically allocated before trying to free the
;;;3915   			memory. */
;;;3916   			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
000004  f8940059          LDRB     r0,[r4,#0x59]
000008  b930              CBNZ     r0,|L6.24|
;;;3917   			{
;;;3918   				/* Both the stack and TCB were allocated dynamically, so both
;;;3919   				must be freed. */
;;;3920   				vPortFree( pxTCB->pxStack );
00000a  6b20              LDR      r0,[r4,#0x30]
00000c  f7fffffe          BL       vPortFree
;;;3921   				vPortFree( pxTCB );
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       vPortFree
000016  e01a              B        |L6.78|
                  |L6.24|
;;;3922   			}
;;;3923   			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
000018  f8940059          LDRB     r0,[r4,#0x59]
00001c  2801              CMP      r0,#1
00001e  d103              BNE      |L6.40|
;;;3924   			{
;;;3925   				/* Only the stack was statically allocated, so the TCB is the
;;;3926   				only memory that must be freed. */
;;;3927   				vPortFree( pxTCB );
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       vPortFree
000026  e012              B        |L6.78|
                  |L6.40|
;;;3928   			}
;;;3929   			else
;;;3930   			{
;;;3931   				/* Neither the stack nor the TCB were allocated dynamically, so
;;;3932   				nothing needs to be freed. */
;;;3933   				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
000028  f8940059          LDRB     r0,[r4,#0x59]
00002c  2802              CMP      r0,#2
00002e  d101              BNE      |L6.52|
000030  2001              MOVS     r0,#1
000032  e000              B        |L6.54|
                  |L6.52|
000034  2000              MOVS     r0,#0
                  |L6.54|
000036  b950              CBNZ     r0,|L6.78|
000038  bf00              NOP      
00003a  2050              MOVS     r0,#0x50
00003c  f3808811          MSR      BASEPRI,r0
000040  f3bf8f4f          DSB      
000044  f3bf8f6f          ISB      
000048  bf00              NOP      
00004a  bf00              NOP      
                  |L6.76|
00004c  e7fe              B        |L6.76|
                  |L6.78|
;;;3934   				mtCOVERAGE_TEST_MARKER();
;;;3935   			}
;;;3936   		}
;;;3937   		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;3938   	}
00004e  bd10              POP      {r4,pc}
;;;3939   
                          ENDP


                          AREA ||i.prvIdleTask||, CODE, READONLY, ALIGN=2

                  prvIdleTask PROC
;;;3391    */
;;;3392   static portTASK_FUNCTION( prvIdleTask, pvParameters )
000000  bf00              NOP      
                  |L7.2|
;;;3393   {
;;;3394   	/* Stop warnings. */
;;;3395   	( void ) pvParameters;
;;;3396   
;;;3397   	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
;;;3398   	SCHEDULER IS STARTED. **/
;;;3399   
;;;3400   	/* In case a task that has a secure context deletes itself, in which case
;;;3401   	the idle task is responsible for deleting the task's secure context, if
;;;3402   	any. */
;;;3403   	portALLOCATE_SECURE_CONTEXT( configMINIMAL_SECURE_STACK_SIZE );
;;;3404   
;;;3405   	for( ;; )
;;;3406   	{
;;;3407   		/* See if any tasks have deleted themselves - if so then the idle task
;;;3408   		is responsible for freeing the deleted task's TCB and stack. */
;;;3409   		prvCheckTasksWaitingTermination();
000002  f7fffffe          BL       prvCheckTasksWaitingTermination
;;;3410   
;;;3411   		#if ( configUSE_PREEMPTION == 0 )
;;;3412   		{
;;;3413   			/* If we are not using preemption we keep forcing a task switch to
;;;3414   			see if any other task has become available.  If we are using
;;;3415   			preemption we don't need to do this as any task becoming available
;;;3416   			will automatically get the processor anyway. */
;;;3417   			taskYIELD();
;;;3418   		}
;;;3419   		#endif /* configUSE_PREEMPTION */
;;;3420   
;;;3421   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
;;;3422   		{
;;;3423   			/* When using preemption tasks of equal priority will be
;;;3424   			timesliced.  If a task that is sharing the idle priority is ready
;;;3425   			to run then the idle task should yield before the end of the
;;;3426   			timeslice.
;;;3427   
;;;3428   			A critical region is not required here as we are just reading from
;;;3429   			the list, and an occasional incorrect value will not matter.  If
;;;3430   			the ready list at the idle priority contains more than one task
;;;3431   			then a task other than the idle task is ready to execute. */
;;;3432   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
000006  4806              LDR      r0,|L7.32|
000008  6800              LDR      r0,[r0,#0]  ; pxReadyTasksLists
00000a  2801              CMP      r0,#1
00000c  d9f9              BLS      |L7.2|
;;;3433   			{
;;;3434   				taskYIELD();
00000e  f04f5080          MOV      r0,#0x10000000
000012  4904              LDR      r1,|L7.36|
000014  6008              STR      r0,[r1,#0]
000016  f3bf8f4f          DSB      
00001a  f3bf8f6f          ISB      
00001e  e7f0              B        |L7.2|
;;;3435   			}
;;;3436   			else
;;;3437   			{
;;;3438   				mtCOVERAGE_TEST_MARKER();
;;;3439   			}
;;;3440   		}
;;;3441   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
;;;3442   
;;;3443   		#if ( configUSE_IDLE_HOOK == 1 )
;;;3444   		{
;;;3445   			extern void vApplicationIdleHook( void );
;;;3446   
;;;3447   			/* Call the user defined function from within the idle task.  This
;;;3448   			allows the application designer to add background functionality
;;;3449   			without the overhead of a separate task.
;;;3450   			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
;;;3451   			CALL A FUNCTION THAT MIGHT BLOCK. */
;;;3452   			vApplicationIdleHook();
;;;3453   		}
;;;3454   		#endif /* configUSE_IDLE_HOOK */
;;;3455   
;;;3456   		/* This conditional compilation should use inequality to 0, not equality
;;;3457   		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
;;;3458   		user defined low power mode	implementations require
;;;3459   		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
;;;3460   		#if ( configUSE_TICKLESS_IDLE != 0 )
;;;3461   		{
;;;3462   		TickType_t xExpectedIdleTime;
;;;3463   
;;;3464   			/* It is not desirable to suspend then resume the scheduler on
;;;3465   			each iteration of the idle task.  Therefore, a preliminary
;;;3466   			test of the expected idle time is performed without the
;;;3467   			scheduler suspended.  The result here is not necessarily
;;;3468   			valid. */
;;;3469   			xExpectedIdleTime = prvGetExpectedIdleTime();
;;;3470   
;;;3471   			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;3472   			{
;;;3473   				vTaskSuspendAll();
;;;3474   				{
;;;3475   					/* Now the scheduler is suspended, the expected idle
;;;3476   					time can be sampled again, and this time its value can
;;;3477   					be used. */
;;;3478   					configASSERT( xNextTaskUnblockTime >= xTickCount );
;;;3479   					xExpectedIdleTime = prvGetExpectedIdleTime();
;;;3480   
;;;3481   					/* Define the following macro to set xExpectedIdleTime to 0
;;;3482   					if the application does not want
;;;3483   					portSUPPRESS_TICKS_AND_SLEEP() to be called. */
;;;3484   					configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );
;;;3485   
;;;3486   					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;3487   					{
;;;3488   						traceLOW_POWER_IDLE_BEGIN();
;;;3489   						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
;;;3490   						traceLOW_POWER_IDLE_END();
;;;3491   					}
;;;3492   					else
;;;3493   					{
;;;3494   						mtCOVERAGE_TEST_MARKER();
;;;3495   					}
;;;3496   				}
;;;3497   				( void ) xTaskResumeAll();
;;;3498   			}
;;;3499   			else
;;;3500   			{
;;;3501   				mtCOVERAGE_TEST_MARKER();
;;;3502   			}
;;;3503   		}
;;;3504   		#endif /* configUSE_TICKLESS_IDLE */
;;;3505   	}
;;;3506   }
;;;3507   /*-----------------------------------------------------------*/
                          ENDP

                  |L7.32|
                          DCD      pxReadyTasksLists
                  |L7.36|
                          DCD      0xe000ed04

                          AREA ||i.prvInitialiseNewTask||, CODE, READONLY, ALIGN=1

                  prvInitialiseNewTask PROC
;;;823    
;;;824    static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;825    									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
;;;826    									const uint32_t ulStackDepth,
;;;827    									void * const pvParameters,
;;;828    									UBaseType_t uxPriority,
;;;829    									TaskHandle_t * const pxCreatedTask,
;;;830    									TCB_t *pxNewTCB,
;;;831    									const MemoryRegion_t * const xRegions )
;;;832    {
000004  4682              MOV      r10,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
00000a  469b              MOV      r11,r3
00000c  9f0a              LDR      r7,[sp,#0x28]
00000e  9c0c              LDR      r4,[sp,#0x30]
;;;833    StackType_t *pxTopOfStack;
;;;834    UBaseType_t x;
;;;835    
;;;836    	#if( portUSING_MPU_WRAPPERS == 1 )
;;;837    		/* Should the task be created in privileged mode? */
;;;838    		BaseType_t xRunPrivileged;
;;;839    		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
;;;840    		{
;;;841    			xRunPrivileged = pdTRUE;
;;;842    		}
;;;843    		else
;;;844    		{
;;;845    			xRunPrivileged = pdFALSE;
;;;846    		}
;;;847    		uxPriority &= ~portPRIVILEGE_BIT;
;;;848    	#endif /* portUSING_MPU_WRAPPERS == 1 */
;;;849    
;;;850    	/* Avoid dependency on memset() if it is not required. */
;;;851    	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
;;;852    	{
;;;853    		/* Fill the stack with a known value to assist debugging. */
;;;854    		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
000010  ea4f0188          LSL      r1,r8,#2
000014  22a5              MOVS     r2,#0xa5
000016  6b20              LDR      r0,[r4,#0x30]
000018  f7fffffe          BL       __aeabi_memset
;;;855    	}
;;;856    	#endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */
;;;857    
;;;858    	/* Calculate the top of stack address.  This depends on whether the stack
;;;859    	grows from high memory to low (as per the 80x86) or vice versa.
;;;860    	portSTACK_GROWTH is used to make the result positive or negative as required
;;;861    	by the port. */
;;;862    	#if( portSTACK_GROWTH < 0 )
;;;863    	{
;;;864    		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
00001c  f1a80001          SUB      r0,r8,#1
000020  6b21              LDR      r1,[r4,#0x30]
000022  eb010980          ADD      r9,r1,r0,LSL #2
;;;865    		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
000026  f0290907          BIC      r9,r9,#7
;;;866    
;;;867    		/* Check the alignment of the calculated top of stack is correct. */
;;;868    		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
00002a  f0090007          AND      r0,r9,#7
00002e  b908              CBNZ     r0,|L8.52|
000030  2001              MOVS     r0,#1
000032  e000              B        |L8.54|
                  |L8.52|
000034  2000              MOVS     r0,#0
                  |L8.54|
000036  b950              CBNZ     r0,|L8.78|
000038  bf00              NOP      
00003a  2050              MOVS     r0,#0x50
00003c  f3808811          MSR      BASEPRI,r0
000040  f3bf8f4f          DSB      
000044  f3bf8f6f          ISB      
000048  bf00              NOP      
00004a  bf00              NOP      
                  |L8.76|
00004c  e7fe              B        |L8.76|
                  |L8.78|
;;;869    
;;;870    		#if( configRECORD_STACK_HIGH_ADDRESS == 1 )
;;;871    		{
;;;872    			/* Also record the stack's high address, which may assist
;;;873    			debugging. */
;;;874    			pxNewTCB->pxEndOfStack = pxTopOfStack;
;;;875    		}
;;;876    		#endif /* configRECORD_STACK_HIGH_ADDRESS */
;;;877    	}
;;;878    	#else /* portSTACK_GROWTH */
;;;879    	{
;;;880    		pxTopOfStack = pxNewTCB->pxStack;
;;;881    
;;;882    		/* Check the alignment of the stack buffer is correct. */
;;;883    		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;;;884    
;;;885    		/* The other extreme of the stack space is required if stack checking is
;;;886    		performed. */
;;;887    		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
;;;888    	}
;;;889    	#endif /* portSTACK_GROWTH */
;;;890    
;;;891    	/* Store the task name in the TCB. */
;;;892    	if( pcName != NULL )
00004e  b186              CBZ      r6,|L8.114|
;;;893    	{
;;;894    		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
000050  2500              MOVS     r5,#0
000052  e007              B        |L8.100|
                  |L8.84|
;;;895    		{
;;;896    			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
000054  5d71              LDRB     r1,[r6,r5]
000056  f1040034          ADD      r0,r4,#0x34
00005a  5541              STRB     r1,[r0,r5]
;;;897    
;;;898    			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
;;;899    			configMAX_TASK_NAME_LEN characters just in case the memory after the
;;;900    			string is not accessible (extremely unlikely). */
;;;901    			if( pcName[ x ] == ( char ) 0x00 )
00005c  5d70              LDRB     r0,[r6,r5]
00005e  b900              CBNZ     r0,|L8.98|
;;;902    			{
;;;903    				break;
000060  e002              B        |L8.104|
                  |L8.98|
000062  1c6d              ADDS     r5,r5,#1              ;894
                  |L8.100|
000064  2d10              CMP      r5,#0x10              ;894
000066  d3f5              BCC      |L8.84|
                  |L8.104|
000068  bf00              NOP      
;;;904    			}
;;;905    			else
;;;906    			{
;;;907    				mtCOVERAGE_TEST_MARKER();
;;;908    			}
;;;909    		}
;;;910    
;;;911    		/* Ensure the name string is terminated in the case that the string length
;;;912    		was greater or equal to configMAX_TASK_NAME_LEN. */
;;;913    		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
00006a  2100              MOVS     r1,#0
00006c  2043              MOVS     r0,#0x43
00006e  5501              STRB     r1,[r0,r4]
000070  e002              B        |L8.120|
                  |L8.114|
;;;914    	}
;;;915    	else
;;;916    	{
;;;917    		/* The task has not been given a name, so just ensure there is a NULL
;;;918    		terminator when it is read out. */
;;;919    		pxNewTCB->pcTaskName[ 0 ] = 0x00;
000072  2000              MOVS     r0,#0
000074  f8840034          STRB     r0,[r4,#0x34]
                  |L8.120|
;;;920    	}
;;;921    
;;;922    	/* This is used as an array index so must ensure it's not too large.  First
;;;923    	remove the privilege bit if one is present. */
;;;924    	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
000078  2f38              CMP      r7,#0x38
00007a  d300              BCC      |L8.126|
;;;925    	{
;;;926    		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
00007c  2737              MOVS     r7,#0x37
                  |L8.126|
;;;927    	}
;;;928    	else
;;;929    	{
;;;930    		mtCOVERAGE_TEST_MARKER();
;;;931    	}
;;;932    
;;;933    	pxNewTCB->uxPriority = uxPriority;
00007e  62e7              STR      r7,[r4,#0x2c]
;;;934    	#if ( configUSE_MUTEXES == 1 )
;;;935    	{
;;;936    		pxNewTCB->uxBasePriority = uxPriority;
000080  64e7              STR      r7,[r4,#0x4c]
;;;937    		pxNewTCB->uxMutexesHeld = 0;
000082  2000              MOVS     r0,#0
000084  6520              STR      r0,[r4,#0x50]
;;;938    	}
;;;939    	#endif /* configUSE_MUTEXES */
;;;940    
;;;941    	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
000086  1d20              ADDS     r0,r4,#4
000088  f7fffffe          BL       vListInitialiseItem
;;;942    	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
00008c  f1040018          ADD      r0,r4,#0x18
000090  f7fffffe          BL       vListInitialiseItem
;;;943    
;;;944    	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
;;;945    	back to	the containing TCB from a generic item in a list. */
;;;946    	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
000094  6124              STR      r4,[r4,#0x10]
;;;947    
;;;948    	/* Event lists are always in priority order. */
;;;949    	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000096  f1c70038          RSB      r0,r7,#0x38
00009a  61a0              STR      r0,[r4,#0x18]
;;;950    	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
00009c  6264              STR      r4,[r4,#0x24]
;;;951    
;;;952    	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
;;;953    	{
;;;954    		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
;;;955    	}
;;;956    	#endif /* portCRITICAL_NESTING_IN_TCB */
;;;957    
;;;958    	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
;;;959    	{
;;;960    		pxNewTCB->pxTaskTag = NULL;
;;;961    	}
;;;962    	#endif /* configUSE_APPLICATION_TASK_TAG */
;;;963    
;;;964    	#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;965    	{
;;;966    		pxNewTCB->ulRunTimeCounter = 0UL;
;;;967    	}
;;;968    	#endif /* configGENERATE_RUN_TIME_STATS */
;;;969    
;;;970    	#if ( portUSING_MPU_WRAPPERS == 1 )
;;;971    	{
;;;972    		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth );
;;;973    	}
;;;974    	#else
;;;975    	{
;;;976    		/* Avoid compiler warning about unreferenced parameter. */
;;;977    		( void ) xRegions;
;;;978    	}
;;;979    	#endif
;;;980    
;;;981    	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
;;;982    	{
;;;983    		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
;;;984    		{
;;;985    			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
;;;986    		}
;;;987    	}
;;;988    	#endif
;;;989    
;;;990    	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
;;;991    	{
;;;992    		pxNewTCB->ulNotifiedValue = 0;
00009e  2000              MOVS     r0,#0
0000a0  6560              STR      r0,[r4,#0x54]
;;;993    		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
0000a2  f8840058          STRB     r0,[r4,#0x58]
;;;994    	}
;;;995    	#endif
;;;996    
;;;997    	#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;998    	{
;;;999    		/* Initialise this task's Newlib reent structure.
;;;1000   		See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
;;;1001   		for additional information. */
;;;1002   		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
;;;1003   	}
;;;1004   	#endif
;;;1005   
;;;1006   	#if( INCLUDE_xTaskAbortDelay == 1 )
;;;1007   	{
;;;1008   		pxNewTCB->ucDelayAborted = pdFALSE;
;;;1009   	}
;;;1010   	#endif
;;;1011   
;;;1012   	/* Initialize the TCB stack to look as if the task was already running,
;;;1013   	but had been interrupted by the scheduler.  The return address is set
;;;1014   	to the start of the task function. Once the stack has been initialised
;;;1015   	the top of stack variable is updated. */
;;;1016   	#if( portUSING_MPU_WRAPPERS == 1 )
;;;1017   	{
;;;1018   		/* If the port has capability to detect stack overflow,
;;;1019   		pass the stack end address to the stack initialization
;;;1020   		function as well. */
;;;1021   		#if( portHAS_STACK_OVERFLOW_CHECKING == 1 )
;;;1022   		{
;;;1023   			#if( portSTACK_GROWTH < 0 )
;;;1024   			{
;;;1025   				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxStack, pxTaskCode, pvParameters, xRunPrivileged );
;;;1026   			}
;;;1027   			#else /* portSTACK_GROWTH */
;;;1028   			{
;;;1029   				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxEndOfStack, pxTaskCode, pvParameters, xRunPrivileged );
;;;1030   			}
;;;1031   			#endif /* portSTACK_GROWTH */
;;;1032   		}
;;;1033   		#else /* portHAS_STACK_OVERFLOW_CHECKING */
;;;1034   		{
;;;1035   			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
;;;1036   		}
;;;1037   		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
;;;1038   	}
;;;1039   	#else /* portUSING_MPU_WRAPPERS */
;;;1040   	{
;;;1041   		/* If the port has capability to detect stack overflow,
;;;1042   		pass the stack end address to the stack initialization
;;;1043   		function as well. */
;;;1044   		#if( portHAS_STACK_OVERFLOW_CHECKING == 1 )
;;;1045   		{
;;;1046   			#if( portSTACK_GROWTH < 0 )
;;;1047   			{
;;;1048   				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxStack, pxTaskCode, pvParameters );
;;;1049   			}
;;;1050   			#else /* portSTACK_GROWTH */
;;;1051   			{
;;;1052   				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxEndOfStack, pxTaskCode, pvParameters );
;;;1053   			}
;;;1054   			#endif /* portSTACK_GROWTH */
;;;1055   		}
;;;1056   		#else /* portHAS_STACK_OVERFLOW_CHECKING */
;;;1057   		{
;;;1058   			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
0000a6  465a              MOV      r2,r11
0000a8  4651              MOV      r1,r10
0000aa  4648              MOV      r0,r9
0000ac  f7fffffe          BL       pxPortInitialiseStack
0000b0  6020              STR      r0,[r4,#0]
;;;1059   		}
;;;1060   		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
;;;1061   	}
;;;1062   	#endif /* portUSING_MPU_WRAPPERS */
;;;1063   
;;;1064   	if( pxCreatedTask != NULL )
0000b2  980b              LDR      r0,[sp,#0x2c]
0000b4  b108              CBZ      r0,|L8.186|
;;;1065   	{
;;;1066   		/* Pass the handle out in an anonymous way.  The handle can be used to
;;;1067   		change the created task's priority, delete the created task, etc.*/
;;;1068   		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
0000b6  980b              LDR      r0,[sp,#0x2c]
0000b8  6004              STR      r4,[r0,#0]
                  |L8.186|
;;;1069   	}
;;;1070   	else
;;;1071   	{
;;;1072   		mtCOVERAGE_TEST_MARKER();
;;;1073   	}
;;;1074   }
0000ba  e8bd9ff0          POP      {r4-r12,pc}
;;;1075   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvInitialiseTaskLists||, CODE, READONLY, ALIGN=2

                  prvInitialiseTaskLists PROC
;;;3606   
;;;3607   static void prvInitialiseTaskLists( void )
000000  b510              PUSH     {r4,lr}
;;;3608   {
;;;3609   UBaseType_t uxPriority;
;;;3610   
;;;3611   	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
000002  2400              MOVS     r4,#0
000004  e007              B        |L9.22|
                  |L9.6|
;;;3612   	{
;;;3613   		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
000006  eb040184          ADD      r1,r4,r4,LSL #2
00000a  4a0f              LDR      r2,|L9.72|
00000c  eb020081          ADD      r0,r2,r1,LSL #2
000010  f7fffffe          BL       vListInitialise
000014  1c64              ADDS     r4,r4,#1              ;3611
                  |L9.22|
000016  2c38              CMP      r4,#0x38              ;3611
000018  d3f5              BCC      |L9.6|
;;;3614   	}
;;;3615   
;;;3616   	vListInitialise( &xDelayedTaskList1 );
00001a  480c              LDR      r0,|L9.76|
00001c  f7fffffe          BL       vListInitialise
;;;3617   	vListInitialise( &xDelayedTaskList2 );
000020  480b              LDR      r0,|L9.80|
000022  f7fffffe          BL       vListInitialise
;;;3618   	vListInitialise( &xPendingReadyList );
000026  480b              LDR      r0,|L9.84|
000028  f7fffffe          BL       vListInitialise
;;;3619   
;;;3620   	#if ( INCLUDE_vTaskDelete == 1 )
;;;3621   	{
;;;3622   		vListInitialise( &xTasksWaitingTermination );
00002c  480a              LDR      r0,|L9.88|
00002e  f7fffffe          BL       vListInitialise
;;;3623   	}
;;;3624   	#endif /* INCLUDE_vTaskDelete */
;;;3625   
;;;3626   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;3627   	{
;;;3628   		vListInitialise( &xSuspendedTaskList );
000032  480a              LDR      r0,|L9.92|
000034  f7fffffe          BL       vListInitialise
;;;3629   	}
;;;3630   	#endif /* INCLUDE_vTaskSuspend */
;;;3631   
;;;3632   	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
;;;3633   	using list2. */
;;;3634   	pxDelayedTaskList = &xDelayedTaskList1;
000038  4804              LDR      r0,|L9.76|
00003a  4909              LDR      r1,|L9.96|
00003c  6008              STR      r0,[r1,#0]  ; pxDelayedTaskList
;;;3635   	pxOverflowDelayedTaskList = &xDelayedTaskList2;
00003e  4804              LDR      r0,|L9.80|
000040  4908              LDR      r1,|L9.100|
000042  6008              STR      r0,[r1,#0]  ; pxOverflowDelayedTaskList
;;;3636   }
000044  bd10              POP      {r4,pc}
;;;3637   /*-----------------------------------------------------------*/
                          ENDP

000046  0000              DCW      0x0000
                  |L9.72|
                          DCD      pxReadyTasksLists
                  |L9.76|
                          DCD      xDelayedTaskList1
                  |L9.80|
                          DCD      xDelayedTaskList2
                  |L9.84|
                          DCD      xPendingReadyList
                  |L9.88|
                          DCD      xTasksWaitingTermination
                  |L9.92|
                          DCD      xSuspendedTaskList
                  |L9.96|
                          DCD      pxDelayedTaskList
                  |L9.100|
                          DCD      pxOverflowDelayedTaskList

                          AREA ||i.prvListTasksWithinSingleList||, CODE, READONLY, ALIGN=1

                  prvListTasksWithinSingleList PROC
;;;3765   
;;;3766   	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;3767   	{
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4690              MOV      r8,r2
;;;3768   	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
;;;3769   	UBaseType_t uxTask = 0;
00000a  2600              MOVS     r6,#0
;;;3770   
;;;3771   		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
00000c  6820              LDR      r0,[r4,#0]
00000e  b348              CBZ      r0,|L10.100|
;;;3772   		{
;;;3773   			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000010  4620              MOV      r0,r4
000012  6841              LDR      r1,[r0,#4]
000014  6849              LDR      r1,[r1,#4]
000016  6041              STR      r1,[r0,#4]
000018  f1000108          ADD      r1,r0,#8
00001c  6842              LDR      r2,[r0,#4]
00001e  428a              CMP      r2,r1
000020  d102              BNE      |L10.40|
000022  6841              LDR      r1,[r0,#4]
000024  6849              LDR      r1,[r1,#4]
000026  6041              STR      r1,[r0,#4]
                  |L10.40|
000028  6841              LDR      r1,[r0,#4]
00002a  f8d1900c          LDR      r9,[r1,#0xc]
;;;3774   
;;;3775   			/* Populate an TaskStatus_t structure within the
;;;3776   			pxTaskStatusArray array for each task that is referenced from
;;;3777   			pxList.  See the definition of TaskStatus_t in task.h for the
;;;3778   			meaning of each TaskStatus_t structure member. */
;;;3779   			do
00002e  bf00              NOP      
                  |L10.48|
;;;3780   			{
;;;3781   				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000030  4620              MOV      r0,r4
000032  6841              LDR      r1,[r0,#4]
000034  6849              LDR      r1,[r1,#4]
000036  6041              STR      r1,[r0,#4]
000038  f1000108          ADD      r1,r0,#8
00003c  6842              LDR      r2,[r0,#4]
00003e  428a              CMP      r2,r1
000040  d102              BNE      |L10.72|
000042  6841              LDR      r1,[r0,#4]
000044  6849              LDR      r1,[r1,#4]
000046  6041              STR      r1,[r0,#4]
                  |L10.72|
000048  6841              LDR      r1,[r0,#4]
00004a  68cd              LDR      r5,[r1,#0xc]
;;;3782   				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
00004c  eb0600c6          ADD      r0,r6,r6,LSL #3
000050  eb070180          ADD      r1,r7,r0,LSL #2
000054  4643              MOV      r3,r8
000056  2201              MOVS     r2,#1
000058  4628              MOV      r0,r5
00005a  f7fffffe          BL       vTaskGetInfo
;;;3783   				uxTask++;
00005e  1c76              ADDS     r6,r6,#1
;;;3784   			} while( pxNextTCB != pxFirstTCB );
000060  454d              CMP      r5,r9
000062  d1e5              BNE      |L10.48|
                  |L10.100|
;;;3785   		}
;;;3786   		else
;;;3787   		{
;;;3788   			mtCOVERAGE_TEST_MARKER();
;;;3789   		}
;;;3790   
;;;3791   		return uxTask;
000064  4630              MOV      r0,r6
;;;3792   	}
000066  e8bd87f0          POP      {r4-r10,pc}
;;;3793   
                          ENDP


                          AREA ||i.prvResetNextTaskUnblockTime||, CODE, READONLY, ALIGN=2

                  prvResetNextTaskUnblockTime PROC
;;;3942   
;;;3943   static void prvResetNextTaskUnblockTime( void )
000000  490a              LDR      r1,|L11.44|
;;;3944   {
;;;3945   TCB_t *pxTCB;
;;;3946   
;;;3947   	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
000002  6809              LDR      r1,[r1,#0]  ; pxDelayedTaskList
000004  6809              LDR      r1,[r1,#0]
000006  b909              CBNZ     r1,|L11.12|
000008  2101              MOVS     r1,#1
00000a  e000              B        |L11.14|
                  |L11.12|
00000c  2100              MOVS     r1,#0
                  |L11.14|
00000e  b121              CBZ      r1,|L11.26|
;;;3948   	{
;;;3949   		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
;;;3950   		the maximum possible value so it is	extremely unlikely that the
;;;3951   		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
;;;3952   		there is an item in the delayed list. */
;;;3953   		xNextTaskUnblockTime = portMAX_DELAY;
000010  f04f31ff          MOV      r1,#0xffffffff
000014  4a06              LDR      r2,|L11.48|
000016  6011              STR      r1,[r2,#0]  ; xNextTaskUnblockTime
000018  e006              B        |L11.40|
                  |L11.26|
;;;3954   	}
;;;3955   	else
;;;3956   	{
;;;3957   		/* The new current delayed list is not empty, get the value of
;;;3958   		the item at the head of the delayed list.  This is the time at
;;;3959   		which the task at the head of the delayed list should be removed
;;;3960   		from the Blocked state. */
;;;3961   		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
00001a  4904              LDR      r1,|L11.44|
00001c  6809              LDR      r1,[r1,#0]  ; pxDelayedTaskList
00001e  68c9              LDR      r1,[r1,#0xc]
000020  68c8              LDR      r0,[r1,#0xc]
;;;3962   		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
000022  4a03              LDR      r2,|L11.48|
000024  6841              LDR      r1,[r0,#4]
000026  6011              STR      r1,[r2,#0]  ; xNextTaskUnblockTime
                  |L11.40|
;;;3963   	}
;;;3964   }
000028  4770              BX       lr
;;;3965   /*-----------------------------------------------------------*/
                          ENDP

00002a  0000              DCW      0x0000
                  |L11.44|
                          DCD      pxDelayedTaskList
                  |L11.48|
                          DCD      xNextTaskUnblockTime

                          AREA ||i.prvTaskCheckFreeStackSpace||, CODE, READONLY, ALIGN=1

                  prvTaskCheckFreeStackSpace PROC
;;;3798   
;;;3799   	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
000000  4602              MOV      r2,r0
;;;3800   	{
;;;3801   	uint32_t ulCount = 0U;
000002  2100              MOVS     r1,#0
;;;3802   
;;;3803   		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
000004  e001              B        |L12.10|
                  |L12.6|
;;;3804   		{
;;;3805   			pucStackByte -= portSTACK_GROWTH;
000006  1c52              ADDS     r2,r2,#1
;;;3806   			ulCount++;
000008  1c49              ADDS     r1,r1,#1
                  |L12.10|
00000a  7810              LDRB     r0,[r2,#0]            ;3803
00000c  28a5              CMP      r0,#0xa5              ;3803
00000e  d0fa              BEQ      |L12.6|
;;;3807   		}
;;;3808   
;;;3809   		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
000010  0889              LSRS     r1,r1,#2
;;;3810   
;;;3811   		return ( configSTACK_DEPTH_TYPE ) ulCount;
000012  b288              UXTH     r0,r1
;;;3812   	}
000014  4770              BX       lr
;;;3813   
                          ENDP


                          AREA ||i.prvTaskIsTaskSuspended||, CODE, READONLY, ALIGN=2

                  prvTaskIsTaskSuspended PROC
;;;1804   
;;;1805   	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
000000  b510              PUSH     {r4,lr}
;;;1806   	{
000002  4602              MOV      r2,r0
;;;1807   	BaseType_t xReturn = pdFALSE;
000004  2000              MOVS     r0,#0
;;;1808   	const TCB_t * const pxTCB = xTask;
000006  4611              MOV      r1,r2
;;;1809   
;;;1810   		/* Accesses xPendingReadyList so must be called from a critical
;;;1811   		section. */
;;;1812   
;;;1813   		/* It does not make sense to check if the calling task is suspended. */
;;;1814   		configASSERT( xTask );
000008  b952              CBNZ     r2,|L13.32|
00000a  bf00              NOP      
00000c  2350              MOVS     r3,#0x50
00000e  f3838811          MSR      BASEPRI,r3
000012  f3bf8f4f          DSB      
000016  f3bf8f6f          ISB      
00001a  bf00              NOP      
00001c  bf00              NOP      
                  |L13.30|
00001e  e7fe              B        |L13.30|
                  |L13.32|
;;;1815   
;;;1816   		/* Is the task being resumed actually in the suspended list? */
;;;1817   		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
000020  4c0b              LDR      r4,|L13.80|
000022  694b              LDR      r3,[r1,#0x14]
000024  42a3              CMP      r3,r4
000026  d101              BNE      |L13.44|
000028  2301              MOVS     r3,#1
00002a  e000              B        |L13.46|
                  |L13.44|
00002c  2300              MOVS     r3,#0
                  |L13.46|
00002e  b173              CBZ      r3,|L13.78|
;;;1818   		{
;;;1819   			/* Has the task already been resumed from within an ISR? */
;;;1820   			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
000030  4c08              LDR      r4,|L13.84|
000032  6a8b              LDR      r3,[r1,#0x28]
000034  42a3              CMP      r3,r4
000036  d101              BNE      |L13.60|
000038  2301              MOVS     r3,#1
00003a  e000              B        |L13.62|
                  |L13.60|
00003c  2300              MOVS     r3,#0
                  |L13.62|
00003e  b933              CBNZ     r3,|L13.78|
;;;1821   			{
;;;1822   				/* Is it in the suspended list because it is in the	Suspended
;;;1823   				state, or because is is blocked with no timeout? */
;;;1824   				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
000040  6a8b              LDR      r3,[r1,#0x28]
000042  b90b              CBNZ     r3,|L13.72|
000044  2301              MOVS     r3,#1
000046  e000              B        |L13.74|
                  |L13.72|
000048  2300              MOVS     r3,#0
                  |L13.74|
00004a  b103              CBZ      r3,|L13.78|
;;;1825   				{
;;;1826   					xReturn = pdTRUE;
00004c  2001              MOVS     r0,#1
                  |L13.78|
;;;1827   				}
;;;1828   				else
;;;1829   				{
;;;1830   					mtCOVERAGE_TEST_MARKER();
;;;1831   				}
;;;1832   			}
;;;1833   			else
;;;1834   			{
;;;1835   				mtCOVERAGE_TEST_MARKER();
;;;1836   			}
;;;1837   		}
;;;1838   		else
;;;1839   		{
;;;1840   			mtCOVERAGE_TEST_MARKER();
;;;1841   		}
;;;1842   
;;;1843   		return xReturn;
;;;1844   	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
00004e  bd10              POP      {r4,pc}
;;;1845   
                          ENDP

                  |L13.80|
                          DCD      xSuspendedTaskList
                  |L13.84|
                          DCD      xPendingReadyList

                          AREA ||i.pvTaskIncrementMutexHeldCount||, CODE, READONLY, ALIGN=2

                  pvTaskIncrementMutexHeldCount PROC
;;;4617   
;;;4618   	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
000000  4806              LDR      r0,|L14.28|
;;;4619   	{
;;;4620   		/* If xSemaphoreCreateMutex() is called before any tasks have been created
;;;4621   		then pxCurrentTCB will be NULL. */
;;;4622   		if( pxCurrentTCB != NULL )
000002  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000004  b130              CBZ      r0,|L14.20|
;;;4623   		{
;;;4624   			( pxCurrentTCB->uxMutexesHeld )++;
000006  4905              LDR      r1,|L14.28|
000008  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00000a  f1010050          ADD      r0,r1,#0x50
00000e  6d09              LDR      r1,[r1,#0x50]
000010  1c49              ADDS     r1,r1,#1
000012  6001              STR      r1,[r0,#0]
                  |L14.20|
;;;4625   		}
;;;4626   
;;;4627   		return pxCurrentTCB;
000014  4801              LDR      r0,|L14.28|
000016  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
;;;4628   	}
000018  4770              BX       lr
;;;4629   
                          ENDP

00001a  0000              DCW      0x0000
                  |L14.28|
                          DCD      pxCurrentTCB

                          AREA ||i.ulTaskNotifyTake||, CODE, READONLY, ALIGN=2

                  ulTaskNotifyTake PROC
;;;4634   
;;;4635   	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;4636   	{
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;4637   	uint32_t ulReturn;
;;;4638   
;;;4639   		taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;4640   		{
;;;4641   			/* Only block if the notification count is not already non-zero. */
;;;4642   			if( pxCurrentTCB->ulNotifiedValue == 0UL )
00000a  4818              LDR      r0,|L15.108|
00000c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000e  6d40              LDR      r0,[r0,#0x54]
000010  b988              CBNZ     r0,|L15.54|
;;;4643   			{
;;;4644   				/* Mark this task as waiting for a notification. */
;;;4645   				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
000012  2001              MOVS     r0,#1
000014  4915              LDR      r1,|L15.108|
000016  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000018  f8810058          STRB     r0,[r1,#0x58]
;;;4646   
;;;4647   				if( xTicksToWait > ( TickType_t ) 0 )
00001c  b15d              CBZ      r5,|L15.54|
;;;4648   				{
;;;4649   					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
00001e  2101              MOVS     r1,#1
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;4650   					traceTASK_NOTIFY_TAKE_BLOCK();
;;;4651   
;;;4652   					/* All ports are written to allow a yield in a critical
;;;4653   					section (some will yield immediately, others wait until the
;;;4654   					critical section exits) - but it is not something that
;;;4655   					application code should ever do. */
;;;4656   					portYIELD_WITHIN_API();
000026  f04f5080          MOV      r0,#0x10000000
00002a  4911              LDR      r1,|L15.112|
00002c  6008              STR      r0,[r1,#0]
00002e  f3bf8f4f          DSB      
000032  f3bf8f6f          ISB      
                  |L15.54|
;;;4657   				}
;;;4658   				else
;;;4659   				{
;;;4660   					mtCOVERAGE_TEST_MARKER();
;;;4661   				}
;;;4662   			}
;;;4663   			else
;;;4664   			{
;;;4665   				mtCOVERAGE_TEST_MARKER();
;;;4666   			}
;;;4667   		}
;;;4668   		taskEXIT_CRITICAL();
000036  f7fffffe          BL       vPortExitCritical
;;;4669   
;;;4670   		taskENTER_CRITICAL();
00003a  f7fffffe          BL       vPortEnterCritical
;;;4671   		{
;;;4672   			traceTASK_NOTIFY_TAKE();
;;;4673   			ulReturn = pxCurrentTCB->ulNotifiedValue;
00003e  480b              LDR      r0,|L15.108|
000040  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000042  6d44              LDR      r4,[r0,#0x54]
;;;4674   
;;;4675   			if( ulReturn != 0UL )
000044  b14c              CBZ      r4,|L15.90|
;;;4676   			{
;;;4677   				if( xClearCountOnExit != pdFALSE )
000046  b126              CBZ      r6,|L15.82|
;;;4678   				{
;;;4679   					pxCurrentTCB->ulNotifiedValue = 0UL;
000048  2000              MOVS     r0,#0
00004a  4908              LDR      r1,|L15.108|
00004c  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00004e  6548              STR      r0,[r1,#0x54]
000050  e003              B        |L15.90|
                  |L15.82|
;;;4680   				}
;;;4681   				else
;;;4682   				{
;;;4683   					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
000052  1e60              SUBS     r0,r4,#1
000054  4905              LDR      r1,|L15.108|
000056  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000058  6548              STR      r0,[r1,#0x54]
                  |L15.90|
;;;4684   				}
;;;4685   			}
;;;4686   			else
;;;4687   			{
;;;4688   				mtCOVERAGE_TEST_MARKER();
;;;4689   			}
;;;4690   
;;;4691   			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
00005a  2000              MOVS     r0,#0
00005c  4903              LDR      r1,|L15.108|
00005e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000060  f8810058          STRB     r0,[r1,#0x58]
;;;4692   		}
;;;4693   		taskEXIT_CRITICAL();
000064  f7fffffe          BL       vPortExitCritical
;;;4694   
;;;4695   		return ulReturn;
000068  4620              MOV      r0,r4
;;;4696   	}
00006a  bd70              POP      {r4-r6,pc}
;;;4697   
                          ENDP

                  |L15.108|
                          DCD      pxCurrentTCB
                  |L15.112|
                          DCD      0xe000ed04

                          AREA ||i.ulTaskNotifyValueClear||, CODE, READONLY, ALIGN=2

                  ulTaskNotifyValueClear PROC
;;;5142   
;;;5143   	uint32_t ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;5144   	{
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;5145   	TCB_t *pxTCB;
;;;5146   	uint32_t ulReturn;
;;;5147   
;;;5148   		/* If null is passed in here then it is the calling task that is having
;;;5149   		its notification state cleared. */
;;;5150   		pxTCB = prvGetTCBFromHandle( xTask );
000008  b914              CBNZ     r4,|L16.16|
00000a  4809              LDR      r0,|L16.48|
00000c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000e  e000              B        |L16.18|
                  |L16.16|
000010  4620              MOV      r0,r4
                  |L16.18|
000012  4606              MOV      r6,r0
;;;5151   
;;;5152   		taskENTER_CRITICAL();
000014  f7fffffe          BL       vPortEnterCritical
;;;5153   		{
;;;5154   			/* Return the notification as it was before the bits were cleared,
;;;5155   			then clear the bit mask. */
;;;5156   			ulReturn = pxCurrentTCB->ulNotifiedValue;
000018  4805              LDR      r0,|L16.48|
00001a  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00001c  6d47              LDR      r7,[r0,#0x54]
;;;5157   			pxTCB->ulNotifiedValue &= ~ulBitsToClear;
00001e  6d70              LDR      r0,[r6,#0x54]
000020  43a8              BICS     r0,r0,r5
000022  6570              STR      r0,[r6,#0x54]
;;;5158   		}
;;;5159   		taskEXIT_CRITICAL();
000024  f7fffffe          BL       vPortExitCritical
;;;5160   
;;;5161   		return ulReturn;
000028  4638              MOV      r0,r7
;;;5162   	}
00002a  e8bd81f0          POP      {r4-r8,pc}
;;;5163   
                          ENDP

00002e  0000              DCW      0x0000
                  |L16.48|
                          DCD      pxCurrentTCB

                          AREA ||i.uxTaskGetNumberOfTasks||, CODE, READONLY, ALIGN=2

                  uxTaskGetNumberOfTasks PROC
;;;2349   
;;;2350   UBaseType_t uxTaskGetNumberOfTasks( void )
000000  4801              LDR      r0,|L17.8|
;;;2351   {
;;;2352   	/* A critical section is not required because the variables are of type
;;;2353   	BaseType_t. */
;;;2354   	return uxCurrentNumberOfTasks;
000002  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
;;;2355   }
000004  4770              BX       lr
;;;2356   /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L17.8|
                          DCD      uxCurrentNumberOfTasks

                          AREA ||i.uxTaskGetStackHighWaterMark||, CODE, READONLY, ALIGN=2

                  uxTaskGetStackHighWaterMark PROC
;;;3858   
;;;3859   	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3860   	{
000004  4604              MOV      r4,r0
;;;3861   	TCB_t *pxTCB;
;;;3862   	uint8_t *pucEndOfStack;
;;;3863   	UBaseType_t uxReturn;
;;;3864   
;;;3865   		pxTCB = prvGetTCBFromHandle( xTask );
000006  b914              CBNZ     r4,|L18.14|
000008  4806              LDR      r0,|L18.36|
00000a  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000c  e000              B        |L18.16|
                  |L18.14|
00000e  4620              MOV      r0,r4
                  |L18.16|
000010  4607              MOV      r7,r0
;;;3866   
;;;3867   		#if portSTACK_GROWTH < 0
;;;3868   		{
;;;3869   			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
000012  6b3d              LDR      r5,[r7,#0x30]
;;;3870   		}
;;;3871   		#else
;;;3872   		{
;;;3873   			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
;;;3874   		}
;;;3875   		#endif
;;;3876   
;;;3877   		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       prvTaskCheckFreeStackSpace
00001a  4606              MOV      r6,r0
;;;3878   
;;;3879   		return uxReturn;
00001c  4630              MOV      r0,r6
;;;3880   	}
00001e  e8bd81f0          POP      {r4-r8,pc}
;;;3881   
                          ENDP

000022  0000              DCW      0x0000
                  |L18.36|
                          DCD      pxCurrentTCB

                          AREA ||i.uxTaskGetSystemState||, CODE, READONLY, ALIGN=2

                  uxTaskGetSystemState PROC
;;;2504   
;;;2505   	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2506   	{
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
;;;2507   	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
00000a  2400              MOVS     r4,#0
00000c  2738              MOVS     r7,#0x38
;;;2508   
;;;2509   		vTaskSuspendAll();
00000e  f7fffffe          BL       vTaskSuspendAll
;;;2510   		{
;;;2511   			/* Is there a space in the array for each task in the system? */
;;;2512   			if( uxArraySize >= uxCurrentNumberOfTasks )
000012  4821              LDR      r0,|L19.152|
000014  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000016  4580              CMP      r8,r0
000018  d339              BCC      |L19.142|
;;;2513   			{
;;;2514   				/* Fill in an TaskStatus_t structure with information on each
;;;2515   				task in the Ready state. */
;;;2516   				do
00001a  bf00              NOP      
                  |L19.28|
;;;2517   				{
;;;2518   					uxQueue--;
00001c  1e7f              SUBS     r7,r7,#1
;;;2519   					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
00001e  eb070287          ADD      r2,r7,r7,LSL #2
000022  4b1e              LDR      r3,|L19.156|
000024  eb030182          ADD      r1,r3,r2,LSL #2
000028  eb0402c4          ADD      r2,r4,r4,LSL #3
00002c  eb050082          ADD      r0,r5,r2,LSL #2
000030  2201              MOVS     r2,#1
000032  f7fffffe          BL       prvListTasksWithinSingleList
000036  4404              ADD      r4,r4,r0
;;;2520   
;;;2521   				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000038  2f00              CMP      r7,#0
00003a  d1ef              BNE      |L19.28|
;;;2522   
;;;2523   				/* Fill in an TaskStatus_t structure with information on each
;;;2524   				task in the Blocked state. */
;;;2525   				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
00003c  eb0401c4          ADD      r1,r4,r4,LSL #3
000040  eb050081          ADD      r0,r5,r1,LSL #2
000044  2202              MOVS     r2,#2
000046  4916              LDR      r1,|L19.160|
000048  6809              LDR      r1,[r1,#0]  ; pxDelayedTaskList
00004a  f7fffffe          BL       prvListTasksWithinSingleList
00004e  4404              ADD      r4,r4,r0
;;;2526   				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
000050  eb0401c4          ADD      r1,r4,r4,LSL #3
000054  eb050081          ADD      r0,r5,r1,LSL #2
000058  2202              MOVS     r2,#2
00005a  4912              LDR      r1,|L19.164|
00005c  6809              LDR      r1,[r1,#0]  ; pxOverflowDelayedTaskList
00005e  f7fffffe          BL       prvListTasksWithinSingleList
000062  4404              ADD      r4,r4,r0
;;;2527   
;;;2528   				#if( INCLUDE_vTaskDelete == 1 )
;;;2529   				{
;;;2530   					/* Fill in an TaskStatus_t structure with information on
;;;2531   					each task that has been deleted but not yet cleaned up. */
;;;2532   					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
000064  eb0401c4          ADD      r1,r4,r4,LSL #3
000068  eb050081          ADD      r0,r5,r1,LSL #2
00006c  2204              MOVS     r2,#4
00006e  490e              LDR      r1,|L19.168|
000070  f7fffffe          BL       prvListTasksWithinSingleList
000074  4404              ADD      r4,r4,r0
;;;2533   				}
;;;2534   				#endif
;;;2535   
;;;2536   				#if ( INCLUDE_vTaskSuspend == 1 )
;;;2537   				{
;;;2538   					/* Fill in an TaskStatus_t structure with information on
;;;2539   					each task in the Suspended state. */
;;;2540   					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
000076  eb0401c4          ADD      r1,r4,r4,LSL #3
00007a  eb050081          ADD      r0,r5,r1,LSL #2
00007e  2203              MOVS     r2,#3
000080  490a              LDR      r1,|L19.172|
000082  f7fffffe          BL       prvListTasksWithinSingleList
000086  4404              ADD      r4,r4,r0
;;;2541   				}
;;;2542   				#endif
;;;2543   
;;;2544   				#if ( configGENERATE_RUN_TIME_STATS == 1)
;;;2545   				{
;;;2546   					if( pulTotalRunTime != NULL )
;;;2547   					{
;;;2548   						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
;;;2549   							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
;;;2550   						#else
;;;2551   							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
;;;2552   						#endif
;;;2553   					}
;;;2554   				}
;;;2555   				#else
;;;2556   				{
;;;2557   					if( pulTotalRunTime != NULL )
000088  b10e              CBZ      r6,|L19.142|
;;;2558   					{
;;;2559   						*pulTotalRunTime = 0;
00008a  2000              MOVS     r0,#0
00008c  6030              STR      r0,[r6,#0]
                  |L19.142|
;;;2560   					}
;;;2561   				}
;;;2562   				#endif
;;;2563   			}
;;;2564   			else
;;;2565   			{
;;;2566   				mtCOVERAGE_TEST_MARKER();
;;;2567   			}
;;;2568   		}
;;;2569   		( void ) xTaskResumeAll();
00008e  f7fffffe          BL       xTaskResumeAll
;;;2570   
;;;2571   		return uxTask;
000092  4620              MOV      r0,r4
;;;2572   	}
000094  e8bd81f0          POP      {r4-r8,pc}
;;;2573   
                          ENDP

                  |L19.152|
                          DCD      uxCurrentNumberOfTasks
                  |L19.156|
                          DCD      pxReadyTasksLists
                  |L19.160|
                          DCD      pxDelayedTaskList
                  |L19.164|
                          DCD      pxOverflowDelayedTaskList
                  |L19.168|
                          DCD      xTasksWaitingTermination
                  |L19.172|
                          DCD      xSuspendedTaskList

                          AREA ||i.uxTaskGetTaskNumber||, CODE, READONLY, ALIGN=1

                  uxTaskGetTaskNumber PROC
;;;3344   
;;;3345   	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
000000  4601              MOV      r1,r0
;;;3346   	{
;;;3347   	UBaseType_t uxReturn;
;;;3348   	TCB_t const *pxTCB;
;;;3349   
;;;3350   		if( xTask != NULL )
000002  b111              CBZ      r1,|L20.10|
;;;3351   		{
;;;3352   			pxTCB = xTask;
000004  460a              MOV      r2,r1
;;;3353   			uxReturn = pxTCB->uxTaskNumber;
000006  6c90              LDR      r0,[r2,#0x48]
000008  e000              B        |L20.12|
                  |L20.10|
;;;3354   		}
;;;3355   		else
;;;3356   		{
;;;3357   			uxReturn = 0U;
00000a  2000              MOVS     r0,#0
                  |L20.12|
;;;3358   		}
;;;3359   
;;;3360   		return uxReturn;
;;;3361   	}
00000c  4770              BX       lr
;;;3362   
                          ENDP


                          AREA ||i.uxTaskPriorityGet||, CODE, READONLY, ALIGN=2

                  uxTaskPriorityGet PROC
;;;1477   
;;;1478   	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
000000  b570              PUSH     {r4-r6,lr}
;;;1479   	{
000002  4604              MOV      r4,r0
;;;1480   	TCB_t const *pxTCB;
;;;1481   	UBaseType_t uxReturn;
;;;1482   
;;;1483   		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1484   		{
;;;1485   			/* If null is passed in here then it is the priority of the task
;;;1486   			that called uxTaskPriorityGet() that is being queried. */
;;;1487   			pxTCB = prvGetTCBFromHandle( xTask );
000008  b914              CBNZ     r4,|L21.16|
00000a  4805              LDR      r0,|L21.32|
00000c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000e  e000              B        |L21.18|
                  |L21.16|
000010  4620              MOV      r0,r4
                  |L21.18|
000012  4606              MOV      r6,r0
;;;1488   			uxReturn = pxTCB->uxPriority;
000014  6af5              LDR      r5,[r6,#0x2c]
;;;1489   		}
;;;1490   		taskEXIT_CRITICAL();
000016  f7fffffe          BL       vPortExitCritical
;;;1491   
;;;1492   		return uxReturn;
00001a  4628              MOV      r0,r5
;;;1493   	}
00001c  bd70              POP      {r4-r6,pc}
;;;1494   
                          ENDP

00001e  0000              DCW      0x0000
                  |L21.32|
                          DCD      pxCurrentTCB

                          AREA ||i.uxTaskPriorityGetFromISR||, CODE, READONLY, ALIGN=2

                  uxTaskPriorityGetFromISR PROC
;;;1499   
;;;1500   	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1501   	{
000004  4605              MOV      r5,r0
;;;1502   	TCB_t const *pxTCB;
;;;1503   	UBaseType_t uxReturn, uxSavedInterruptState;
;;;1504   
;;;1505   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1506   		maximum	system call (or maximum API call) interrupt priority.
;;;1507   		Interrupts that are	above the maximum system call priority are keep
;;;1508   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1509   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1510   		is defined in FreeRTOSConfig.h then
;;;1511   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1512   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1513   		been assigned a priority above the configured maximum system call
;;;1514   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1515   		from interrupts	that have been assigned a priority at or (logically)
;;;1516   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1517   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1518   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1519   		provided on the following link:
;;;1520   		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1521   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000006  f7fffffe          BL       vPortValidateInterruptPriority
;;;1522   
;;;1523   		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
00000a  bf00              NOP      
00000c  2150              MOVS     r1,#0x50
00000e  f3ef8011          MRS      r0,BASEPRI
000012  f3818811          MSR      BASEPRI,r1
000016  f3bf8f4f          DSB      
00001a  f3bf8f6f          ISB      
00001e  bf00              NOP      
000020  4604              MOV      r4,r0
;;;1524   		{
;;;1525   			/* If null is passed in here then it is the priority of the calling
;;;1526   			task that is being queried. */
;;;1527   			pxTCB = prvGetTCBFromHandle( xTask );
000022  b915              CBNZ     r5,|L22.42|
000024  4806              LDR      r0,|L22.64|
000026  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000028  e000              B        |L22.44|
                  |L22.42|
00002a  4628              MOV      r0,r5
                  |L22.44|
00002c  4607              MOV      r7,r0
;;;1528   			uxReturn = pxTCB->uxPriority;
00002e  6afe              LDR      r6,[r7,#0x2c]
;;;1529   		}
;;;1530   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
000030  bf00              NOP      
000032  f3848811          MSR      BASEPRI,r4
000036  bf00              NOP      
;;;1531   
;;;1532   		return uxReturn;
000038  4630              MOV      r0,r6
;;;1533   	}
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;1534   
                          ENDP

00003e  0000              DCW      0x0000
                  |L22.64|
                          DCD      pxCurrentTCB

                          AREA ||i.uxTaskResetEventItemValue||, CODE, READONLY, ALIGN=2

                  uxTaskResetEventItemValue PROC
;;;4601   
;;;4602   TickType_t uxTaskResetEventItemValue( void )
000000  4905              LDR      r1,|L23.24|
;;;4603   {
;;;4604   TickType_t uxReturn;
;;;4605   
;;;4606   	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
000002  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000004  6988              LDR      r0,[r1,#0x18]
;;;4607   
;;;4608   	/* Reset the event list item to its normal value - so it can be used with
;;;4609   	queues and semaphores. */
;;;4610   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000006  4904              LDR      r1,|L23.24|
000008  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00000a  6ac9              LDR      r1,[r1,#0x2c]
00000c  f1c10138          RSB      r1,r1,#0x38
000010  4a01              LDR      r2,|L23.24|
000012  6812              LDR      r2,[r2,#0]  ; pxCurrentTCB
000014  6191              STR      r1,[r2,#0x18]
;;;4611   
;;;4612   	return uxReturn;
;;;4613   }
000016  4770              BX       lr
;;;4614   /*-----------------------------------------------------------*/
                          ENDP

                  |L23.24|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskDelay||, CODE, READONLY, ALIGN=2

                  vTaskDelay PROC
;;;1340   
;;;1341   	void vTaskDelay( const TickType_t xTicksToDelay )
000000  b570              PUSH     {r4-r6,lr}
;;;1342   	{
000002  4604              MOV      r4,r0
;;;1343   	BaseType_t xAlreadyYielded = pdFALSE;
000004  2500              MOVS     r5,#0
;;;1344   
;;;1345   		/* A delay time of zero just forces a reschedule. */
;;;1346   		if( xTicksToDelay > ( TickType_t ) 0U )
000006  b1d4              CBZ      r4,|L24.62|
;;;1347   		{
;;;1348   			configASSERT( uxSchedulerSuspended == 0 );
000008  4812              LDR      r0,|L24.84|
00000a  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00000c  b908              CBNZ     r0,|L24.18|
00000e  2001              MOVS     r0,#1
000010  e000              B        |L24.20|
                  |L24.18|
000012  2000              MOVS     r0,#0
                  |L24.20|
000014  b950              CBNZ     r0,|L24.44|
000016  bf00              NOP      
000018  2050              MOVS     r0,#0x50
00001a  f3808811          MSR      BASEPRI,r0
00001e  f3bf8f4f          DSB      
000022  f3bf8f6f          ISB      
000026  bf00              NOP      
000028  bf00              NOP      
                  |L24.42|
00002a  e7fe              B        |L24.42|
                  |L24.44|
;;;1349   			vTaskSuspendAll();
00002c  f7fffffe          BL       vTaskSuspendAll
;;;1350   			{
;;;1351   				traceTASK_DELAY();
;;;1352   
;;;1353   				/* A task that is removed from the event list while the
;;;1354   				scheduler is suspended will not get placed in the ready
;;;1355   				list or removed from the blocked list until the scheduler
;;;1356   				is resumed.
;;;1357   
;;;1358   				This task cannot be in an event list as it is the currently
;;;1359   				executing task. */
;;;1360   				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
000030  2100              MOVS     r1,#0
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;1361   			}
;;;1362   			xAlreadyYielded = xTaskResumeAll();
000038  f7fffffe          BL       xTaskResumeAll
00003c  4605              MOV      r5,r0
                  |L24.62|
;;;1363   		}
;;;1364   		else
;;;1365   		{
;;;1366   			mtCOVERAGE_TEST_MARKER();
;;;1367   		}
;;;1368   
;;;1369   		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;1370   		have put ourselves to sleep. */
;;;1371   		if( xAlreadyYielded == pdFALSE )
00003e  b93d              CBNZ     r5,|L24.80|
;;;1372   		{
;;;1373   			portYIELD_WITHIN_API();
000040  f04f5080          MOV      r0,#0x10000000
000044  4904              LDR      r1,|L24.88|
000046  6008              STR      r0,[r1,#0]
000048  f3bf8f4f          DSB      
00004c  f3bf8f6f          ISB      
                  |L24.80|
;;;1374   		}
;;;1375   		else
;;;1376   		{
;;;1377   			mtCOVERAGE_TEST_MARKER();
;;;1378   		}
;;;1379   	}
000050  bd70              POP      {r4-r6,pc}
;;;1380   
                          ENDP

000052  0000              DCW      0x0000
                  |L24.84|
                          DCD      uxSchedulerSuspended
                  |L24.88|
                          DCD      0xe000ed04

                          AREA ||i.vTaskDelayUntil||, CODE, READONLY, ALIGN=2

                  vTaskDelayUntil PROC
;;;1256   
;;;1257   	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1258   	{
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;1259   	TickType_t xTimeToWake;
;;;1260   	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
000008  f04f0900          MOV      r9,#0
;;;1261   
;;;1262   		configASSERT( pxPreviousWakeTime );
00000c  b954              CBNZ     r4,|L25.36|
00000e  bf00              NOP      
000010  2050              MOVS     r0,#0x50
000012  f3808811          MSR      BASEPRI,r0
000016  f3bf8f4f          DSB      
00001a  f3bf8f6f          ISB      
00001e  bf00              NOP      
000020  bf00              NOP      
                  |L25.34|
000022  e7fe              B        |L25.34|
                  |L25.36|
;;;1263   		configASSERT( ( xTimeIncrement > 0U ) );
000024  b10f              CBZ      r7,|L25.42|
000026  2001              MOVS     r0,#1
000028  e000              B        |L25.44|
                  |L25.42|
00002a  2000              MOVS     r0,#0
                  |L25.44|
00002c  b950              CBNZ     r0,|L25.68|
00002e  bf00              NOP      
000030  2050              MOVS     r0,#0x50
000032  f3808811          MSR      BASEPRI,r0
000036  f3bf8f4f          DSB      
00003a  f3bf8f6f          ISB      
00003e  bf00              NOP      
000040  bf00              NOP      
                  |L25.66|
000042  e7fe              B        |L25.66|
                  |L25.68|
;;;1264   		configASSERT( uxSchedulerSuspended == 0 );
000044  4820              LDR      r0,|L25.200|
000046  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000048  b908              CBNZ     r0,|L25.78|
00004a  2001              MOVS     r0,#1
00004c  e000              B        |L25.80|
                  |L25.78|
00004e  2000              MOVS     r0,#0
                  |L25.80|
000050  b950              CBNZ     r0,|L25.104|
000052  bf00              NOP      
000054  2050              MOVS     r0,#0x50
000056  f3808811          MSR      BASEPRI,r0
00005a  f3bf8f4f          DSB      
00005e  f3bf8f6f          ISB      
000062  bf00              NOP      
000064  bf00              NOP      
                  |L25.102|
000066  e7fe              B        |L25.102|
                  |L25.104|
;;;1265   
;;;1266   		vTaskSuspendAll();
000068  f7fffffe          BL       vTaskSuspendAll
;;;1267   		{
;;;1268   			/* Minor optimisation.  The tick count cannot change in this
;;;1269   			block. */
;;;1270   			const TickType_t xConstTickCount = xTickCount;
00006c  4817              LDR      r0,|L25.204|
00006e  6806              LDR      r6,[r0,#0]  ; xTickCount
;;;1271   
;;;1272   			/* Generate the tick time at which the task wants to wake. */
;;;1273   			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
000070  6820              LDR      r0,[r4,#0]
000072  19c5              ADDS     r5,r0,r7
;;;1274   
;;;1275   			if( xConstTickCount < *pxPreviousWakeTime )
000074  6820              LDR      r0,[r4,#0]
000076  42b0              CMP      r0,r6
000078  d907              BLS      |L25.138|
;;;1276   			{
;;;1277   				/* The tick count has overflowed since this function was
;;;1278   				lasted called.  In this case the only time we should ever
;;;1279   				actually delay is if the wake time has also	overflowed,
;;;1280   				and the wake time is greater than the tick time.  When this
;;;1281   				is the case it is as if neither time had overflowed. */
;;;1282   				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
00007a  6820              LDR      r0,[r4,#0]
00007c  42a8              CMP      r0,r5
00007e  d90b              BLS      |L25.152|
000080  42b5              CMP      r5,r6
000082  d909              BLS      |L25.152|
;;;1283   				{
;;;1284   					xShouldDelay = pdTRUE;
000084  f04f0901          MOV      r9,#1
000088  e006              B        |L25.152|
                  |L25.138|
;;;1285   				}
;;;1286   				else
;;;1287   				{
;;;1288   					mtCOVERAGE_TEST_MARKER();
;;;1289   				}
;;;1290   			}
;;;1291   			else
;;;1292   			{
;;;1293   				/* The tick time has not overflowed.  In this case we will
;;;1294   				delay if either the wake time has overflowed, and/or the
;;;1295   				tick time is less than the wake time. */
;;;1296   				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
00008a  6820              LDR      r0,[r4,#0]
00008c  42a8              CMP      r0,r5
00008e  d801              BHI      |L25.148|
000090  42b5              CMP      r5,r6
000092  d901              BLS      |L25.152|
                  |L25.148|
;;;1297   				{
;;;1298   					xShouldDelay = pdTRUE;
000094  f04f0901          MOV      r9,#1
                  |L25.152|
;;;1299   				}
;;;1300   				else
;;;1301   				{
;;;1302   					mtCOVERAGE_TEST_MARKER();
;;;1303   				}
;;;1304   			}
;;;1305   
;;;1306   			/* Update the wake time ready for the next call. */
;;;1307   			*pxPreviousWakeTime = xTimeToWake;
000098  6025              STR      r5,[r4,#0]
;;;1308   
;;;1309   			if( xShouldDelay != pdFALSE )
00009a  f1b90f00          CMP      r9,#0
00009e  d003              BEQ      |L25.168|
;;;1310   			{
;;;1311   				traceTASK_DELAY_UNTIL( xTimeToWake );
;;;1312   
;;;1313   				/* prvAddCurrentTaskToDelayedList() needs the block time, not
;;;1314   				the time to wake, so subtract the current tick count. */
;;;1315   				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
0000a0  1ba8              SUBS     r0,r5,r6
0000a2  2100              MOVS     r1,#0
0000a4  f7fffffe          BL       prvAddCurrentTaskToDelayedList
                  |L25.168|
;;;1316   			}
;;;1317   			else
;;;1318   			{
;;;1319   				mtCOVERAGE_TEST_MARKER();
;;;1320   			}
;;;1321   		}
;;;1322   		xAlreadyYielded = xTaskResumeAll();
0000a8  f7fffffe          BL       xTaskResumeAll
0000ac  4680              MOV      r8,r0
;;;1323   
;;;1324   		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;1325   		have put ourselves to sleep. */
;;;1326   		if( xAlreadyYielded == pdFALSE )
0000ae  f1b80f00          CMP      r8,#0
0000b2  d107              BNE      |L25.196|
;;;1327   		{
;;;1328   			portYIELD_WITHIN_API();
0000b4  f04f5080          MOV      r0,#0x10000000
0000b8  4905              LDR      r1,|L25.208|
0000ba  6008              STR      r0,[r1,#0]
0000bc  f3bf8f4f          DSB      
0000c0  f3bf8f6f          ISB      
                  |L25.196|
;;;1329   		}
;;;1330   		else
;;;1331   		{
;;;1332   			mtCOVERAGE_TEST_MARKER();
;;;1333   		}
;;;1334   	}
0000c4  e8bd87f0          POP      {r4-r10,pc}
;;;1335   
                          ENDP

                  |L25.200|
                          DCD      uxSchedulerSuspended
                  |L25.204|
                          DCD      xTickCount
                  |L25.208|
                          DCD      0xe000ed04

                          AREA ||i.vTaskDelete||, CODE, READONLY, ALIGN=2

                  vTaskDelete PROC
;;;1161   
;;;1162   	void vTaskDelete( TaskHandle_t xTaskToDelete )
000000  b570              PUSH     {r4-r6,lr}
;;;1163   	{
000002  4605              MOV      r5,r0
;;;1164   	TCB_t *pxTCB;
;;;1165   
;;;1166   		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1167   		{
;;;1168   			/* If null is passed in here then it is the calling task that is
;;;1169   			being deleted. */
;;;1170   			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
000008  b915              CBNZ     r5,|L26.16|
00000a  4827              LDR      r0,|L26.168|
00000c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000e  e000              B        |L26.18|
                  |L26.16|
000010  4628              MOV      r0,r5
                  |L26.18|
000012  4604              MOV      r4,r0
;;;1171   
;;;1172   			/* Remove task from the ready/delayed list. */
;;;1173   			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000014  1d20              ADDS     r0,r4,#4
000016  f7fffffe          BL       uxListRemove
;;;1174   			{
;;;1175   				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
;;;1176   			}
;;;1177   			else
;;;1178   			{
;;;1179   				mtCOVERAGE_TEST_MARKER();
;;;1180   			}
;;;1181   
;;;1182   			/* Is the task waiting on an event also? */
;;;1183   			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
00001a  6aa0              LDR      r0,[r4,#0x28]
00001c  b118              CBZ      r0,|L26.38|
;;;1184   			{
;;;1185   				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
00001e  f1040018          ADD      r0,r4,#0x18
000022  f7fffffe          BL       uxListRemove
                  |L26.38|
;;;1186   			}
;;;1187   			else
;;;1188   			{
;;;1189   				mtCOVERAGE_TEST_MARKER();
;;;1190   			}
;;;1191   
;;;1192   			/* Increment the uxTaskNumber also so kernel aware debuggers can
;;;1193   			detect that the task lists need re-generating.  This is done before
;;;1194   			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
;;;1195   			not return. */
;;;1196   			uxTaskNumber++;
000026  4821              LDR      r0,|L26.172|
000028  6800              LDR      r0,[r0,#0]  ; uxTaskNumber
00002a  1c40              ADDS     r0,r0,#1
00002c  491f              LDR      r1,|L26.172|
00002e  6008              STR      r0,[r1,#0]  ; uxTaskNumber
;;;1197   
;;;1198   			if( pxTCB == pxCurrentTCB )
000030  481d              LDR      r0,|L26.168|
000032  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000034  4284              CMP      r4,r0
000036  d109              BNE      |L26.76|
;;;1199   			{
;;;1200   				/* A task is deleting itself.  This cannot complete within the
;;;1201   				task itself, as a context switch to another task is required.
;;;1202   				Place the task in the termination list.  The idle task will
;;;1203   				check the termination list and free up any memory allocated by
;;;1204   				the scheduler for the TCB and stack of the deleted task. */
;;;1205   				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
000038  1d21              ADDS     r1,r4,#4
00003a  481d              LDR      r0,|L26.176|
00003c  f7fffffe          BL       vListInsertEnd
;;;1206   
;;;1207   				/* Increment the ucTasksDeleted variable so the idle task knows
;;;1208   				there is a task that has been deleted and that it should therefore
;;;1209   				check the xTasksWaitingTermination list. */
;;;1210   				++uxDeletedTasksWaitingCleanUp;
000040  481c              LDR      r0,|L26.180|
000042  6800              LDR      r0,[r0,#0]  ; uxDeletedTasksWaitingCleanUp
000044  1c40              ADDS     r0,r0,#1
000046  491b              LDR      r1,|L26.180|
000048  6008              STR      r0,[r1,#0]  ; uxDeletedTasksWaitingCleanUp
00004a  e009              B        |L26.96|
                  |L26.76|
;;;1211   
;;;1212   				/* Call the delete hook before portPRE_TASK_DELETE_HOOK() as
;;;1213   				portPRE_TASK_DELETE_HOOK() does not return in the Win32 port. */
;;;1214   				traceTASK_DELETE( pxTCB );
;;;1215   
;;;1216   				/* The pre-delete hook is primarily for the Windows simulator,
;;;1217   				in which Windows specific clean up operations are performed,
;;;1218   				after which it is not possible to yield away from this task -
;;;1219   				hence xYieldPending is used to latch that a context switch is
;;;1220   				required. */
;;;1221   				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
;;;1222   			}
;;;1223   			else
;;;1224   			{
;;;1225   				--uxCurrentNumberOfTasks;
00004c  481a              LDR      r0,|L26.184|
00004e  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000050  1e40              SUBS     r0,r0,#1
000052  4919              LDR      r1,|L26.184|
000054  6008              STR      r0,[r1,#0]  ; uxCurrentNumberOfTasks
;;;1226   				traceTASK_DELETE( pxTCB );
;;;1227   				prvDeleteTCB( pxTCB );
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       prvDeleteTCB
;;;1228   
;;;1229   				/* Reset the next expected unblock time in case it referred to
;;;1230   				the task that has just been deleted. */
;;;1231   				prvResetNextTaskUnblockTime();
00005c  f7fffffe          BL       prvResetNextTaskUnblockTime
                  |L26.96|
;;;1232   			}
;;;1233   		}
;;;1234   		taskEXIT_CRITICAL();
000060  f7fffffe          BL       vPortExitCritical
;;;1235   
;;;1236   		/* Force a reschedule if it is the currently running task that has just
;;;1237   		been deleted. */
;;;1238   		if( xSchedulerRunning != pdFALSE )
000064  4815              LDR      r0,|L26.188|
000066  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
000068  b1e8              CBZ      r0,|L26.166|
;;;1239   		{
;;;1240   			if( pxTCB == pxCurrentTCB )
00006a  480f              LDR      r0,|L26.168|
00006c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00006e  4284              CMP      r4,r0
000070  d119              BNE      |L26.166|
;;;1241   			{
;;;1242   				configASSERT( uxSchedulerSuspended == 0 );
000072  4813              LDR      r0,|L26.192|
000074  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000076  b908              CBNZ     r0,|L26.124|
000078  2001              MOVS     r0,#1
00007a  e000              B        |L26.126|
                  |L26.124|
00007c  2000              MOVS     r0,#0
                  |L26.126|
00007e  b950              CBNZ     r0,|L26.150|
000080  bf00              NOP      
000082  2050              MOVS     r0,#0x50
000084  f3808811          MSR      BASEPRI,r0
000088  f3bf8f4f          DSB      
00008c  f3bf8f6f          ISB      
000090  bf00              NOP      
000092  bf00              NOP      
                  |L26.148|
000094  e7fe              B        |L26.148|
                  |L26.150|
;;;1243   				portYIELD_WITHIN_API();
000096  f04f5080          MOV      r0,#0x10000000
00009a  490a              LDR      r1,|L26.196|
00009c  6008              STR      r0,[r1,#0]
00009e  f3bf8f4f          DSB      
0000a2  f3bf8f6f          ISB      
                  |L26.166|
;;;1244   			}
;;;1245   			else
;;;1246   			{
;;;1247   				mtCOVERAGE_TEST_MARKER();
;;;1248   			}
;;;1249   		}
;;;1250   	}
0000a6  bd70              POP      {r4-r6,pc}
;;;1251   
                          ENDP

                  |L26.168|
                          DCD      pxCurrentTCB
                  |L26.172|
                          DCD      uxTaskNumber
                  |L26.176|
                          DCD      xTasksWaitingTermination
                  |L26.180|
                          DCD      uxDeletedTasksWaitingCleanUp
                  |L26.184|
                          DCD      uxCurrentNumberOfTasks
                  |L26.188|
                          DCD      xSchedulerRunning
                  |L26.192|
                          DCD      uxSchedulerSuspended
                  |L26.196|
                          DCD      0xe000ed04

                          AREA ||i.vTaskEndScheduler||, CODE, READONLY, ALIGN=2

                  vTaskEndScheduler PROC
;;;2098   
;;;2099   void vTaskEndScheduler( void )
000000  b510              PUSH     {r4,lr}
;;;2100   {
;;;2101   	/* Stop the scheduler interrupts and call the portable scheduler end
;;;2102   	routine so the original ISRs can be restored if necessary.  The port
;;;2103   	layer must ensure interrupts enable	bit is left in the correct state. */
;;;2104   	portDISABLE_INTERRUPTS();
000002  bf00              NOP      
000004  2050              MOVS     r0,#0x50
000006  f3808811          MSR      BASEPRI,r0
00000a  f3bf8f4f          DSB      
00000e  f3bf8f6f          ISB      
000012  bf00              NOP      
;;;2105   	xSchedulerRunning = pdFALSE;
000014  2000              MOVS     r0,#0
000016  4902              LDR      r1,|L27.32|
000018  6008              STR      r0,[r1,#0]  ; xSchedulerRunning
;;;2106   	vPortEndScheduler();
00001a  f7fffffe          BL       vPortEndScheduler
;;;2107   }
00001e  bd10              POP      {r4,pc}
;;;2108   /*----------------------------------------------------------*/
                          ENDP

                  |L27.32|
                          DCD      xSchedulerRunning

                          AREA ||i.vTaskGetInfo||, CODE, READONLY, ALIGN=2

                  vTaskGetInfo PROC
;;;3669   
;;;3670   	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3671   	{
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4690              MOV      r8,r2
00000a  461e              MOV      r6,r3
;;;3672   	TCB_t *pxTCB;
;;;3673   
;;;3674   		/* xTask is NULL then get the state of the calling task. */
;;;3675   		pxTCB = prvGetTCBFromHandle( xTask );
00000c  b917              CBNZ     r7,|L28.20|
00000e  481c              LDR      r0,|L28.128|
000010  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000012  e000              B        |L28.22|
                  |L28.20|
000014  4638              MOV      r0,r7
                  |L28.22|
000016  4605              MOV      r5,r0
;;;3676   
;;;3677   		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
000018  6025              STR      r5,[r4,#0]
;;;3678   		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
00001a  f1050034          ADD      r0,r5,#0x34
00001e  6060              STR      r0,[r4,#4]
;;;3679   		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
000020  6ae8              LDR      r0,[r5,#0x2c]
000022  6120              STR      r0,[r4,#0x10]
;;;3680   		pxTaskStatus->pxStackBase = pxTCB->pxStack;
000024  6b28              LDR      r0,[r5,#0x30]
000026  61e0              STR      r0,[r4,#0x1c]
;;;3681   		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
000028  6c68              LDR      r0,[r5,#0x44]
00002a  60a0              STR      r0,[r4,#8]
;;;3682   
;;;3683   		#if ( configUSE_MUTEXES == 1 )
;;;3684   		{
;;;3685   			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
00002c  6ce8              LDR      r0,[r5,#0x4c]
00002e  6160              STR      r0,[r4,#0x14]
;;;3686   		}
;;;3687   		#else
;;;3688   		{
;;;3689   			pxTaskStatus->uxBasePriority = 0;
;;;3690   		}
;;;3691   		#endif
;;;3692   
;;;3693   		#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;3694   		{
;;;3695   			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
;;;3696   		}
;;;3697   		#else
;;;3698   		{
;;;3699   			pxTaskStatus->ulRunTimeCounter = 0;
000030  2000              MOVS     r0,#0
000032  61a0              STR      r0,[r4,#0x18]
;;;3700   		}
;;;3701   		#endif
;;;3702   
;;;3703   		/* Obtaining the task state is a little fiddly, so is only done if the
;;;3704   		value of eState passed into this function is eInvalid - otherwise the
;;;3705   		state is just set to whatever is passed in. */
;;;3706   		if( eState != eInvalid )
000034  2e05              CMP      r6,#5
000036  d012              BEQ      |L28.94|
;;;3707   		{
;;;3708   			if( pxTCB == pxCurrentTCB )
000038  4811              LDR      r0,|L28.128|
00003a  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00003c  4285              CMP      r5,r0
00003e  d102              BNE      |L28.70|
;;;3709   			{
;;;3710   				pxTaskStatus->eCurrentState = eRunning;
000040  2000              MOVS     r0,#0
000042  7320              STRB     r0,[r4,#0xc]
000044  e00f              B        |L28.102|
                  |L28.70|
;;;3711   			}
;;;3712   			else
;;;3713   			{
;;;3714   				pxTaskStatus->eCurrentState = eState;
000046  7326              STRB     r6,[r4,#0xc]
;;;3715   
;;;3716   				#if ( INCLUDE_vTaskSuspend == 1 )
;;;3717   				{
;;;3718   					/* If the task is in the suspended list then there is a
;;;3719   					chance it is actually just blocked indefinitely - so really
;;;3720   					it should be reported as being in the Blocked state. */
;;;3721   					if( eState == eSuspended )
000048  2e03              CMP      r6,#3
00004a  d10c              BNE      |L28.102|
;;;3722   					{
;;;3723   						vTaskSuspendAll();
00004c  f7fffffe          BL       vTaskSuspendAll
;;;3724   						{
;;;3725   							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
000050  6aa8              LDR      r0,[r5,#0x28]
000052  b108              CBZ      r0,|L28.88|
;;;3726   							{
;;;3727   								pxTaskStatus->eCurrentState = eBlocked;
000054  2002              MOVS     r0,#2
000056  7320              STRB     r0,[r4,#0xc]
                  |L28.88|
;;;3728   							}
;;;3729   						}
;;;3730   						( void ) xTaskResumeAll();
000058  f7fffffe          BL       xTaskResumeAll
00005c  e003              B        |L28.102|
                  |L28.94|
;;;3731   					}
;;;3732   				}
;;;3733   				#endif /* INCLUDE_vTaskSuspend */
;;;3734   			}
;;;3735   		}
;;;3736   		else
;;;3737   		{
;;;3738   			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
00005e  4628              MOV      r0,r5
000060  f7fffffe          BL       eTaskGetState
000064  7320              STRB     r0,[r4,#0xc]
                  |L28.102|
;;;3739   		}
;;;3740   
;;;3741   		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
;;;3742   		parameter is provided to allow it to be skipped. */
;;;3743   		if( xGetFreeStackSpace != pdFALSE )
000066  f1b80f00          CMP      r8,#0
00006a  d004              BEQ      |L28.118|
;;;3744   		{
;;;3745   			#if ( portSTACK_GROWTH > 0 )
;;;3746   			{
;;;3747   				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
;;;3748   			}
;;;3749   			#else
;;;3750   			{
;;;3751   				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
00006c  6b28              LDR      r0,[r5,#0x30]
00006e  f7fffffe          BL       prvTaskCheckFreeStackSpace
000072  8420              STRH     r0,[r4,#0x20]
000074  e001              B        |L28.122|
                  |L28.118|
;;;3752   			}
;;;3753   			#endif
;;;3754   		}
;;;3755   		else
;;;3756   		{
;;;3757   			pxTaskStatus->usStackHighWaterMark = 0;
000076  2000              MOVS     r0,#0
000078  8420              STRH     r0,[r4,#0x20]
                  |L28.122|
;;;3758   		}
;;;3759   	}
00007a  e8bd81f0          POP      {r4-r8,pc}
;;;3760   
                          ENDP

00007e  0000              DCW      0x0000
                  |L28.128|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskInternalSetTimeOutState||, CODE, READONLY, ALIGN=2

                  vTaskInternalSetTimeOutState PROC
;;;3265   
;;;3266   void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
000000  4903              LDR      r1,|L29.16|
;;;3267   {
;;;3268   	/* For internal use only as it does not use a critical section. */
;;;3269   	pxTimeOut->xOverflowCount = xNumOfOverflows;
000002  6809              LDR      r1,[r1,#0]  ; xNumOfOverflows
000004  6001              STR      r1,[r0,#0]
;;;3270   	pxTimeOut->xTimeOnEntering = xTickCount;
000006  4903              LDR      r1,|L29.20|
000008  6809              LDR      r1,[r1,#0]  ; xTickCount
00000a  6041              STR      r1,[r0,#4]
;;;3271   }
00000c  4770              BX       lr
;;;3272   /*-----------------------------------------------------------*/
                          ENDP

00000e  0000              DCW      0x0000
                  |L29.16|
                          DCD      xNumOfOverflows
                  |L29.20|
                          DCD      xTickCount

                          AREA ||i.vTaskMissedYield||, CODE, READONLY, ALIGN=2

                  vTaskMissedYield PROC
;;;3336   
;;;3337   void vTaskMissedYield( void )
000000  2001              MOVS     r0,#1
;;;3338   {
;;;3339   	xYieldPending = pdTRUE;
000002  4901              LDR      r1,|L30.8|
000004  6008              STR      r0,[r1,#0]  ; xYieldPending
;;;3340   }
000006  4770              BX       lr
;;;3341   /*-----------------------------------------------------------*/
                          ENDP

                  |L30.8|
                          DCD      xYieldPending

                          AREA ||i.vTaskNotifyGiveFromISR||, CODE, READONLY, ALIGN=2

                  vTaskNotifyGiveFromISR PROC
;;;5025   
;;;5026   	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;5027   	{
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;5028   	TCB_t * pxTCB;
;;;5029   	uint8_t ucOriginalNotifyState;
;;;5030   	UBaseType_t uxSavedInterruptStatus;
;;;5031   
;;;5032   		configASSERT( xTaskToNotify );
000008  b955              CBNZ     r5,|L31.32|
00000a  bf00              NOP      
00000c  2050              MOVS     r0,#0x50
00000e  f3808811          MSR      BASEPRI,r0
000012  f3bf8f4f          DSB      
000016  f3bf8f6f          ISB      
00001a  bf00              NOP      
00001c  bf00              NOP      
                  |L31.30|
00001e  e7fe              B        |L31.30|
                  |L31.32|
;;;5033   
;;;5034   		/* RTOS ports that support interrupt nesting have the concept of a
;;;5035   		maximum	system call (or maximum API call) interrupt priority.
;;;5036   		Interrupts that are	above the maximum system call priority are keep
;;;5037   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;5038   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;5039   		is defined in FreeRTOSConfig.h then
;;;5040   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;5041   		failure if a FreeRTOS API function is called from an interrupt that has
;;;5042   		been assigned a priority above the configured maximum system call
;;;5043   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;5044   		from interrupts	that have been assigned a priority at or (logically)
;;;5045   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;5046   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;5047   		simple as possible.  More information (albeit Cortex-M specific) is
;;;5048   		provided on the following link:
;;;5049   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;5050   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000020  f7fffffe          BL       vPortValidateInterruptPriority
;;;5051   
;;;5052   		pxTCB = xTaskToNotify;
000024  462c              MOV      r4,r5
;;;5053   
;;;5054   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000026  bf00              NOP      
000028  2150              MOVS     r1,#0x50
00002a  f3ef8011          MRS      r0,BASEPRI
00002e  f3818811          MSR      BASEPRI,r1
000032  f3bf8f4f          DSB      
000036  f3bf8f6f          ISB      
00003a  bf00              NOP      
00003c  4606              MOV      r6,r0
;;;5055   		{
;;;5056   			ucOriginalNotifyState = pxTCB->ucNotifyState;
00003e  f8948058          LDRB     r8,[r4,#0x58]
;;;5057   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
000042  2002              MOVS     r0,#2
000044  f8840058          STRB     r0,[r4,#0x58]
;;;5058   
;;;5059   			/* 'Giving' is equivalent to incrementing a count in a counting
;;;5060   			semaphore. */
;;;5061   			( pxTCB->ulNotifiedValue )++;
000048  6d60              LDR      r0,[r4,#0x54]
00004a  1c40              ADDS     r0,r0,#1
00004c  6560              STR      r0,[r4,#0x54]
;;;5062   
;;;5063   			traceTASK_NOTIFY_GIVE_FROM_ISR();
;;;5064   
;;;5065   			/* If the task is in the blocked state specifically to wait for a
;;;5066   			notification then unblock it now. */
;;;5067   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
00004e  f1b80f01          CMP      r8,#1
000052  d139              BNE      |L31.200|
;;;5068   			{
;;;5069   				/* The task should not have been on an event list. */
;;;5070   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
000054  6aa0              LDR      r0,[r4,#0x28]
000056  b908              CBNZ     r0,|L31.92|
000058  2001              MOVS     r0,#1
00005a  e000              B        |L31.94|
                  |L31.92|
00005c  2000              MOVS     r0,#0
                  |L31.94|
00005e  b950              CBNZ     r0,|L31.118|
000060  bf00              NOP      
000062  2050              MOVS     r0,#0x50
000064  f3808811          MSR      BASEPRI,r0
000068  f3bf8f4f          DSB      
00006c  f3bf8f6f          ISB      
000070  bf00              NOP      
000072  bf00              NOP      
                  |L31.116|
000074  e7fe              B        |L31.116|
                  |L31.118|
;;;5071   
;;;5072   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000076  4817              LDR      r0,|L31.212|
000078  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00007a  b9a0              CBNZ     r0,|L31.166|
;;;5073   				{
;;;5074   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
00007c  1d20              ADDS     r0,r4,#4
00007e  f7fffffe          BL       uxListRemove
;;;5075   					prvAddTaskToReadyList( pxTCB );
000082  4915              LDR      r1,|L31.216|
000084  6ae0              LDR      r0,[r4,#0x2c]
000086  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000088  4288              CMP      r0,r1
00008a  d902              BLS      |L31.146|
00008c  4912              LDR      r1,|L31.216|
00008e  6ae0              LDR      r0,[r4,#0x2c]
000090  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L31.146|
000092  6ae1              LDR      r1,[r4,#0x2c]
000094  eb010181          ADD      r1,r1,r1,LSL #2
000098  4a10              LDR      r2,|L31.220|
00009a  eb020081          ADD      r0,r2,r1,LSL #2
00009e  1d21              ADDS     r1,r4,#4
0000a0  f7fffffe          BL       vListInsertEnd
0000a4  e004              B        |L31.176|
                  |L31.166|
;;;5076   				}
;;;5077   				else
;;;5078   				{
;;;5079   					/* The delayed and ready lists cannot be accessed, so hold
;;;5080   					this task pending until the scheduler is resumed. */
;;;5081   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
0000a6  f1040118          ADD      r1,r4,#0x18
0000aa  480d              LDR      r0,|L31.224|
0000ac  f7fffffe          BL       vListInsertEnd
                  |L31.176|
;;;5082   				}
;;;5083   
;;;5084   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
0000b0  490c              LDR      r1,|L31.228|
0000b2  6ae0              LDR      r0,[r4,#0x2c]
0000b4  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
0000b6  6ac9              LDR      r1,[r1,#0x2c]
0000b8  4288              CMP      r0,r1
0000ba  d905              BLS      |L31.200|
;;;5085   				{
;;;5086   					/* The notified task has a priority above the currently
;;;5087   					executing task so a yield is required. */
;;;5088   					if( pxHigherPriorityTaskWoken != NULL )
0000bc  b10f              CBZ      r7,|L31.194|
;;;5089   					{
;;;5090   						*pxHigherPriorityTaskWoken = pdTRUE;
0000be  2001              MOVS     r0,#1
0000c0  6038              STR      r0,[r7,#0]
                  |L31.194|
;;;5091   					}
;;;5092   
;;;5093   					/* Mark that a yield is pending in case the user is not
;;;5094   					using the "xHigherPriorityTaskWoken" parameter in an ISR
;;;5095   					safe FreeRTOS function. */
;;;5096   					xYieldPending = pdTRUE;
0000c2  2001              MOVS     r0,#1
0000c4  4908              LDR      r1,|L31.232|
0000c6  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L31.200|
;;;5097   				}
;;;5098   				else
;;;5099   				{
;;;5100   					mtCOVERAGE_TEST_MARKER();
;;;5101   				}
;;;5102   			}
;;;5103   		}
;;;5104   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0000c8  bf00              NOP      
0000ca  f3868811          MSR      BASEPRI,r6
0000ce  bf00              NOP      
;;;5105   	}
0000d0  e8bd81f0          POP      {r4-r8,pc}
;;;5106   
                          ENDP

                  |L31.212|
                          DCD      uxSchedulerSuspended
                  |L31.216|
                          DCD      uxTopReadyPriority
                  |L31.220|
                          DCD      pxReadyTasksLists
                  |L31.224|
                          DCD      xPendingReadyList
                  |L31.228|
                          DCD      pxCurrentTCB
                  |L31.232|
                          DCD      xYieldPending

                          AREA ||i.vTaskPlaceOnEventList||, CODE, READONLY, ALIGN=2

                  vTaskPlaceOnEventList PROC
;;;3063   
;;;3064   void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;3065   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;3066   	configASSERT( pxEventList );
000006  b954              CBNZ     r4,|L32.30|
000008  bf00              NOP      
00000a  2050              MOVS     r0,#0x50
00000c  f3808811          MSR      BASEPRI,r0
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L32.28|
00001c  e7fe              B        |L32.28|
                  |L32.30|
;;;3067   
;;;3068   	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
;;;3069   	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
;;;3070   
;;;3071   	/* Place the event list item of the TCB in the appropriate event list.
;;;3072   	This is placed in the list in priority order so the highest priority task
;;;3073   	is the first to be woken by the event.  The queue that contains the event
;;;3074   	list is locked, preventing simultaneous access from interrupts. */
;;;3075   	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
00001e  4805              LDR      r0,|L32.52|
000020  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000022  3118              ADDS     r1,r1,#0x18
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       vListInsert
;;;3076   
;;;3077   	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
00002a  2101              MOVS     r1,#1
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;3078   }
000032  bd70              POP      {r4-r6,pc}
;;;3079   /*-----------------------------------------------------------*/
                          ENDP

                  |L32.52|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskPlaceOnEventListRestricted||, CODE, READONLY, ALIGN=2

                  vTaskPlaceOnEventListRestricted PROC
;;;3106   
;;;3107   	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
000000  b570              PUSH     {r4-r6,lr}
;;;3108   	{
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;3109   		configASSERT( pxEventList );
000008  b955              CBNZ     r5,|L33.32|
00000a  bf00              NOP      
00000c  2050              MOVS     r0,#0x50
00000e  f3808811          MSR      BASEPRI,r0
000012  f3bf8f4f          DSB      
000016  f3bf8f6f          ISB      
00001a  bf00              NOP      
00001c  bf00              NOP      
                  |L33.30|
00001e  e7fe              B        |L33.30|
                  |L33.32|
;;;3110   
;;;3111   		/* This function should not be called by application code hence the
;;;3112   		'Restricted' in its name.  It is not part of the public API.  It is
;;;3113   		designed for use by kernel code, and has special calling requirements -
;;;3114   		it should be called with the scheduler suspended. */
;;;3115   
;;;3116   
;;;3117   		/* Place the event list item of the TCB in the appropriate event list.
;;;3118   		In this case it is assume that this is the only task that is going to
;;;3119   		be waiting on this event list, so the faster vListInsertEnd() function
;;;3120   		can be used in place of vListInsert. */
;;;3121   		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
000020  4806              LDR      r0,|L33.60|
000022  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000024  3118              ADDS     r1,r1,#0x18
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       vListInsertEnd
;;;3122   
;;;3123   		/* If the task should block indefinitely then set the block time to a
;;;3124   		value that will be recognised as an indefinite delay inside the
;;;3125   		prvAddCurrentTaskToDelayedList() function. */
;;;3126   		if( xWaitIndefinitely != pdFALSE )
00002c  b10c              CBZ      r4,|L33.50|
;;;3127   		{
;;;3128   			xTicksToWait = portMAX_DELAY;
00002e  f04f36ff          MOV      r6,#0xffffffff
                  |L33.50|
;;;3129   		}
;;;3130   
;;;3131   		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
;;;3132   		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
000032  4621              MOV      r1,r4
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;3133   	}
00003a  bd70              POP      {r4-r6,pc}
;;;3134   
                          ENDP

                  |L33.60|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskPlaceOnUnorderedEventList||, CODE, READONLY, ALIGN=2

                  vTaskPlaceOnUnorderedEventList PROC
;;;3080   
;;;3081   void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;3082   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;3083   	configASSERT( pxEventList );
000008  b954              CBNZ     r4,|L34.32|
00000a  bf00              NOP      
00000c  2050              MOVS     r0,#0x50
00000e  f3808811          MSR      BASEPRI,r0
000012  f3bf8f4f          DSB      
000016  f3bf8f6f          ISB      
00001a  bf00              NOP      
00001c  bf00              NOP      
                  |L34.30|
00001e  e7fe              B        |L34.30|
                  |L34.32|
;;;3084   
;;;3085   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
;;;3086   	the event groups implementation. */
;;;3087   	configASSERT( uxSchedulerSuspended != 0 );
000020  4810              LDR      r0,|L34.100|
000022  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000024  b108              CBZ      r0,|L34.42|
000026  2001              MOVS     r0,#1
000028  e000              B        |L34.44|
                  |L34.42|
00002a  2000              MOVS     r0,#0
                  |L34.44|
00002c  b950              CBNZ     r0,|L34.68|
00002e  bf00              NOP      
000030  2050              MOVS     r0,#0x50
000032  f3808811          MSR      BASEPRI,r0
000036  f3bf8f4f          DSB      
00003a  f3bf8f6f          ISB      
00003e  bf00              NOP      
000040  bf00              NOP      
                  |L34.66|
000042  e7fe              B        |L34.66|
                  |L34.68|
;;;3088   
;;;3089   	/* Store the item value in the event list item.  It is safe to access the
;;;3090   	event list item here as interrupts won't access the event list item of a
;;;3091   	task that is not in the Blocked state. */
;;;3092   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
000044  f0454000          ORR      r0,r5,#0x80000000
000048  4907              LDR      r1,|L34.104|
00004a  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00004c  6188              STR      r0,[r1,#0x18]
;;;3093   
;;;3094   	/* Place the event list item of the TCB at the end of the appropriate event
;;;3095   	list.  It is safe to access the event list here because it is part of an
;;;3096   	event group implementation - and interrupts don't access event groups
;;;3097   	directly (instead they access them indirectly by pending function calls to
;;;3098   	the task level). */
;;;3099   	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
00004e  4806              LDR      r0,|L34.104|
000050  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000052  3118              ADDS     r1,r1,#0x18
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       vListInsertEnd
;;;3100   
;;;3101   	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
00005a  2101              MOVS     r1,#1
00005c  4630              MOV      r0,r6
00005e  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;3102   }
000062  bd70              POP      {r4-r6,pc}
;;;3103   /*-----------------------------------------------------------*/
                          ENDP

                  |L34.100|
                          DCD      uxSchedulerSuspended
                  |L34.104|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskPriorityDisinheritAfterTimeout||, CODE, READONLY, ALIGN=2

                  vTaskPriorityDisinheritAfterTimeout PROC
;;;4183   
;;;4184   	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;4185   	{
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;4186   	TCB_t * const pxTCB = pxMutexHolder;
000008  4634              MOV      r4,r6
;;;4187   	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
;;;4188   	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
00000a  f04f0901          MOV      r9,#1
;;;4189   
;;;4190   		if( pxMutexHolder != NULL )
00000e  2e00              CMP      r6,#0
000010  d055              BEQ      |L35.190|
;;;4191   		{
;;;4192   			/* If pxMutexHolder is not NULL then the holder must hold at least
;;;4193   			one mutex. */
;;;4194   			configASSERT( pxTCB->uxMutexesHeld );
000012  6d20              LDR      r0,[r4,#0x50]
000014  b950              CBNZ     r0,|L35.44|
000016  bf00              NOP      
000018  2050              MOVS     r0,#0x50
00001a  f3808811          MSR      BASEPRI,r0
00001e  f3bf8f4f          DSB      
000022  f3bf8f6f          ISB      
000026  bf00              NOP      
000028  bf00              NOP      
                  |L35.42|
00002a  e7fe              B        |L35.42|
                  |L35.44|
;;;4195   
;;;4196   			/* Determine the priority to which the priority of the task that
;;;4197   			holds the mutex should be set.  This will be the greater of the
;;;4198   			holding task's base priority and the priority of the highest
;;;4199   			priority task that is waiting to obtain the mutex. */
;;;4200   			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
00002c  6ce0              LDR      r0,[r4,#0x4c]
00002e  42b8              CMP      r0,r7
000030  d201              BCS      |L35.54|
;;;4201   			{
;;;4202   				uxPriorityToUse = uxHighestPriorityWaitingTask;
000032  463d              MOV      r5,r7
000034  e000              B        |L35.56|
                  |L35.54|
;;;4203   			}
;;;4204   			else
;;;4205   			{
;;;4206   				uxPriorityToUse = pxTCB->uxBasePriority;
000036  6ce5              LDR      r5,[r4,#0x4c]
                  |L35.56|
;;;4207   			}
;;;4208   
;;;4209   			/* Does the priority need to change? */
;;;4210   			if( pxTCB->uxPriority != uxPriorityToUse )
000038  6ae0              LDR      r0,[r4,#0x2c]
00003a  42a8              CMP      r0,r5
00003c  d03f              BEQ      |L35.190|
;;;4211   			{
;;;4212   				/* Only disinherit if no other mutexes are held.  This is a
;;;4213   				simplification in the priority inheritance implementation.  If
;;;4214   				the task that holds the mutex is also holding other mutexes then
;;;4215   				the other mutexes may have caused the priority inheritance. */
;;;4216   				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
00003e  6d20              LDR      r0,[r4,#0x50]
000040  2801              CMP      r0,#1
000042  d13c              BNE      |L35.190|
;;;4217   				{
;;;4218   					/* If a task has timed out because it already holds the
;;;4219   					mutex it was trying to obtain then it cannot of inherited
;;;4220   					its own priority. */
;;;4221   					configASSERT( pxTCB != pxCurrentTCB );
000044  481f              LDR      r0,|L35.196|
000046  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000048  4284              CMP      r4,r0
00004a  d001              BEQ      |L35.80|
00004c  2001              MOVS     r0,#1
00004e  e000              B        |L35.82|
                  |L35.80|
000050  2000              MOVS     r0,#0
                  |L35.82|
000052  b950              CBNZ     r0,|L35.106|
000054  bf00              NOP      
000056  2050              MOVS     r0,#0x50
000058  f3808811          MSR      BASEPRI,r0
00005c  f3bf8f4f          DSB      
000060  f3bf8f6f          ISB      
000064  bf00              NOP      
000066  bf00              NOP      
                  |L35.104|
000068  e7fe              B        |L35.104|
                  |L35.106|
;;;4222   
;;;4223   					/* Disinherit the priority, remembering the previous
;;;4224   					priority to facilitate determining the subject task's
;;;4225   					state. */
;;;4226   					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
;;;4227   					uxPriorityUsedOnEntry = pxTCB->uxPriority;
00006a  f8d4802c          LDR      r8,[r4,#0x2c]
;;;4228   					pxTCB->uxPriority = uxPriorityToUse;
00006e  62e5              STR      r5,[r4,#0x2c]
;;;4229   
;;;4230   					/* Only reset the event list item value if the value is not
;;;4231   					being used for anything else. */
;;;4232   					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
000070  69a0              LDR      r0,[r4,#0x18]
000072  f0004000          AND      r0,r0,#0x80000000
000076  b910              CBNZ     r0,|L35.126|
;;;4233   					{
;;;4234   						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000078  f1c50038          RSB      r0,r5,#0x38
00007c  61a0              STR      r0,[r4,#0x18]
                  |L35.126|
;;;4235   					}
;;;4236   					else
;;;4237   					{
;;;4238   						mtCOVERAGE_TEST_MARKER();
;;;4239   					}
;;;4240   
;;;4241   					/* If the running task is not the task that holds the mutex
;;;4242   					then the task that holds the mutex could be in either the
;;;4243   					Ready, Blocked or Suspended states.  Only remove the task
;;;4244   					from its current state list if it is in the Ready state as
;;;4245   					the task's priority is going to change and there is one
;;;4246   					Ready list per priority. */
;;;4247   					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
00007e  eb080188          ADD      r1,r8,r8,LSL #2
000082  4a11              LDR      r2,|L35.200|
000084  eb020181          ADD      r1,r2,r1,LSL #2
000088  6960              LDR      r0,[r4,#0x14]
00008a  4288              CMP      r0,r1
00008c  d101              BNE      |L35.146|
00008e  2001              MOVS     r0,#1
000090  e000              B        |L35.148|
                  |L35.146|
000092  2000              MOVS     r0,#0
                  |L35.148|
000094  b198              CBZ      r0,|L35.190|
;;;4248   					{
;;;4249   						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000096  1d20              ADDS     r0,r4,#4
000098  f7fffffe          BL       uxListRemove
;;;4250   						{
;;;4251   							/* It is known that the task is in its ready list so
;;;4252   							there is no need to check again and the port level
;;;4253   							reset macro can be called directly. */
;;;4254   							portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
;;;4255   						}
;;;4256   						else
;;;4257   						{
;;;4258   							mtCOVERAGE_TEST_MARKER();
;;;4259   						}
;;;4260   
;;;4261   						prvAddTaskToReadyList( pxTCB );
00009c  490b              LDR      r1,|L35.204|
00009e  6ae0              LDR      r0,[r4,#0x2c]
0000a0  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
0000a2  4288              CMP      r0,r1
0000a4  d902              BLS      |L35.172|
0000a6  4909              LDR      r1,|L35.204|
0000a8  6ae0              LDR      r0,[r4,#0x2c]
0000aa  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L35.172|
0000ac  6ae1              LDR      r1,[r4,#0x2c]
0000ae  eb010181          ADD      r1,r1,r1,LSL #2
0000b2  4a05              LDR      r2,|L35.200|
0000b4  eb020081          ADD      r0,r2,r1,LSL #2
0000b8  1d21              ADDS     r1,r4,#4
0000ba  f7fffffe          BL       vListInsertEnd
                  |L35.190|
;;;4262   					}
;;;4263   					else
;;;4264   					{
;;;4265   						mtCOVERAGE_TEST_MARKER();
;;;4266   					}
;;;4267   				}
;;;4268   				else
;;;4269   				{
;;;4270   					mtCOVERAGE_TEST_MARKER();
;;;4271   				}
;;;4272   			}
;;;4273   			else
;;;4274   			{
;;;4275   				mtCOVERAGE_TEST_MARKER();
;;;4276   			}
;;;4277   		}
;;;4278   		else
;;;4279   		{
;;;4280   			mtCOVERAGE_TEST_MARKER();
;;;4281   		}
;;;4282   	}
0000be  e8bd87f0          POP      {r4-r10,pc}
;;;4283   
                          ENDP

0000c2  0000              DCW      0x0000
                  |L35.196|
                          DCD      pxCurrentTCB
                  |L35.200|
                          DCD      pxReadyTasksLists
                  |L35.204|
                          DCD      uxTopReadyPriority

                          AREA ||i.vTaskPrioritySet||, CODE, READONLY, ALIGN=2

                  vTaskPrioritySet PROC
;;;1539   
;;;1540   	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1541   	{
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
;;;1542   	TCB_t *pxTCB;
;;;1543   	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
;;;1544   	BaseType_t xYieldRequired = pdFALSE;
000008  f04f0900          MOV      r9,#0
;;;1545   
;;;1546   		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
00000c  2d38              CMP      r5,#0x38
00000e  d201              BCS      |L36.20|
000010  2001              MOVS     r0,#1
000012  e000              B        |L36.22|
                  |L36.20|
000014  2000              MOVS     r0,#0
                  |L36.22|
000016  b950              CBNZ     r0,|L36.46|
000018  bf00              NOP      
00001a  2050              MOVS     r0,#0x50
00001c  f3808811          MSR      BASEPRI,r0
000020  f3bf8f4f          DSB      
000024  f3bf8f6f          ISB      
000028  bf00              NOP      
00002a  bf00              NOP      
                  |L36.44|
00002c  e7fe              B        |L36.44|
                  |L36.46|
;;;1547   
;;;1548   		/* Ensure the new priority is valid. */
;;;1549   		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
00002e  2d38              CMP      r5,#0x38
000030  d300              BCC      |L36.52|
;;;1550   		{
;;;1551   			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
000032  2537              MOVS     r5,#0x37
                  |L36.52|
;;;1552   		}
;;;1553   		else
;;;1554   		{
;;;1555   			mtCOVERAGE_TEST_MARKER();
;;;1556   		}
;;;1557   
;;;1558   		taskENTER_CRITICAL();
000034  f7fffffe          BL       vPortEnterCritical
;;;1559   		{
;;;1560   			/* If null is passed in here then it is the priority of the calling
;;;1561   			task that is being changed. */
;;;1562   			pxTCB = prvGetTCBFromHandle( xTask );
000038  b917              CBNZ     r7,|L36.64|
00003a  482d              LDR      r0,|L36.240|
00003c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00003e  e000              B        |L36.66|
                  |L36.64|
000040  4638              MOV      r0,r7
                  |L36.66|
000042  4604              MOV      r4,r0
;;;1563   
;;;1564   			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
;;;1565   
;;;1566   			#if ( configUSE_MUTEXES == 1 )
;;;1567   			{
;;;1568   				uxCurrentBasePriority = pxTCB->uxBasePriority;
000044  6ce6              LDR      r6,[r4,#0x4c]
;;;1569   			}
;;;1570   			#else
;;;1571   			{
;;;1572   				uxCurrentBasePriority = pxTCB->uxPriority;
;;;1573   			}
;;;1574   			#endif
;;;1575   
;;;1576   			if( uxCurrentBasePriority != uxNewPriority )
000046  42ae              CMP      r6,r5
000048  d04e              BEQ      |L36.232|
;;;1577   			{
;;;1578   				/* The priority change may have readied a task of higher
;;;1579   				priority than the calling task. */
;;;1580   				if( uxNewPriority > uxCurrentBasePriority )
00004a  42b5              CMP      r5,r6
00004c  d90b              BLS      |L36.102|
;;;1581   				{
;;;1582   					if( pxTCB != pxCurrentTCB )
00004e  4828              LDR      r0,|L36.240|
000050  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000052  4284              CMP      r4,r0
000054  d00d              BEQ      |L36.114|
;;;1583   					{
;;;1584   						/* The priority of a task other than the currently
;;;1585   						running task is being raised.  Is the priority being
;;;1586   						raised above that of the running task? */
;;;1587   						if( uxNewPriority >= pxCurrentTCB->uxPriority )
000056  4826              LDR      r0,|L36.240|
000058  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00005a  6ac0              LDR      r0,[r0,#0x2c]
00005c  42a8              CMP      r0,r5
00005e  d808              BHI      |L36.114|
;;;1588   						{
;;;1589   							xYieldRequired = pdTRUE;
000060  f04f0901          MOV      r9,#1
000064  e005              B        |L36.114|
                  |L36.102|
;;;1590   						}
;;;1591   						else
;;;1592   						{
;;;1593   							mtCOVERAGE_TEST_MARKER();
;;;1594   						}
;;;1595   					}
;;;1596   					else
;;;1597   					{
;;;1598   						/* The priority of the running task is being raised,
;;;1599   						but the running task must already be the highest
;;;1600   						priority task able to run so no yield is required. */
;;;1601   					}
;;;1602   				}
;;;1603   				else if( pxTCB == pxCurrentTCB )
000066  4822              LDR      r0,|L36.240|
000068  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00006a  4284              CMP      r4,r0
00006c  d101              BNE      |L36.114|
;;;1604   				{
;;;1605   					/* Setting the priority of the running task down means
;;;1606   					there may now be another task of higher priority that
;;;1607   					is ready to execute. */
;;;1608   					xYieldRequired = pdTRUE;
00006e  f04f0901          MOV      r9,#1
                  |L36.114|
;;;1609   				}
;;;1610   				else
;;;1611   				{
;;;1612   					/* Setting the priority of any other task down does not
;;;1613   					require a yield as the running task must be above the
;;;1614   					new priority of the task being modified. */
;;;1615   				}
;;;1616   
;;;1617   				/* Remember the ready list the task might be referenced from
;;;1618   				before its uxPriority member is changed so the
;;;1619   				taskRESET_READY_PRIORITY() macro can function correctly. */
;;;1620   				uxPriorityUsedOnEntry = pxTCB->uxPriority;
000072  f8d4802c          LDR      r8,[r4,#0x2c]
;;;1621   
;;;1622   				#if ( configUSE_MUTEXES == 1 )
;;;1623   				{
;;;1624   					/* Only change the priority being used if the task is not
;;;1625   					currently using an inherited priority. */
;;;1626   					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
000076  6ae1              LDR      r1,[r4,#0x2c]
000078  6ce0              LDR      r0,[r4,#0x4c]
00007a  4288              CMP      r0,r1
00007c  d100              BNE      |L36.128|
;;;1627   					{
;;;1628   						pxTCB->uxPriority = uxNewPriority;
00007e  62e5              STR      r5,[r4,#0x2c]
                  |L36.128|
;;;1629   					}
;;;1630   					else
;;;1631   					{
;;;1632   						mtCOVERAGE_TEST_MARKER();
;;;1633   					}
;;;1634   
;;;1635   					/* The base priority gets set whatever. */
;;;1636   					pxTCB->uxBasePriority = uxNewPriority;
000080  64e5              STR      r5,[r4,#0x4c]
;;;1637   				}
;;;1638   				#else
;;;1639   				{
;;;1640   					pxTCB->uxPriority = uxNewPriority;
;;;1641   				}
;;;1642   				#endif
;;;1643   
;;;1644   				/* Only reset the event list item value if the value is not
;;;1645   				being used for anything else. */
;;;1646   				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
000082  69a0              LDR      r0,[r4,#0x18]
000084  f0004000          AND      r0,r0,#0x80000000
000088  b910              CBNZ     r0,|L36.144|
;;;1647   				{
;;;1648   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00008a  f1c50038          RSB      r0,r5,#0x38
00008e  61a0              STR      r0,[r4,#0x18]
                  |L36.144|
;;;1649   				}
;;;1650   				else
;;;1651   				{
;;;1652   					mtCOVERAGE_TEST_MARKER();
;;;1653   				}
;;;1654   
;;;1655   				/* If the task is in the blocked or suspended list we need do
;;;1656   				nothing more than change its priority variable. However, if
;;;1657   				the task is in a ready list it needs to be removed and placed
;;;1658   				in the list appropriate to its new priority. */
;;;1659   				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
000090  eb080188          ADD      r1,r8,r8,LSL #2
000094  4a17              LDR      r2,|L36.244|
000096  eb020181          ADD      r1,r2,r1,LSL #2
00009a  6960              LDR      r0,[r4,#0x14]
00009c  4288              CMP      r0,r1
00009e  d101              BNE      |L36.164|
0000a0  2001              MOVS     r0,#1
0000a2  e000              B        |L36.166|
                  |L36.164|
0000a4  2000              MOVS     r0,#0
                  |L36.166|
0000a6  b198              CBZ      r0,|L36.208|
;;;1660   				{
;;;1661   					/* The task is currently in its ready list - remove before
;;;1662   					adding it to it's new ready list.  As we are in a critical
;;;1663   					section we can do this even if the scheduler is suspended. */
;;;1664   					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
0000a8  1d20              ADDS     r0,r4,#4
0000aa  f7fffffe          BL       uxListRemove
;;;1665   					{
;;;1666   						/* It is known that the task is in its ready list so
;;;1667   						there is no need to check again and the port level
;;;1668   						reset macro can be called directly. */
;;;1669   						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
;;;1670   					}
;;;1671   					else
;;;1672   					{
;;;1673   						mtCOVERAGE_TEST_MARKER();
;;;1674   					}
;;;1675   					prvAddTaskToReadyList( pxTCB );
0000ae  4912              LDR      r1,|L36.248|
0000b0  6ae0              LDR      r0,[r4,#0x2c]
0000b2  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
0000b4  4288              CMP      r0,r1
0000b6  d902              BLS      |L36.190|
0000b8  490f              LDR      r1,|L36.248|
0000ba  6ae0              LDR      r0,[r4,#0x2c]
0000bc  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L36.190|
0000be  6ae1              LDR      r1,[r4,#0x2c]
0000c0  eb010181          ADD      r1,r1,r1,LSL #2
0000c4  4a0b              LDR      r2,|L36.244|
0000c6  eb020081          ADD      r0,r2,r1,LSL #2
0000ca  1d21              ADDS     r1,r4,#4
0000cc  f7fffffe          BL       vListInsertEnd
                  |L36.208|
;;;1676   				}
;;;1677   				else
;;;1678   				{
;;;1679   					mtCOVERAGE_TEST_MARKER();
;;;1680   				}
;;;1681   
;;;1682   				if( xYieldRequired != pdFALSE )
0000d0  f1b90f00          CMP      r9,#0
0000d4  d007              BEQ      |L36.230|
;;;1683   				{
;;;1684   					taskYIELD_IF_USING_PREEMPTION();
0000d6  f04f5080          MOV      r0,#0x10000000
0000da  4908              LDR      r1,|L36.252|
0000dc  6008              STR      r0,[r1,#0]
0000de  f3bf8f4f          DSB      
0000e2  f3bf8f6f          ISB      
                  |L36.230|
;;;1685   				}
;;;1686   				else
;;;1687   				{
;;;1688   					mtCOVERAGE_TEST_MARKER();
;;;1689   				}
;;;1690   
;;;1691   				/* Remove compiler warning about unused variables when the port
;;;1692   				optimised task selection is not being used. */
;;;1693   				( void ) uxPriorityUsedOnEntry;
0000e6  bf00              NOP      
                  |L36.232|
;;;1694   			}
;;;1695   		}
;;;1696   		taskEXIT_CRITICAL();
0000e8  f7fffffe          BL       vPortExitCritical
;;;1697   	}
0000ec  e8bd87f0          POP      {r4-r10,pc}
;;;1698   
                          ENDP

                  |L36.240|
                          DCD      pxCurrentTCB
                  |L36.244|
                          DCD      pxReadyTasksLists
                  |L36.248|
                          DCD      uxTopReadyPriority
                  |L36.252|
                          DCD      0xe000ed04

                          AREA ||i.vTaskRemoveFromUnorderedEventList||, CODE, READONLY, ALIGN=2

                  vTaskRemoveFromUnorderedEventList PROC
;;;3205   
;;;3206   void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
000000  b570              PUSH     {r4-r6,lr}
;;;3207   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;3208   TCB_t *pxUnblockedTCB;
;;;3209   
;;;3210   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
;;;3211   	the event flags implementation. */
;;;3212   	configASSERT( uxSchedulerSuspended != pdFALSE );
000006  4821              LDR      r0,|L37.140|
000008  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00000a  b108              CBZ      r0,|L37.16|
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L37.18|
                  |L37.16|
000010  2000              MOVS     r0,#0
                  |L37.18|
000012  b950              CBNZ     r0,|L37.42|
000014  bf00              NOP      
000016  2050              MOVS     r0,#0x50
000018  f3808811          MSR      BASEPRI,r0
00001c  f3bf8f4f          DSB      
000020  f3bf8f6f          ISB      
000024  bf00              NOP      
000026  bf00              NOP      
                  |L37.40|
000028  e7fe              B        |L37.40|
                  |L37.42|
;;;3213   
;;;3214   	/* Store the new item value in the event list. */
;;;3215   	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
00002a  f0464000          ORR      r0,r6,#0x80000000
00002e  6028              STR      r0,[r5,#0]
;;;3216   
;;;3217   	/* Remove the event list form the event flag.  Interrupts do not access
;;;3218   	event flags. */
;;;3219   	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000030  68ec              LDR      r4,[r5,#0xc]
;;;3220   	configASSERT( pxUnblockedTCB );
000032  b954              CBNZ     r4,|L37.74|
000034  bf00              NOP      
000036  2050              MOVS     r0,#0x50
000038  f3808811          MSR      BASEPRI,r0
00003c  f3bf8f4f          DSB      
000040  f3bf8f6f          ISB      
000044  bf00              NOP      
000046  bf00              NOP      
                  |L37.72|
000048  e7fe              B        |L37.72|
                  |L37.74|
;;;3221   	( void ) uxListRemove( pxEventListItem );
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       uxListRemove
;;;3222   
;;;3223   	#if( configUSE_TICKLESS_IDLE != 0 )
;;;3224   	{
;;;3225   		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
;;;3226   		might be set to the blocked task's time out time.  If the task is
;;;3227   		unblocked for a reason other than a timeout xNextTaskUnblockTime is
;;;3228   		normally left unchanged, because it is automatically reset to a new
;;;3229   		value when the tick count equals xNextTaskUnblockTime.  However if
;;;3230   		tickless idling is used it might be more important to enter sleep mode
;;;3231   		at the earliest possible time - so reset xNextTaskUnblockTime here to
;;;3232   		ensure it is updated at the earliest possible time. */
;;;3233   		prvResetNextTaskUnblockTime();
;;;3234   	}
;;;3235   	#endif
;;;3236   
;;;3237   	/* Remove the task from the delayed list and add it to the ready list.  The
;;;3238   	scheduler is suspended so interrupts will not be accessing the ready
;;;3239   	lists. */
;;;3240   	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
000050  1d20              ADDS     r0,r4,#4
000052  f7fffffe          BL       uxListRemove
;;;3241   	prvAddTaskToReadyList( pxUnblockedTCB );
000056  490e              LDR      r1,|L37.144|
000058  6ae0              LDR      r0,[r4,#0x2c]
00005a  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00005c  4288              CMP      r0,r1
00005e  d902              BLS      |L37.102|
000060  490b              LDR      r1,|L37.144|
000062  6ae0              LDR      r0,[r4,#0x2c]
000064  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L37.102|
000066  6ae1              LDR      r1,[r4,#0x2c]
000068  eb010181          ADD      r1,r1,r1,LSL #2
00006c  4a09              LDR      r2,|L37.148|
00006e  eb020081          ADD      r0,r2,r1,LSL #2
000072  1d21              ADDS     r1,r4,#4
000074  f7fffffe          BL       vListInsertEnd
;;;3242   
;;;3243   	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
000078  4907              LDR      r1,|L37.152|
00007a  6ae0              LDR      r0,[r4,#0x2c]
00007c  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00007e  6ac9              LDR      r1,[r1,#0x2c]
000080  4288              CMP      r0,r1
000082  d902              BLS      |L37.138|
;;;3244   	{
;;;3245   		/* The unblocked task has a priority above that of the calling task, so
;;;3246   		a context switch is required.  This function is called with the
;;;3247   		scheduler suspended so xYieldPending is set so the context switch
;;;3248   		occurs immediately that the scheduler is resumed (unsuspended). */
;;;3249   		xYieldPending = pdTRUE;
000084  2001              MOVS     r0,#1
000086  4905              LDR      r1,|L37.156|
000088  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L37.138|
;;;3250   	}
;;;3251   }
00008a  bd70              POP      {r4-r6,pc}
;;;3252   /*-----------------------------------------------------------*/
                          ENDP

                  |L37.140|
                          DCD      uxSchedulerSuspended
                  |L37.144|
                          DCD      uxTopReadyPriority
                  |L37.148|
                          DCD      pxReadyTasksLists
                  |L37.152|
                          DCD      pxCurrentTCB
                  |L37.156|
                          DCD      xYieldPending

                          AREA ||i.vTaskResume||, CODE, READONLY, ALIGN=2

                  vTaskResume PROC
;;;1850   
;;;1851   	void vTaskResume( TaskHandle_t xTaskToResume )
000000  b570              PUSH     {r4-r6,lr}
;;;1852   	{
000002  4605              MOV      r5,r0
;;;1853   	TCB_t * const pxTCB = xTaskToResume;
000004  462c              MOV      r4,r5
;;;1854   
;;;1855   		/* It does not make sense to resume the calling task. */
;;;1856   		configASSERT( xTaskToResume );
000006  b955              CBNZ     r5,|L38.30|
000008  bf00              NOP      
00000a  2050              MOVS     r0,#0x50
00000c  f3808811          MSR      BASEPRI,r0
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L38.28|
00001c  e7fe              B        |L38.28|
                  |L38.30|
;;;1857   
;;;1858   		/* The parameter cannot be NULL as it is impossible to resume the
;;;1859   		currently executing task. */
;;;1860   		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
00001e  4818              LDR      r0,|L38.128|
000020  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000022  4284              CMP      r4,r0
000024  d02a              BEQ      |L38.124|
000026  b34c              CBZ      r4,|L38.124|
;;;1861   		{
;;;1862   			taskENTER_CRITICAL();
000028  f7fffffe          BL       vPortEnterCritical
;;;1863   			{
;;;1864   				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       prvTaskIsTaskSuspended
000032  b308              CBZ      r0,|L38.120|
;;;1865   				{
;;;1866   					traceTASK_RESUME( pxTCB );
;;;1867   
;;;1868   					/* The ready list can be accessed even if the scheduler is
;;;1869   					suspended because this is inside a critical section. */
;;;1870   					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
000034  1d20              ADDS     r0,r4,#4
000036  f7fffffe          BL       uxListRemove
;;;1871   					prvAddTaskToReadyList( pxTCB );
00003a  4912              LDR      r1,|L38.132|
00003c  6ae0              LDR      r0,[r4,#0x2c]
00003e  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000040  4288              CMP      r0,r1
000042  d902              BLS      |L38.74|
000044  490f              LDR      r1,|L38.132|
000046  6ae0              LDR      r0,[r4,#0x2c]
000048  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L38.74|
00004a  6ae1              LDR      r1,[r4,#0x2c]
00004c  eb010181          ADD      r1,r1,r1,LSL #2
000050  4a0d              LDR      r2,|L38.136|
000052  eb020081          ADD      r0,r2,r1,LSL #2
000056  1d21              ADDS     r1,r4,#4
000058  f7fffffe          BL       vListInsertEnd
;;;1872   
;;;1873   					/* A higher priority task may have just been resumed. */
;;;1874   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
00005c  4908              LDR      r1,|L38.128|
00005e  6ae0              LDR      r0,[r4,#0x2c]
000060  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000062  6ac9              LDR      r1,[r1,#0x2c]
000064  4288              CMP      r0,r1
000066  d307              BCC      |L38.120|
;;;1875   					{
;;;1876   						/* This yield may not cause the task just resumed to run,
;;;1877   						but will leave the lists in the correct state for the
;;;1878   						next yield. */
;;;1879   						taskYIELD_IF_USING_PREEMPTION();
000068  f04f5080          MOV      r0,#0x10000000
00006c  4907              LDR      r1,|L38.140|
00006e  6008              STR      r0,[r1,#0]
000070  f3bf8f4f          DSB      
000074  f3bf8f6f          ISB      
                  |L38.120|
;;;1880   					}
;;;1881   					else
;;;1882   					{
;;;1883   						mtCOVERAGE_TEST_MARKER();
;;;1884   					}
;;;1885   				}
;;;1886   				else
;;;1887   				{
;;;1888   					mtCOVERAGE_TEST_MARKER();
;;;1889   				}
;;;1890   			}
;;;1891   			taskEXIT_CRITICAL();
000078  f7fffffe          BL       vPortExitCritical
                  |L38.124|
;;;1892   		}
;;;1893   		else
;;;1894   		{
;;;1895   			mtCOVERAGE_TEST_MARKER();
;;;1896   		}
;;;1897   	}
00007c  bd70              POP      {r4-r6,pc}
;;;1898   
                          ENDP

00007e  0000              DCW      0x0000
                  |L38.128|
                          DCD      pxCurrentTCB
                  |L38.132|
                          DCD      uxTopReadyPriority
                  |L38.136|
                          DCD      pxReadyTasksLists
                  |L38.140|
                          DCD      0xe000ed04

                          AREA ||i.vTaskSetTaskNumber||, CODE, READONLY, ALIGN=1

                  vTaskSetTaskNumber PROC
;;;3367   
;;;3368   	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
000000  b108              CBZ      r0,|L39.6|
;;;3369   	{
;;;3370   	TCB_t * pxTCB;
;;;3371   
;;;3372   		if( xTask != NULL )
;;;3373   		{
;;;3374   			pxTCB = xTask;
000002  4602              MOV      r2,r0
;;;3375   			pxTCB->uxTaskNumber = uxHandle;
000004  6491              STR      r1,[r2,#0x48]
                  |L39.6|
;;;3376   		}
;;;3377   	}
000006  4770              BX       lr
;;;3378   
                          ENDP


                          AREA ||i.vTaskSetTimeOutState||, CODE, READONLY, ALIGN=2

                  vTaskSetTimeOutState PROC
;;;3253   
;;;3254   void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
000000  b510              PUSH     {r4,lr}
;;;3255   {
000002  4604              MOV      r4,r0
;;;3256   	configASSERT( pxTimeOut );
000004  b954              CBNZ     r4,|L40.28|
000006  bf00              NOP      
000008  2050              MOVS     r0,#0x50
00000a  f3808811          MSR      BASEPRI,r0
00000e  f3bf8f4f          DSB      
000012  f3bf8f6f          ISB      
000016  bf00              NOP      
000018  bf00              NOP      
                  |L40.26|
00001a  e7fe              B        |L40.26|
                  |L40.28|
;;;3257   	taskENTER_CRITICAL();
00001c  f7fffffe          BL       vPortEnterCritical
;;;3258   	{
;;;3259   		pxTimeOut->xOverflowCount = xNumOfOverflows;
000020  4804              LDR      r0,|L40.52|
000022  6800              LDR      r0,[r0,#0]  ; xNumOfOverflows
000024  6020              STR      r0,[r4,#0]
;;;3260   		pxTimeOut->xTimeOnEntering = xTickCount;
000026  4804              LDR      r0,|L40.56|
000028  6800              LDR      r0,[r0,#0]  ; xTickCount
00002a  6060              STR      r0,[r4,#4]
;;;3261   	}
;;;3262   	taskEXIT_CRITICAL();
00002c  f7fffffe          BL       vPortExitCritical
;;;3263   }
000030  bd10              POP      {r4,pc}
;;;3264   /*-----------------------------------------------------------*/
                          ENDP

000032  0000              DCW      0x0000
                  |L40.52|
                          DCD      xNumOfOverflows
                  |L40.56|
                          DCD      xTickCount

                          AREA ||i.vTaskStartScheduler||, CODE, READONLY, ALIGN=2

                  vTaskStartScheduler PROC
;;;1974   
;;;1975   void vTaskStartScheduler( void )
000000  b510              PUSH     {r4,lr}
;;;1976   {
000002  b086              SUB      sp,sp,#0x18
;;;1977   BaseType_t xReturn;
;;;1978   
;;;1979   	/* Add the idle task at the lowest priority. */
;;;1980   	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;1981   	{
;;;1982   		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
000004  2000              MOVS     r0,#0
000006  9005              STR      r0,[sp,#0x14]
;;;1983   		StackType_t *pxIdleTaskStackBuffer = NULL;
000008  9004              STR      r0,[sp,#0x10]
;;;1984   		uint32_t ulIdleTaskStackSize;
;;;1985   
;;;1986   		/* The Idle task is created using user provided RAM - obtain the
;;;1987   		address of the RAM then create the idle task. */
;;;1988   		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
00000a  aa03              ADD      r2,sp,#0xc
00000c  a904              ADD      r1,sp,#0x10
00000e  a805              ADD      r0,sp,#0x14
000010  f7fffffe          BL       vApplicationGetIdleTaskMemory
;;;1989   		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
000014  2200              MOVS     r2,#0
000016  e9dd1004          LDRD     r1,r0,[sp,#0x10]
00001a  4613              MOV      r3,r2
00001c  e9cd2100          STRD     r2,r1,[sp,#0]
000020  9002              STR      r0,[sp,#8]
000022  a11e              ADR      r1,|L41.156|
000024  481f              LDR      r0,|L41.164|
000026  9a03              LDR      r2,[sp,#0xc]
000028  f7fffffe          BL       xTaskCreateStatic
00002c  491e              LDR      r1,|L41.168|
00002e  6008              STR      r0,[r1,#0]  ; xIdleTaskHandle
;;;1990   												configIDLE_TASK_NAME,
;;;1991   												ulIdleTaskStackSize,
;;;1992   												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
;;;1993   												portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. */
;;;1994   												pxIdleTaskStackBuffer,
;;;1995   												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
;;;1996   
;;;1997   		if( xIdleTaskHandle != NULL )
000030  4608              MOV      r0,r1
000032  6800              LDR      r0,[r0,#0]  ; xIdleTaskHandle
000034  b108              CBZ      r0,|L41.58|
;;;1998   		{
;;;1999   			xReturn = pdPASS;
000036  2401              MOVS     r4,#1
000038  e000              B        |L41.60|
                  |L41.58|
;;;2000   		}
;;;2001   		else
;;;2002   		{
;;;2003   			xReturn = pdFAIL;
00003a  2400              MOVS     r4,#0
                  |L41.60|
;;;2004   		}
;;;2005   	}
;;;2006   	#else
;;;2007   	{
;;;2008   		/* The Idle task is being created using dynamically allocated RAM. */
;;;2009   		xReturn = xTaskCreate(	prvIdleTask,
;;;2010   								configIDLE_TASK_NAME,
;;;2011   								configMINIMAL_STACK_SIZE,
;;;2012   								( void * ) NULL,
;;;2013   								portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. */
;;;2014   								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
;;;2015   	}
;;;2016   	#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;2017   
;;;2018   	#if ( configUSE_TIMERS == 1 )
;;;2019   	{
;;;2020   		if( xReturn == pdPASS )
00003c  2c01              CMP      r4,#1
00003e  d102              BNE      |L41.70|
;;;2021   		{
;;;2022   			xReturn = xTimerCreateTimerTask();
000040  f7fffffe          BL       xTimerCreateTimerTask
000044  4604              MOV      r4,r0
                  |L41.70|
;;;2023   		}
;;;2024   		else
;;;2025   		{
;;;2026   			mtCOVERAGE_TEST_MARKER();
;;;2027   		}
;;;2028   	}
;;;2029   	#endif /* configUSE_TIMERS */
;;;2030   
;;;2031   	if( xReturn == pdPASS )
000046  2c01              CMP      r4,#1
000048  d115              BNE      |L41.118|
;;;2032   	{
;;;2033   		/* freertos_tasks_c_additions_init() should only be called if the user
;;;2034   		definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is
;;;2035   		the only macro called by the function. */
;;;2036   		#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
;;;2037   		{
;;;2038   			freertos_tasks_c_additions_init();
;;;2039   		}
;;;2040   		#endif
;;;2041   
;;;2042   		/* Interrupts are turned off here, to ensure a tick does not occur
;;;2043   		before or during the call to xPortStartScheduler().  The stacks of
;;;2044   		the created tasks contain a status word with interrupts switched on
;;;2045   		so interrupts will automatically get re-enabled when the first task
;;;2046   		starts to run. */
;;;2047   		portDISABLE_INTERRUPTS();
00004a  bf00              NOP      
00004c  2050              MOVS     r0,#0x50
00004e  f3808811          MSR      BASEPRI,r0
000052  f3bf8f4f          DSB      
000056  f3bf8f6f          ISB      
00005a  bf00              NOP      
;;;2048   
;;;2049   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;2050   		{
;;;2051   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;2052   			structure specific to the task that will run first.
;;;2053   			See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
;;;2054   			for additional information. */
;;;2055   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;2056   		}
;;;2057   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;2058   
;;;2059   		xNextTaskUnblockTime = portMAX_DELAY;
00005c  f04f30ff          MOV      r0,#0xffffffff
000060  4912              LDR      r1,|L41.172|
000062  6008              STR      r0,[r1,#0]  ; xNextTaskUnblockTime
;;;2060   		xSchedulerRunning = pdTRUE;
000064  2001              MOVS     r0,#1
000066  4912              LDR      r1,|L41.176|
000068  6008              STR      r0,[r1,#0]  ; xSchedulerRunning
;;;2061   		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
00006a  2000              MOVS     r0,#0
00006c  4911              LDR      r1,|L41.180|
00006e  6008              STR      r0,[r1,#0]  ; xTickCount
;;;2062   
;;;2063   		/* If configGENERATE_RUN_TIME_STATS is defined then the following
;;;2064   		macro must be defined to configure the timer/counter used to generate
;;;2065   		the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
;;;2066   		is set to 0 and the following line fails to build then ensure you do not
;;;2067   		have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
;;;2068   		FreeRTOSConfig.h file. */
;;;2069   		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
;;;2070   
;;;2071   		traceTASK_SWITCHED_IN();
;;;2072   
;;;2073   		/* Setting up the timer tick is hardware specific and thus in the
;;;2074   		portable interface. */
;;;2075   		if( xPortStartScheduler() != pdFALSE )
000070  f7fffffe          BL       xPortStartScheduler
000074  e010              B        |L41.152|
                  |L41.118|
;;;2076   		{
;;;2077   			/* Should not reach here as if the scheduler is running the
;;;2078   			function will not return. */
;;;2079   		}
;;;2080   		else
;;;2081   		{
;;;2082   			/* Should only reach here if a task calls xTaskEndScheduler(). */
;;;2083   		}
;;;2084   	}
;;;2085   	else
;;;2086   	{
;;;2087   		/* This line will only be reached if the kernel could not be started,
;;;2088   		because there was not enough FreeRTOS heap to create the idle task
;;;2089   		or the timer task. */
;;;2090   		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
000076  1c60              ADDS     r0,r4,#1
000078  b108              CBZ      r0,|L41.126|
00007a  2001              MOVS     r0,#1
00007c  e000              B        |L41.128|
                  |L41.126|
00007e  2000              MOVS     r0,#0
                  |L41.128|
000080  b950              CBNZ     r0,|L41.152|
000082  bf00              NOP      
000084  2050              MOVS     r0,#0x50
000086  f3808811          MSR      BASEPRI,r0
00008a  f3bf8f4f          DSB      
00008e  f3bf8f6f          ISB      
000092  bf00              NOP      
000094  bf00              NOP      
                  |L41.150|
000096  e7fe              B        |L41.150|
                  |L41.152|
;;;2091   	}
;;;2092   
;;;2093   	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
;;;2094   	meaning xIdleTaskHandle is not used anywhere else. */
;;;2095   	( void ) xIdleTaskHandle;
;;;2096   }
000098  b006              ADD      sp,sp,#0x18
00009a  bd10              POP      {r4,pc}
;;;2097   /*-----------------------------------------------------------*/
                          ENDP

                  |L41.156|
00009c  49444c45          DCB      "IDLE",0
0000a0  00      
0000a1  00                DCB      0
0000a2  00                DCB      0
0000a3  00                DCB      0
                  |L41.164|
                          DCD      prvIdleTask
                  |L41.168|
                          DCD      xIdleTaskHandle
                  |L41.172|
                          DCD      xNextTaskUnblockTime
                  |L41.176|
                          DCD      xSchedulerRunning
                  |L41.180|
                          DCD      xTickCount

                          AREA ||i.vTaskSuspend||, CODE, READONLY, ALIGN=2

                  vTaskSuspend PROC
;;;1703   
;;;1704   	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
000000  b570              PUSH     {r4-r6,lr}
;;;1705   	{
000002  4605              MOV      r5,r0
;;;1706   	TCB_t *pxTCB;
;;;1707   
;;;1708   		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1709   		{
;;;1710   			/* If null is passed in here then it is the running task that is
;;;1711   			being suspended. */
;;;1712   			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
000008  b915              CBNZ     r5,|L42.16|
00000a  4829              LDR      r0,|L42.176|
00000c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000e  e000              B        |L42.18|
                  |L42.16|
000010  4628              MOV      r0,r5
                  |L42.18|
000012  4604              MOV      r4,r0
;;;1713   
;;;1714   			traceTASK_SUSPEND( pxTCB );
;;;1715   
;;;1716   			/* Remove task from the ready/delayed list and place in the
;;;1717   			suspended list. */
;;;1718   			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000014  1d20              ADDS     r0,r4,#4
000016  f7fffffe          BL       uxListRemove
;;;1719   			{
;;;1720   				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
;;;1721   			}
;;;1722   			else
;;;1723   			{
;;;1724   				mtCOVERAGE_TEST_MARKER();
;;;1725   			}
;;;1726   
;;;1727   			/* Is the task waiting on an event also? */
;;;1728   			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
00001a  6aa0              LDR      r0,[r4,#0x28]
00001c  b118              CBZ      r0,|L42.38|
;;;1729   			{
;;;1730   				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
00001e  f1040018          ADD      r0,r4,#0x18
000022  f7fffffe          BL       uxListRemove
                  |L42.38|
;;;1731   			}
;;;1732   			else
;;;1733   			{
;;;1734   				mtCOVERAGE_TEST_MARKER();
;;;1735   			}
;;;1736   
;;;1737   			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
000026  1d21              ADDS     r1,r4,#4
000028  4822              LDR      r0,|L42.180|
00002a  f7fffffe          BL       vListInsertEnd
;;;1738   
;;;1739   			#if( configUSE_TASK_NOTIFICATIONS == 1 )
;;;1740   			{
;;;1741   				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
00002e  f8940058          LDRB     r0,[r4,#0x58]
000032  2801              CMP      r0,#1
000034  d102              BNE      |L42.60|
;;;1742   				{
;;;1743   					/* The task was blocked to wait for a notification, but is
;;;1744   					now suspended, so no notification was received. */
;;;1745   					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
000036  2000              MOVS     r0,#0
000038  f8840058          STRB     r0,[r4,#0x58]
                  |L42.60|
;;;1746   				}
;;;1747   			}
;;;1748   			#endif
;;;1749   		}
;;;1750   		taskEXIT_CRITICAL();
00003c  f7fffffe          BL       vPortExitCritical
;;;1751   
;;;1752   		if( xSchedulerRunning != pdFALSE )
000040  481d              LDR      r0,|L42.184|
000042  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
000044  b128              CBZ      r0,|L42.82|
;;;1753   		{
;;;1754   			/* Reset the next expected unblock time in case it referred to the
;;;1755   			task that is now in the Suspended state. */
;;;1756   			taskENTER_CRITICAL();
000046  f7fffffe          BL       vPortEnterCritical
;;;1757   			{
;;;1758   				prvResetNextTaskUnblockTime();
00004a  f7fffffe          BL       prvResetNextTaskUnblockTime
;;;1759   			}
;;;1760   			taskEXIT_CRITICAL();
00004e  f7fffffe          BL       vPortExitCritical
                  |L42.82|
;;;1761   		}
;;;1762   		else
;;;1763   		{
;;;1764   			mtCOVERAGE_TEST_MARKER();
;;;1765   		}
;;;1766   
;;;1767   		if( pxTCB == pxCurrentTCB )
000052  4817              LDR      r0,|L42.176|
000054  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000056  4284              CMP      r4,r0
000058  d129              BNE      |L42.174|
;;;1768   		{
;;;1769   			if( xSchedulerRunning != pdFALSE )
00005a  4817              LDR      r0,|L42.184|
00005c  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
00005e  b1d0              CBZ      r0,|L42.150|
;;;1770   			{
;;;1771   				/* The current task has just been suspended. */
;;;1772   				configASSERT( uxSchedulerSuspended == 0 );
000060  4816              LDR      r0,|L42.188|
000062  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000064  b908              CBNZ     r0,|L42.106|
000066  2001              MOVS     r0,#1
000068  e000              B        |L42.108|
                  |L42.106|
00006a  2000              MOVS     r0,#0
                  |L42.108|
00006c  b950              CBNZ     r0,|L42.132|
00006e  bf00              NOP      
000070  2050              MOVS     r0,#0x50
000072  f3808811          MSR      BASEPRI,r0
000076  f3bf8f4f          DSB      
00007a  f3bf8f6f          ISB      
00007e  bf00              NOP      
000080  bf00              NOP      
                  |L42.130|
000082  e7fe              B        |L42.130|
                  |L42.132|
;;;1773   				portYIELD_WITHIN_API();
000084  f04f5080          MOV      r0,#0x10000000
000088  490d              LDR      r1,|L42.192|
00008a  6008              STR      r0,[r1,#0]
00008c  f3bf8f4f          DSB      
000090  f3bf8f6f          ISB      
000094  e00b              B        |L42.174|
                  |L42.150|
;;;1774   			}
;;;1775   			else
;;;1776   			{
;;;1777   				/* The scheduler is not running, but the task that was pointed
;;;1778   				to by pxCurrentTCB has just been suspended and pxCurrentTCB
;;;1779   				must be adjusted to point to a different task. */
;;;1780   				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
000096  4807              LDR      r0,|L42.180|
000098  6800              LDR      r0,[r0,#0]  ; xSuspendedTaskList
00009a  490a              LDR      r1,|L42.196|
00009c  6809              LDR      r1,[r1,#0]  ; uxCurrentNumberOfTasks
00009e  4288              CMP      r0,r1
0000a0  d103              BNE      |L42.170|
;;;1781   				{
;;;1782   					/* No other tasks are ready, so set pxCurrentTCB back to
;;;1783   					NULL so when the next task is created pxCurrentTCB will
;;;1784   					be set to point to it no matter what its relative priority
;;;1785   					is. */
;;;1786   					pxCurrentTCB = NULL;
0000a2  2000              MOVS     r0,#0
0000a4  4902              LDR      r1,|L42.176|
0000a6  6008              STR      r0,[r1,#0]  ; pxCurrentTCB
0000a8  e001              B        |L42.174|
                  |L42.170|
;;;1787   				}
;;;1788   				else
;;;1789   				{
;;;1790   					vTaskSwitchContext();
0000aa  f7fffffe          BL       vTaskSwitchContext
                  |L42.174|
;;;1791   				}
;;;1792   			}
;;;1793   		}
;;;1794   		else
;;;1795   		{
;;;1796   			mtCOVERAGE_TEST_MARKER();
;;;1797   		}
;;;1798   	}
0000ae  bd70              POP      {r4-r6,pc}
;;;1799   
                          ENDP

                  |L42.176|
                          DCD      pxCurrentTCB
                  |L42.180|
                          DCD      xSuspendedTaskList
                  |L42.184|
                          DCD      xSchedulerRunning
                  |L42.188|
                          DCD      uxSchedulerSuspended
                  |L42.192|
                          DCD      0xe000ed04
                  |L42.196|
                          DCD      uxCurrentNumberOfTasks

                          AREA ||i.vTaskSuspendAll||, CODE, READONLY, ALIGN=2

                  vTaskSuspendAll PROC
;;;2109   
;;;2110   void vTaskSuspendAll( void )
000000  4802              LDR      r0,|L43.12|
;;;2111   {
;;;2112   	/* A critical section is not required as the variable is of type
;;;2113   	BaseType_t.  Please read Richard Barry's reply in the following link to a
;;;2114   	post in the FreeRTOS support forum before reporting this as a bug! -
;;;2115   	http://goo.gl/wu4acr */
;;;2116   
;;;2117   	/* portSOFRWARE_BARRIER() is only implemented for emulated/simulated ports that
;;;2118   	do not otherwise exhibit real time behaviour. */
;;;2119   	portSOFTWARE_BARRIER();
;;;2120   
;;;2121   	/* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
;;;2122   	is used to allow calls to vTaskSuspendAll() to nest. */
;;;2123   	++uxSchedulerSuspended;
000002  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000004  1c40              ADDS     r0,r0,#1
000006  4901              LDR      r1,|L43.12|
000008  6008              STR      r0,[r1,#0]  ; uxSchedulerSuspended
;;;2124   
;;;2125   	/* Enforces ordering for ports and optimised compilers that may otherwise place
;;;2126   	the above increment elsewhere. */
;;;2127   	portMEMORY_BARRIER();
;;;2128   }
00000a  4770              BX       lr
;;;2129   /*----------------------------------------------------------*/
                          ENDP

                  |L43.12|
                          DCD      uxSchedulerSuspended

                          AREA ||i.vTaskSwitchContext||, CODE, READONLY, ALIGN=2

                  vTaskSwitchContext PROC
;;;2988   
;;;2989   void vTaskSwitchContext( void )
000000  481e              LDR      r0,|L44.124|
;;;2990   {
;;;2991   	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
000002  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000004  b118              CBZ      r0,|L44.14|
;;;2992   	{
;;;2993   		/* The scheduler is currently suspended - do not allow a context
;;;2994   		switch. */
;;;2995   		xYieldPending = pdTRUE;
000006  2001              MOVS     r0,#1
000008  491d              LDR      r1,|L44.128|
00000a  6008              STR      r0,[r1,#0]  ; xYieldPending
00000c  e034              B        |L44.120|
                  |L44.14|
;;;2996   	}
;;;2997   	else
;;;2998   	{
;;;2999   		xYieldPending = pdFALSE;
00000e  2000              MOVS     r0,#0
000010  491b              LDR      r1,|L44.128|
000012  6008              STR      r0,[r1,#0]  ; xYieldPending
;;;3000   		traceTASK_SWITCHED_OUT();
;;;3001   
;;;3002   		#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;3003   		{
;;;3004   			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
;;;3005   				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
;;;3006   			#else
;;;3007   				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
;;;3008   			#endif
;;;3009   
;;;3010   			/* Add the amount of time the task has been running to the
;;;3011   			accumulated time so far.  The time the task started running was
;;;3012   			stored in ulTaskSwitchedInTime.  Note that there is no overflow
;;;3013   			protection here so count values are only valid until the timer
;;;3014   			overflows.  The guard against negative values is to protect
;;;3015   			against suspect run time stat counter implementations - which
;;;3016   			are provided by the application, not the kernel. */
;;;3017   			if( ulTotalRunTime > ulTaskSwitchedInTime )
;;;3018   			{
;;;3019   				pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
;;;3020   			}
;;;3021   			else
;;;3022   			{
;;;3023   				mtCOVERAGE_TEST_MARKER();
;;;3024   			}
;;;3025   			ulTaskSwitchedInTime = ulTotalRunTime;
;;;3026   		}
;;;3027   		#endif /* configGENERATE_RUN_TIME_STATS */
;;;3028   
;;;3029   		/* Check for stack overflow, if configured. */
;;;3030   		taskCHECK_FOR_STACK_OVERFLOW();
;;;3031   
;;;3032   		/* Before the currently running task is switched out, save its errno. */
;;;3033   		#if( configUSE_POSIX_ERRNO == 1 )
;;;3034   		{
;;;3035   			pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
;;;3036   		}
;;;3037   		#endif
;;;3038   
;;;3039   		/* Select a new task to run using either the generic C or port
;;;3040   		optimised asm code. */
;;;3041   		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000014  481b              LDR      r0,|L44.132|
000016  6801              LDR      r1,[r0,#0]  ; uxTopReadyPriority
000018  e00c              B        |L44.52|
                  |L44.26|
00001a  b951              CBNZ     r1,|L44.50|
00001c  bf00              NOP      
00001e  2050              MOVS     r0,#0x50
000020  f3808811          MSR      BASEPRI,r0
000024  f3bf8f4f          DSB      
000028  f3bf8f6f          ISB      
00002c  bf00              NOP      
00002e  bf00              NOP      
                  |L44.48|
000030  e7fe              B        |L44.48|
                  |L44.50|
000032  1e49              SUBS     r1,r1,#1
                  |L44.52|
000034  eb010081          ADD      r0,r1,r1,LSL #2
000038  4a13              LDR      r2,|L44.136|
00003a  f8520020          LDR      r0,[r2,r0,LSL #2]
00003e  b908              CBNZ     r0,|L44.68|
000040  2001              MOVS     r0,#1
000042  e000              B        |L44.70|
                  |L44.68|
000044  2000              MOVS     r0,#0
                  |L44.70|
000046  2800              CMP      r0,#0
000048  d1e7              BNE      |L44.26|
00004a  eb010281          ADD      r2,r1,r1,LSL #2
00004e  4b0e              LDR      r3,|L44.136|
000050  eb030082          ADD      r0,r3,r2,LSL #2
000054  6842              LDR      r2,[r0,#4]
000056  6852              LDR      r2,[r2,#4]
000058  6042              STR      r2,[r0,#4]
00005a  f1000208          ADD      r2,r0,#8
00005e  6843              LDR      r3,[r0,#4]
000060  4293              CMP      r3,r2
000062  d102              BNE      |L44.106|
000064  6842              LDR      r2,[r0,#4]
000066  6852              LDR      r2,[r2,#4]
000068  6042              STR      r2,[r0,#4]
                  |L44.106|
00006a  6842              LDR      r2,[r0,#4]
00006c  68d2              LDR      r2,[r2,#0xc]
00006e  4b07              LDR      r3,|L44.140|
000070  601a              STR      r2,[r3,#0]  ; pxCurrentTCB
000072  4804              LDR      r0,|L44.132|
000074  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
000076  bf00              NOP      
                  |L44.120|
;;;3042   		traceTASK_SWITCHED_IN();
;;;3043   
;;;3044   		/* After the new task is switched in, update the global errno. */
;;;3045   		#if( configUSE_POSIX_ERRNO == 1 )
;;;3046   		{
;;;3047   			FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
;;;3048   		}
;;;3049   		#endif
;;;3050   
;;;3051   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;3052   		{
;;;3053   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;3054   			structure specific to this task.
;;;3055   			See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
;;;3056   			for additional information. */
;;;3057   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;3058   		}
;;;3059   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;3060   	}
;;;3061   }
000078  4770              BX       lr
;;;3062   /*-----------------------------------------------------------*/
                          ENDP

00007a  0000              DCW      0x0000
                  |L44.124|
                          DCD      uxSchedulerSuspended
                  |L44.128|
                          DCD      xYieldPending
                  |L44.132|
                          DCD      uxTopReadyPriority
                  |L44.136|
                          DCD      pxReadyTasksLists
                  |L44.140|
                          DCD      pxCurrentTCB

                          AREA ||i.xTaskCatchUpTicks||, CODE, READONLY, ALIGN=2

                  xTaskCatchUpTicks PROC
;;;2608   
;;;2609   BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
000000  b570              PUSH     {r4-r6,lr}
;;;2610   {
000002  4604              MOV      r4,r0
;;;2611   BaseType_t xYieldRequired = pdFALSE;
000004  2500              MOVS     r5,#0
;;;2612   
;;;2613   	/* Must not be called with the scheduler suspended as the implementation
;;;2614   	relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
;;;2615   	configASSERT( uxSchedulerSuspended == 0 );
000006  480f              LDR      r0,|L45.68|
000008  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00000a  b908              CBNZ     r0,|L45.16|
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L45.18|
                  |L45.16|
000010  2000              MOVS     r0,#0
                  |L45.18|
000012  b950              CBNZ     r0,|L45.42|
000014  bf00              NOP      
000016  2050              MOVS     r0,#0x50
000018  f3808811          MSR      BASEPRI,r0
00001c  f3bf8f4f          DSB      
000020  f3bf8f6f          ISB      
000024  bf00              NOP      
000026  bf00              NOP      
                  |L45.40|
000028  e7fe              B        |L45.40|
                  |L45.42|
;;;2616   
;;;2617   	/* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
;;;2618   	the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
;;;2619   	vTaskSuspendAll();
00002a  f7fffffe          BL       vTaskSuspendAll
;;;2620   	xPendedTicks += xTicksToCatchUp;
00002e  4806              LDR      r0,|L45.72|
000030  6800              LDR      r0,[r0,#0]  ; xPendedTicks
000032  4420              ADD      r0,r0,r4
000034  4904              LDR      r1,|L45.72|
000036  6008              STR      r0,[r1,#0]  ; xPendedTicks
;;;2621   	xYieldRequired = xTaskResumeAll();
000038  f7fffffe          BL       xTaskResumeAll
00003c  4605              MOV      r5,r0
;;;2622   
;;;2623   	return xYieldRequired;
00003e  4628              MOV      r0,r5
;;;2624   }
000040  bd70              POP      {r4-r6,pc}
;;;2625   /*----------------------------------------------------------*/
                          ENDP

000042  0000              DCW      0x0000
                  |L45.68|
                          DCD      uxSchedulerSuspended
                  |L45.72|
                          DCD      xPendedTicks

                          AREA ||i.xTaskCheckForTimeOut||, CODE, READONLY, ALIGN=2

                  xTaskCheckForTimeOut PROC
;;;3273   
;;;3274   BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;3275   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;3276   BaseType_t xReturn;
;;;3277   
;;;3278   	configASSERT( pxTimeOut );
000006  b955              CBNZ     r5,|L46.30|
000008  bf00              NOP      
00000a  2050              MOVS     r0,#0x50
00000c  f3808811          MSR      BASEPRI,r0
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L46.28|
00001c  e7fe              B        |L46.28|
                  |L46.30|
;;;3279   	configASSERT( pxTicksToWait );
00001e  b954              CBNZ     r4,|L46.54|
000020  bf00              NOP      
000022  2050              MOVS     r0,#0x50
000024  f3808811          MSR      BASEPRI,r0
000028  f3bf8f4f          DSB      
00002c  f3bf8f6f          ISB      
000030  bf00              NOP      
000032  bf00              NOP      
                  |L46.52|
000034  e7fe              B        |L46.52|
                  |L46.54|
;;;3280   
;;;3281   	taskENTER_CRITICAL();
000036  f7fffffe          BL       vPortEnterCritical
;;;3282   	{
;;;3283   		/* Minor optimisation.  The tick count cannot change in this block. */
;;;3284   		const TickType_t xConstTickCount = xTickCount;
00003a  4812              LDR      r0,|L46.132|
00003c  6802              LDR      r2,[r0,#0]  ; xTickCount
;;;3285   		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
00003e  6868              LDR      r0,[r5,#4]
000040  1a13              SUBS     r3,r2,r0
;;;3286   
;;;3287   		#if( INCLUDE_xTaskAbortDelay == 1 )
;;;3288   			if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
;;;3289   			{
;;;3290   				/* The delay was aborted, which is not the same as a time out,
;;;3291   				but has the same result. */
;;;3292   				pxCurrentTCB->ucDelayAborted = pdFALSE;
;;;3293   				xReturn = pdTRUE;
;;;3294   			}
;;;3295   			else
;;;3296   		#endif
;;;3297   
;;;3298   		#if ( INCLUDE_vTaskSuspend == 1 )
;;;3299   			if( *pxTicksToWait == portMAX_DELAY )
000042  6820              LDR      r0,[r4,#0]
000044  1c40              ADDS     r0,r0,#1
000046  b908              CBNZ     r0,|L46.76|
;;;3300   			{
;;;3301   				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
;;;3302   				specified is the maximum block time then the task should block
;;;3303   				indefinitely, and therefore never time out. */
;;;3304   				xReturn = pdFALSE;
000048  2600              MOVS     r6,#0
00004a  e017              B        |L46.124|
                  |L46.76|
;;;3305   			}
;;;3306   			else
;;;3307   		#endif
;;;3308   
;;;3309   		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
00004c  490e              LDR      r1,|L46.136|
00004e  6828              LDR      r0,[r5,#0]
000050  6809              LDR      r1,[r1,#0]  ; xNumOfOverflows
000052  4288              CMP      r0,r1
000054  d004              BEQ      |L46.96|
000056  6868              LDR      r0,[r5,#4]
000058  4290              CMP      r0,r2
00005a  d801              BHI      |L46.96|
;;;3310   		{
;;;3311   			/* The tick count is greater than the time at which
;;;3312   			vTaskSetTimeout() was called, but has also overflowed since
;;;3313   			vTaskSetTimeOut() was called.  It must have wrapped all the way
;;;3314   			around and gone past again. This passed since vTaskSetTimeout()
;;;3315   			was called. */
;;;3316   			xReturn = pdTRUE;
00005c  2601              MOVS     r6,#1
00005e  e00d              B        |L46.124|
                  |L46.96|
;;;3317   		}
;;;3318   		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
000060  6820              LDR      r0,[r4,#0]
000062  4298              CMP      r0,r3
000064  d907              BLS      |L46.118|
;;;3319   		{
;;;3320   			/* Not a genuine timeout. Adjust parameters for time remaining. */
;;;3321   			*pxTicksToWait -= xElapsedTime;
000066  6820              LDR      r0,[r4,#0]
000068  1ac0              SUBS     r0,r0,r3
00006a  6020              STR      r0,[r4,#0]
;;;3322   			vTaskInternalSetTimeOutState( pxTimeOut );
00006c  4628              MOV      r0,r5
00006e  f7fffffe          BL       vTaskInternalSetTimeOutState
;;;3323   			xReturn = pdFALSE;
000072  2600              MOVS     r6,#0
000074  e002              B        |L46.124|
                  |L46.118|
;;;3324   		}
;;;3325   		else
;;;3326   		{
;;;3327   			*pxTicksToWait = 0;
000076  2000              MOVS     r0,#0
000078  6020              STR      r0,[r4,#0]
;;;3328   			xReturn = pdTRUE;
00007a  2601              MOVS     r6,#1
                  |L46.124|
;;;3329   		}
;;;3330   	}
;;;3331   	taskEXIT_CRITICAL();
00007c  f7fffffe          BL       vPortExitCritical
;;;3332   
;;;3333   	return xReturn;
000080  4630              MOV      r0,r6
;;;3334   }
000082  bd70              POP      {r4-r6,pc}
;;;3335   /*-----------------------------------------------------------*/
                          ENDP

                  |L46.132|
                          DCD      xTickCount
                  |L46.136|
                          DCD      xNumOfOverflows

                          AREA ||i.xTaskCreate||, CODE, READONLY, ALIGN=1

                  xTaskCreate PROC
;;;732    
;;;733    	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;734    							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
;;;735    							const configSTACK_DEPTH_TYPE usStackDepth,
;;;736    							void * const pvParameters,
;;;737    							UBaseType_t uxPriority,
;;;738    							TaskHandle_t * const pxCreatedTask )
;;;739    	{
000004  b085              SUB      sp,sp,#0x14
000006  4680              MOV      r8,r0
000008  4689              MOV      r9,r1
00000a  4617              MOV      r7,r2
00000c  e9ddab12          LDRD     r10,r11,[sp,#0x48]
;;;740    	TCB_t *pxNewTCB;
;;;741    	BaseType_t xReturn;
;;;742    
;;;743    		/* If the stack grows down then allocate the stack then the TCB so the stack
;;;744    		does not grow into the TCB.  Likewise if the stack grows up then allocate
;;;745    		the TCB then the stack. */
;;;746    		#if( portSTACK_GROWTH > 0 )
;;;747    		{
;;;748    			/* Allocate space for the TCB.  Where the memory comes from depends on
;;;749    			the implementation of the port malloc function and whether or not static
;;;750    			allocation is being used. */
;;;751    			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
;;;752    
;;;753    			if( pxNewTCB != NULL )
;;;754    			{
;;;755    				/* Allocate space for the stack used by the task being created.
;;;756    				The base of the stack memory stored in the TCB so the task can
;;;757    				be deleted later if required. */
;;;758    				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
;;;759    
;;;760    				if( pxNewTCB->pxStack == NULL )
;;;761    				{
;;;762    					/* Could not allocate the stack.  Delete the allocated TCB. */
;;;763    					vPortFree( pxNewTCB );
;;;764    					pxNewTCB = NULL;
;;;765    				}
;;;766    			}
;;;767    		}
;;;768    		#else /* portSTACK_GROWTH */
;;;769    		{
;;;770    		StackType_t *pxStack;
;;;771    
;;;772    			/* Allocate space for the stack used by the task being created. */
;;;773    			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
000010  00b8              LSLS     r0,r7,#2
000012  f7fffffe          BL       pvPortMalloc
000016  4606              MOV      r6,r0
;;;774    
;;;775    			if( pxStack != NULL )
000018  b156              CBZ      r6,|L47.48|
;;;776    			{
;;;777    				/* Allocate space for the TCB. */
;;;778    				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
00001a  205c              MOVS     r0,#0x5c
00001c  f7fffffe          BL       pvPortMalloc
000020  4604              MOV      r4,r0
;;;779    
;;;780    				if( pxNewTCB != NULL )
000022  b10c              CBZ      r4,|L47.40|
;;;781    				{
;;;782    					/* Store the stack location in the TCB. */
;;;783    					pxNewTCB->pxStack = pxStack;
000024  6326              STR      r6,[r4,#0x30]
000026  e004              B        |L47.50|
                  |L47.40|
;;;784    				}
;;;785    				else
;;;786    				{
;;;787    					/* The stack cannot be used as the TCB was not created.  Free
;;;788    					it again. */
;;;789    					vPortFree( pxStack );
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       vPortFree
00002e  e000              B        |L47.50|
                  |L47.48|
;;;790    				}
;;;791    			}
;;;792    			else
;;;793    			{
;;;794    				pxNewTCB = NULL;
000030  2400              MOVS     r4,#0
                  |L47.50|
;;;795    			}
;;;796    		}
;;;797    		#endif /* portSTACK_GROWTH */
;;;798    
;;;799    		if( pxNewTCB != NULL )
000032  b18c              CBZ      r4,|L47.88|
;;;800    		{
;;;801    			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e9029 !e731 Macro has been consolidated for readability reasons. */
;;;802    			{
;;;803    				/* Tasks can be created statically or dynamically, so note this
;;;804    				task was created dynamically in case it is later deleted. */
;;;805    				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
000034  2000              MOVS     r0,#0
000036  f8840059          STRB     r0,[r4,#0x59]
;;;806    			}
;;;807    			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
;;;808    
;;;809    			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
00003a  e9cdab00          STRD     r10,r11,[sp,#0]
00003e  e9cd4002          STRD     r4,r0,[sp,#8]
000042  463a              MOV      r2,r7
000044  4649              MOV      r1,r9
000046  4640              MOV      r0,r8
000048  9b08              LDR      r3,[sp,#0x20]
00004a  f7fffffe          BL       prvInitialiseNewTask
;;;810    			prvAddNewTaskToReadyList( pxNewTCB );
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       prvAddNewTaskToReadyList
;;;811    			xReturn = pdPASS;
000054  2501              MOVS     r5,#1
000056  e001              B        |L47.92|
                  |L47.88|
;;;812    		}
;;;813    		else
;;;814    		{
;;;815    			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
000058  f04f35ff          MOV      r5,#0xffffffff
                  |L47.92|
;;;816    		}
;;;817    
;;;818    		return xReturn;
00005c  4628              MOV      r0,r5
;;;819    	}
00005e  b009              ADD      sp,sp,#0x24
000060  e8bd8ff0          POP      {r4-r11,pc}
;;;820    
                          ENDP


                          AREA ||i.xTaskCreateStatic||, CODE, READONLY, ALIGN=1

                  xTaskCreateStatic PROC
;;;580    
;;;581    	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;582    									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
;;;583    									const uint32_t ulStackDepth,
;;;584    									void * const pvParameters,
;;;585    									UBaseType_t uxPriority,
;;;586    									StackType_t * const puxStackBuffer,
;;;587    									StaticTask_t * const pxTaskBuffer )
;;;588    	{
000004  b085              SUB      sp,sp,#0x14
000006  4607              MOV      r7,r0
000008  4688              MOV      r8,r1
00000a  4691              MOV      r9,r2
00000c  469a              MOV      r10,r3
00000e  e9ddb60e          LDRD     r11,r6,[sp,#0x38]
000012  9c10              LDR      r4,[sp,#0x40]
;;;589    	TCB_t *pxNewTCB;
;;;590    	TaskHandle_t xReturn;
;;;591    
;;;592    		configASSERT( puxStackBuffer != NULL );
000014  b10e              CBZ      r6,|L48.26|
000016  2001              MOVS     r0,#1
000018  e000              B        |L48.28|
                  |L48.26|
00001a  2000              MOVS     r0,#0
                  |L48.28|
00001c  b950              CBNZ     r0,|L48.52|
00001e  bf00              NOP      
000020  2050              MOVS     r0,#0x50
000022  f3808811          MSR      BASEPRI,r0
000026  f3bf8f4f          DSB      
00002a  f3bf8f6f          ISB      
00002e  bf00              NOP      
000030  bf00              NOP      
                  |L48.50|
000032  e7fe              B        |L48.50|
                  |L48.52|
;;;593    		configASSERT( pxTaskBuffer != NULL );
000034  b10c              CBZ      r4,|L48.58|
000036  2001              MOVS     r0,#1
000038  e000              B        |L48.60|
                  |L48.58|
00003a  2000              MOVS     r0,#0
                  |L48.60|
00003c  b950              CBNZ     r0,|L48.84|
00003e  bf00              NOP      
000040  2050              MOVS     r0,#0x50
000042  f3808811          MSR      BASEPRI,r0
000046  f3bf8f4f          DSB      
00004a  f3bf8f6f          ISB      
00004e  bf00              NOP      
000050  bf00              NOP      
                  |L48.82|
000052  e7fe              B        |L48.82|
                  |L48.84|
;;;594    
;;;595    		#if( configASSERT_DEFINED == 1 )
;;;596    		{
;;;597    			/* Sanity check that the size of the structure used to declare a
;;;598    			variable of type StaticTask_t equals the size of the real task
;;;599    			structure. */
;;;600    			volatile size_t xSize = sizeof( StaticTask_t );
000054  205c              MOVS     r0,#0x5c
000056  9003              STR      r0,[sp,#0xc]
;;;601    			configASSERT( xSize == sizeof( TCB_t ) );
000058  9803              LDR      r0,[sp,#0xc]
00005a  285c              CMP      r0,#0x5c
00005c  d101              BNE      |L48.98|
00005e  2001              MOVS     r0,#1
000060  e000              B        |L48.100|
                  |L48.98|
000062  2000              MOVS     r0,#0
                  |L48.100|
000064  b950              CBNZ     r0,|L48.124|
000066  bf00              NOP      
000068  2050              MOVS     r0,#0x50
00006a  f3808811          MSR      BASEPRI,r0
00006e  f3bf8f4f          DSB      
000072  f3bf8f6f          ISB      
000076  bf00              NOP      
000078  bf00              NOP      
                  |L48.122|
00007a  e7fe              B        |L48.122|
                  |L48.124|
;;;602    			( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
00007c  bf00              NOP      
;;;603    		}
;;;604    		#endif /* configASSERT_DEFINED */
;;;605    
;;;606    
;;;607    		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
00007e  b1b4              CBZ      r4,|L48.174|
000080  b1ae              CBZ      r6,|L48.174|
;;;608    		{
;;;609    			/* The memory used for the task's TCB and stack are passed into this
;;;610    			function - use them. */
;;;611    			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
000082  4625              MOV      r5,r4
;;;612    			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
000084  462c              MOV      r4,r5
000086  632e              STR      r6,[r5,#0x30]
;;;613    
;;;614    			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
;;;615    			{
;;;616    				/* Tasks can be created statically or dynamically, so note this
;;;617    				task was created statically in case the task is later deleted. */
;;;618    				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
000088  2002              MOVS     r0,#2
00008a  f8850059          STRB     r0,[r5,#0x59]
;;;619    			}
;;;620    			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
;;;621    
;;;622    			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
00008e  2000              MOVS     r0,#0
000090  a904              ADD      r1,sp,#0x10
000092  4653              MOV      r3,r10
000094  464a              MOV      r2,r9
000096  e9cdb100          STRD     r11,r1,[sp,#0]
00009a  e9cd5002          STRD     r5,r0,[sp,#8]
00009e  4641              MOV      r1,r8
0000a0  4638              MOV      r0,r7
0000a2  f7fffffe          BL       prvInitialiseNewTask
;;;623    			prvAddNewTaskToReadyList( pxNewTCB );
0000a6  4628              MOV      r0,r5
0000a8  f7fffffe          BL       prvAddNewTaskToReadyList
0000ac  e001              B        |L48.178|
                  |L48.174|
;;;624    		}
;;;625    		else
;;;626    		{
;;;627    			xReturn = NULL;
0000ae  2000              MOVS     r0,#0
0000b0  9004              STR      r0,[sp,#0x10]
                  |L48.178|
;;;628    		}
;;;629    
;;;630    		return xReturn;
0000b2  9804              LDR      r0,[sp,#0x10]
;;;631    	}
0000b4  b005              ADD      sp,sp,#0x14
0000b6  e8bd8ff0          POP      {r4-r11,pc}
;;;632    
                          ENDP


                          AREA ||i.xTaskGenericNotify||, CODE, READONLY, ALIGN=2

                  xTaskGenericNotify PROC
;;;4782   
;;;4783   	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;4784   	{
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;4785   	TCB_t * pxTCB;
;;;4786   	BaseType_t xReturn = pdPASS;
00000c  f04f0a01          MOV      r10,#1
;;;4787   	uint8_t ucOriginalNotifyState;
;;;4788   
;;;4789   		configASSERT( xTaskToNotify );
000010  b956              CBNZ     r6,|L49.40|
000012  bf00              NOP      
000014  2050              MOVS     r0,#0x50
000016  f3808811          MSR      BASEPRI,r0
00001a  f3bf8f4f          DSB      
00001e  f3bf8f6f          ISB      
000022  bf00              NOP      
000024  bf00              NOP      
                  |L49.38|
000026  e7fe              B        |L49.38|
                  |L49.40|
;;;4790   		pxTCB = xTaskToNotify;
000028  4634              MOV      r4,r6
;;;4791   
;;;4792   		taskENTER_CRITICAL();
00002a  f7fffffe          BL       vPortEnterCritical
;;;4793   		{
;;;4794   			if( pulPreviousNotificationValue != NULL )
00002e  f1b80f00          CMP      r8,#0
000032  d002              BEQ      |L49.58|
;;;4795   			{
;;;4796   				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
000034  6d60              LDR      r0,[r4,#0x54]
000036  f8c80000          STR      r0,[r8,#0]
                  |L49.58|
;;;4797   			}
;;;4798   
;;;4799   			ucOriginalNotifyState = pxTCB->ucNotifyState;
00003a  f8949058          LDRB     r9,[r4,#0x58]
;;;4800   
;;;4801   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
00003e  2002              MOVS     r0,#2
000040  f8840058          STRB     r0,[r4,#0x58]
;;;4802   
;;;4803   			switch( eAction )
000044  2f05              CMP      r7,#5
000046  d217              BCS      |L49.120|
000048  e8dff007          TBB      [pc,r7]
00004c  1503070b          DCB      0x15,0x03,0x07,0x0b
000050  0d00              DCB      0x0d,0x00
;;;4804   			{
;;;4805   				case eSetBits	:
;;;4806   					pxTCB->ulNotifiedValue |= ulValue;
000052  6d60              LDR      r0,[r4,#0x54]
000054  4328              ORRS     r0,r0,r5
000056  6560              STR      r0,[r4,#0x54]
;;;4807   					break;
000058  e021              B        |L49.158|
;;;4808   
;;;4809   				case eIncrement	:
;;;4810   					( pxTCB->ulNotifiedValue )++;
00005a  6d60              LDR      r0,[r4,#0x54]
00005c  1c40              ADDS     r0,r0,#1
00005e  6560              STR      r0,[r4,#0x54]
;;;4811   					break;
000060  e01d              B        |L49.158|
;;;4812   
;;;4813   				case eSetValueWithOverwrite	:
;;;4814   					pxTCB->ulNotifiedValue = ulValue;
000062  6565              STR      r5,[r4,#0x54]
;;;4815   					break;
000064  e01b              B        |L49.158|
;;;4816   
;;;4817   				case eSetValueWithoutOverwrite :
;;;4818   					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
000066  f1b90f02          CMP      r9,#2
00006a  d001              BEQ      |L49.112|
;;;4819   					{
;;;4820   						pxTCB->ulNotifiedValue = ulValue;
00006c  6565              STR      r5,[r4,#0x54]
00006e  e001              B        |L49.116|
                  |L49.112|
;;;4821   					}
;;;4822   					else
;;;4823   					{
;;;4824   						/* The value could not be written to the task. */
;;;4825   						xReturn = pdFAIL;
000070  f04f0a00          MOV      r10,#0
                  |L49.116|
;;;4826   					}
;;;4827   					break;
000074  e013              B        |L49.158|
;;;4828   
;;;4829   				case eNoAction:
;;;4830   					/* The task is being notified without its notify value being
;;;4831   					updated. */
;;;4832   					break;
000076  e012              B        |L49.158|
                  |L49.120|
;;;4833   
;;;4834   				default:
;;;4835   					/* Should not get here if all enums are handled.
;;;4836   					Artificially force an assert by testing a value the
;;;4837   					compiler can't assume is const. */
;;;4838   					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
000078  6d60              LDR      r0,[r4,#0x54]
00007a  1c40              ADDS     r0,r0,#1
00007c  b908              CBNZ     r0,|L49.130|
00007e  2001              MOVS     r0,#1
000080  e000              B        |L49.132|
                  |L49.130|
000082  2000              MOVS     r0,#0
                  |L49.132|
000084  b950              CBNZ     r0,|L49.156|
000086  bf00              NOP      
000088  2050              MOVS     r0,#0x50
00008a  f3808811          MSR      BASEPRI,r0
00008e  f3bf8f4f          DSB      
000092  f3bf8f6f          ISB      
000096  bf00              NOP      
000098  bf00              NOP      
                  |L49.154|
00009a  e7fe              B        |L49.154|
                  |L49.156|
;;;4839   
;;;4840   					break;
00009c  bf00              NOP      
                  |L49.158|
00009e  bf00              NOP                            ;4807
;;;4841   			}
;;;4842   
;;;4843   			traceTASK_NOTIFY();
;;;4844   
;;;4845   			/* If the task is in the blocked state specifically to wait for a
;;;4846   			notification then unblock it now. */
;;;4847   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
0000a0  f1b90f01          CMP      r9,#1
0000a4  d132              BNE      |L49.268|
;;;4848   			{
;;;4849   				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
0000a6  1d20              ADDS     r0,r4,#4
0000a8  f7fffffe          BL       uxListRemove
;;;4850   				prvAddTaskToReadyList( pxTCB );
0000ac  491a              LDR      r1,|L49.280|
0000ae  6ae0              LDR      r0,[r4,#0x2c]
0000b0  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
0000b2  4288              CMP      r0,r1
0000b4  d902              BLS      |L49.188|
0000b6  4918              LDR      r1,|L49.280|
0000b8  6ae0              LDR      r0,[r4,#0x2c]
0000ba  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L49.188|
0000bc  6ae1              LDR      r1,[r4,#0x2c]
0000be  eb010181          ADD      r1,r1,r1,LSL #2
0000c2  4a16              LDR      r2,|L49.284|
0000c4  eb020081          ADD      r0,r2,r1,LSL #2
0000c8  1d21              ADDS     r1,r4,#4
0000ca  f7fffffe          BL       vListInsertEnd
;;;4851   
;;;4852   				/* The task should not have been on an event list. */
;;;4853   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
0000ce  6aa0              LDR      r0,[r4,#0x28]
0000d0  b908              CBNZ     r0,|L49.214|
0000d2  2001              MOVS     r0,#1
0000d4  e000              B        |L49.216|
                  |L49.214|
0000d6  2000              MOVS     r0,#0
                  |L49.216|
0000d8  b950              CBNZ     r0,|L49.240|
0000da  bf00              NOP      
0000dc  2050              MOVS     r0,#0x50
0000de  f3808811          MSR      BASEPRI,r0
0000e2  f3bf8f4f          DSB      
0000e6  f3bf8f6f          ISB      
0000ea  bf00              NOP      
0000ec  bf00              NOP      
                  |L49.238|
0000ee  e7fe              B        |L49.238|
                  |L49.240|
;;;4854   
;;;4855   				#if( configUSE_TICKLESS_IDLE != 0 )
;;;4856   				{
;;;4857   					/* If a task is blocked waiting for a notification then
;;;4858   					xNextTaskUnblockTime might be set to the blocked task's time
;;;4859   					out time.  If the task is unblocked for a reason other than
;;;4860   					a timeout xNextTaskUnblockTime is normally left unchanged,
;;;4861   					because it will automatically get reset to a new value when
;;;4862   					the tick count equals xNextTaskUnblockTime.  However if
;;;4863   					tickless idling is used it might be more important to enter
;;;4864   					sleep mode at the earliest possible time - so reset
;;;4865   					xNextTaskUnblockTime here to ensure it is updated at the
;;;4866   					earliest possible time. */
;;;4867   					prvResetNextTaskUnblockTime();
;;;4868   				}
;;;4869   				#endif
;;;4870   
;;;4871   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
0000f0  490b              LDR      r1,|L49.288|
0000f2  6ae0              LDR      r0,[r4,#0x2c]
0000f4  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
0000f6  6ac9              LDR      r1,[r1,#0x2c]
0000f8  4288              CMP      r0,r1
0000fa  d907              BLS      |L49.268|
;;;4872   				{
;;;4873   					/* The notified task has a priority above the currently
;;;4874   					executing task so a yield is required. */
;;;4875   					taskYIELD_IF_USING_PREEMPTION();
0000fc  f04f5080          MOV      r0,#0x10000000
000100  4908              LDR      r1,|L49.292|
000102  6008              STR      r0,[r1,#0]
000104  f3bf8f4f          DSB      
000108  f3bf8f6f          ISB      
                  |L49.268|
;;;4876   				}
;;;4877   				else
;;;4878   				{
;;;4879   					mtCOVERAGE_TEST_MARKER();
;;;4880   				}
;;;4881   			}
;;;4882   			else
;;;4883   			{
;;;4884   				mtCOVERAGE_TEST_MARKER();
;;;4885   			}
;;;4886   		}
;;;4887   		taskEXIT_CRITICAL();
00010c  f7fffffe          BL       vPortExitCritical
;;;4888   
;;;4889   		return xReturn;
000110  4650              MOV      r0,r10
;;;4890   	}
000112  e8bd87f0          POP      {r4-r10,pc}
;;;4891   
                          ENDP

000116  0000              DCW      0x0000
                  |L49.280|
                          DCD      uxTopReadyPriority
                  |L49.284|
                          DCD      pxReadyTasksLists
                  |L49.288|
                          DCD      pxCurrentTCB
                  |L49.292|
                          DCD      0xe000ed04

                          AREA ||i.xTaskGenericNotifyFromISR||, CODE, READONLY, ALIGN=2

                  xTaskGenericNotifyFromISR PROC
;;;4896   
;;;4897   	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;4898   	{
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  f8ddb028          LDR      r11,[sp,#0x28]
;;;4899   	TCB_t * pxTCB;
;;;4900   	uint8_t ucOriginalNotifyState;
;;;4901   	BaseType_t xReturn = pdPASS;
000010  2001              MOVS     r0,#1
000012  9000              STR      r0,[sp,#0]
;;;4902   	UBaseType_t uxSavedInterruptStatus;
;;;4903   
;;;4904   		configASSERT( xTaskToNotify );
000014  b957              CBNZ     r7,|L50.44|
000016  bf00              NOP      
000018  2050              MOVS     r0,#0x50
00001a  f3808811          MSR      BASEPRI,r0
00001e  f3bf8f4f          DSB      
000022  f3bf8f6f          ISB      
000026  bf00              NOP      
000028  bf00              NOP      
                  |L50.42|
00002a  e7fe              B        |L50.42|
                  |L50.44|
;;;4905   
;;;4906   		/* RTOS ports that support interrupt nesting have the concept of a
;;;4907   		maximum	system call (or maximum API call) interrupt priority.
;;;4908   		Interrupts that are	above the maximum system call priority are keep
;;;4909   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;4910   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;4911   		is defined in FreeRTOSConfig.h then
;;;4912   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;4913   		failure if a FreeRTOS API function is called from an interrupt that has
;;;4914   		been assigned a priority above the configured maximum system call
;;;4915   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;4916   		from interrupts	that have been assigned a priority at or (logically)
;;;4917   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;4918   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;4919   		simple as possible.  More information (albeit Cortex-M specific) is
;;;4920   		provided on the following link:
;;;4921   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;4922   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
00002c  f7fffffe          BL       vPortValidateInterruptPriority
;;;4923   
;;;4924   		pxTCB = xTaskToNotify;
000030  463c              MOV      r4,r7
;;;4925   
;;;4926   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000032  bf00              NOP      
000034  2150              MOVS     r1,#0x50
000036  f3ef8011          MRS      r0,BASEPRI
00003a  f3818811          MSR      BASEPRI,r1
00003e  f3bf8f4f          DSB      
000042  f3bf8f6f          ISB      
000046  bf00              NOP      
000048  4605              MOV      r5,r0
;;;4927   		{
;;;4928   			if( pulPreviousNotificationValue != NULL )
00004a  f1b90f00          CMP      r9,#0
00004e  d002              BEQ      |L50.86|
;;;4929   			{
;;;4930   				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
000050  6d60              LDR      r0,[r4,#0x54]
000052  f8c90000          STR      r0,[r9,#0]
                  |L50.86|
;;;4931   			}
;;;4932   
;;;4933   			ucOriginalNotifyState = pxTCB->ucNotifyState;
000056  f894a058          LDRB     r10,[r4,#0x58]
;;;4934   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
00005a  2002              MOVS     r0,#2
00005c  f8840058          STRB     r0,[r4,#0x58]
;;;4935   
;;;4936   			switch( eAction )
000060  f1b80f05          CMP      r8,#5
000064  d217              BCS      |L50.150|
000066  e8dff008          TBB      [pc,r8]
00006a  1503              DCB      0x15,0x03
00006c  070b0d00          DCB      0x07,0x0b,0x0d,0x00
;;;4937   			{
;;;4938   				case eSetBits	:
;;;4939   					pxTCB->ulNotifiedValue |= ulValue;
000070  6d60              LDR      r0,[r4,#0x54]
000072  4330              ORRS     r0,r0,r6
000074  6560              STR      r0,[r4,#0x54]
;;;4940   					break;
000076  e021              B        |L50.188|
;;;4941   
;;;4942   				case eIncrement	:
;;;4943   					( pxTCB->ulNotifiedValue )++;
000078  6d60              LDR      r0,[r4,#0x54]
00007a  1c40              ADDS     r0,r0,#1
00007c  6560              STR      r0,[r4,#0x54]
;;;4944   					break;
00007e  e01d              B        |L50.188|
;;;4945   
;;;4946   				case eSetValueWithOverwrite	:
;;;4947   					pxTCB->ulNotifiedValue = ulValue;
000080  6566              STR      r6,[r4,#0x54]
;;;4948   					break;
000082  e01b              B        |L50.188|
;;;4949   
;;;4950   				case eSetValueWithoutOverwrite :
;;;4951   					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
000084  f1ba0f02          CMP      r10,#2
000088  d001              BEQ      |L50.142|
;;;4952   					{
;;;4953   						pxTCB->ulNotifiedValue = ulValue;
00008a  6566              STR      r6,[r4,#0x54]
00008c  e001              B        |L50.146|
                  |L50.142|
;;;4954   					}
;;;4955   					else
;;;4956   					{
;;;4957   						/* The value could not be written to the task. */
;;;4958   						xReturn = pdFAIL;
00008e  2000              MOVS     r0,#0
000090  9000              STR      r0,[sp,#0]
                  |L50.146|
;;;4959   					}
;;;4960   					break;
000092  e013              B        |L50.188|
;;;4961   
;;;4962   				case eNoAction :
;;;4963   					/* The task is being notified without its notify value being
;;;4964   					updated. */
;;;4965   					break;
000094  e012              B        |L50.188|
                  |L50.150|
;;;4966   
;;;4967   				default:
;;;4968   					/* Should not get here if all enums are handled.
;;;4969   					Artificially force an assert by testing a value the
;;;4970   					compiler can't assume is const. */
;;;4971   					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
000096  6d60              LDR      r0,[r4,#0x54]
000098  1c40              ADDS     r0,r0,#1
00009a  b908              CBNZ     r0,|L50.160|
00009c  2001              MOVS     r0,#1
00009e  e000              B        |L50.162|
                  |L50.160|
0000a0  2000              MOVS     r0,#0
                  |L50.162|
0000a2  b950              CBNZ     r0,|L50.186|
0000a4  bf00              NOP      
0000a6  2050              MOVS     r0,#0x50
0000a8  f3808811          MSR      BASEPRI,r0
0000ac  f3bf8f4f          DSB      
0000b0  f3bf8f6f          ISB      
0000b4  bf00              NOP      
0000b6  bf00              NOP      
                  |L50.184|
0000b8  e7fe              B        |L50.184|
                  |L50.186|
;;;4972   					break;
0000ba  bf00              NOP      
                  |L50.188|
0000bc  bf00              NOP                            ;4940
;;;4973   			}
;;;4974   
;;;4975   			traceTASK_NOTIFY_FROM_ISR();
;;;4976   
;;;4977   			/* If the task is in the blocked state specifically to wait for a
;;;4978   			notification then unblock it now. */
;;;4979   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
0000be  f1ba0f01          CMP      r10,#1
0000c2  d13c              BNE      |L50.318|
;;;4980   			{
;;;4981   				/* The task should not have been on an event list. */
;;;4982   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
0000c4  6aa0              LDR      r0,[r4,#0x28]
0000c6  b908              CBNZ     r0,|L50.204|
0000c8  2001              MOVS     r0,#1
0000ca  e000              B        |L50.206|
                  |L50.204|
0000cc  2000              MOVS     r0,#0
                  |L50.206|
0000ce  b950              CBNZ     r0,|L50.230|
0000d0  bf00              NOP      
0000d2  2050              MOVS     r0,#0x50
0000d4  f3808811          MSR      BASEPRI,r0
0000d8  f3bf8f4f          DSB      
0000dc  f3bf8f6f          ISB      
0000e0  bf00              NOP      
0000e2  bf00              NOP      
                  |L50.228|
0000e4  e7fe              B        |L50.228|
                  |L50.230|
;;;4983   
;;;4984   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
0000e6  4819              LDR      r0,|L50.332|
0000e8  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
0000ea  b9a0              CBNZ     r0,|L50.278|
;;;4985   				{
;;;4986   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
0000ec  1d20              ADDS     r0,r4,#4
0000ee  f7fffffe          BL       uxListRemove
;;;4987   					prvAddTaskToReadyList( pxTCB );
0000f2  4917              LDR      r1,|L50.336|
0000f4  6ae0              LDR      r0,[r4,#0x2c]
0000f6  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
0000f8  4288              CMP      r0,r1
0000fa  d902              BLS      |L50.258|
0000fc  4914              LDR      r1,|L50.336|
0000fe  6ae0              LDR      r0,[r4,#0x2c]
000100  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L50.258|
000102  6ae1              LDR      r1,[r4,#0x2c]
000104  eb010181          ADD      r1,r1,r1,LSL #2
000108  4a12              LDR      r2,|L50.340|
00010a  eb020081          ADD      r0,r2,r1,LSL #2
00010e  1d21              ADDS     r1,r4,#4
000110  f7fffffe          BL       vListInsertEnd
000114  e004              B        |L50.288|
                  |L50.278|
;;;4988   				}
;;;4989   				else
;;;4990   				{
;;;4991   					/* The delayed and ready lists cannot be accessed, so hold
;;;4992   					this task pending until the scheduler is resumed. */
;;;4993   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
000116  f1040118          ADD      r1,r4,#0x18
00011a  480f              LDR      r0,|L50.344|
00011c  f7fffffe          BL       vListInsertEnd
                  |L50.288|
;;;4994   				}
;;;4995   
;;;4996   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
000120  490e              LDR      r1,|L50.348|
000122  6ae0              LDR      r0,[r4,#0x2c]
000124  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000126  6ac9              LDR      r1,[r1,#0x2c]
000128  4288              CMP      r0,r1
00012a  d908              BLS      |L50.318|
;;;4997   				{
;;;4998   					/* The notified task has a priority above the currently
;;;4999   					executing task so a yield is required. */
;;;5000   					if( pxHigherPriorityTaskWoken != NULL )
00012c  f1bb0f00          CMP      r11,#0
000130  d002              BEQ      |L50.312|
;;;5001   					{
;;;5002   						*pxHigherPriorityTaskWoken = pdTRUE;
000132  2001              MOVS     r0,#1
000134  f8cb0000          STR      r0,[r11,#0]
                  |L50.312|
;;;5003   					}
;;;5004   
;;;5005   					/* Mark that a yield is pending in case the user is not
;;;5006   					using the "xHigherPriorityTaskWoken" parameter to an ISR
;;;5007   					safe FreeRTOS function. */
;;;5008   					xYieldPending = pdTRUE;
000138  2001              MOVS     r0,#1
00013a  4909              LDR      r1,|L50.352|
00013c  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L50.318|
;;;5009   				}
;;;5010   				else
;;;5011   				{
;;;5012   					mtCOVERAGE_TEST_MARKER();
;;;5013   				}
;;;5014   			}
;;;5015   		}
;;;5016   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
00013e  bf00              NOP      
000140  f3858811          MSR      BASEPRI,r5
000144  bf00              NOP      
;;;5017   
;;;5018   		return xReturn;
000146  9800              LDR      r0,[sp,#0]
;;;5019   	}
000148  e8bd8ff8          POP      {r3-r11,pc}
;;;5020   
                          ENDP

                  |L50.332|
                          DCD      uxSchedulerSuspended
                  |L50.336|
                          DCD      uxTopReadyPriority
                  |L50.340|
                          DCD      pxReadyTasksLists
                  |L50.344|
                          DCD      xPendingReadyList
                  |L50.348|
                          DCD      pxCurrentTCB
                  |L50.352|
                          DCD      xYieldPending

                          AREA ||i.xTaskGetCurrentTaskHandle||, CODE, READONLY, ALIGN=2

                  xTaskGetCurrentTaskHandle PROC
;;;3968   
;;;3969   	TaskHandle_t xTaskGetCurrentTaskHandle( void )
000000  4901              LDR      r1,|L51.8|
;;;3970   	{
;;;3971   	TaskHandle_t xReturn;
;;;3972   
;;;3973   		/* A critical section is not required as this is not called from
;;;3974   		an interrupt and the current TCB will always be the same for any
;;;3975   		individual execution thread. */
;;;3976   		xReturn = pxCurrentTCB;
000002  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
;;;3977   
;;;3978   		return xReturn;
;;;3979   	}
000004  4770              BX       lr
;;;3980   
                          ENDP

000006  0000              DCW      0x0000
                  |L51.8|
                          DCD      pxCurrentTCB

                          AREA ||i.xTaskGetSchedulerState||, CODE, READONLY, ALIGN=2

                  xTaskGetSchedulerState PROC
;;;3985   
;;;3986   	BaseType_t xTaskGetSchedulerState( void )
000000  4905              LDR      r1,|L52.24|
;;;3987   	{
;;;3988   	BaseType_t xReturn;
;;;3989   
;;;3990   		if( xSchedulerRunning == pdFALSE )
000002  6809              LDR      r1,[r1,#0]  ; xSchedulerRunning
000004  b909              CBNZ     r1,|L52.10|
;;;3991   		{
;;;3992   			xReturn = taskSCHEDULER_NOT_STARTED;
000006  2001              MOVS     r0,#1
000008  e005              B        |L52.22|
                  |L52.10|
;;;3993   		}
;;;3994   		else
;;;3995   		{
;;;3996   			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
00000a  4904              LDR      r1,|L52.28|
00000c  6809              LDR      r1,[r1,#0]  ; uxSchedulerSuspended
00000e  b909              CBNZ     r1,|L52.20|
;;;3997   			{
;;;3998   				xReturn = taskSCHEDULER_RUNNING;
000010  2002              MOVS     r0,#2
000012  e000              B        |L52.22|
                  |L52.20|
;;;3999   			}
;;;4000   			else
;;;4001   			{
;;;4002   				xReturn = taskSCHEDULER_SUSPENDED;
000014  2000              MOVS     r0,#0
                  |L52.22|
;;;4003   			}
;;;4004   		}
;;;4005   
;;;4006   		return xReturn;
;;;4007   	}
000016  4770              BX       lr
;;;4008   
                          ENDP

                  |L52.24|
                          DCD      xSchedulerRunning
                  |L52.28|
                          DCD      uxSchedulerSuspended

                          AREA ||i.xTaskGetTickCount||, CODE, READONLY, ALIGN=2

                  xTaskGetTickCount PROC
;;;2303   
;;;2304   TickType_t xTaskGetTickCount( void )
000000  4901              LDR      r1,|L53.8|
;;;2305   {
;;;2306   TickType_t xTicks;
;;;2307   
;;;2308   	/* Critical section required if running on a 16 bit processor. */
;;;2309   	portTICK_TYPE_ENTER_CRITICAL();
;;;2310   	{
;;;2311   		xTicks = xTickCount;
000002  6808              LDR      r0,[r1,#0]  ; xTickCount
;;;2312   	}
;;;2313   	portTICK_TYPE_EXIT_CRITICAL();
;;;2314   
;;;2315   	return xTicks;
;;;2316   }
000004  4770              BX       lr
;;;2317   /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L53.8|
                          DCD      xTickCount

                          AREA ||i.xTaskGetTickCountFromISR||, CODE, READONLY, ALIGN=2

                  xTaskGetTickCountFromISR PROC
;;;2318   
;;;2319   TickType_t xTaskGetTickCountFromISR( void )
000000  b570              PUSH     {r4-r6,lr}
;;;2320   {
;;;2321   TickType_t xReturn;
;;;2322   UBaseType_t uxSavedInterruptStatus;
;;;2323   
;;;2324   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;2325   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;2326   	above the maximum system call priority are kept permanently enabled, even
;;;2327   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;2328   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;2329   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;2330   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;2331   	assigned a priority above the configured maximum system call priority.
;;;2332   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;2333   	that have been assigned a priority at or (logically) below the maximum
;;;2334   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;2335   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;2336   	More information (albeit Cortex-M specific) is provided on the following
;;;2337   	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;2338   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000002  f7fffffe          BL       vPortValidateInterruptPriority
;;;2339   
;;;2340   	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
000006  2500              MOVS     r5,#0
;;;2341   	{
;;;2342   		xReturn = xTickCount;
000008  4801              LDR      r0,|L54.16|
00000a  6804              LDR      r4,[r0,#0]  ; xTickCount
;;;2343   	}
;;;2344   	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;2345   
;;;2346   	return xReturn;
00000c  4620              MOV      r0,r4
;;;2347   }
00000e  bd70              POP      {r4-r6,pc}
;;;2348   /*-----------------------------------------------------------*/
                          ENDP

                  |L54.16|
                          DCD      xTickCount

                          AREA ||i.xTaskIncrementTick||, CODE, READONLY, ALIGN=2

                  xTaskIncrementTick PROC
;;;2706   
;;;2707   BaseType_t xTaskIncrementTick( void )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2708   {
;;;2709   TCB_t * pxTCB;
;;;2710   TickType_t xItemValue;
;;;2711   BaseType_t xSwitchRequired = pdFALSE;
000004  f04f0800          MOV      r8,#0
;;;2712   
;;;2713   	/* Called by the portable layer each time a tick interrupt occurs.
;;;2714   	Increments the tick then checks to see if the new tick value will cause any
;;;2715   	tasks to be unblocked. */
;;;2716   	traceTASK_INCREMENT_TICK( xTickCount );
;;;2717   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000008  4843              LDR      r0,|L55.280|
00000a  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00000c  2800              CMP      r0,#0
00000e  d17b              BNE      |L55.264|
;;;2718   	{
;;;2719   		/* Minor optimisation.  The tick count cannot change in this
;;;2720   		block. */
;;;2721   		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
000010  4842              LDR      r0,|L55.284|
000012  6800              LDR      r0,[r0,#0]  ; xTickCount
000014  1c45              ADDS     r5,r0,#1
;;;2722   
;;;2723   		/* Increment the RTOS tick, switching the delayed and overflowed
;;;2724   		delayed lists if it wraps to 0. */
;;;2725   		xTickCount = xConstTickCount;
000016  4841              LDR      r0,|L55.284|
000018  6005              STR      r5,[r0,#0]  ; xTickCount
;;;2726   
;;;2727   		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
00001a  bb15              CBNZ     r5,|L55.98|
;;;2728   		{
;;;2729   			taskSWITCH_DELAYED_LISTS();
00001c  4840              LDR      r0,|L55.288|
00001e  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
000020  6800              LDR      r0,[r0,#0]
000022  b908              CBNZ     r0,|L55.40|
000024  2001              MOVS     r0,#1
000026  e000              B        |L55.42|
                  |L55.40|
000028  2000              MOVS     r0,#0
                  |L55.42|
00002a  b950              CBNZ     r0,|L55.66|
00002c  bf00              NOP      
00002e  2050              MOVS     r0,#0x50
000030  f3808811          MSR      BASEPRI,r0
000034  f3bf8f4f          DSB      
000038  f3bf8f6f          ISB      
00003c  bf00              NOP      
00003e  bf00              NOP      
                  |L55.64|
000040  e7fe              B        |L55.64|
                  |L55.66|
000042  4837              LDR      r0,|L55.288|
000044  6807              LDR      r7,[r0,#0]  ; pxDelayedTaskList
000046  4837              LDR      r0,|L55.292|
000048  6800              LDR      r0,[r0,#0]  ; pxOverflowDelayedTaskList
00004a  4935              LDR      r1,|L55.288|
00004c  6008              STR      r0,[r1,#0]  ; pxDelayedTaskList
00004e  4835              LDR      r0,|L55.292|
000050  6007              STR      r7,[r0,#0]  ; pxOverflowDelayedTaskList
000052  4835              LDR      r0,|L55.296|
000054  6800              LDR      r0,[r0,#0]  ; xNumOfOverflows
000056  1c40              ADDS     r0,r0,#1
000058  4933              LDR      r1,|L55.296|
00005a  6008              STR      r0,[r1,#0]  ; xNumOfOverflows
00005c  f7fffffe          BL       prvResetNextTaskUnblockTime
000060  bf00              NOP      
                  |L55.98|
;;;2730   		}
;;;2731   		else
;;;2732   		{
;;;2733   			mtCOVERAGE_TEST_MARKER();
;;;2734   		}
;;;2735   
;;;2736   		/* See if this tick has made a timeout expire.  Tasks are stored in
;;;2737   		the	queue in the order of their wake time - meaning once one task
;;;2738   		has been found whose block time has not expired there is no need to
;;;2739   		look any further down the list. */
;;;2740   		if( xConstTickCount >= xNextTaskUnblockTime )
000062  4832              LDR      r0,|L55.300|
000064  6800              LDR      r0,[r0,#0]  ; xNextTaskUnblockTime
000066  4285              CMP      r5,r0
000068  d33b              BCC      |L55.226|
;;;2741   		{
;;;2742   			for( ;; )
00006a  bf00              NOP      
                  |L55.108|
;;;2743   			{
;;;2744   				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
00006c  482c              LDR      r0,|L55.288|
00006e  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
000070  6800              LDR      r0,[r0,#0]
000072  b908              CBNZ     r0,|L55.120|
000074  2001              MOVS     r0,#1
000076  e000              B        |L55.122|
                  |L55.120|
000078  2000              MOVS     r0,#0
                  |L55.122|
00007a  b120              CBZ      r0,|L55.134|
;;;2745   				{
;;;2746   					/* The delayed list is empty.  Set xNextTaskUnblockTime
;;;2747   					to the maximum possible value so it is extremely
;;;2748   					unlikely that the
;;;2749   					if( xTickCount >= xNextTaskUnblockTime ) test will pass
;;;2750   					next time through. */
;;;2751   					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00007c  f04f30ff          MOV      r0,#0xffffffff
000080  492a              LDR      r1,|L55.300|
000082  6008              STR      r0,[r1,#0]  ; xNextTaskUnblockTime
;;;2752   					break;
000084  e02c              B        |L55.224|
                  |L55.134|
;;;2753   				}
;;;2754   				else
;;;2755   				{
;;;2756   					/* The delayed list is not empty, get the value of the
;;;2757   					item at the head of the delayed list.  This is the time
;;;2758   					at which the task at the head of the delayed list must
;;;2759   					be removed from the Blocked state. */
;;;2760   					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000086  4826              LDR      r0,|L55.288|
000088  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
00008a  68c0              LDR      r0,[r0,#0xc]
00008c  68c4              LDR      r4,[r0,#0xc]
;;;2761   					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
00008e  6866              LDR      r6,[r4,#4]
;;;2762   
;;;2763   					if( xConstTickCount < xItemValue )
000090  42b5              CMP      r5,r6
000092  d202              BCS      |L55.154|
;;;2764   					{
;;;2765   						/* It is not time to unblock this item yet, but the
;;;2766   						item value is the time at which the task at the head
;;;2767   						of the blocked list must be removed from the Blocked
;;;2768   						state -	so record the item value in
;;;2769   						xNextTaskUnblockTime. */
;;;2770   						xNextTaskUnblockTime = xItemValue;
000094  4825              LDR      r0,|L55.300|
000096  6006              STR      r6,[r0,#0]  ; xNextTaskUnblockTime
;;;2771   						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
000098  e022              B        |L55.224|
                  |L55.154|
;;;2772   					}
;;;2773   					else
;;;2774   					{
;;;2775   						mtCOVERAGE_TEST_MARKER();
;;;2776   					}
;;;2777   
;;;2778   					/* It is time to remove the item from the Blocked state. */
;;;2779   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
00009a  1d20              ADDS     r0,r4,#4
00009c  f7fffffe          BL       uxListRemove
;;;2780   
;;;2781   					/* Is the task waiting on an event also?  If so remove
;;;2782   					it from the event list. */
;;;2783   					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
0000a0  6aa0              LDR      r0,[r4,#0x28]
0000a2  b118              CBZ      r0,|L55.172|
;;;2784   					{
;;;2785   						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
0000a4  f1040018          ADD      r0,r4,#0x18
0000a8  f7fffffe          BL       uxListRemove
                  |L55.172|
;;;2786   					}
;;;2787   					else
;;;2788   					{
;;;2789   						mtCOVERAGE_TEST_MARKER();
;;;2790   					}
;;;2791   
;;;2792   					/* Place the unblocked task into the appropriate ready
;;;2793   					list. */
;;;2794   					prvAddTaskToReadyList( pxTCB );
0000ac  4920              LDR      r1,|L55.304|
0000ae  6ae0              LDR      r0,[r4,#0x2c]
0000b0  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
0000b2  4288              CMP      r0,r1
0000b4  d902              BLS      |L55.188|
0000b6  491e              LDR      r1,|L55.304|
0000b8  6ae0              LDR      r0,[r4,#0x2c]
0000ba  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L55.188|
0000bc  6ae1              LDR      r1,[r4,#0x2c]
0000be  eb010181          ADD      r1,r1,r1,LSL #2
0000c2  4a1c              LDR      r2,|L55.308|
0000c4  eb020081          ADD      r0,r2,r1,LSL #2
0000c8  1d21              ADDS     r1,r4,#4
0000ca  f7fffffe          BL       vListInsertEnd
;;;2795   
;;;2796   					/* A task being unblocked cannot cause an immediate
;;;2797   					context switch if preemption is turned off. */
;;;2798   					#if (  configUSE_PREEMPTION == 1 )
;;;2799   					{
;;;2800   						/* Preemption is on, but a context switch should
;;;2801   						only be performed if the unblocked task has a
;;;2802   						priority that is equal to or higher than the
;;;2803   						currently executing task. */
;;;2804   						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
0000ce  491a              LDR      r1,|L55.312|
0000d0  6ae0              LDR      r0,[r4,#0x2c]
0000d2  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
0000d4  6ac9              LDR      r1,[r1,#0x2c]
0000d6  4288              CMP      r0,r1
0000d8  d3c8              BCC      |L55.108|
;;;2805   						{
;;;2806   							xSwitchRequired = pdTRUE;
0000da  f04f0801          MOV      r8,#1
0000de  e7c5              B        |L55.108|
                  |L55.224|
0000e0  bf00              NOP                            ;2752
                  |L55.226|
;;;2807   						}
;;;2808   						else
;;;2809   						{
;;;2810   							mtCOVERAGE_TEST_MARKER();
;;;2811   						}
;;;2812   					}
;;;2813   					#endif /* configUSE_PREEMPTION */
;;;2814   				}
;;;2815   			}
;;;2816   		}
;;;2817   
;;;2818   		/* Tasks of equal priority to the currently running task will share
;;;2819   		processing time (time slice) if preemption is on, and the application
;;;2820   		writer has not explicitly turned time slicing off. */
;;;2821   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
;;;2822   		{
;;;2823   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
0000e2  4815              LDR      r0,|L55.312|
0000e4  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0000e6  6ac0              LDR      r0,[r0,#0x2c]
0000e8  eb000080          ADD      r0,r0,r0,LSL #2
0000ec  4911              LDR      r1,|L55.308|
0000ee  f8510020          LDR      r0,[r1,r0,LSL #2]
0000f2  2801              CMP      r0,#1
0000f4  d901              BLS      |L55.250|
;;;2824   			{
;;;2825   				xSwitchRequired = pdTRUE;
0000f6  f04f0801          MOV      r8,#1
                  |L55.250|
;;;2826   			}
;;;2827   			else
;;;2828   			{
;;;2829   				mtCOVERAGE_TEST_MARKER();
;;;2830   			}
;;;2831   		}
;;;2832   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
;;;2833   
;;;2834   		#if ( configUSE_TICK_HOOK == 1 )
;;;2835   		{
;;;2836   			/* Guard against the tick hook being called when the pended tick
;;;2837   			count is being unwound (when the scheduler is being unlocked). */
;;;2838   			if( xPendedTicks == ( TickType_t ) 0 )
;;;2839   			{
;;;2840   				vApplicationTickHook();
;;;2841   			}
;;;2842   			else
;;;2843   			{
;;;2844   				mtCOVERAGE_TEST_MARKER();
;;;2845   			}
;;;2846   		}
;;;2847   		#endif /* configUSE_TICK_HOOK */
;;;2848   
;;;2849   		#if ( configUSE_PREEMPTION == 1 )
;;;2850   		{
;;;2851   			if( xYieldPending != pdFALSE )
0000fa  4810              LDR      r0,|L55.316|
0000fc  6800              LDR      r0,[r0,#0]  ; xYieldPending
0000fe  b108              CBZ      r0,|L55.260|
;;;2852   			{
;;;2853   				xSwitchRequired = pdTRUE;
000100  f04f0801          MOV      r8,#1
                  |L55.260|
;;;2854   			}
;;;2855   			else
;;;2856   			{
;;;2857   				mtCOVERAGE_TEST_MARKER();
;;;2858   			}
;;;2859   		}
;;;2860   		#endif /* configUSE_PREEMPTION */
;;;2861   	}
000104  e005              B        |L55.274|
000106  e7ff              B        |L55.264|
                  |L55.264|
;;;2862   	else
;;;2863   	{
;;;2864   		++xPendedTicks;
000108  480d              LDR      r0,|L55.320|
00010a  6800              LDR      r0,[r0,#0]  ; xPendedTicks
00010c  1c40              ADDS     r0,r0,#1
00010e  490c              LDR      r1,|L55.320|
000110  6008              STR      r0,[r1,#0]  ; xPendedTicks
                  |L55.274|
;;;2865   
;;;2866   		/* The tick hook gets called at regular intervals, even if the
;;;2867   		scheduler is locked. */
;;;2868   		#if ( configUSE_TICK_HOOK == 1 )
;;;2869   		{
;;;2870   			vApplicationTickHook();
;;;2871   		}
;;;2872   		#endif
;;;2873   	}
;;;2874   
;;;2875   	return xSwitchRequired;
000112  4640              MOV      r0,r8
;;;2876   }
000114  e8bd81f0          POP      {r4-r8,pc}
;;;2877   /*-----------------------------------------------------------*/
                          ENDP

                  |L55.280|
                          DCD      uxSchedulerSuspended
                  |L55.284|
                          DCD      xTickCount
                  |L55.288|
                          DCD      pxDelayedTaskList
                  |L55.292|
                          DCD      pxOverflowDelayedTaskList
                  |L55.296|
                          DCD      xNumOfOverflows
                  |L55.300|
                          DCD      xNextTaskUnblockTime
                  |L55.304|
                          DCD      uxTopReadyPriority
                  |L55.308|
                          DCD      pxReadyTasksLists
                  |L55.312|
                          DCD      pxCurrentTCB
                  |L55.316|
                          DCD      xYieldPending
                  |L55.320|
                          DCD      xPendedTicks

                          AREA ||i.xTaskNotifyStateClear||, CODE, READONLY, ALIGN=2

                  xTaskNotifyStateClear PROC
;;;5111   
;;;5112   	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
000000  b570              PUSH     {r4-r6,lr}
;;;5113   	{
000002  4605              MOV      r5,r0
;;;5114   	TCB_t *pxTCB;
;;;5115   	BaseType_t xReturn;
;;;5116   
;;;5117   		/* If null is passed in here then it is the calling task that is having
;;;5118   		its notification state cleared. */
;;;5119   		pxTCB = prvGetTCBFromHandle( xTask );
000004  b915              CBNZ     r5,|L56.12|
000006  480a              LDR      r0,|L56.48|
000008  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000a  e000              B        |L56.14|
                  |L56.12|
00000c  4628              MOV      r0,r5
                  |L56.14|
00000e  4606              MOV      r6,r0
;;;5120   
;;;5121   		taskENTER_CRITICAL();
000010  f7fffffe          BL       vPortEnterCritical
;;;5122   		{
;;;5123   			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
000014  f8960058          LDRB     r0,[r6,#0x58]
000018  2802              CMP      r0,#2
00001a  d104              BNE      |L56.38|
;;;5124   			{
;;;5125   				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
00001c  2000              MOVS     r0,#0
00001e  f8860058          STRB     r0,[r6,#0x58]
;;;5126   				xReturn = pdPASS;
000022  2401              MOVS     r4,#1
000024  e000              B        |L56.40|
                  |L56.38|
;;;5127   			}
;;;5128   			else
;;;5129   			{
;;;5130   				xReturn = pdFAIL;
000026  2400              MOVS     r4,#0
                  |L56.40|
;;;5131   			}
;;;5132   		}
;;;5133   		taskEXIT_CRITICAL();
000028  f7fffffe          BL       vPortExitCritical
;;;5134   
;;;5135   		return xReturn;
00002c  4620              MOV      r0,r4
;;;5136   	}
00002e  bd70              POP      {r4-r6,pc}
;;;5137   
                          ENDP

                  |L56.48|
                          DCD      pxCurrentTCB

                          AREA ||i.xTaskNotifyWait||, CODE, READONLY, ALIGN=2

                  xTaskNotifyWait PROC
;;;4702   
;;;4703   	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4704   	{
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;4705   	BaseType_t xReturn;
;;;4706   
;;;4707   		taskENTER_CRITICAL();
00000c  f7fffffe          BL       vPortEnterCritical
;;;4708   		{
;;;4709   			/* Only block if a notification is not already pending. */
;;;4710   			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
000010  4821              LDR      r0,|L57.152|
000012  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000014  f8900058          LDRB     r0,[r0,#0x58]
000018  2802              CMP      r0,#2
00001a  d018              BEQ      |L57.78|
;;;4711   			{
;;;4712   				/* Clear bits in the task's notification value as bits may get
;;;4713   				set	by the notifying task or interrupt.  This can be used to
;;;4714   				clear the value to zero. */
;;;4715   				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
00001c  491e              LDR      r1,|L57.152|
00001e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000020  f1010054          ADD      r0,r1,#0x54
000024  6d49              LDR      r1,[r1,#0x54]
000026  43b9              BICS     r1,r1,r7
000028  6001              STR      r1,[r0,#0]
;;;4716   
;;;4717   				/* Mark this task as waiting for a notification. */
;;;4718   				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
00002a  2001              MOVS     r0,#1
00002c  491a              LDR      r1,|L57.152|
00002e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000030  f8810058          STRB     r0,[r1,#0x58]
;;;4719   
;;;4720   				if( xTicksToWait > ( TickType_t ) 0 )
000034  b15d              CBZ      r5,|L57.78|
;;;4721   				{
;;;4722   					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
000036  2101              MOVS     r1,#1
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;4723   					traceTASK_NOTIFY_WAIT_BLOCK();
;;;4724   
;;;4725   					/* All ports are written to allow a yield in a critical
;;;4726   					section (some will yield immediately, others wait until the
;;;4727   					critical section exits) - but it is not something that
;;;4728   					application code should ever do. */
;;;4729   					portYIELD_WITHIN_API();
00003e  f04f5080          MOV      r0,#0x10000000
000042  4916              LDR      r1,|L57.156|
000044  6008              STR      r0,[r1,#0]
000046  f3bf8f4f          DSB      
00004a  f3bf8f6f          ISB      
                  |L57.78|
;;;4730   				}
;;;4731   				else
;;;4732   				{
;;;4733   					mtCOVERAGE_TEST_MARKER();
;;;4734   				}
;;;4735   			}
;;;4736   			else
;;;4737   			{
;;;4738   				mtCOVERAGE_TEST_MARKER();
;;;4739   			}
;;;4740   		}
;;;4741   		taskEXIT_CRITICAL();
00004e  f7fffffe          BL       vPortExitCritical
;;;4742   
;;;4743   		taskENTER_CRITICAL();
000052  f7fffffe          BL       vPortEnterCritical
;;;4744   		{
;;;4745   			traceTASK_NOTIFY_WAIT();
;;;4746   
;;;4747   			if( pulNotificationValue != NULL )
000056  b11c              CBZ      r4,|L57.96|
;;;4748   			{
;;;4749   				/* Output the current notification value, which may or may not
;;;4750   				have changed. */
;;;4751   				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
000058  480f              LDR      r0,|L57.152|
00005a  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00005c  6d40              LDR      r0,[r0,#0x54]
00005e  6020              STR      r0,[r4,#0]
                  |L57.96|
;;;4752   			}
;;;4753   
;;;4754   			/* If ucNotifyValue is set then either the task never entered the
;;;4755   			blocked state (because a notification was already pending) or the
;;;4756   			task unblocked because of a notification.  Otherwise the task
;;;4757   			unblocked because of a timeout. */
;;;4758   			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
000060  480d              LDR      r0,|L57.152|
000062  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000064  f8900058          LDRB     r0,[r0,#0x58]
000068  2802              CMP      r0,#2
00006a  d001              BEQ      |L57.112|
;;;4759   			{
;;;4760   				/* A notification was not received. */
;;;4761   				xReturn = pdFALSE;
00006c  2600              MOVS     r6,#0
00006e  e008              B        |L57.130|
                  |L57.112|
;;;4762   			}
;;;4763   			else
;;;4764   			{
;;;4765   				/* A notification was already pending or a notification was
;;;4766   				received while the task was waiting. */
;;;4767   				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
000070  4909              LDR      r1,|L57.152|
000072  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000074  f1010054          ADD      r0,r1,#0x54
000078  6d49              LDR      r1,[r1,#0x54]
00007a  ea210108          BIC      r1,r1,r8
00007e  6001              STR      r1,[r0,#0]
;;;4768   				xReturn = pdTRUE;
000080  2601              MOVS     r6,#1
                  |L57.130|
;;;4769   			}
;;;4770   
;;;4771   			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
000082  2000              MOVS     r0,#0
000084  4904              LDR      r1,|L57.152|
000086  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000088  f8810058          STRB     r0,[r1,#0x58]
;;;4772   		}
;;;4773   		taskEXIT_CRITICAL();
00008c  f7fffffe          BL       vPortExitCritical
;;;4774   
;;;4775   		return xReturn;
000090  4630              MOV      r0,r6
;;;4776   	}
000092  e8bd81f0          POP      {r4-r8,pc}
;;;4777   
                          ENDP

000096  0000              DCW      0x0000
                  |L57.152|
                          DCD      pxCurrentTCB
                  |L57.156|
                          DCD      0xe000ed04

                          AREA ||i.xTaskPriorityDisinherit||, CODE, READONLY, ALIGN=2

                  xTaskPriorityDisinherit PROC
;;;4103   
;;;4104   	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
000000  b570              PUSH     {r4-r6,lr}
;;;4105   	{
000002  4605              MOV      r5,r0
;;;4106   	TCB_t * const pxTCB = pxMutexHolder;
000004  462c              MOV      r4,r5
;;;4107   	BaseType_t xReturn = pdFALSE;
000006  2600              MOVS     r6,#0
;;;4108   
;;;4109   		if( pxMutexHolder != NULL )
000008  2d00              CMP      r5,#0
00000a  d043              BEQ      |L58.148|
;;;4110   		{
;;;4111   			/* A task can only have an inherited priority if it holds the mutex.
;;;4112   			If the mutex is held by a task then it cannot be given from an
;;;4113   			interrupt, and if a mutex is given by the holding task then it must
;;;4114   			be the running state task. */
;;;4115   			configASSERT( pxTCB == pxCurrentTCB );
00000c  4822              LDR      r0,|L58.152|
00000e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000010  4284              CMP      r4,r0
000012  d101              BNE      |L58.24|
000014  2001              MOVS     r0,#1
000016  e000              B        |L58.26|
                  |L58.24|
000018  2000              MOVS     r0,#0
                  |L58.26|
00001a  b950              CBNZ     r0,|L58.50|
00001c  bf00              NOP      
00001e  2050              MOVS     r0,#0x50
000020  f3808811          MSR      BASEPRI,r0
000024  f3bf8f4f          DSB      
000028  f3bf8f6f          ISB      
00002c  bf00              NOP      
00002e  bf00              NOP      
                  |L58.48|
000030  e7fe              B        |L58.48|
                  |L58.50|
;;;4116   			configASSERT( pxTCB->uxMutexesHeld );
000032  6d20              LDR      r0,[r4,#0x50]
000034  b950              CBNZ     r0,|L58.76|
000036  bf00              NOP      
000038  2050              MOVS     r0,#0x50
00003a  f3808811          MSR      BASEPRI,r0
00003e  f3bf8f4f          DSB      
000042  f3bf8f6f          ISB      
000046  bf00              NOP      
000048  bf00              NOP      
                  |L58.74|
00004a  e7fe              B        |L58.74|
                  |L58.76|
;;;4117   			( pxTCB->uxMutexesHeld )--;
00004c  6d20              LDR      r0,[r4,#0x50]
00004e  1e40              SUBS     r0,r0,#1
000050  6520              STR      r0,[r4,#0x50]
;;;4118   
;;;4119   			/* Has the holder of the mutex inherited the priority of another
;;;4120   			task? */
;;;4121   			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
000052  6ce1              LDR      r1,[r4,#0x4c]
000054  6ae0              LDR      r0,[r4,#0x2c]
000056  4288              CMP      r0,r1
000058  d01c              BEQ      |L58.148|
;;;4122   			{
;;;4123   				/* Only disinherit if no other mutexes are held. */
;;;4124   				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
00005a  6d20              LDR      r0,[r4,#0x50]
00005c  b9d0              CBNZ     r0,|L58.148|
;;;4125   				{
;;;4126   					/* A task can only have an inherited priority if it holds
;;;4127   					the mutex.  If the mutex is held by a task then it cannot be
;;;4128   					given from an interrupt, and if a mutex is given by the
;;;4129   					holding task then it must be the running state task.  Remove
;;;4130   					the holding task from the ready/delayed list. */
;;;4131   					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
00005e  1d20              ADDS     r0,r4,#4
000060  f7fffffe          BL       uxListRemove
;;;4132   					{
;;;4133   						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
;;;4134   					}
;;;4135   					else
;;;4136   					{
;;;4137   						mtCOVERAGE_TEST_MARKER();
;;;4138   					}
;;;4139   
;;;4140   					/* Disinherit the priority before adding the task into the
;;;4141   					new	ready list. */
;;;4142   					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
;;;4143   					pxTCB->uxPriority = pxTCB->uxBasePriority;
000064  6ce0              LDR      r0,[r4,#0x4c]
000066  62e0              STR      r0,[r4,#0x2c]
;;;4144   
;;;4145   					/* Reset the event list item value.  It cannot be in use for
;;;4146   					any other purpose if this task is running, and it must be
;;;4147   					running to give back the mutex. */
;;;4148   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000068  6ae0              LDR      r0,[r4,#0x2c]
00006a  f1c00038          RSB      r0,r0,#0x38
00006e  61a0              STR      r0,[r4,#0x18]
;;;4149   					prvAddTaskToReadyList( pxTCB );
000070  490a              LDR      r1,|L58.156|
000072  6ae0              LDR      r0,[r4,#0x2c]
000074  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000076  4288              CMP      r0,r1
000078  d902              BLS      |L58.128|
00007a  4908              LDR      r1,|L58.156|
00007c  6ae0              LDR      r0,[r4,#0x2c]
00007e  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L58.128|
000080  6ae1              LDR      r1,[r4,#0x2c]
000082  eb010181          ADD      r1,r1,r1,LSL #2
000086  4a06              LDR      r2,|L58.160|
000088  eb020081          ADD      r0,r2,r1,LSL #2
00008c  1d21              ADDS     r1,r4,#4
00008e  f7fffffe          BL       vListInsertEnd
;;;4150   
;;;4151   					/* Return true to indicate that a context switch is required.
;;;4152   					This is only actually required in the corner case whereby
;;;4153   					multiple mutexes were held and the mutexes were given back
;;;4154   					in an order different to that in which they were taken.
;;;4155   					If a context switch did not occur when the first mutex was
;;;4156   					returned, even if a task was waiting on it, then a context
;;;4157   					switch should occur when the last mutex is returned whether
;;;4158   					a task is waiting on it or not. */
;;;4159   					xReturn = pdTRUE;
000092  2601              MOVS     r6,#1
                  |L58.148|
;;;4160   				}
;;;4161   				else
;;;4162   				{
;;;4163   					mtCOVERAGE_TEST_MARKER();
;;;4164   				}
;;;4165   			}
;;;4166   			else
;;;4167   			{
;;;4168   				mtCOVERAGE_TEST_MARKER();
;;;4169   			}
;;;4170   		}
;;;4171   		else
;;;4172   		{
;;;4173   			mtCOVERAGE_TEST_MARKER();
;;;4174   		}
;;;4175   
;;;4176   		return xReturn;
000094  4630              MOV      r0,r6
;;;4177   	}
000096  bd70              POP      {r4-r6,pc}
;;;4178   
                          ENDP

                  |L58.152|
                          DCD      pxCurrentTCB
                  |L58.156|
                          DCD      uxTopReadyPriority
                  |L58.160|
                          DCD      pxReadyTasksLists

                          AREA ||i.xTaskPriorityInherit||, CODE, READONLY, ALIGN=2

                  xTaskPriorityInherit PROC
;;;4013   
;;;4014   	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
000000  b570              PUSH     {r4-r6,lr}
;;;4015   	{
000002  4605              MOV      r5,r0
;;;4016   	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
000004  462c              MOV      r4,r5
;;;4017   	BaseType_t xReturn = pdFALSE;
000006  2600              MOVS     r6,#0
;;;4018   
;;;4019   		/* If the mutex was given back by an interrupt while the queue was
;;;4020   		locked then the mutex holder might now be NULL.  _RB_ Is this still
;;;4021   		needed as interrupts can no longer use mutexes? */
;;;4022   		if( pxMutexHolder != NULL )
000008  2d00              CMP      r5,#0
00000a  d042              BEQ      |L59.146|
;;;4023   		{
;;;4024   			/* If the holder of the mutex has a priority below the priority of
;;;4025   			the task attempting to obtain the mutex then it will temporarily
;;;4026   			inherit the priority of the task attempting to obtain the mutex. */
;;;4027   			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
00000c  4922              LDR      r1,|L59.152|
00000e  6ae0              LDR      r0,[r4,#0x2c]
000010  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000012  6ac9              LDR      r1,[r1,#0x2c]
000014  4288              CMP      r0,r1
000016  d235              BCS      |L59.132|
;;;4028   			{
;;;4029   				/* Adjust the mutex holder state to account for its new
;;;4030   				priority.  Only reset the event list item value if the value is
;;;4031   				not being used for anything else. */
;;;4032   				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
000018  69a0              LDR      r0,[r4,#0x18]
00001a  f0004000          AND      r0,r0,#0x80000000
00001e  b928              CBNZ     r0,|L59.44|
;;;4033   				{
;;;4034   					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000020  481d              LDR      r0,|L59.152|
000022  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000024  6ac0              LDR      r0,[r0,#0x2c]
000026  f1c00038          RSB      r0,r0,#0x38
00002a  61a0              STR      r0,[r4,#0x18]
                  |L59.44|
;;;4035   				}
;;;4036   				else
;;;4037   				{
;;;4038   					mtCOVERAGE_TEST_MARKER();
;;;4039   				}
;;;4040   
;;;4041   				/* If the task being modified is in the ready state it will need
;;;4042   				to be moved into a new list. */
;;;4043   				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
00002c  6ae1              LDR      r1,[r4,#0x2c]
00002e  eb010181          ADD      r1,r1,r1,LSL #2
000032  4a1a              LDR      r2,|L59.156|
000034  eb020181          ADD      r1,r2,r1,LSL #2
000038  6960              LDR      r0,[r4,#0x14]
00003a  4288              CMP      r0,r1
00003c  d101              BNE      |L59.66|
00003e  2001              MOVS     r0,#1
000040  e000              B        |L59.68|
                  |L59.66|
000042  2000              MOVS     r0,#0
                  |L59.68|
000044  b1c0              CBZ      r0,|L59.120|
;;;4044   				{
;;;4045   					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000046  1d20              ADDS     r0,r4,#4
000048  f7fffffe          BL       uxListRemove
;;;4046   					{
;;;4047   						/* It is known that the task is in its ready list so
;;;4048   						there is no need to check again and the port level
;;;4049   						reset macro can be called directly. */
;;;4050   						portRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority, uxTopReadyPriority );
;;;4051   					}
;;;4052   					else
;;;4053   					{
;;;4054   						mtCOVERAGE_TEST_MARKER();
;;;4055   					}
;;;4056   
;;;4057   					/* Inherit the priority before being moved into the new list. */
;;;4058   					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
00004c  4812              LDR      r0,|L59.152|
00004e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000050  6ac0              LDR      r0,[r0,#0x2c]
000052  62e0              STR      r0,[r4,#0x2c]
;;;4059   					prvAddTaskToReadyList( pxMutexHolderTCB );
000054  4912              LDR      r1,|L59.160|
000056  6ae0              LDR      r0,[r4,#0x2c]
000058  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00005a  4288              CMP      r0,r1
00005c  d902              BLS      |L59.100|
00005e  4910              LDR      r1,|L59.160|
000060  6ae0              LDR      r0,[r4,#0x2c]
000062  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L59.100|
000064  6ae1              LDR      r1,[r4,#0x2c]
000066  eb010181          ADD      r1,r1,r1,LSL #2
00006a  4a0c              LDR      r2,|L59.156|
00006c  eb020081          ADD      r0,r2,r1,LSL #2
000070  1d21              ADDS     r1,r4,#4
000072  f7fffffe          BL       vListInsertEnd
000076  e003              B        |L59.128|
                  |L59.120|
;;;4060   				}
;;;4061   				else
;;;4062   				{
;;;4063   					/* Just inherit the priority. */
;;;4064   					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
000078  4807              LDR      r0,|L59.152|
00007a  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00007c  6ac0              LDR      r0,[r0,#0x2c]
00007e  62e0              STR      r0,[r4,#0x2c]
                  |L59.128|
;;;4065   				}
;;;4066   
;;;4067   				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
;;;4068   
;;;4069   				/* Inheritance occurred. */
;;;4070   				xReturn = pdTRUE;
000080  2601              MOVS     r6,#1
000082  e006              B        |L59.146|
                  |L59.132|
;;;4071   			}
;;;4072   			else
;;;4073   			{
;;;4074   				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
000084  4904              LDR      r1,|L59.152|
000086  6ce0              LDR      r0,[r4,#0x4c]
000088  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00008a  6ac9              LDR      r1,[r1,#0x2c]
00008c  4288              CMP      r0,r1
00008e  d200              BCS      |L59.146|
;;;4075   				{
;;;4076   					/* The base priority of the mutex holder is lower than the
;;;4077   					priority of the task attempting to take the mutex, but the
;;;4078   					current priority of the mutex holder is not lower than the
;;;4079   					priority of the task attempting to take the mutex.
;;;4080   					Therefore the mutex holder must have already inherited a
;;;4081   					priority, but inheritance would have occurred if that had
;;;4082   					not been the case. */
;;;4083   					xReturn = pdTRUE;
000090  2601              MOVS     r6,#1
                  |L59.146|
;;;4084   				}
;;;4085   				else
;;;4086   				{
;;;4087   					mtCOVERAGE_TEST_MARKER();
;;;4088   				}
;;;4089   			}
;;;4090   		}
;;;4091   		else
;;;4092   		{
;;;4093   			mtCOVERAGE_TEST_MARKER();
;;;4094   		}
;;;4095   
;;;4096   		return xReturn;
000092  4630              MOV      r0,r6
;;;4097   	}
000094  bd70              POP      {r4-r6,pc}
;;;4098   
                          ENDP

000096  0000              DCW      0x0000
                  |L59.152|
                          DCD      pxCurrentTCB
                  |L59.156|
                          DCD      pxReadyTasksLists
                  |L59.160|
                          DCD      uxTopReadyPriority

                          AREA ||i.xTaskRemoveFromEventList||, CODE, READONLY, ALIGN=2

                  xTaskRemoveFromEventList PROC
;;;3137   
;;;3138   BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
000000  b570              PUSH     {r4-r6,lr}
;;;3139   {
000002  4606              MOV      r6,r0
;;;3140   TCB_t *pxUnblockedTCB;
;;;3141   BaseType_t xReturn;
;;;3142   
;;;3143   	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
;;;3144   	called from a critical section within an ISR. */
;;;3145   
;;;3146   	/* The event list is sorted in priority order, so the first in the list can
;;;3147   	be removed as it is known to be the highest priority.  Remove the TCB from
;;;3148   	the delayed list, and add it to the ready list.
;;;3149   
;;;3150   	If an event is for a queue that is locked then this function will never
;;;3151   	get called - the lock count on the queue will get modified instead.  This
;;;3152   	means exclusive access to the event list is guaranteed here.
;;;3153   
;;;3154   	This function assumes that a check has already been made to ensure that
;;;3155   	pxEventList is not empty. */
;;;3156   	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000004  68f0              LDR      r0,[r6,#0xc]
000006  68c4              LDR      r4,[r0,#0xc]
;;;3157   	configASSERT( pxUnblockedTCB );
000008  b954              CBNZ     r4,|L60.32|
00000a  bf00              NOP      
00000c  2050              MOVS     r0,#0x50
00000e  f3808811          MSR      BASEPRI,r0
000012  f3bf8f4f          DSB      
000016  f3bf8f6f          ISB      
00001a  bf00              NOP      
00001c  bf00              NOP      
                  |L60.30|
00001e  e7fe              B        |L60.30|
                  |L60.32|
;;;3158   	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
000020  f1040018          ADD      r0,r4,#0x18
000024  f7fffffe          BL       uxListRemove
;;;3159   
;;;3160   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000028  4815              LDR      r0,|L60.128|
00002a  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00002c  b9a0              CBNZ     r0,|L60.88|
;;;3161   	{
;;;3162   		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
00002e  1d20              ADDS     r0,r4,#4
000030  f7fffffe          BL       uxListRemove
;;;3163   		prvAddTaskToReadyList( pxUnblockedTCB );
000034  4913              LDR      r1,|L60.132|
000036  6ae0              LDR      r0,[r4,#0x2c]
000038  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00003a  4288              CMP      r0,r1
00003c  d902              BLS      |L60.68|
00003e  4911              LDR      r1,|L60.132|
000040  6ae0              LDR      r0,[r4,#0x2c]
000042  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L60.68|
000044  6ae1              LDR      r1,[r4,#0x2c]
000046  eb010181          ADD      r1,r1,r1,LSL #2
00004a  4a0f              LDR      r2,|L60.136|
00004c  eb020081          ADD      r0,r2,r1,LSL #2
000050  1d21              ADDS     r1,r4,#4
000052  f7fffffe          BL       vListInsertEnd
000056  e004              B        |L60.98|
                  |L60.88|
;;;3164   
;;;3165   		#if( configUSE_TICKLESS_IDLE != 0 )
;;;3166   		{
;;;3167   			/* If a task is blocked on a kernel object then xNextTaskUnblockTime
;;;3168   			might be set to the blocked task's time out time.  If the task is
;;;3169   			unblocked for a reason other than a timeout xNextTaskUnblockTime is
;;;3170   			normally left unchanged, because it is automatically reset to a new
;;;3171   			value when the tick count equals xNextTaskUnblockTime.  However if
;;;3172   			tickless idling is used it might be more important to enter sleep mode
;;;3173   			at the earliest possible time - so reset xNextTaskUnblockTime here to
;;;3174   			ensure it is updated at the earliest possible time. */
;;;3175   			prvResetNextTaskUnblockTime();
;;;3176   		}
;;;3177   		#endif
;;;3178   	}
;;;3179   	else
;;;3180   	{
;;;3181   		/* The delayed and ready lists cannot be accessed, so hold this task
;;;3182   		pending until the scheduler is resumed. */
;;;3183   		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
000058  f1040118          ADD      r1,r4,#0x18
00005c  480b              LDR      r0,|L60.140|
00005e  f7fffffe          BL       vListInsertEnd
                  |L60.98|
;;;3184   	}
;;;3185   
;;;3186   	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
000062  490b              LDR      r1,|L60.144|
000064  6ae0              LDR      r0,[r4,#0x2c]
000066  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000068  6ac9              LDR      r1,[r1,#0x2c]
00006a  4288              CMP      r0,r1
00006c  d904              BLS      |L60.120|
;;;3187   	{
;;;3188   		/* Return true if the task removed from the event list has a higher
;;;3189   		priority than the calling task.  This allows the calling task to know if
;;;3190   		it should force a context switch now. */
;;;3191   		xReturn = pdTRUE;
00006e  2501              MOVS     r5,#1
;;;3192   
;;;3193   		/* Mark that a yield is pending in case the user is not using the
;;;3194   		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
;;;3195   		xYieldPending = pdTRUE;
000070  2001              MOVS     r0,#1
000072  4908              LDR      r1,|L60.148|
000074  6008              STR      r0,[r1,#0]  ; xYieldPending
000076  e000              B        |L60.122|
                  |L60.120|
;;;3196   	}
;;;3197   	else
;;;3198   	{
;;;3199   		xReturn = pdFALSE;
000078  2500              MOVS     r5,#0
                  |L60.122|
;;;3200   	}
;;;3201   
;;;3202   	return xReturn;
00007a  4628              MOV      r0,r5
;;;3203   }
00007c  bd70              POP      {r4-r6,pc}
;;;3204   /*-----------------------------------------------------------*/
                          ENDP

00007e  0000              DCW      0x0000
                  |L60.128|
                          DCD      uxSchedulerSuspended
                  |L60.132|
                          DCD      uxTopReadyPriority
                  |L60.136|
                          DCD      pxReadyTasksLists
                  |L60.140|
                          DCD      xPendingReadyList
                  |L60.144|
                          DCD      pxCurrentTCB
                  |L60.148|
                          DCD      xYieldPending

                          AREA ||i.xTaskResumeAll||, CODE, READONLY, ALIGN=2

                  xTaskResumeAll PROC
;;;2193   
;;;2194   BaseType_t xTaskResumeAll( void )
000000  b570              PUSH     {r4-r6,lr}
;;;2195   {
;;;2196   TCB_t *pxTCB = NULL;
000002  2400              MOVS     r4,#0
;;;2197   BaseType_t xAlreadyYielded = pdFALSE;
000004  2600              MOVS     r6,#0
;;;2198   
;;;2199   	/* If uxSchedulerSuspended is zero then this function does not match a
;;;2200   	previous call to vTaskSuspendAll(). */
;;;2201   	configASSERT( uxSchedulerSuspended );
000006  4836              LDR      r0,|L61.224|
000008  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00000a  b950              CBNZ     r0,|L61.34|
00000c  bf00              NOP      
00000e  2050              MOVS     r0,#0x50
000010  f3808811          MSR      BASEPRI,r0
000014  f3bf8f4f          DSB      
000018  f3bf8f6f          ISB      
00001c  bf00              NOP      
00001e  bf00              NOP      
                  |L61.32|
000020  e7fe              B        |L61.32|
                  |L61.34|
;;;2202   
;;;2203   	/* It is possible that an ISR caused a task to be removed from an event
;;;2204   	list while the scheduler was suspended.  If this was the case then the
;;;2205   	removed task will have been added to the xPendingReadyList.  Once the
;;;2206   	scheduler has been resumed it is safe to move all the pending ready
;;;2207   	tasks from this list into their appropriate ready list. */
;;;2208   	taskENTER_CRITICAL();
000022  f7fffffe          BL       vPortEnterCritical
;;;2209   	{
;;;2210   		--uxSchedulerSuspended;
000026  482e              LDR      r0,|L61.224|
000028  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00002a  1e40              SUBS     r0,r0,#1
00002c  492c              LDR      r1,|L61.224|
00002e  6008              STR      r0,[r1,#0]  ; uxSchedulerSuspended
;;;2211   
;;;2212   		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000030  4608              MOV      r0,r1
000032  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000034  2800              CMP      r0,#0
000036  d14e              BNE      |L61.214|
;;;2213   		{
;;;2214   			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
000038  482a              LDR      r0,|L61.228|
00003a  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
00003c  2800              CMP      r0,#0
00003e  d04a              BEQ      |L61.214|
;;;2215   			{
;;;2216   				/* Move any readied tasks from the pending list into the
;;;2217   				appropriate ready list. */
;;;2218   				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
000040  e023              B        |L61.138|
                  |L61.66|
;;;2219   				{
;;;2220   					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000042  4829              LDR      r0,|L61.232|
000044  68c0              LDR      r0,[r0,#0xc]
000046  68c4              LDR      r4,[r0,#0xc]
;;;2221   					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
000048  f1040018          ADD      r0,r4,#0x18
00004c  f7fffffe          BL       uxListRemove
;;;2222   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000050  1d20              ADDS     r0,r4,#4
000052  f7fffffe          BL       uxListRemove
;;;2223   					prvAddTaskToReadyList( pxTCB );
000056  4925              LDR      r1,|L61.236|
000058  6ae0              LDR      r0,[r4,#0x2c]
00005a  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00005c  4288              CMP      r0,r1
00005e  d902              BLS      |L61.102|
000060  4922              LDR      r1,|L61.236|
000062  6ae0              LDR      r0,[r4,#0x2c]
000064  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L61.102|
000066  6ae1              LDR      r1,[r4,#0x2c]
000068  eb010181          ADD      r1,r1,r1,LSL #2
00006c  4a20              LDR      r2,|L61.240|
00006e  eb020081          ADD      r0,r2,r1,LSL #2
000072  1d21              ADDS     r1,r4,#4
000074  f7fffffe          BL       vListInsertEnd
;;;2224   
;;;2225   					/* If the moved task has a priority higher than the current
;;;2226   					task then a yield must be performed. */
;;;2227   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
000078  491e              LDR      r1,|L61.244|
00007a  6ae0              LDR      r0,[r4,#0x2c]
00007c  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00007e  6ac9              LDR      r1,[r1,#0x2c]
000080  4288              CMP      r0,r1
000082  d302              BCC      |L61.138|
;;;2228   					{
;;;2229   						xYieldPending = pdTRUE;
000084  2001              MOVS     r0,#1
000086  491c              LDR      r1,|L61.248|
000088  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L61.138|
00008a  4817              LDR      r0,|L61.232|
00008c  6800              LDR      r0,[r0,#0]            ;2218  ; xPendingReadyList
00008e  b908              CBNZ     r0,|L61.148|
000090  2001              MOVS     r0,#1                 ;2218
000092  e000              B        |L61.150|
                  |L61.148|
000094  2000              MOVS     r0,#0                 ;2218
                  |L61.150|
000096  2800              CMP      r0,#0                 ;2218
000098  d0d3              BEQ      |L61.66|
;;;2230   					}
;;;2231   					else
;;;2232   					{
;;;2233   						mtCOVERAGE_TEST_MARKER();
;;;2234   					}
;;;2235   				}
;;;2236   
;;;2237   				if( pxTCB != NULL )
00009a  b10c              CBZ      r4,|L61.160|
;;;2238   				{
;;;2239   					/* A task was unblocked while the scheduler was suspended,
;;;2240   					which may have prevented the next unblock time from being
;;;2241   					re-calculated, in which case re-calculate it now.  Mainly
;;;2242   					important for low power tickless implementations, where
;;;2243   					this can prevent an unnecessary exit from low power
;;;2244   					state. */
;;;2245   					prvResetNextTaskUnblockTime();
00009c  f7fffffe          BL       prvResetNextTaskUnblockTime
                  |L61.160|
;;;2246   				}
;;;2247   
;;;2248   				/* If any ticks occurred while the scheduler was suspended then
;;;2249   				they should be processed now.  This ensures the tick count does
;;;2250   				not	slip, and that any delayed tasks are resumed at the correct
;;;2251   				time. */
;;;2252   				{
;;;2253   					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
0000a0  4816              LDR      r0,|L61.252|
0000a2  6805              LDR      r5,[r0,#0]  ; xPendedTicks
;;;2254   
;;;2255   					if( xPendedCounts > ( TickType_t ) 0U )
0000a4  b165              CBZ      r5,|L61.192|
;;;2256   					{
;;;2257   						do
0000a6  bf00              NOP      
                  |L61.168|
;;;2258   						{
;;;2259   							if( xTaskIncrementTick() != pdFALSE )
0000a8  f7fffffe          BL       xTaskIncrementTick
0000ac  b110              CBZ      r0,|L61.180|
;;;2260   							{
;;;2261   								xYieldPending = pdTRUE;
0000ae  2001              MOVS     r0,#1
0000b0  4911              LDR      r1,|L61.248|
0000b2  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L61.180|
;;;2262   							}
;;;2263   							else
;;;2264   							{
;;;2265   								mtCOVERAGE_TEST_MARKER();
;;;2266   							}
;;;2267   							--xPendedCounts;
0000b4  1e6d              SUBS     r5,r5,#1
;;;2268   						} while( xPendedCounts > ( TickType_t ) 0U );
0000b6  2d00              CMP      r5,#0
0000b8  d1f6              BNE      |L61.168|
;;;2269   
;;;2270   						xPendedTicks = 0;
0000ba  2000              MOVS     r0,#0
0000bc  490f              LDR      r1,|L61.252|
0000be  6008              STR      r0,[r1,#0]  ; xPendedTicks
                  |L61.192|
;;;2271   					}
;;;2272   					else
;;;2273   					{
;;;2274   						mtCOVERAGE_TEST_MARKER();
;;;2275   					}
;;;2276   				}
;;;2277   
;;;2278   				if( xYieldPending != pdFALSE )
0000c0  480d              LDR      r0,|L61.248|
0000c2  6800              LDR      r0,[r0,#0]  ; xYieldPending
0000c4  b138              CBZ      r0,|L61.214|
;;;2279   				{
;;;2280   					#if( configUSE_PREEMPTION != 0 )
;;;2281   					{
;;;2282   						xAlreadyYielded = pdTRUE;
0000c6  2601              MOVS     r6,#1
;;;2283   					}
;;;2284   					#endif
;;;2285   					taskYIELD_IF_USING_PREEMPTION();
0000c8  0730              LSLS     r0,r6,#28
0000ca  490d              LDR      r1,|L61.256|
0000cc  6008              STR      r0,[r1,#0]
0000ce  f3bf8f4f          DSB      
0000d2  f3bf8f6f          ISB      
                  |L61.214|
;;;2286   				}
;;;2287   				else
;;;2288   				{
;;;2289   					mtCOVERAGE_TEST_MARKER();
;;;2290   				}
;;;2291   			}
;;;2292   		}
;;;2293   		else
;;;2294   		{
;;;2295   			mtCOVERAGE_TEST_MARKER();
;;;2296   		}
;;;2297   	}
;;;2298   	taskEXIT_CRITICAL();
0000d6  f7fffffe          BL       vPortExitCritical
;;;2299   
;;;2300   	return xAlreadyYielded;
0000da  4630              MOV      r0,r6
;;;2301   }
0000dc  bd70              POP      {r4-r6,pc}
;;;2302   /*-----------------------------------------------------------*/
                          ENDP

0000de  0000              DCW      0x0000
                  |L61.224|
                          DCD      uxSchedulerSuspended
                  |L61.228|
                          DCD      uxCurrentNumberOfTasks
                  |L61.232|
                          DCD      xPendingReadyList
                  |L61.236|
                          DCD      uxTopReadyPriority
                  |L61.240|
                          DCD      pxReadyTasksLists
                  |L61.244|
                          DCD      pxCurrentTCB
                  |L61.248|
                          DCD      xYieldPending
                  |L61.252|
                          DCD      xPendedTicks
                  |L61.256|
                          DCD      0xe000ed04

                          AREA ||i.xTaskResumeFromISR||, CODE, READONLY, ALIGN=2

                  xTaskResumeFromISR PROC
;;;1904   
;;;1905   	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1906   	{
000004  4606              MOV      r6,r0
;;;1907   	BaseType_t xYieldRequired = pdFALSE;
000006  2700              MOVS     r7,#0
;;;1908   	TCB_t * const pxTCB = xTaskToResume;
000008  4634              MOV      r4,r6
;;;1909   	UBaseType_t uxSavedInterruptStatus;
;;;1910   
;;;1911   		configASSERT( xTaskToResume );
00000a  b956              CBNZ     r6,|L62.34|
00000c  bf00              NOP      
00000e  2050              MOVS     r0,#0x50
000010  f3808811          MSR      BASEPRI,r0
000014  f3bf8f4f          DSB      
000018  f3bf8f6f          ISB      
00001c  bf00              NOP      
00001e  bf00              NOP      
                  |L62.32|
000020  e7fe              B        |L62.32|
                  |L62.34|
;;;1912   
;;;1913   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1914   		maximum	system call (or maximum API call) interrupt priority.
;;;1915   		Interrupts that are	above the maximum system call priority are keep
;;;1916   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1917   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1918   		is defined in FreeRTOSConfig.h then
;;;1919   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1920   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1921   		been assigned a priority above the configured maximum system call
;;;1922   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1923   		from interrupts	that have been assigned a priority at or (logically)
;;;1924   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1925   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1926   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1927   		provided on the following link:
;;;1928   		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1929   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000022  f7fffffe          BL       vPortValidateInterruptPriority
;;;1930   
;;;1931   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000026  bf00              NOP      
000028  2150              MOVS     r1,#0x50
00002a  f3ef8011          MRS      r0,BASEPRI
00002e  f3818811          MSR      BASEPRI,r1
000032  f3bf8f4f          DSB      
000036  f3bf8f6f          ISB      
00003a  bf00              NOP      
00003c  4605              MOV      r5,r0
;;;1932   		{
;;;1933   			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       prvTaskIsTaskSuspended
000044  b318              CBZ      r0,|L62.142|
;;;1934   			{
;;;1935   				traceTASK_RESUME_FROM_ISR( pxTCB );
;;;1936   
;;;1937   				/* Check the ready lists can be accessed. */
;;;1938   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000046  4815              LDR      r0,|L62.156|
000048  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00004a  b9d8              CBNZ     r0,|L62.132|
;;;1939   				{
;;;1940   					/* Ready lists can be accessed so move the task from the
;;;1941   					suspended list to the ready list directly. */
;;;1942   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
00004c  4914              LDR      r1,|L62.160|
00004e  6ae0              LDR      r0,[r4,#0x2c]
000050  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000052  6ac9              LDR      r1,[r1,#0x2c]
000054  4288              CMP      r0,r1
000056  d300              BCC      |L62.90|
;;;1943   					{
;;;1944   						xYieldRequired = pdTRUE;
000058  2701              MOVS     r7,#1
                  |L62.90|
;;;1945   					}
;;;1946   					else
;;;1947   					{
;;;1948   						mtCOVERAGE_TEST_MARKER();
;;;1949   					}
;;;1950   
;;;1951   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
00005a  1d20              ADDS     r0,r4,#4
00005c  f7fffffe          BL       uxListRemove
;;;1952   					prvAddTaskToReadyList( pxTCB );
000060  4910              LDR      r1,|L62.164|
000062  6ae0              LDR      r0,[r4,#0x2c]
000064  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000066  4288              CMP      r0,r1
000068  d902              BLS      |L62.112|
00006a  490e              LDR      r1,|L62.164|
00006c  6ae0              LDR      r0,[r4,#0x2c]
00006e  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L62.112|
000070  6ae1              LDR      r1,[r4,#0x2c]
000072  eb010181          ADD      r1,r1,r1,LSL #2
000076  4a0c              LDR      r2,|L62.168|
000078  eb020081          ADD      r0,r2,r1,LSL #2
00007c  1d21              ADDS     r1,r4,#4
00007e  f7fffffe          BL       vListInsertEnd
000082  e004              B        |L62.142|
                  |L62.132|
;;;1953   				}
;;;1954   				else
;;;1955   				{
;;;1956   					/* The delayed or ready lists cannot be accessed so the task
;;;1957   					is held in the pending ready list until the scheduler is
;;;1958   					unsuspended. */
;;;1959   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
000084  f1040118          ADD      r1,r4,#0x18
000088  4808              LDR      r0,|L62.172|
00008a  f7fffffe          BL       vListInsertEnd
                  |L62.142|
;;;1960   				}
;;;1961   			}
;;;1962   			else
;;;1963   			{
;;;1964   				mtCOVERAGE_TEST_MARKER();
;;;1965   			}
;;;1966   		}
;;;1967   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
00008e  bf00              NOP      
000090  f3858811          MSR      BASEPRI,r5
000094  bf00              NOP      
;;;1968   
;;;1969   		return xYieldRequired;
000096  4638              MOV      r0,r7
;;;1970   	}
000098  e8bd81f0          POP      {r4-r8,pc}
;;;1971   
                          ENDP

                  |L62.156|
                          DCD      uxSchedulerSuspended
                  |L62.160|
                          DCD      pxCurrentTCB
                  |L62.164|
                          DCD      uxTopReadyPriority
                  |L62.168|
                          DCD      pxReadyTasksLists
                  |L62.172|
                          DCD      xPendingReadyList

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  pxReadyTasksLists
                          %        1120
                  xDelayedTaskList1
                          %        20
                  xDelayedTaskList2
                          %        20
                  xPendingReadyList
                          %        20
                  xTasksWaitingTermination
                          %        20
                  xSuspendedTaskList
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  pxCurrentTCB
                          DCD      0x00000000
                  pxDelayedTaskList
                          DCD      0x00000000
                  pxOverflowDelayedTaskList
                          DCD      0x00000000
                  uxDeletedTasksWaitingCleanUp
                          DCD      0x00000000
                  uxCurrentNumberOfTasks
                          DCD      0x00000000
                  xTickCount
                          DCD      0x00000000
                  uxTopReadyPriority
                          DCD      0x00000000
                  xSchedulerRunning
                          DCD      0x00000000
                  xPendedTicks
                          DCD      0x00000000
                  xYieldPending
                          DCD      0x00000000
                  xNumOfOverflows
                          DCD      0x00000000
                  uxTaskNumber
                          DCD      0x00000000
                  xNextTaskUnblockTime
                          DCD      0x00000000
                  xIdleTaskHandle
                          DCD      0x00000000
                  uxSchedulerSuspended
                          DCD      0x00000000
