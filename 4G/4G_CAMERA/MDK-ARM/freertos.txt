; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o4gcamera\freertos.o --asm_dir=.\ --list_dir=.\ --depend=4gcamera\freertos.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../USB_DEVICE/App -I../USB_DEVICE/Target -I../Core/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Middlewares/ST/STM32_USB_Device_Library/Core/Inc -I../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 -I../Middlewares/Third_Party/FreeRTOS/Source/portable/RVDS/ARM_CM4F -I../HARDWARE/OV2640 -I../HARDWARE/WS2812B -I../HARDWARE/RING_BUFFER -I../HARDWARE/FLASH -I.\RTE\_4GCAMERA -IC:\Users\czm\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\czm\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=536 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F407xx --omf_browse=4gcamera\freertos.crf ../Core/Src/freertos.c]
                          THUMB

                          AREA ||i.MX_FREERTOS_Init||, CODE, READONLY, ALIGN=2

                  MX_FREERTOS_Init PROC
;;;118      */
;;;119    void MX_FREERTOS_Init(void) {
000000  b510              PUSH     {r4,lr}
;;;120      /* USER CODE BEGIN Init */
;;;121    	taskENTER_CRITICAL();//进入灵临界区
000002  f7fffffe          BL       vPortEnterCritical
;;;122      /* USER CODE END Init */
;;;123    
;;;124      /* USER CODE BEGIN RTOS_MUTEX */
;;;125      /* add mutexes, ... */
;;;126      /* USER CODE END RTOS_MUTEX */
;;;127    
;;;128      /* USER CODE BEGIN RTOS_SEMAPHORES */
;;;129      /* add semaphores, ... */
;;;130      /* USER CODE END RTOS_SEMAPHORES */
;;;131    
;;;132      /* USER CODE BEGIN RTOS_TIMERS */
;;;133      /* start timers, add new ones, ... */
;;;134      /* USER CODE END RTOS_TIMERS */
;;;135    
;;;136      /* USER CODE BEGIN RTOS_QUEUES */
;;;137      /* add queues, ... */
;;;138      /* USER CODE END RTOS_QUEUES */
;;;139    
;;;140      /* Create the thread(s) */
;;;141      /* creation of defaultTask */
;;;142      defaultTaskHandle = osThreadNew(StartDefaultTask, NULL, &defaultTask_attributes);
000006  4a0f              LDR      r2,|L1.68|
000008  2100              MOVS     r1,#0
00000a  480f              LDR      r0,|L1.72|
00000c  f7fffffe          BL       osThreadNew
000010  490e              LDR      r1,|L1.76|
000012  6008              STR      r0,[r1,#0]  ; defaultTaskHandle
;;;143    
;;;144      /* creation of cmdAnalysis */
;;;145      cmdAnalysisHandle = osThreadNew(StartCmdAnalysis, NULL, &cmdAnalysis_attributes);
000014  4a0e              LDR      r2,|L1.80|
000016  2100              MOVS     r1,#0
000018  480e              LDR      r0,|L1.84|
00001a  f7fffffe          BL       osThreadNew
00001e  490e              LDR      r1,|L1.88|
000020  6008              STR      r0,[r1,#0]  ; cmdAnalysisHandle
;;;146    
;;;147      /* creation of sendDataTask */
;;;148      sendDataTaskHandle = osThreadNew(StartSendDataTask, NULL, &sendDataTask_attributes);
000022  4a0e              LDR      r2,|L1.92|
000024  2100              MOVS     r1,#0
000026  480e              LDR      r0,|L1.96|
000028  f7fffffe          BL       osThreadNew
00002c  490d              LDR      r1,|L1.100|
00002e  6008              STR      r0,[r1,#0]  ; sendDataTaskHandle
;;;149    
;;;150      /* creation of ledTask */
;;;151      ledTaskHandle = osThreadNew(StartLedTask, NULL, &ledTask_attributes);
000030  4a0d              LDR      r2,|L1.104|
000032  2100              MOVS     r1,#0
000034  480d              LDR      r0,|L1.108|
000036  f7fffffe          BL       osThreadNew
00003a  490d              LDR      r1,|L1.112|
00003c  6008              STR      r0,[r1,#0]  ; ledTaskHandle
;;;152    
;;;153      /* USER CODE BEGIN RTOS_THREADS */
;;;154      /* add threads, ... */
;;;155      /* USER CODE END RTOS_THREADS */
;;;156    
;;;157      /* USER CODE BEGIN RTOS_EVENTS */
;;;158      /* add events, ... */
;;;159    	taskEXIT_CRITICAL();//退出临界区
00003e  f7fffffe          BL       vPortExitCritical
;;;160      /* USER CODE END RTOS_EVENTS */
;;;161    
;;;162    }
000042  bd10              POP      {r4,pc}
;;;163    
                          ENDP

                  |L1.68|
                          DCD      defaultTask_attributes
                  |L1.72|
                          DCD      StartDefaultTask
                  |L1.76|
                          DCD      defaultTaskHandle
                  |L1.80|
                          DCD      cmdAnalysis_attributes
                  |L1.84|
                          DCD      StartCmdAnalysis
                  |L1.88|
                          DCD      cmdAnalysisHandle
                  |L1.92|
                          DCD      sendDataTask_attributes
                  |L1.96|
                          DCD      StartSendDataTask
                  |L1.100|
                          DCD      sendDataTaskHandle
                  |L1.104|
                          DCD      ledTask_attributes
                  |L1.108|
                          DCD      StartLedTask
                  |L1.112|
                          DCD      ledTaskHandle

                          AREA ||i.StartCmdAnalysis||, CODE, READONLY, ALIGN=2

                  StartCmdAnalysis PROC
;;;198    /* USER CODE END Header_StartCmdAnalysis */
;;;199    void StartCmdAnalysis(void *argument)
000000  b508              PUSH     {r3,lr}
;;;200    {
;;;201      /* USER CODE BEGIN StartCmdAnalysis */
;;;202    	TickType_t	PreviousWakeTime = xTaskGetTickCount(); 
000002  f7fffffe          BL       xTaskGetTickCount
000006  9000              STR      r0,[sp,#0]
;;;203      /* Infinite loop */
;;;204    //	WriteFlashData(ADDR_FLASH_SECTOR_7,(unsigned char *)deviceAttributeInfo.picFormat,sizeof(_deviceInfo));
;;;205    	memcpy((unsigned char *)deviceAttributeInfo.picFormat,(uint32_t*)ADDR_FLASH_SECTOR_7,sizeof(_deviceInfo));
000008  f44f72d4          MOV      r2,#0x1a8
00000c  4909              LDR      r1,|L2.52|
00000e  480a              LDR      r0,|L2.56|
000010  f7fffffe          BL       __aeabi_memcpy4
;;;206      for(;;)
000014  bf00              NOP      
                  |L2.22|
;;;207      {
;;;208    		vcpDataAnalysis(&VCP_RxRingBuffer);
000016  4809              LDR      r0,|L2.60|
000018  f7fffffe          BL       vcpDataAnalysis
;;;209    		if(anlysis == 1)
00001c  4808              LDR      r0,|L2.64|
00001e  7800              LDRB     r0,[r0,#0]  ; anlysis
000020  2801              CMP      r0,#1
000022  d102              BNE      |L2.42|
;;;210    			usart1DataAnalysis(&UART_RxRingBuffer);
000024  4807              LDR      r0,|L2.68|
000026  f7fffffe          BL       usart1DataAnalysis
                  |L2.42|
;;;211        vTaskDelayUntil(&PreviousWakeTime, configTICK_RATE_HZ/100);//指令解析任务执行周期为10Hz
00002a  210a              MOVS     r1,#0xa
00002c  4668              MOV      r0,sp
00002e  f7fffffe          BL       vTaskDelayUntil
000032  e7f0              B        |L2.22|
;;;212      }
;;;213      /* USER CODE END StartCmdAnalysis */
;;;214    }
;;;215    
                          ENDP

                  |L2.52|
                          DCD      0x08060000
                  |L2.56|
                          DCD      deviceAttributeInfo
                  |L2.60|
                          DCD      VCP_RxRingBuffer
                  |L2.64|
                          DCD      anlysis
                  |L2.68|
                          DCD      UART_RxRingBuffer

                          AREA ||i.StartDefaultTask||, CODE, READONLY, ALIGN=2

                  StartDefaultTask PROC
;;;170    /* USER CODE END Header_StartDefaultTask */
;;;171    void StartDefaultTask(void *argument)
000000  f7fffffe          BL       MX_USB_DEVICE_Init
;;;172    {
;;;173      /* init code for USB_DEVICE */
;;;174      MX_USB_DEVICE_Init();
;;;175      /* USER CODE BEGIN StartDefaultTask */
;;;176      /* Infinite loop */
;;;177      for(;;)
000004  bf00              NOP      
                  |L3.6|
;;;178      {
;;;179    		usbOK = 1;
000006  2001              MOVS     r0,#1
000008  4902              LDR      r1,|L3.20|
00000a  7008              STRB     r0,[r1,#0]
;;;180    		
;;;181    //		if(jpeg_data_ok == 1)
;;;182    //		{
;;;183    //			while(CDC_Transmit_HS((unsigned char *)dcmi_data_buff,jpeg_data_len * 4) != USBD_OK){};
;;;184    //			jpeg_data_ok = 2;
;;;185    //		}
;;;186        osDelay(1);
00000c  f7fffffe          BL       osDelay
000010  e7f9              B        |L3.6|
;;;187      }
;;;188      /* USER CODE END StartDefaultTask */
;;;189    }
;;;190    
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      usbOK

                          AREA ||i.StartLedTask||, CODE, READONLY, ALIGN=1

                  StartLedTask PROC
;;;408    /* USER CODE END Header_StartLedTask */
;;;409    void StartLedTask(void *argument)
000000  bf00              NOP      
                  |L4.2|
;;;410    {
;;;411      /* USER CODE BEGIN StartLedTask */
;;;412      /* Infinite loop */
;;;413      for(;;)
;;;414      {
;;;415        osDelay(1);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       osDelay
000008  e7fb              B        |L4.2|
;;;416      }
;;;417      /* USER CODE END StartLedTask */
;;;418    }
;;;419    
                          ENDP


                          AREA ||i.StartSendDataTask||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  StartSendDataTask PROC
;;;224    /* USER CODE END Header_StartSendDataTask */
;;;225    void StartSendDataTask(void *argument)
000000  b09a              SUB      sp,sp,#0x68
;;;226    {
;;;227      /* USER CODE BEGIN StartSendDataTask */
;;;228    	char frameBuffer[100];
;;;229    	unsigned int sendTcpDataLen = 0;
000002  2400              MOVS     r4,#0
;;;230    	HAL_UART_Transmit(&huart1,(const unsigned char *)"AT\r\n",4,0xFFFFFFFF);
000004  1e63              SUBS     r3,r4,#1
000006  2204              MOVS     r2,#4
000008  a1fa              ADR      r1,|L5.1012|
00000a  48fc              LDR      r0,|L5.1020|
00000c  f7fffffe          BL       HAL_UART_Transmit
;;;231    	osDelay(2000);
000010  f44f60fa          MOV      r0,#0x7d0
000014  f7fffffe          BL       osDelay
;;;232    	HAL_UART_Transmit(&huart1,(const unsigned char *)"AT\r\n",4,0xFFFFFFFF);
000018  1e63              SUBS     r3,r4,#1
00001a  2204              MOVS     r2,#4
00001c  a1f5              ADR      r1,|L5.1012|
00001e  48f7              LDR      r0,|L5.1020|
000020  f7fffffe          BL       HAL_UART_Transmit
;;;233    	osDelay(2000);
000024  f44f60fa          MOV      r0,#0x7d0
000028  f7fffffe          BL       osDelay
;;;234    	HAL_UART_Transmit(&huart1,(const unsigned char *)"AT\r\n",4,0xFFFFFFFF);
00002c  1e63              SUBS     r3,r4,#1
00002e  2204              MOVS     r2,#4
000030  a1f0              ADR      r1,|L5.1012|
000032  48f2              LDR      r0,|L5.1020|
000034  f7fffffe          BL       HAL_UART_Transmit
;;;235    	osDelay(2000);
000038  f44f60fa          MOV      r0,#0x7d0
00003c  f7fffffe          BL       osDelay
;;;236    	
;;;237    	HAL_UART_Transmit(&huart1,(const unsigned char *)AT_CDM_1,strlen(AT_CDM_1),0xFFFFFFFF);
000040  48ef              LDR      r0,|L5.1024|
000042  f7fffffe          BL       strlen
000046  b285              UXTH     r5,r0
000048  1e63              SUBS     r3,r4,#1
00004a  462a              MOV      r2,r5
00004c  49ec              LDR      r1,|L5.1024|
00004e  48eb              LDR      r0,|L5.1020|
000050  f7fffffe          BL       HAL_UART_Transmit
;;;238    	osDelay(1000);
000054  f44f707a          MOV      r0,#0x3e8
000058  f7fffffe          BL       osDelay
;;;239    	HAL_UART_Transmit(&huart1,(const unsigned char *)AT_CDM_2,strlen(AT_CDM_2),0xFFFFFFFF);
00005c  48e9              LDR      r0,|L5.1028|
00005e  f7fffffe          BL       strlen
000062  b285              UXTH     r5,r0
000064  1e63              SUBS     r3,r4,#1
000066  462a              MOV      r2,r5
000068  49e6              LDR      r1,|L5.1028|
00006a  48e4              LDR      r0,|L5.1020|
00006c  f7fffffe          BL       HAL_UART_Transmit
;;;240    	osDelay(1000);
000070  f44f707a          MOV      r0,#0x3e8
000074  f7fffffe          BL       osDelay
;;;241    	HAL_UART_Transmit(&huart1,(const unsigned char *)AT_CDM_3,strlen(AT_CDM_3),0xFFFFFFFF);
000078  48e3              LDR      r0,|L5.1032|
00007a  f7fffffe          BL       strlen
00007e  b285              UXTH     r5,r0
000080  1e63              SUBS     r3,r4,#1
000082  462a              MOV      r2,r5
000084  49e0              LDR      r1,|L5.1032|
000086  48dd              LDR      r0,|L5.1020|
000088  f7fffffe          BL       HAL_UART_Transmit
;;;242    	osDelay(1000);
00008c  f44f707a          MOV      r0,#0x3e8
000090  f7fffffe          BL       osDelay
;;;243    	HAL_UART_Transmit(&huart1,(const unsigned char *)AT_CDM_4,strlen(AT_CDM_4),0xFFFFFFFF);
000094  48dd              LDR      r0,|L5.1036|
000096  f7fffffe          BL       strlen
00009a  b285              UXTH     r5,r0
00009c  1e63              SUBS     r3,r4,#1
00009e  462a              MOV      r2,r5
0000a0  49da              LDR      r1,|L5.1036|
0000a2  48d6              LDR      r0,|L5.1020|
0000a4  f7fffffe          BL       HAL_UART_Transmit
;;;244    	osDelay(1000);
0000a8  f44f707a          MOV      r0,#0x3e8
0000ac  f7fffffe          BL       osDelay
;;;245    	HAL_UART_Transmit(&huart1,(const unsigned char *)AT_CDM_5,strlen(AT_CDM_5),0xFFFFFFFF);
0000b0  48d7              LDR      r0,|L5.1040|
0000b2  f7fffffe          BL       strlen
0000b6  b285              UXTH     r5,r0
0000b8  1e63              SUBS     r3,r4,#1
0000ba  462a              MOV      r2,r5
0000bc  49d4              LDR      r1,|L5.1040|
0000be  48cf              LDR      r0,|L5.1020|
0000c0  f7fffffe          BL       HAL_UART_Transmit
;;;246    	osDelay(1000);
0000c4  f44f707a          MOV      r0,#0x3e8
0000c8  f7fffffe          BL       osDelay
;;;247    	HAL_UART_Transmit(&huart1,(const unsigned char *)AT_CDM_6,strlen(AT_CDM_6),0xFFFFFFFF);
0000cc  48d1              LDR      r0,|L5.1044|
0000ce  f7fffffe          BL       strlen
0000d2  b285              UXTH     r5,r0
0000d4  1e63              SUBS     r3,r4,#1
0000d6  462a              MOV      r2,r5
0000d8  49ce              LDR      r1,|L5.1044|
0000da  48c8              LDR      r0,|L5.1020|
0000dc  f7fffffe          BL       HAL_UART_Transmit
;;;248    	osDelay(1000);
0000e0  f44f707a          MOV      r0,#0x3e8
0000e4  f7fffffe          BL       osDelay
;;;249    	HAL_UART_Transmit(&huart1,(const unsigned char *)AT_CDM_7,strlen(AT_CDM_7),0xFFFFFFFF);
0000e8  48cb              LDR      r0,|L5.1048|
0000ea  f7fffffe          BL       strlen
0000ee  b285              UXTH     r5,r0
0000f0  1e63              SUBS     r3,r4,#1
0000f2  462a              MOV      r2,r5
0000f4  49c8              LDR      r1,|L5.1048|
0000f6  48c1              LDR      r0,|L5.1020|
0000f8  f7fffffe          BL       HAL_UART_Transmit
;;;250    	osDelay(1000);
0000fc  f44f707a          MOV      r0,#0x3e8
000100  f7fffffe          BL       osDelay
;;;251    	HAL_UART_Transmit(&huart1,(const unsigned char *)AT_CDM_8,strlen(AT_CDM_8),0xFFFFFFFF);
000104  48c5              LDR      r0,|L5.1052|
000106  f7fffffe          BL       strlen
00010a  b285              UXTH     r5,r0
00010c  1e63              SUBS     r3,r4,#1
00010e  462a              MOV      r2,r5
000110  49c2              LDR      r1,|L5.1052|
000112  48ba              LDR      r0,|L5.1020|
000114  f7fffffe          BL       HAL_UART_Transmit
;;;252    	osDelay(1000);
000118  f44f707a          MOV      r0,#0x3e8
00011c  f7fffffe          BL       osDelay
;;;253    	memset(AT_CDM_9,0,sizeof(AT_CDM_9));
000120  2132              MOVS     r1,#0x32
000122  48bf              LDR      r0,|L5.1056|
000124  f7fffffe          BL       __aeabi_memclr
;;;254    	sprintf(AT_CDM_9,"AT+CIPSTART=\"TCP\",%s,%d\r\n",deviceAttributeInfo.UDP_serverIP,deviceAttributeInfo.UDP_serverPort);
000128  48be              LDR      r0,|L5.1060|
00012a  f1000258          ADD      r2,r0,#0x58
00012e  a1be              ADR      r1,|L5.1064|
000130  6ec3              LDR      r3,[r0,#0x6c]  ; deviceAttributeInfo
000132  48bb              LDR      r0,|L5.1056|
000134  f7fffffe          BL       __2sprintf
;;;255    	HAL_UART_Transmit(&huart1,(const unsigned char *)AT_CDM_9,strlen(AT_CDM_9),0xFFFFFFFF);
000138  48b9              LDR      r0,|L5.1056|
00013a  f7fffffe          BL       strlen
00013e  b285              UXTH     r5,r0
000140  1e63              SUBS     r3,r4,#1
000142  462a              MOV      r2,r5
000144  49b6              LDR      r1,|L5.1056|
000146  48ad              LDR      r0,|L5.1020|
000148  f7fffffe          BL       HAL_UART_Transmit
;;;256    	osDelay(5000);
00014c  f2413088          MOV      r0,#0x1388
000150  f7fffffe          BL       osDelay
;;;257    	anlysis = 1;
000154  2001              MOVS     r0,#1
000156  49bb              LDR      r1,|L5.1092|
000158  7008              STRB     r0,[r1,#0]
;;;258    	
;;;259    	
;;;260    	
;;;261    	memset(frameBuffer,0,100);/* 清空数组 */
00015a  2164              MOVS     r1,#0x64
00015c  a801              ADD      r0,sp,#4
00015e  f7fffffe          BL       __aeabi_memclr4
;;;262    	sendTcpDataLen = 1;
000162  2401              MOVS     r4,#1
;;;263    	frameBuffer[0] = sendTcpDataLen;
000164  f88d4004          STRB     r4,[sp,#4]
;;;264    	frameBuffer[1] = sendTcpDataLen>>8;
000168  0a20              LSRS     r0,r4,#8
00016a  f88d0005          STRB     r0,[sp,#5]
;;;265    	frameBuffer[2] = sendTcpDataLen>>16;
00016e  0c20              LSRS     r0,r4,#16
000170  f88d0006          STRB     r0,[sp,#6]
;;;266    	frameBuffer[3] = sendTcpDataLen>>24;
000174  0e20              LSRS     r0,r4,#24
000176  f88d0007          STRB     r0,[sp,#7]
;;;267    	frameBuffer[4] = SET_CAMERA_DEVICE_FLAG;
00017a  2008              MOVS     r0,#8
00017c  f88d0008          STRB     r0,[sp,#8]
;;;268    	HAL_UART_Transmit(&huart1,(const unsigned char *)frameBuffer,5,0xFFFFFFFF);
000180  1ea3              SUBS     r3,r4,#2
000182  2205              MOVS     r2,#5
000184  a901              ADD      r1,sp,#4
000186  489d              LDR      r0,|L5.1020|
000188  f7fffffe          BL       HAL_UART_Transmit
;;;269    		
;;;270    	memset(frameBuffer,0,100);/* 清空数组 */
00018c  2164              MOVS     r1,#0x64
00018e  a801              ADD      r0,sp,#4
000190  f7fffffe          BL       __aeabi_memclr4
;;;271    	sendTcpDataLen = 1 + strlen(deviceAttributeInfo.deviceID);
000194  48a3              LDR      r0,|L5.1060|
000196  3020              ADDS     r0,r0,#0x20
000198  f7fffffe          BL       strlen
00019c  1c44              ADDS     r4,r0,#1
;;;272    	frameBuffer[0] = sendTcpDataLen;
00019e  b2e0              UXTB     r0,r4
0001a0  f88d0004          STRB     r0,[sp,#4]
;;;273    	frameBuffer[1] = sendTcpDataLen>>8;
0001a4  0a20              LSRS     r0,r4,#8
0001a6  f88d0005          STRB     r0,[sp,#5]
;;;274    	frameBuffer[2] = sendTcpDataLen>>16;
0001aa  0c20              LSRS     r0,r4,#16
0001ac  f88d0006          STRB     r0,[sp,#6]
;;;275    	frameBuffer[3] = sendTcpDataLen>>24;
0001b0  0e20              LSRS     r0,r4,#24
0001b2  f88d0007          STRB     r0,[sp,#7]
;;;276    
;;;277    	frameBuffer[4] = SET_CAMERA_DEVICE_ID;
0001b6  2009              MOVS     r0,#9
0001b8  f88d0008          STRB     r0,[sp,#8]
;;;278    
;;;279    	memcpy(&frameBuffer[5],&deviceAttributeInfo.deviceID,strlen(deviceAttributeInfo.deviceID));
0001bc  4899              LDR      r0,|L5.1060|
0001be  3020              ADDS     r0,r0,#0x20
0001c0  f7fffffe          BL       strlen
0001c4  4605              MOV      r5,r0
0001c6  462a              MOV      r2,r5
0001c8  4996              LDR      r1,|L5.1060|
0001ca  3120              ADDS     r1,r1,#0x20
0001cc  f10d0009          ADD      r0,sp,#9
0001d0  f7fffffe          BL       __aeabi_memcpy
;;;280    	HAL_UART_Transmit(&huart1,(const unsigned char *)frameBuffer,5+strlen(deviceAttributeInfo.deviceID),0xFFFFFFFF);
0001d4  4893              LDR      r0,|L5.1060|
0001d6  3020              ADDS     r0,r0,#0x20
0001d8  f7fffffe          BL       strlen
0001dc  1d40              ADDS     r0,r0,#5
0001de  b285              UXTH     r5,r0
0001e0  f04f33ff          MOV      r3,#0xffffffff
0001e4  462a              MOV      r2,r5
0001e6  a901              ADD      r1,sp,#4
0001e8  4884              LDR      r0,|L5.1020|
0001ea  f7fffffe          BL       HAL_UART_Transmit
;;;281    	
;;;282      /* Infinite loop */
;;;283      for(;;)
0001ee  bf00              NOP      
                  |L5.496|
;;;284      {
;;;285    		/* 发送TCP心跳包 */
;;;286    		memset(frameBuffer,0,100);/* 清空数组 */
0001f0  2164              MOVS     r1,#0x64
0001f2  a801              ADD      r0,sp,#4
0001f4  f7fffffe          BL       __aeabi_memclr4
;;;287    		sendTcpDataLen = 1;
0001f8  2401              MOVS     r4,#1
;;;288    		frameBuffer[0] = sendTcpDataLen;
0001fa  f88d4004          STRB     r4,[sp,#4]
;;;289    		frameBuffer[1] = sendTcpDataLen>>8;
0001fe  0a20              LSRS     r0,r4,#8
000200  f88d0005          STRB     r0,[sp,#5]
;;;290    		frameBuffer[2] = sendTcpDataLen>>16;
000204  0c20              LSRS     r0,r4,#16
000206  f88d0006          STRB     r0,[sp,#6]
;;;291    		frameBuffer[3] = sendTcpDataLen>>24;
00020a  0e20              LSRS     r0,r4,#24
00020c  f88d0007          STRB     r0,[sp,#7]
;;;292    
;;;293    		frameBuffer[4] = HERAT_BEAT_PACK;
000210  2000              MOVS     r0,#0
000212  f88d0008          STRB     r0,[sp,#8]
;;;294    		HAL_UART_Transmit(&huart1,(const unsigned char *)frameBuffer,5,0xFFFFFFFF);
000216  1e43              SUBS     r3,r0,#1
000218  2205              MOVS     r2,#5
00021a  a901              ADD      r1,sp,#4
00021c  4877              LDR      r0,|L5.1020|
00021e  f7fffffe          BL       HAL_UART_Transmit
;;;295    		
;;;296    /*******************************************************************************拍照**********************************************************************************************/
;;;297    		if(takePictureFlag == 1)
000222  4889              LDR      r0,|L5.1096|
000224  7800              LDRB     r0,[r0,#0]  ; takePictureFlag
000226  2801              CMP      r0,#1
000228  d17e              BNE      |L5.808|
;;;298    		{
;;;299    			__HAL_TIM_SetCompare(&htim1, TIM_CHANNEL_1, deviceAttributeInfo.ledFlashBrightness);
00022a  487e              LDR      r0,|L5.1060|
00022c  f8d001a0          LDR      r0,[r0,#0x1a0]  ; deviceAttributeInfo
000230  4986              LDR      r1,|L5.1100|
000232  6809              LDR      r1,[r1,#0]  ; htim1
000234  6348              STR      r0,[r1,#0x34]
;;;300    			
;;;301    			unsigned int tryPic = deviceAttributeInfo.takePictureDelayTime * 10;
000236  487b              LDR      r0,|L5.1060|
000238  f8d001a4          LDR      r0,[r0,#0x1a4]  ; deviceAttributeInfo
00023c  eb000080          ADD      r0,r0,r0,LSL #2
000240  0047              LSLS     r7,r0,#1
;;;302    			while(tryPic)
000242  e00b              B        |L5.604|
                  |L5.580|
;;;303    			{
;;;304    					jpeg_data_ok = 2;
000244  2002              MOVS     r0,#2
000246  4982              LDR      r1,|L5.1104|
000248  7008              STRB     r0,[r1,#0]
;;;305    					while(jpeg_data_ok != 1);
00024a  bf00              NOP      
                  |L5.588|
00024c  4880              LDR      r0,|L5.1104|
00024e  7800              LDRB     r0,[r0,#0]  ; jpeg_data_ok
000250  2801              CMP      r0,#1
000252  d1fb              BNE      |L5.588|
;;;306    					vTaskDelay(100 /portTICK_PERIOD_MS);
000254  2064              MOVS     r0,#0x64
000256  f7fffffe          BL       vTaskDelay
;;;307    					tryPic--;
00025a  1e7f              SUBS     r7,r7,#1
                  |L5.604|
00025c  2f00              CMP      r7,#0                 ;302
00025e  d1f1              BNE      |L5.580|
;;;308    			}
;;;309    			
;;;310    			if(jpeg_data_ok == 1)
000260  487b              LDR      r0,|L5.1104|
000262  7800              LDRB     r0,[r0,#0]  ; jpeg_data_ok
000264  2801              CMP      r0,#1
000266  d15c              BNE      |L5.802|
;;;311    			{
;;;312    				unsigned char *p = (unsigned char *)dcmi_data_buff;
000268  4d7a              LDR      r5,|L5.1108|
;;;313    				int index = 0;
00026a  2600              MOVS     r6,#0
;;;314    				while(p[0] != 0xff && p[1]!= 0xd8 && index < 100)
00026c  e001              B        |L5.626|
                  |L5.622|
;;;315    				{
;;;316    					p++;
00026e  1c6d              ADDS     r5,r5,#1
;;;317    					index++;
000270  1c76              ADDS     r6,r6,#1
                  |L5.626|
000272  7828              LDRB     r0,[r5,#0]            ;314
000274  28ff              CMP      r0,#0xff              ;314
000276  d004              BEQ      |L5.642|
000278  7868              LDRB     r0,[r5,#1]            ;314
00027a  28d8              CMP      r0,#0xd8              ;314
00027c  d001              BEQ      |L5.642|
00027e  2e64              CMP      r6,#0x64              ;314
000280  dbf5              BLT      |L5.622|
                  |L5.642|
;;;318    				}
;;;319    				
;;;320    				
;;;321    				memset(frameBuffer,0,100);/* 清空数组 */
000282  2164              MOVS     r1,#0x64
000284  a801              ADD      r0,sp,#4
000286  f7fffffe          BL       __aeabi_memclr4
;;;322    				sendTcpDataLen = jpeg_data_len * 4 + 1 - index;
00028a  4873              LDR      r0,|L5.1112|
00028c  6800              LDR      r0,[r0,#0]  ; jpeg_data_len
00028e  2101              MOVS     r1,#1
000290  eb010080          ADD      r0,r1,r0,LSL #2
000294  1b84              SUBS     r4,r0,r6
;;;323    				frameBuffer[0] = sendTcpDataLen;
000296  b2e0              UXTB     r0,r4
000298  f88d0004          STRB     r0,[sp,#4]
;;;324    				frameBuffer[1] = sendTcpDataLen>>8;
00029c  0a20              LSRS     r0,r4,#8
00029e  f88d0005          STRB     r0,[sp,#5]
;;;325    				frameBuffer[2] = sendTcpDataLen>>16;
0002a2  0c20              LSRS     r0,r4,#16
0002a4  f88d0006          STRB     r0,[sp,#6]
;;;326    				frameBuffer[3] = sendTcpDataLen>>24;
0002a8  0e20              LSRS     r0,r4,#24
0002aa  f88d0007          STRB     r0,[sp,#7]
;;;327    
;;;328    				frameBuffer[4] = PICTURE_DATA;
0002ae  2001              MOVS     r0,#1
0002b0  f88d0008          STRB     r0,[sp,#8]
;;;329                        
;;;330            HAL_UART_Transmit(&huart1,(const unsigned char *)frameBuffer,5,0xFFFFFFFF);
0002b4  1e83              SUBS     r3,r0,#2
0002b6  2205              MOVS     r2,#5
0002b8  a901              ADD      r1,sp,#4
0002ba  4850              LDR      r0,|L5.1020|
0002bc  f7fffffe          BL       HAL_UART_Transmit
;;;331    				
;;;332    				
;;;333    				HAL_UART_Transmit(&huart1,(const unsigned char *)p,jpeg_data_len * 4 - index,0xFFFFFFFF);
0002c0  4865              LDR      r0,|L5.1112|
0002c2  8800              LDRH     r0,[r0,#0]  ; jpeg_data_len
0002c4  ebc60080          RSB      r0,r6,r0,LSL #2
0002c8  b282              UXTH     r2,r0
0002ca  f04f33ff          MOV      r3,#0xffffffff
0002ce  4629              MOV      r1,r5
0002d0  484a              LDR      r0,|L5.1020|
0002d2  f7fffffe          BL       HAL_UART_Transmit
;;;334    				memset(dcmi_data_buff,0,PictureSize);/* 清空数组 */
0002d6  f44f41b0          MOV      r1,#0x5800
0002da  485e              LDR      r0,|L5.1108|
0002dc  f7fffffe          BL       __aeabi_memclr4
;;;335    				
;;;336    				memset(frameBuffer,0,100);/* 清空数组 */
0002e0  2164              MOVS     r1,#0x64
0002e2  a801              ADD      r0,sp,#4
0002e4  f7fffffe          BL       __aeabi_memclr4
;;;337    				sendTcpDataLen = 1;
0002e8  2401              MOVS     r4,#1
;;;338    				frameBuffer[0] = sendTcpDataLen;
0002ea  f88d4004          STRB     r4,[sp,#4]
;;;339    				frameBuffer[1] = sendTcpDataLen>>8;
0002ee  0a20              LSRS     r0,r4,#8
0002f0  f88d0005          STRB     r0,[sp,#5]
;;;340    				frameBuffer[2] = sendTcpDataLen>>16;
0002f4  0c20              LSRS     r0,r4,#16
0002f6  f88d0006          STRB     r0,[sp,#6]
;;;341    				frameBuffer[3] = sendTcpDataLen>>24;
0002fa  0e20              LSRS     r0,r4,#24
0002fc  f88d0007          STRB     r0,[sp,#7]
;;;342    
;;;343    				frameBuffer[4] = CAMERA_TAKE_PICTURE_DONE;
000300  200b              MOVS     r0,#0xb
000302  f88d0008          STRB     r0,[sp,#8]
;;;344                        
;;;345           HAL_UART_Transmit(&huart1,(const unsigned char *)frameBuffer,5,0xFFFFFFFF);
000306  1ea3              SUBS     r3,r4,#2
000308  2205              MOVS     r2,#5
00030a  a901              ADD      r1,sp,#4
00030c  483b              LDR      r0,|L5.1020|
00030e  f7fffffe          BL       HAL_UART_Transmit
;;;346    										
;;;347    //				while(CDC_Transmit_HS((unsigned char *)dcmi_data_buff,jpeg_data_len * 4) != USBD_OK){};
;;;348    				
;;;349    				__HAL_TIM_SetCompare(&htim1, TIM_CHANNEL_1, 0);
000312  2000              MOVS     r0,#0
000314  494d              LDR      r1,|L5.1100|
000316  6809              LDR      r1,[r1,#0]  ; htim1
000318  6348              STR      r0,[r1,#0x34]
;;;350    				jpeg_data_ok = 2;
00031a  2002              MOVS     r0,#2
00031c  494c              LDR      r1,|L5.1104|
00031e  7008              STRB     r0,[r1,#0]
;;;351    			}
000320  bf00              NOP      
                  |L5.802|
;;;352    			takePictureFlag = 0;
000322  2000              MOVS     r0,#0
000324  4948              LDR      r1,|L5.1096|
000326  e000              B        |L5.810|
                  |L5.808|
000328  e001              B        |L5.814|
                  |L5.810|
00032a  7008              STRB     r0,[r1,#0]
;;;353    		}
00032c  bf00              NOP      
                  |L5.814|
;;;354    /*******************************************************************************外部电平检测**********************************************************************************************/
;;;355    		static char keyFlag = 0;
;;;356    		if(HAL_GPIO_ReadPin(IN1_GPIO_Port,IN1_Pin) == 0 && keyFlag == 0)/* 吸合检测到低电平，水位到达水位线 */
00032e  f44f4100          MOV      r1,#0x8000
000332  484a              LDR      r0,|L5.1116|
000334  f7fffffe          BL       HAL_GPIO_ReadPin
000338  b968              CBNZ     r0,|L5.854|
00033a  4849              LDR      r0,|L5.1120|
00033c  7800              LDRB     r0,[r0,#0]  ; keyFlag
00033e  b950              CBNZ     r0,|L5.854|
;;;357    		{
;;;358    				takePictureFlag = 1;
000340  2001              MOVS     r0,#1
000342  4941              LDR      r1,|L5.1096|
000344  7008              STRB     r0,[r1,#0]
;;;359    				keyFlag = 1;
000346  4946              LDR      r1,|L5.1120|
000348  7008              STRB     r0,[r1,#0]
;;;360    //				espSendLogMessage(0xAA,MCU,CMD_LOG_MESSAGE,(char*)"ESP:外部触发拍照");
;;;361    				HAL_GPIO_WritePin(MOTO_CTR_GPIO_Port, MOTO_CTR_Pin, GPIO_PIN_RESET);//检测到水位到达，立马关闭水泵
00034a  2200              MOVS     r2,#0
00034c  0341              LSLS     r1,r0,#13
00034e  4845              LDR      r0,|L5.1124|
000350  f7fffffe          BL       HAL_GPIO_WritePin
000354  e00d              B        |L5.882|
                  |L5.854|
;;;362    //				espSendLogMessage(0xAA,MCU,CMD_LOG_MESSAGE,(char*)"ESP:水泵关闭");
;;;363    //				vTaskDelay(1000 / portTICK_PERIOD_MS);
;;;364    		}
;;;365    		else if(HAL_GPIO_ReadPin(IN1_GPIO_Port,IN1_Pin) == 1 && keyFlag == 1)/* 断开检测到高电平 */
000356  f44f4100          MOV      r1,#0x8000
00035a  4840              LDR      r0,|L5.1116|
00035c  f7fffffe          BL       HAL_GPIO_ReadPin
000360  2801              CMP      r0,#1
000362  d106              BNE      |L5.882|
000364  483e              LDR      r0,|L5.1120|
000366  7800              LDRB     r0,[r0,#0]  ; keyFlag
000368  2801              CMP      r0,#1
00036a  d102              BNE      |L5.882|
;;;366    		{
;;;367    				keyFlag = 0;
00036c  2000              MOVS     r0,#0
00036e  493c              LDR      r1,|L5.1120|
000370  7008              STRB     r0,[r1,#0]
                  |L5.882|
;;;368    		}
;;;369    /*********************************************************************************继电器控制****************************************************************************************************/
;;;370    		if(openMotoFlag == 1 && HAL_GPIO_ReadPin(IN1_GPIO_Port,IN1_Pin) == 1) /* 水位检测开关没有到达水位线，可以打开水泵 */
000372  483d              LDR      r0,|L5.1128|
000374  7800              LDRB     r0,[r0,#0]  ; openMotoFlag
000376  2801              CMP      r0,#1
000378  d127              BNE      |L5.970|
00037a  03c1              LSLS     r1,r0,#15
00037c  4837              LDR      r0,|L5.1116|
00037e  f7fffffe          BL       HAL_GPIO_ReadPin
000382  2801              CMP      r0,#1
000384  d121              BNE      |L5.970|
;;;371    		{
;;;372    				HAL_GPIO_WritePin(MOTO_CTR_GPIO_Port, MOTO_CTR_Pin, GPIO_PIN_SET);//打开水泵命令，打开水泵
000386  2201              MOVS     r2,#1
000388  0341              LSLS     r1,r0,#13
00038a  4836              LDR      r0,|L5.1124|
00038c  f7fffffe          BL       HAL_GPIO_WritePin
;;;373    				memset(frameBuffer,0,100);/* 清空数组 */
000390  2164              MOVS     r1,#0x64
000392  a801              ADD      r0,sp,#4
000394  f7fffffe          BL       __aeabi_memclr4
;;;374    				sendTcpDataLen = 1;
000398  2401              MOVS     r4,#1
;;;375    				frameBuffer[0] = sendTcpDataLen;
00039a  f88d4004          STRB     r4,[sp,#4]
;;;376    				frameBuffer[1] = sendTcpDataLen>>8;
00039e  0a20              LSRS     r0,r4,#8
0003a0  f88d0005          STRB     r0,[sp,#5]
;;;377    				frameBuffer[2] = sendTcpDataLen>>16;
0003a4  0c20              LSRS     r0,r4,#16
0003a6  f88d0006          STRB     r0,[sp,#6]
;;;378    				frameBuffer[3] = sendTcpDataLen>>24;
0003aa  0e20              LSRS     r0,r4,#24
0003ac  f88d0007          STRB     r0,[sp,#7]
;;;379    
;;;380    				frameBuffer[4] = OPEN_MOTO_SUCCESS_CMD;
0003b0  2019              MOVS     r0,#0x19
0003b2  f88d0008          STRB     r0,[sp,#8]
;;;381    				HAL_UART_Transmit(&huart1,(const unsigned char *)frameBuffer,5,0xFFFFFFFF);
0003b6  1ea3              SUBS     r3,r4,#2
0003b8  2205              MOVS     r2,#5
0003ba  a901              ADD      r1,sp,#4
0003bc  480f              LDR      r0,|L5.1020|
0003be  f7fffffe          BL       HAL_UART_Transmit
;;;382    //				if(tcpSendErr <= 0){espSendLogMessage(0xAA,MCU,CMD_LOG_MESSAGE,(char*)"ESP:3 TCP发送错误");vTaskDelay(1000 / portTICK_PERIOD_MS);esp_restart();}
;;;383    
;;;384    //				espSendLogMessage(0xAA,MCU,CMD_LOG_MESSAGE,(char*)"ESP:水泵打开");
;;;385    				openMotoFlag = 0;
0003c2  2000              MOVS     r0,#0
0003c4  4928              LDR      r1,|L5.1128|
0003c6  7008              STRB     r0,[r1,#0]
0003c8  e00e              B        |L5.1000|
                  |L5.970|
;;;386    		}
;;;387    		else if(openMotoFlag == 1 && HAL_GPIO_ReadPin(IN1_GPIO_Port,IN1_Pin) == 0)
0003ca  4827              LDR      r0,|L5.1128|
0003cc  7800              LDRB     r0,[r0,#0]  ; openMotoFlag
0003ce  2801              CMP      r0,#1
0003d0  d10a              BNE      |L5.1000|
0003d2  03c1              LSLS     r1,r0,#15
0003d4  4821              LDR      r0,|L5.1116|
0003d6  f7fffffe          BL       HAL_GPIO_ReadPin
0003da  b928              CBNZ     r0,|L5.1000|
;;;388    		{
;;;389    //				ESP_LOGI("camera","水泵打开指令，外部检测到水位已到达");
;;;390    				//此时就只执行拍照
;;;391    				takePictureFlag = 1;
0003dc  2001              MOVS     r0,#1
0003de  491a              LDR      r1,|L5.1096|
0003e0  7008              STRB     r0,[r1,#0]
;;;392    				openMotoFlag = 0;
0003e2  2000              MOVS     r0,#0
0003e4  4920              LDR      r1,|L5.1128|
0003e6  7008              STRB     r0,[r1,#0]
                  |L5.1000|
;;;393    		}
;;;394    						
;;;395    		
;;;396    		
;;;397        osDelay(1000);
0003e8  f44f707a          MOV      r0,#0x3e8
0003ec  f7fffffe          BL       osDelay
0003f0  e6fe              B        |L5.496|
0003f2  0000              DCW      0x0000
                  |L5.1012|
0003f4  41540d0a          DCB      "AT\r\n",0
0003f8  00      
0003f9  00                DCB      0
0003fa  00                DCB      0
0003fb  00                DCB      0
                  |L5.1020|
                          DCD      huart1
                  |L5.1024|
                          DCD      AT_CDM_1
                  |L5.1028|
                          DCD      AT_CDM_2
                  |L5.1032|
                          DCD      AT_CDM_3
                  |L5.1036|
                          DCD      AT_CDM_4
                  |L5.1040|
                          DCD      AT_CDM_5
                  |L5.1044|
                          DCD      AT_CDM_6
                  |L5.1048|
                          DCD      AT_CDM_7
                  |L5.1052|
                          DCD      AT_CDM_8
                  |L5.1056|
                          DCD      AT_CDM_9
                  |L5.1060|
                          DCD      deviceAttributeInfo
                  |L5.1064|
000428  41542b43          DCB      "AT+CIPSTART=""TCP"",%s,%d\r\n",0
00042c  49505354
000430  4152543d
000434  22544350
000438  222c2573
00043c  2c25640d
000440  0a00    
000442  00                DCB      0
000443  00                DCB      0
                  |L5.1092|
                          DCD      anlysis
                  |L5.1096|
                          DCD      takePictureFlag
                  |L5.1100|
                          DCD      htim1
                  |L5.1104|
                          DCD      jpeg_data_ok
                  |L5.1108|
                          DCD      dcmi_data_buff
                  |L5.1112|
                          DCD      jpeg_data_len
                  |L5.1116|
                          DCD      0x40020000
                  |L5.1120|
                          DCD      keyFlag
                  |L5.1124|
                          DCD      0x40020c00
                  |L5.1128|
                          DCD      openMotoFlag
                          ENDP


                          AREA ||i.usart1DataAnalysis||, CODE, READONLY, ALIGN=2

                  usart1DataAnalysis PROC
;;;577    */
;;;578    static void usart1DataAnalysis(_RingBuffer *ringbuffer)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;579    {
000004  4607              MOV      r7,r0
;;;580    	unsigned char *FrameData;                                               /*存储解析帧的空间*/
;;;581    	unsigned short allFrameDataLen = ringbuffer->Lenght;               			/* 获取缓冲区中的存储的数据长度 */
000006  88be              LDRH     r6,[r7,#4]
;;;582    	int dataIndex = 0;                                                      /* 数组中的偏移位置 */
000008  2400              MOVS     r4,#0
;;;583    
;;;584    	if(xPortGetFreeHeapSize() >= allFrameDataLen)                           /* 判断剩余内存是否大于申请内存 */
00000a  f7fffffe          BL       xPortGetFreeHeapSize
00000e  42b0              CMP      r0,r6
000010  d371              BCC      |L6.246|
;;;585    	{
;;;586    			FrameData = (unsigned char *)pvPortMalloc(allFrameDataLen);	        /*为读取缓冲区中的所有数据申请内存*/
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       pvPortMalloc
000018  4605              MOV      r5,r0
;;;587    			if(ReadBytes(ringbuffer,FrameData,allFrameDataLen) == 1)		/*读取缓冲区中的所有数据*/
00001a  4632              MOV      r2,r6
00001c  4629              MOV      r1,r5
00001e  4638              MOV      r0,r7
000020  f7fffffe          BL       ReadBytes
000024  2801              CMP      r0,#1
000026  d167              BNE      |L6.248|
;;;588    			{
;;;589    					while(allFrameDataLen - dataIndex >= 4)/* 仍然可以得到数据长度 */
000028  e096              B        |L6.344|
                  |L6.42|
;;;590    					{
;;;591    							unsigned int frameDataLen = (int)FrameData[dataIndex + 0] |
00002a  5d29              LDRB     r1,[r5,r4]
00002c  1c60              ADDS     r0,r4,#1
00002e  5c28              LDRB     r0,[r5,r0]
000030  ea412100          ORR      r1,r1,r0,LSL #8
000034  1ca0              ADDS     r0,r4,#2
000036  5c28              LDRB     r0,[r5,r0]
000038  ea414100          ORR      r1,r1,r0,LSL #16
00003c  1ce0              ADDS     r0,r4,#3
00003e  5c28              LDRB     r0,[r5,r0]
000040  ea416800          ORR      r8,r1,r0,LSL #24
;;;592    																					(int)FrameData[dataIndex + 1] <<  8 |
;;;593    																					(int)FrameData[dataIndex + 2] << 16 |
;;;594    																					(int)FrameData[dataIndex + 3] << 24;/* 得到长度数据 */
;;;595    
;;;596    							if(allFrameDataLen - dataIndex - 4 >= frameDataLen)/* 能得到数据内容 */
000044  1b30              SUBS     r0,r6,r4
000046  1f00              SUBS     r0,r0,#4
000048  4540              CMP      r0,r8
00004a  d37d              BCC      |L6.328|
;;;597    							{   
;;;598    									dataIndex += 4;
00004c  1d24              ADDS     r4,r4,#4
;;;599    									switch(FrameData[dataIndex])
00004e  5d28              LDRB     r0,[r5,r4]
000050  281c              CMP      r0,#0x1c
000052  d041              BEQ      |L6.216|
000054  dc06              BGT      |L6.100|
000056  280a              CMP      r0,#0xa
000058  d00b              BEQ      |L6.114|
00005a  2818              CMP      r0,#0x18
00005c  d00d              BEQ      |L6.122|
00005e  281b              CMP      r0,#0x1b
000060  d16e              BNE      |L6.320|
000062  e00e              B        |L6.130|
                  |L6.100|
000064  281d              CMP      r0,#0x1d
000066  d03c              BEQ      |L6.226|
000068  281f              CMP      r0,#0x1f
00006a  d053              BEQ      |L6.276|
00006c  2820              CMP      r0,#0x20
00006e  d167              BNE      |L6.320|
000070  e05a              B        |L6.296|
                  |L6.114|
;;;600    									{
;;;601    											case CAMERA_TAKE_PICTURE:/* 拍照 */
;;;602    											{
;;;603    //												CDC_Transmit_HS("ok\r\n",4);//USART1接收数据转发到VCP发送
;;;604    															takePictureFlag = 1;
000072  2001              MOVS     r0,#1
000074  493d              LDR      r1,|L6.364|
000076  7008              STRB     r0,[r1,#0]
;;;605    //															espSendLogMessage(0xAA,MCU,CMD_LOG_MESSAGE,(char*)"ESP:收到拍照指令");
;;;606    													break;
000078  e063              B        |L6.322|
                  |L6.122|
;;;607    											}
;;;608    											case OPEN_MOTO_CMD:
;;;609    											{
;;;610    															openMotoFlag = 1;
00007a  2001              MOVS     r0,#1
00007c  493c              LDR      r1,|L6.368|
00007e  7008              STRB     r0,[r1,#0]
;;;611    //															espSendLogMessage(0xAA,MCU,CMD_LOG_MESSAGE,(char*)"ESP:收到打开水泵指令");
;;;612    													break;
000080  e05f              B        |L6.322|
                  |L6.130|
;;;613    											}
;;;614    											case SET_RECORD_TIME_CMD:/* 设置固定定时 */
;;;615    											{
;;;616    													dataIndex++;
000082  1c64              ADDS     r4,r4,#1
;;;617    													if(deviceAttributeInfo.recordTimeIndex > 50)
000084  483b              LDR      r0,|L6.372|
000086  f8d0019c          LDR      r0,[r0,#0x19c]  ; deviceAttributeInfo
00008a  2832              CMP      r0,#0x32
00008c  dd00              BLE      |L6.144|
;;;618    													{
;;;619    //																	espSendLogMessage(0xAA,MCU,CMD_LOG_MESSAGE,(char*)"ESP:超过最大设置定时分组，请删除重试");
;;;620    															break;
00008e  e058              B        |L6.322|
                  |L6.144|
;;;621    													}
;;;622    													memcpy((char *)deviceAttributeInfo.recordTime[deviceAttributeInfo.recordTimeIndex],
000090  4838              LDR      r0,|L6.372|
000092  f8d0019c          LDR      r0,[r0,#0x19c]  ; deviceAttributeInfo
000096  eb000140          ADD      r1,r0,r0,LSL #1
00009a  4836              LDR      r0,|L6.372|
00009c  3070              ADDS     r0,r0,#0x70
00009e  eb000041          ADD      r0,r0,r1,LSL #1
0000a2  1929              ADDS     r1,r5,r4
0000a4  680a              LDR      r2,[r1,#0]
0000a6  6002              STR      r2,[r0,#0]
0000a8  7909              LDRB     r1,[r1,#4]
0000aa  7101              STRB     r1,[r0,#4]
;;;623    																			&FrameData[dataIndex],5);
;;;624    													deviceAttributeInfo.recordTime[deviceAttributeInfo.recordTimeIndex][5] = '\0';
0000ac  2100              MOVS     r1,#0
0000ae  4831              LDR      r0,|L6.372|
0000b0  f8d0019c          LDR      r0,[r0,#0x19c]  ; deviceAttributeInfo
0000b4  eb000240          ADD      r2,r0,r0,LSL #1
0000b8  482e              LDR      r0,|L6.372|
0000ba  3070              ADDS     r0,r0,#0x70
0000bc  eb000042          ADD      r0,r0,r2,LSL #1
0000c0  7141              STRB     r1,[r0,#5]
;;;625    													
;;;626    //															ESP_LOGI("TCP","收到数据:%s",(char *)deviceAttributeInfo.recordTime[deviceAttributeInfo.recordTimeIndex]);
;;;627    													deviceAttributeInfo.recordTimeIndex++;
0000c2  482c              LDR      r0,|L6.372|
0000c4  f8d0019c          LDR      r0,[r0,#0x19c]  ; deviceAttributeInfo
0000c8  1c40              ADDS     r0,r0,#1
0000ca  492a              LDR      r1,|L6.372|
0000cc  f8c1019c          STR      r0,[r1,#0x19c]  ; deviceAttributeInfo
;;;628    													
;;;629    													deviceAttributeInfo.scheduledDeletion = 0;/* 固定定时时，间隔定时时间设置无效 */
0000d0  2000              MOVS     r0,#0
0000d2  61c8              STR      r0,[r1,#0x1c]  ; deviceAttributeInfo
;;;630    													dataIndex--;
0000d4  1e64              SUBS     r4,r4,#1
;;;631    													// espSendLogMessage(0xAA,MCU,CMD_LOG_MESSAGE,(char*)"ESP:定时时间");
;;;632    													break;
0000d6  e034              B        |L6.322|
                  |L6.216|
;;;633    											}
;;;634    											case SET_RECORD_TIME_DONE_CMD:
;;;635    											{
;;;636    //															ESP_LOGI("TCP","定时设置结束");
;;;637    												deviceAttributeInfo.recordTimeIndex = 0;
0000d8  2000              MOVS     r0,#0
0000da  4926              LDR      r1,|L6.372|
0000dc  f8c1019c          STR      r0,[r1,#0x19c]  ; deviceAttributeInfo
;;;638    												
;;;639    //															writeDeviceInfo();/* 写入数据到NVS中保存 */
;;;640    													break;
0000e0  e02f              B        |L6.322|
                  |L6.226|
;;;641    											}
;;;642    											case SET_SCHEDULED_TIME_CMD:
;;;643    											{
;;;644    //															ESP_LOGI("TCP","间隔定时");
;;;645    													deviceAttributeInfo.scheduledDeletion = (unsigned short)FrameData[dataIndex + 1] | 
0000e2  1c60              ADDS     r0,r4,#1
0000e4  5c29              LDRB     r1,[r5,r0]
0000e6  1ca0              ADDS     r0,r4,#2
0000e8  5c28              LDRB     r0,[r5,r0]
0000ea  ea412000          ORR      r0,r1,r0,LSL #8
0000ee  4921              LDR      r1,|L6.372|
0000f0  61c8              STR      r0,[r1,#0x1c]  ; deviceAttributeInfo
;;;646    																																	(unsigned short)FrameData[dataIndex + 2]<<8;
;;;647    
;;;648    													for(int i=0;i<50;i++)/* 间隔定时时清除固定定时设置的时间 */
0000f2  2000              MOVS     r0,#0
0000f4  e00b              B        |L6.270|
                  |L6.246|
0000f6  e037              B        |L6.360|
                  |L6.248|
0000f8  e033              B        |L6.354|
                  |L6.250|
;;;649    													{
;;;650    															memset(deviceAttributeInfo.recordTime[i],0,6);
0000fa  eb000240          ADD      r2,r0,r0,LSL #1
0000fe  491d              LDR      r1,|L6.372|
000100  3170              ADDS     r1,r1,#0x70
000102  eb010142          ADD      r1,r1,r2,LSL #1
000106  2200              MOVS     r2,#0
000108  600a              STR      r2,[r1,#0]
00010a  808a              STRH     r2,[r1,#4]
00010c  1c40              ADDS     r0,r0,#1              ;648
                  |L6.270|
00010e  2832              CMP      r0,#0x32              ;648
000110  dbf3              BLT      |L6.250|
;;;651    													}
;;;652    //															ESP_LOGI("TCP","scheduledDeletion = %d",deviceAttributeInfo.scheduledDeletion);
;;;653    													break;
000112  e016              B        |L6.322|
                  |L6.276|
;;;654    											}
;;;655    											case SET_LIED_BRIGHTNESS_CMD:   /* 设置闪光灯亮度 */
;;;656    											{
;;;657    //															ESP_LOGI("TCP","设置闪光灯亮度");
;;;658    													deviceAttributeInfo.ledFlashBrightness = (unsigned short)FrameData[dataIndex + 1] | 
000114  1c60              ADDS     r0,r4,#1
000116  5c29              LDRB     r1,[r5,r0]
000118  1ca0              ADDS     r0,r4,#2
00011a  5c28              LDRB     r0,[r5,r0]
00011c  ea412000          ORR      r0,r1,r0,LSL #8
000120  4914              LDR      r1,|L6.372|
000122  f8c101a0          STR      r0,[r1,#0x1a0]  ; deviceAttributeInfo
;;;659    																																	(unsigned short)FrameData[dataIndex + 2]<<8;
;;;660    
;;;661    //															ESP_LOGI("TCP","ledFlashBrightness = %d",deviceAttributeInfo.ledFlashBrightness);
;;;662    													break;
000126  e00c              B        |L6.322|
                  |L6.296|
;;;663    											}
;;;664    											case SET_TAKE_PICTURE_DELAY_TIME_CMD:    /* 设置拍照延时时间 */
;;;665    											{
;;;666    //															ESP_LOGI("TCP","拍照延时时间");
;;;667    													deviceAttributeInfo.takePictureDelayTime = (unsigned short)FrameData[dataIndex + 1] | 
000128  1c60              ADDS     r0,r4,#1
00012a  5c29              LDRB     r1,[r5,r0]
00012c  1ca0              ADDS     r0,r4,#2
00012e  5c28              LDRB     r0,[r5,r0]
000130  ea412000          ORR      r0,r1,r0,LSL #8
000134  490f              LDR      r1,|L6.372|
000136  f8c101a4          STR      r0,[r1,#0x1a4]  ; deviceAttributeInfo
;;;668    																																	(unsigned short)FrameData[dataIndex + 2]<<8;
;;;669    
;;;670    //															ESP_LOGI("TCP","takePictureDelayTime = %d",deviceAttributeInfo.takePictureDelayTime);
;;;671    													break;
00013a  e002              B        |L6.322|
00013c  e004              B        |L6.328|
00013e  e7ff              B        |L6.320|
                  |L6.320|
;;;672    											}
;;;673    											default:
;;;674    											{
;;;675    													break;
000140  bf00              NOP      
                  |L6.322|
000142  bf00              NOP                            ;606
;;;676    											}
;;;677    									}
;;;678    									dataIndex += frameDataLen;
000144  4444              ADD      r4,r4,r8
000146  e006              B        |L6.342|
                  |L6.328|
;;;679    							}
;;;680    							else/* 有数据长度但是没有数据内容,继续接受数据,下一次解析 */
;;;681    							{
;;;682    									WriteBytes(ringbuffer,&FrameData[dataIndex],allFrameDataLen - dataIndex);/* 写入剩余数据 */
000148  1b30              SUBS     r0,r6,r4
00014a  b282              UXTH     r2,r0
00014c  1929              ADDS     r1,r5,r4
00014e  4638              MOV      r0,r7
000150  f7fffffe          BL       WriteBytes
;;;683    									break;
000154  e004              B        |L6.352|
                  |L6.342|
;;;684    							}
;;;685    					}
000156  bf00              NOP      
                  |L6.344|
000158  1b30              SUBS     r0,r6,r4              ;589
00015a  2804              CMP      r0,#4                 ;589
00015c  f6bfaf65          BGE      |L6.42|
                  |L6.352|
000160  bf00              NOP                            ;683
                  |L6.354|
;;;686    			}
;;;687    			vPortFree(FrameData);  //释放内存
000162  4628              MOV      r0,r5
000164  f7fffffe          BL       vPortFree
                  |L6.360|
;;;688    	}
;;;689    }
000168  e8bd81f0          POP      {r4-r8,pc}
;;;690    /* USER CODE END Application */
                          ENDP

                  |L6.364|
                          DCD      takePictureFlag
                  |L6.368|
                          DCD      openMotoFlag
                  |L6.372|
                          DCD      deviceAttributeInfo

                          AREA ||i.vcpDataAnalysis||, CODE, READONLY, ALIGN=2

                  vcpDataAnalysis PROC
;;;425    */
;;;426    static void vcpDataAnalysis(_RingBuffer *ringbuffer)
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;427    {
000004  4680              MOV      r8,r0
;;;428    	unsigned char *RxFrameData;/*存储解析帧的空间*/
;;;429    	unsigned short FrameDataLen = ringbuffer->Lenght;
000006  f8b86004          LDRH     r6,[r8,#4]
;;;430    	if(xPortGetFreeHeapSize() >= FrameDataLen)
00000a  f7fffffe          BL       xPortGetFreeHeapSize
00000e  42b0              CMP      r0,r6
000010  d371              BCC      |L7.246|
;;;431    	{
;;;432    		RxFrameData = (unsigned char *)pvPortMalloc(FrameDataLen);	/*为读取缓冲区中的所有数据申请内存*/
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       pvPortMalloc
000018  4605              MOV      r5,r0
;;;433    		if(ReadBytes(ringbuffer,RxFrameData,FrameDataLen) == 1)		/*读取缓冲区中的所有数据*/
00001a  4632              MOV      r2,r6
00001c  4629              MOV      r1,r5
00001e  4640              MOV      r0,r8
000020  f7fffffe          BL       ReadBytes
000024  2801              CMP      r0,#1
000026  d167              BNE      |L7.248|
;;;434    		{
;;;435    			/*读取到缓冲区的数据*/
;;;436    			for(int i=0;i<FrameDataLen;i++)	/*遍历*/
000028  2400              MOVS     r4,#0
00002a  e0e6              B        |L7.506|
                  |L7.44|
;;;437    			{
;;;438    				if(RxFrameData[i] == 0xAA)			/*找帧头*/
00002c  5d28              LDRB     r0,[r5,r4]
00002e  28aa              CMP      r0,#0xaa
000030  d176              BNE      |L7.288|
;;;439    				{
;;;440    					if(FrameDataLen - i <= 3)		/*帧头后面无数据长度*/
000032  1b30              SUBS     r0,r6,r4
000034  2803              CMP      r0,#3
000036  dc0a              BGT      |L7.78|
;;;441    					{
;;;442    						WriteBytes(ringbuffer,&RxFrameData[i],FrameDataLen - i);/*未处理的数据写回缓冲区*/
000038  1b30              SUBS     r0,r6,r4
00003a  b282              UXTH     r2,r0
00003c  1929              ADDS     r1,r5,r4
00003e  4640              MOV      r0,r8
000040  f7fffffe          BL       WriteBytes
;;;443    						vPortFree(RxFrameData);  //释放内存
000044  4628              MOV      r0,r5
000046  f7fffffe          BL       vPortFree
                  |L7.74|
;;;444    						return ;/*返回空数据*/
;;;445    					}
;;;446    					
;;;447    					unsigned short FrameLen = RxFrameData[i+3];			/*得到帧数据内容长度*/
;;;448    					
;;;449    					if((FrameDataLen - i) >= (4 + FrameLen + 2))	/*剩余数据是否还有一帧的长度*/
;;;450    					{
;;;451    						if(FrameDataCheck( &RxFrameData[i] ) == 1)		/*校验帧数据*/
;;;452    						{
;;;453    							unsigned short OneFrameDataLen = 4 + FrameLen + 2;			/*返回帧总长*/
;;;454    							if(RxFrameData[i+1] == PC)														/*是上位机发送的数据*/
;;;455    							{
;;;456    								switch (RxFrameData[i+2])
;;;457    								{
;;;458    										case CDM_WIFI_NAME:
;;;459    										{
;;;460    //																					memset(wifiName,0,sizeof(wifiName));
;;;461    //																					memcpy((char *)wifiName, &RxFrameData[i+4],FrameLen);
;;;462    												break;
;;;463    										}
;;;464    										case CMD_WIFI_PASSWORD:
;;;465    										{
;;;466    //																					memset(wifiPassword,0,sizeof(wifiPassword));
;;;467    //																					memcpy((char *)wifiPassword, &RxFrameData[i+4],FrameLen);
;;;468    												break;
;;;469    										}
;;;470    										case CMD_SERVER_IP:
;;;471    										{
;;;472    												memset(deviceAttributeInfo.UDP_serverIP,0,sizeof(deviceAttributeInfo.UDP_serverIP));
;;;473    												memcpy((char *)deviceAttributeInfo.UDP_serverIP, &RxFrameData[i+4],FrameLen);
;;;474    												break;
;;;475    										}
;;;476    										case CMD_DEVICE_ID:
;;;477    										{
;;;478    												memset(deviceAttributeInfo.deviceID,0,sizeof(deviceAttributeInfo.deviceID));
;;;479    												memcpy((char *)deviceAttributeInfo.deviceID, &RxFrameData[i+4],FrameLen);
;;;480    												break;
;;;481    										}
;;;482    										case CMD_SERVER_PORT:
;;;483    										{
;;;484    												char temp[10];
;;;485    												memcpy((char *)temp, &RxFrameData[i+4],FrameLen);
;;;486    												deviceAttributeInfo.UDP_serverPort = atoi(temp);
;;;487    												break;
;;;488    										}
;;;489    										case CMD_PICTURE_SIZE:
;;;490    										{
;;;491    //																					camera_config.frame_size = RxFrameData[i+4] | RxFrameData[i+5] <<8;
;;;492    												break;
;;;493    										}
;;;494    										case CMD_PICTURE_QUALITY:
;;;495    										{
;;;496    //																					camera_config.jpeg_quality = RxFrameData[i+4] | RxFrameData[i+5] <<8;
;;;497    												break;
;;;498    										}
;;;499    										case CMD_SET_LIED_BRIGHTNESS:
;;;500    										{
;;;501    												deviceAttributeInfo.ledFlashBrightness = RxFrameData[i+4] | RxFrameData[i+5] <<8;
;;;502    //																					ESP_LOGI("UART","灯的亮度为 = %d",deviceAttributeInfo.ledFlashBrightness);
;;;503    												break;
;;;504    										}
;;;505    										case CMD_SET_TAKE_PICTURE_DELAY_TIME:
;;;506    										{
;;;507    												deviceAttributeInfo.takePictureDelayTime = RxFrameData[i+4] | RxFrameData[i+5] <<8;
;;;508    //																					ESP_LOGI("UART","拍照延时 = %d",deviceAttributeInfo.takePictureDelayTime);
;;;509    												break;
;;;510    										}
;;;511    
;;;512    										case CMD_SET_PARA_END:
;;;513    										{
;;;514    											WriteFlashData(ADDR_FLASH_SECTOR_7,(unsigned char *)deviceAttributeInfo.picFormat,sizeof(_deviceInfo));
;;;515    //																					writeDeviceInfo();
;;;516    //																					espSendLogMessage(0xAA,MCU,CMD_LOG_MESSAGE,(char*)"ESP:数据写入完成,2s后重启");
;;;517    //																					ESP_LOGI("UART","数据写入完成,2s后重启");
;;;518    //																					vTaskDelay(2000/portTICK_PERIOD_MS);
;;;519    //																					esp_restart();/* 重启设备 */
;;;520    												break;
;;;521    										}
;;;522    										case CMD_SHOW_DEVICE_INFO:
;;;523    										{
;;;524    //																					showEspInfo();
;;;525    												break;
;;;526    										}
;;;527    										case CMD_RESET_DEVICE:
;;;528    										{
;;;529    //																					esp_restart();
;;;530    												break;
;;;531    										}
;;;532    										case CMD_SET_RECORD_TIME:
;;;533    										{
;;;534    												if(deviceAttributeInfo.recordTimeIndex > 50)
;;;535    												{
;;;536    //																							espSendLogMessage(0xAA,MCU,CMD_LOG_MESSAGE,(char*)"ESP:超过最大设置定时分组，请删除重试");
;;;537    														break;
;;;538    												}
;;;539    												memset((char *)deviceAttributeInfo.recordTime[deviceAttributeInfo.recordTimeIndex],0,6);
;;;540    												memcpy((char *)deviceAttributeInfo.recordTime[deviceAttributeInfo.recordTimeIndex], &RxFrameData[i+4],FrameLen);
;;;541    												deviceAttributeInfo.recordTime[deviceAttributeInfo.recordTimeIndex][5] = '\0';
;;;542    												deviceAttributeInfo.recordTimeIndex++;
;;;543    												deviceAttributeInfo.scheduledDeletion = 0;
;;;544    												break;
;;;545    										}
;;;546    										case CMD_SET_DELAY_TIME:
;;;547    										{
;;;548    												deviceAttributeInfo.scheduledDeletion = RxFrameData[i+4] | RxFrameData[i+5] <<8;
;;;549    //																					ESP_LOGI("info","scheduledDeletion = %d",deviceAttributeInfo.scheduledDeletion);
;;;550    												for(int i=0;i<50;i++)/* 间隔定时时清除固定定时设置的时间 */
;;;551    												{
;;;552    														memset(deviceAttributeInfo.recordTime[i],0,6);
;;;553    												}
;;;554    										}
;;;555    										default:
;;;556    												break;
;;;557    								}
;;;558    							}
;;;559    							i += OneFrameDataLen-1;										/*偏移*/
;;;560    						}
;;;561    					}
;;;562    					else
;;;563    					{
;;;564    						WriteBytes(ringbuffer,&RxFrameData[i],FrameDataLen - i);/*未处理的数据写回缓冲区*/
;;;565    						vPortFree(RxFrameData);  //释放内存
;;;566    						return ;
;;;567    					}
;;;568    				}
;;;569    			}
;;;570    		}
;;;571    		vPortFree(RxFrameData);  //释放内存
;;;572    	}
;;;573    }
00004a  e8bd83fe          POP      {r1-r9,pc}
                  |L7.78|
00004e  1ce0              ADDS     r0,r4,#3              ;447
000050  5c2f              LDRB     r7,[r5,r0]            ;447
000052  1b31              SUBS     r1,r6,r4              ;449
000054  1db8              ADDS     r0,r7,#6              ;449
000056  4281              CMP      r1,r0                 ;449
000058  db7e              BLT      |L7.344|
00005a  1928              ADDS     r0,r5,r4              ;451
00005c  f7fffffe          BL       FrameDataCheck
000060  2801              CMP      r0,#1                 ;451
000062  d17a              BNE      |L7.346|
000064  1db8              ADDS     r0,r7,#6              ;453
000066  fa1ff980          UXTH     r9,r0                 ;453
00006a  1c60              ADDS     r0,r4,#1              ;454
00006c  5c28              LDRB     r0,[r5,r0]            ;454
00006e  28a5              CMP      r0,#0xa5              ;454
000070  d174              BNE      |L7.348|
000072  1ca0              ADDS     r0,r4,#2              ;456
000074  5c28              LDRB     r0,[r5,r0]            ;456
000076  280f              CMP      r0,#0xf               ;456
000078  d271              BCS      |L7.350|
00007a  e8dff000          TBB      [pc,r0]               ;456
00007e  0809              DCB      0x08,0x09
000080  0a222f30          DCB      0x0a,0x22,0x2f,0x30
000084  49ac1552          DCB      0x49,0xac,0x15,0x52
000088  53549431          DCB      0x53,0x54,0x94,0x31
00008c  3e00              DCB      0x3e,0x00
00008e  e0a3              B        |L7.472|
000090  e0a2              B        |L7.472|
000092  2114              MOVS     r1,#0x14              ;472
000094  485d              LDR      r0,|L7.524|
000096  f7fffffe          BL       __aeabi_memclr4
00009a  1d20              ADDS     r0,r4,#4              ;473
00009c  1829              ADDS     r1,r5,r0              ;473
00009e  463a              MOV      r2,r7                 ;473
0000a0  485a              LDR      r0,|L7.524|
0000a2  f7fffffe          BL       __aeabi_memcpy
0000a6  e097              B        |L7.472|
0000a8  2132              MOVS     r1,#0x32              ;478
0000aa  4858              LDR      r0,|L7.524|
0000ac  3838              SUBS     r0,r0,#0x38           ;478
0000ae  f7fffffe          BL       __aeabi_memclr4
0000b2  1d20              ADDS     r0,r4,#4              ;479
0000b4  1829              ADDS     r1,r5,r0              ;479
0000b6  463a              MOV      r2,r7                 ;479
0000b8  4854              LDR      r0,|L7.524|
0000ba  3838              SUBS     r0,r0,#0x38           ;479
0000bc  f7fffffe          BL       __aeabi_memcpy
0000c0  e08a              B        |L7.472|
0000c2  1d20              ADDS     r0,r4,#4              ;485
0000c4  1829              ADDS     r1,r5,r0              ;485
0000c6  463a              MOV      r2,r7                 ;485
0000c8  4668              MOV      r0,sp                 ;485
0000ca  f7fffffe          BL       __aeabi_memcpy
0000ce  4668              MOV      r0,sp                 ;486
0000d0  f7fffffe          BL       atoi
0000d4  494d              LDR      r1,|L7.524|
0000d6  3958              SUBS     r1,r1,#0x58           ;486
0000d8  66c8              STR      r0,[r1,#0x6c]         ;486  ; deviceAttributeInfo
0000da  e07d              B        |L7.472|
0000dc  e07c              B        |L7.472|
0000de  e07b              B        |L7.472|
0000e0  1d20              ADDS     r0,r4,#4              ;501
0000e2  5c29              LDRB     r1,[r5,r0]            ;501
0000e4  1d60              ADDS     r0,r4,#5              ;501
0000e6  5c28              LDRB     r0,[r5,r0]            ;501
0000e8  ea412000          ORR      r0,r1,r0,LSL #8       ;501
0000ec  4947              LDR      r1,|L7.524|
0000ee  3958              SUBS     r1,r1,#0x58           ;501
0000f0  f8c101a0          STR      r0,[r1,#0x1a0]        ;501  ; deviceAttributeInfo
0000f4  e070              B        |L7.472|
                  |L7.246|
0000f6  e086              B        |L7.518|
                  |L7.248|
0000f8  e082              B        |L7.512|
0000fa  1d20              ADDS     r0,r4,#4              ;507
0000fc  5c29              LDRB     r1,[r5,r0]            ;507
0000fe  1d60              ADDS     r0,r4,#5              ;507
000100  5c28              LDRB     r0,[r5,r0]            ;507
000102  ea412000          ORR      r0,r1,r0,LSL #8       ;507
000106  4941              LDR      r1,|L7.524|
000108  3958              SUBS     r1,r1,#0x58           ;507
00010a  f8c101a4          STR      r0,[r1,#0x1a4]        ;507  ; deviceAttributeInfo
00010e  e063              B        |L7.472|
000110  f44f72d4          MOV      r2,#0x1a8             ;514
000114  493d              LDR      r1,|L7.524|
000116  3958              SUBS     r1,r1,#0x58           ;514
000118  483d              LDR      r0,|L7.528|
00011a  f7fffffe          BL       WriteFlashData
00011e  e05b              B        |L7.472|
                  |L7.288|
000120  e06a              B        |L7.504|
000122  e059              B        |L7.472|
000124  e058              B        |L7.472|
000126  4839              LDR      r0,|L7.524|
000128  3858              SUBS     r0,r0,#0x58           ;534
00012a  f8d0019c          LDR      r0,[r0,#0x19c]        ;534  ; deviceAttributeInfo
00012e  2832              CMP      r0,#0x32              ;534
000130  dd00              BLE      |L7.308|
000132  e051              B        |L7.472|
                  |L7.308|
000134  4835              LDR      r0,|L7.524|
000136  3858              SUBS     r0,r0,#0x58           ;539
000138  f8d0019c          LDR      r0,[r0,#0x19c]        ;539  ; deviceAttributeInfo
00013c  eb000140          ADD      r1,r0,r0,LSL #1       ;539
000140  4832              LDR      r0,|L7.524|
000142  3018              ADDS     r0,r0,#0x18           ;539
000144  eb000041          ADD      r0,r0,r1,LSL #1       ;539
000148  2100              MOVS     r1,#0                 ;539
00014a  6001              STR      r1,[r0,#0]            ;539
00014c  8081              STRH     r1,[r0,#4]            ;539
00014e  1d22              ADDS     r2,r4,#4              ;540
000150  18a9              ADDS     r1,r5,r2              ;540
000152  4a2e              LDR      r2,|L7.524|
000154  3a58              SUBS     r2,r2,#0x58           ;540
000156  e003              B        |L7.352|
                  |L7.344|
000158  e043              B        |L7.482|
                  |L7.346|
00015a  e04c              B        |L7.502|
                  |L7.348|
00015c  e03d              B        |L7.474|
                  |L7.350|
00015e  e03a              B        |L7.470|
                  |L7.352|
000160  f8d2219c          LDR      r2,[r2,#0x19c]        ;540  ; deviceAttributeInfo
000164  eb020342          ADD      r3,r2,r2,LSL #1       ;540
000168  4a28              LDR      r2,|L7.524|
00016a  3218              ADDS     r2,r2,#0x18           ;540
00016c  eb020043          ADD      r0,r2,r3,LSL #1       ;540
000170  463a              MOV      r2,r7                 ;540
000172  f7fffffe          BL       __aeabi_memcpy
000176  2100              MOVS     r1,#0                 ;541
000178  4824              LDR      r0,|L7.524|
00017a  3858              SUBS     r0,r0,#0x58           ;541
00017c  f8d0019c          LDR      r0,[r0,#0x19c]        ;541  ; deviceAttributeInfo
000180  eb000240          ADD      r2,r0,r0,LSL #1       ;541
000184  4821              LDR      r0,|L7.524|
000186  3018              ADDS     r0,r0,#0x18           ;541
000188  eb000042          ADD      r0,r0,r2,LSL #1       ;541
00018c  7141              STRB     r1,[r0,#5]            ;541
00018e  481f              LDR      r0,|L7.524|
000190  3858              SUBS     r0,r0,#0x58           ;542
000192  f8d0019c          LDR      r0,[r0,#0x19c]        ;542  ; deviceAttributeInfo
000196  1c40              ADDS     r0,r0,#1              ;542
000198  491c              LDR      r1,|L7.524|
00019a  3958              SUBS     r1,r1,#0x58           ;542
00019c  f8c1019c          STR      r0,[r1,#0x19c]        ;542  ; deviceAttributeInfo
0001a0  2000              MOVS     r0,#0                 ;543
0001a2  61c8              STR      r0,[r1,#0x1c]         ;543  ; deviceAttributeInfo
0001a4  e018              B        |L7.472|
0001a6  1d20              ADDS     r0,r4,#4              ;548
0001a8  5c29              LDRB     r1,[r5,r0]            ;548
0001aa  1d60              ADDS     r0,r4,#5              ;548
0001ac  5c28              LDRB     r0,[r5,r0]            ;548
0001ae  ea412000          ORR      r0,r1,r0,LSL #8       ;548
0001b2  4916              LDR      r1,|L7.524|
0001b4  3958              SUBS     r1,r1,#0x58           ;548
0001b6  61c8              STR      r0,[r1,#0x1c]         ;548  ; deviceAttributeInfo
0001b8  2000              MOVS     r0,#0                 ;550
0001ba  e009              B        |L7.464|
                  |L7.444|
0001bc  eb000240          ADD      r2,r0,r0,LSL #1       ;552
0001c0  4912              LDR      r1,|L7.524|
0001c2  3118              ADDS     r1,r1,#0x18           ;552
0001c4  eb010142          ADD      r1,r1,r2,LSL #1       ;552
0001c8  2200              MOVS     r2,#0                 ;552
0001ca  600a              STR      r2,[r1,#0]            ;552
0001cc  808a              STRH     r2,[r1,#4]            ;552
0001ce  1c40              ADDS     r0,r0,#1              ;550
                  |L7.464|
0001d0  2832              CMP      r0,#0x32              ;550
0001d2  dbf3              BLT      |L7.444|
0001d4  bf00              NOP                            ;555
                  |L7.470|
0001d6  bf00              NOP                            ;556
                  |L7.472|
0001d8  bf00              NOP                            ;462
                  |L7.474|
0001da  f1a90001          SUB      r0,r9,#1              ;559
0001de  4404              ADD      r4,r4,r0              ;559
0001e0  e009              B        |L7.502|
                  |L7.482|
0001e2  1b30              SUBS     r0,r6,r4              ;564
0001e4  b282              UXTH     r2,r0                 ;564
0001e6  1929              ADDS     r1,r5,r4              ;564
0001e8  4640              MOV      r0,r8                 ;564
0001ea  f7fffffe          BL       WriteBytes
0001ee  4628              MOV      r0,r5                 ;565
0001f0  f7fffffe          BL       vPortFree
0001f4  e729              B        |L7.74|
                  |L7.502|
0001f6  bf00              NOP                            ;568
                  |L7.504|
0001f8  1c64              ADDS     r4,r4,#1              ;436
                  |L7.506|
0001fa  42b4              CMP      r4,r6                 ;436
0001fc  f6ffaf16          BLT      |L7.44|
                  |L7.512|
000200  4628              MOV      r0,r5                 ;571
000202  f7fffffe          BL       vPortFree
                  |L7.518|
000206  bf00              NOP      
000208  e71f              B        |L7.74|
;;;574    /*
                          ENDP

00020a  0000              DCW      0x0000
                  |L7.524|
                          DCD      deviceAttributeInfo+0x58
                  |L7.528|
                          DCD      0x08060000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  AT_CDM_9
                          %        50

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  AT_CDM_1
000000  41542b43          DCB      0x41,0x54,0x2b,0x43
000004  5245473f          DCB      0x52,0x45,0x47,0x3f
000008  0d0a00            DCB      0x0d,0x0a,0x00
                  AT_CDM_2
00000b  41                DCB      0x41
00000c  542b4347          DCB      0x54,0x2b,0x43,0x47
000010  4154543f          DCB      0x41,0x54,0x54,0x3f
000014  0d0a00            DCB      0x0d,0x0a,0x00
                  AT_CDM_3
000017  41                DCB      0x41
000018  542b4349          DCB      0x54,0x2b,0x43,0x49
00001c  504d5558          DCB      0x50,0x4d,0x55,0x58
000020  3d300d0a          DCB      0x3d,0x30,0x0d,0x0a
000024  00                DCB      0x00
                  AT_CDM_4
000025  41542b            DCB      0x41,0x54,0x2b
000028  4349504d          DCB      0x43,0x49,0x50,0x4d
00002c  4f44453d          DCB      0x4f,0x44,0x45,0x3d
000030  310d0a00          DCB      0x31,0x0d,0x0a,0x00
                  AT_CDM_5
000034  41542b43          DCB      0x41,0x54,0x2b,0x43
000038  5354540d          DCB      0x53,0x54,0x54,0x0d
00003c  0a00              DCB      0x0a,0x00
                  AT_CDM_6
00003e  4154              DCB      0x41,0x54
000040  2b434949          DCB      0x2b,0x43,0x49,0x49
000044  43520d0a          DCB      0x43,0x52,0x0d,0x0a
000048  00                DCB      0x00
                  AT_CDM_7
000049  41542b            DCB      0x41,0x54,0x2b
00004c  43494653          DCB      0x43,0x49,0x46,0x53
000050  520d0a00          DCB      0x52,0x0d,0x0a,0x00
                  AT_CDM_8
000054  41542b43          DCB      0x41,0x54,0x2b,0x43
000058  49505354          DCB      0x49,0x50,0x53,0x54
00005c  41545553          DCB      0x41,0x54,0x55,0x53
000060  0d0a0000          DCB      0x0d,0x0a,0x00,0x00
                  defaultTask_attributes
                          DCD      ||.conststring||
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000200
                          DCD      0x00000018
                          DCD      0x00000000
                          DCD      0x00000000
                  cmdAnalysis_attributes
                          DCD      ||.conststring||+0xc
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000200
                          DCD      0x0000001f
                          DCD      0x00000000
                          DCD      0x00000000
                  sendDataTask_attributes
                          DCD      ||.conststring||+0x18
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000200
                          DCD      0x0000001e
                          DCD      0x00000000
                          DCD      0x00000000
                  ledTask_attributes
                          DCD      ||.conststring||+0x28
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000200
                          DCD      0x0000000f
                          DCD      0x00000000
                          DCD      0x00000000

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  64656661          DCB      "defaultTask",0
000004  756c7454
000008  61736b00
00000c  636d6441          DCB      "cmdAnalysis",0
000010  6e616c79
000014  73697300
000018  73656e64          DCB      "sendDataTask",0
00001c  44617461
000020  5461736b
000024  00      
000025  00                DCB      0
000026  00                DCB      0
000027  00                DCB      0
000028  6c656454          DCB      "ledTask",0
00002c  61736b00

                          AREA ||.data||, DATA, ALIGN=2

                  defaultTaskHandle
                          DCD      0x00000000
                  cmdAnalysisHandle
                          DCD      0x00000000
                  sendDataTaskHandle
                          DCD      0x00000000
                  ledTaskHandle
                          DCD      0x00000000
                  anlysis
000010  00                DCB      0x00
                  takePictureFlag
000011  00                DCB      0x00
                  openMotoFlag
000012  00                DCB      0x00
                  keyFlag
000013  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "../Core/Src/freertos.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_freertos_c_AT_CDM_1____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___10_freertos_c_AT_CDM_1____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_freertos_c_AT_CDM_1____REVSH|
#line 478
|__asm___10_freertos_c_AT_CDM_1____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_freertos_c_AT_CDM_1____RRX|
#line 665
|__asm___10_freertos_c_AT_CDM_1____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
