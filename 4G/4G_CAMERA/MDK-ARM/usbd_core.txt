; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o4gcamera\usbd_core.o --asm_dir=.\ --list_dir=.\ --depend=4gcamera\usbd_core.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../USB_DEVICE/App -I../USB_DEVICE/Target -I../Core/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Middlewares/ST/STM32_USB_Device_Library/Core/Inc -I../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 -I../Middlewares/Third_Party/FreeRTOS/Source/portable/RVDS/ARM_CM4F -I../HARDWARE/OV2640 -I../HARDWARE/WS2812B -I../HARDWARE/RING_BUFFER -I../HARDWARE/FLASH -I.\RTE\_4GCAMERA -IC:\Users\czm\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\czm\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=536 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F407xx --omf_browse=4gcamera\usbd_core.crf ../Middlewares/ST/STM32_USB_Device_Library/Core/Src/usbd_core.c]
                          THUMB

                          AREA ||i.USBD_ClrClassConfig||, CODE, READONLY, ALIGN=1

                  USBD_ClrClassConfig PROC
;;;491      */
;;;492    USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
000000  b570              PUSH     {r4-r6,lr}
;;;493    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;494      USBD_StatusTypeDef ret = USBD_OK;
000006  2600              MOVS     r6,#0
;;;495    
;;;496    #ifdef USE_USBD_COMPOSITE
;;;497      /* Parse the table of classes in use */
;;;498      for (uint32_t i = 0U; i < USBD_MAX_SUPPORTED_CLASS; i++)
;;;499      {
;;;500        /* Check if current class is in use */
;;;501        if ((pdev->tclasslist[i].Active) == 1U)
;;;502        {
;;;503          if (pdev->pClass[i] != NULL)
;;;504          {
;;;505            pdev->classId = i;
;;;506            /* Clear configuration  and De-initialize the Class process */
;;;507            if (pdev->pClass[i]->DeInit(pdev, cfgidx) != 0U)
;;;508            {
;;;509              ret = USBD_FAIL;
;;;510            }
;;;511          }
;;;512        }
;;;513      }
;;;514    #else
;;;515      /* Clear configuration  and De-initialize the Class process */
;;;516      if (pdev->pClass[0]->DeInit(pdev, cfgidx) != 0U)
000008  f8d402b8          LDR      r0,[r4,#0x2b8]
00000c  4629              MOV      r1,r5
00000e  6842              LDR      r2,[r0,#4]
000010  4620              MOV      r0,r4
000012  4790              BLX      r2
000014  b100              CBZ      r0,|L1.24|
;;;517      {
;;;518        ret = USBD_FAIL;
000016  2603              MOVS     r6,#3
                  |L1.24|
;;;519      }
;;;520    #endif /* USE_USBD_COMPOSITE */
;;;521    
;;;522      return ret;
000018  4630              MOV      r0,r6
;;;523    }
00001a  bd70              POP      {r4-r6,pc}
;;;524    
                          ENDP


                          AREA ||i.USBD_CoreFindEP||, CODE, READONLY, ALIGN=1

                  USBD_CoreFindEP PROC
;;;1085     */
;;;1086   uint8_t USBD_CoreFindEP(USBD_HandleTypeDef *pdev, uint8_t index)
000000  4602              MOV      r2,r0
;;;1087   {
;;;1088   #ifdef USE_USBD_COMPOSITE
;;;1089     /* Parse the table of classes in use */
;;;1090     for (uint32_t i = 0U; i < USBD_MAX_SUPPORTED_CLASS; i++)
;;;1091     {
;;;1092       /* Check if current class is in use */
;;;1093       if ((pdev->tclasslist[i].Active) == 1U)
;;;1094       {
;;;1095         /* Parse all endpoints listed in the current class */
;;;1096         for (uint32_t j = 0U; j < pdev->tclasslist[i].NumEps; j++)
;;;1097         {
;;;1098           /* Check if requested endpoint matches the current class endpoint */
;;;1099           if (pdev->tclasslist[i].Eps[j].add == index)
;;;1100           {
;;;1101             if (pdev->pClass[i]->Setup != NULL)
;;;1102             {
;;;1103               return (uint8_t)i;
;;;1104             }
;;;1105           }
;;;1106         }
;;;1107       }
;;;1108     }
;;;1109   
;;;1110     return 0xFFU;
;;;1111   #else
;;;1112     UNUSED(pdev);
;;;1113     UNUSED(index);
;;;1114   
;;;1115     return 0x00U;
000002  2000              MOVS     r0,#0
;;;1116   #endif /* USE_USBD_COMPOSITE */
;;;1117   }
000004  4770              BX       lr
;;;1118   
                          ENDP


                          AREA ||i.USBD_CoreFindIF||, CODE, READONLY, ALIGN=1

                  USBD_CoreFindIF PROC
;;;1045     */
;;;1046   uint8_t USBD_CoreFindIF(USBD_HandleTypeDef *pdev, uint8_t index)
000000  4602              MOV      r2,r0
;;;1047   {
;;;1048   #ifdef USE_USBD_COMPOSITE
;;;1049     /* Parse the table of classes in use */
;;;1050     for (uint32_t i = 0U; i < USBD_MAX_SUPPORTED_CLASS; i++)
;;;1051     {
;;;1052       /* Check if current class is in use */
;;;1053       if ((pdev->tclasslist[i].Active) == 1U)
;;;1054       {
;;;1055         /* Parse all interfaces listed in the current class */
;;;1056         for (uint32_t j = 0U; j < pdev->tclasslist[i].NumIf; j++)
;;;1057         {
;;;1058           /* Check if requested Interface matches the current class interface */
;;;1059           if (pdev->tclasslist[i].Ifs[j] == index)
;;;1060           {
;;;1061             if (pdev->pClass[i]->Setup != NULL)
;;;1062             {
;;;1063               return (uint8_t)i;
;;;1064             }
;;;1065           }
;;;1066         }
;;;1067       }
;;;1068     }
;;;1069   
;;;1070     return 0xFFU;
;;;1071   #else
;;;1072     UNUSED(pdev);
;;;1073     UNUSED(index);
;;;1074   
;;;1075     return 0x00U;
000002  2000              MOVS     r0,#0
;;;1076   #endif /* USE_USBD_COMPOSITE */
;;;1077   }
000004  4770              BX       lr
;;;1078   
                          ENDP


                          AREA ||i.USBD_DeInit||, CODE, READONLY, ALIGN=1

                  USBD_DeInit PROC
;;;148      */
;;;149    USBD_StatusTypeDef USBD_DeInit(USBD_HandleTypeDef *pdev)
000000  b570              PUSH     {r4-r6,lr}
;;;150    {
000002  4604              MOV      r4,r0
;;;151      USBD_StatusTypeDef ret;
;;;152    
;;;153      /* Disconnect the USB Device */
;;;154      (void)USBD_LL_Stop(pdev);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       USBD_LL_Stop
;;;155    
;;;156      /* Set Default State */
;;;157      pdev->dev_state = USBD_STATE_DEFAULT;
00000a  2001              MOVS     r0,#1
00000c  f884029c          STRB     r0,[r4,#0x29c]
;;;158    
;;;159    #ifdef USE_USBD_COMPOSITE
;;;160      /* Parse the table of classes in use */
;;;161      for (uint32_t i = 0; i < USBD_MAX_SUPPORTED_CLASS; i++)
;;;162      {
;;;163        /* Check if current class is in use */
;;;164        if ((pdev->tclasslist[i].Active) == 1U)
;;;165        {
;;;166          if (pdev->pClass[i] != NULL)
;;;167          {
;;;168            pdev->classId = i;
;;;169            /* Free Class Resources */
;;;170            pdev->pClass[i]->DeInit(pdev, (uint8_t)pdev->dev_config);
;;;171          }
;;;172        }
;;;173      }
;;;174    #else
;;;175      /* Free Class Resources */
;;;176      if (pdev->pClass[0] != NULL)
000010  f8d402b8          LDR      r0,[r4,#0x2b8]
000014  b128              CBZ      r0,|L4.34|
;;;177      {
;;;178        pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config);
000016  7921              LDRB     r1,[r4,#4]
000018  f8d402b8          LDR      r0,[r4,#0x2b8]
00001c  6842              LDR      r2,[r0,#4]
00001e  4620              MOV      r0,r4
000020  4790              BLX      r2
                  |L4.34|
;;;179      }
;;;180    
;;;181      pdev->pUserData[0] = NULL;
000022  2000              MOVS     r0,#0
000024  f8c402c4          STR      r0,[r4,#0x2c4]
;;;182    
;;;183    #endif /* USE_USBD_COMPOSITE */
;;;184    
;;;185      /* Free Device descriptors resources */
;;;186      pdev->pDesc = NULL;
000028  f8c402b4          STR      r0,[r4,#0x2b4]
;;;187      pdev->pConfDesc = NULL;
00002c  f8c402d0          STR      r0,[r4,#0x2d0]
;;;188    
;;;189      /* DeInitialize low level driver */
;;;190      ret = USBD_LL_DeInit(pdev);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       USBD_LL_DeInit
000036  4605              MOV      r5,r0
;;;191    
;;;192      return ret;
000038  4628              MOV      r0,r5
;;;193    }
00003a  bd70              POP      {r4-r6,pc}
;;;194    
                          ENDP


                          AREA ||i.USBD_GetEpDesc||, CODE, READONLY, ALIGN=1

                  USBD_GetEpDesc PROC
;;;1155     */
;;;1156   void *USBD_GetEpDesc(uint8_t *pConfDesc, uint8_t EpAddr)
000000  e92d41f8          PUSH     {r3-r8,lr}
;;;1157   {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;1158     USBD_DescHeaderTypeDef *pdesc = (USBD_DescHeaderTypeDef *)(void *)pConfDesc;
000008  462c              MOV      r4,r5
;;;1159     USBD_ConfigDescTypeDef *desc = (USBD_ConfigDescTypeDef *)(void *)pConfDesc;
00000a  462e              MOV      r6,r5
;;;1160     USBD_EpDescTypeDef *pEpDesc = NULL;
00000c  f04f0800          MOV      r8,#0
;;;1161     uint16_t ptr;
;;;1162   
;;;1163     if (desc->wTotalLength > desc->bLength)
000010  8870              LDRH     r0,[r6,#2]
000012  7831              LDRB     r1,[r6,#0]
000014  4288              CMP      r0,r1
000016  dd18              BLE      |L5.74|
;;;1164     {
;;;1165       ptr = desc->bLength;
000018  7830              LDRB     r0,[r6,#0]
00001a  9000              STR      r0,[sp,#0]
;;;1166   
;;;1167       while (ptr < desc->wTotalLength)
00001c  e00f              B        |L5.62|
                  |L5.30|
;;;1168       {
;;;1169         pdesc = USBD_GetNextDesc((uint8_t *)pdesc, &ptr);
00001e  4669              MOV      r1,sp
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       USBD_GetNextDesc
000026  4604              MOV      r4,r0
;;;1170   
;;;1171         if (pdesc->bDescriptorType == USB_DESC_TYPE_ENDPOINT)
000028  7860              LDRB     r0,[r4,#1]
00002a  2805              CMP      r0,#5
00002c  d107              BNE      |L5.62|
;;;1172         {
;;;1173           pEpDesc = (USBD_EpDescTypeDef *)(void *)pdesc;
00002e  46a0              MOV      r8,r4
;;;1174   
;;;1175           if (pEpDesc->bEndpointAddress == EpAddr)
000030  f8980002          LDRB     r0,[r8,#2]
000034  42b8              CMP      r0,r7
000036  d100              BNE      |L5.58|
;;;1176           {
;;;1177             break;
000038  e006              B        |L5.72|
                  |L5.58|
;;;1178           }
;;;1179           else
;;;1180           {
;;;1181             pEpDesc = NULL;
00003a  f04f0800          MOV      r8,#0
                  |L5.62|
00003e  8870              LDRH     r0,[r6,#2]            ;1167
000040  f8bd1000          LDRH     r1,[sp,#0]            ;1167
000044  4288              CMP      r0,r1                 ;1167
000046  dcea              BGT      |L5.30|
                  |L5.72|
000048  bf00              NOP                            ;1177
                  |L5.74|
;;;1182           }
;;;1183         }
;;;1184       }
;;;1185     }
;;;1186   
;;;1187     return (void *)pEpDesc;
00004a  4640              MOV      r0,r8
;;;1188   }
00004c  e8bd81f8          POP      {r3-r8,pc}
;;;1189   
                          ENDP


                          AREA ||i.USBD_GetNextDesc||, CODE, READONLY, ALIGN=1

                  USBD_GetNextDesc PROC
;;;1196     */
;;;1197   USBD_DescHeaderTypeDef *USBD_GetNextDesc(uint8_t *pbuf, uint16_t *ptr)
000000  b510              PUSH     {r4,lr}
;;;1198   {
000002  4602              MOV      r2,r0
;;;1199     USBD_DescHeaderTypeDef *pnext = (USBD_DescHeaderTypeDef *)(void *)pbuf;
000004  4610              MOV      r0,r2
;;;1200   
;;;1201     *ptr += pnext->bLength;
000006  880b              LDRH     r3,[r1,#0]
000008  7804              LDRB     r4,[r0,#0]
00000a  4423              ADD      r3,r3,r4
00000c  800b              STRH     r3,[r1,#0]
;;;1202     pnext = (USBD_DescHeaderTypeDef *)(void *)(pbuf + pnext->bLength);
00000e  7803              LDRB     r3,[r0,#0]
000010  1898              ADDS     r0,r3,r2
;;;1203   
;;;1204     return (pnext);
;;;1205   }
000012  bd10              POP      {r4,pc}
;;;1206   
                          ENDP


                          AREA ||i.USBD_Init||, CODE, READONLY, ALIGN=1

                  USBD_Init PROC
;;;91       */
;;;92     USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;93                                  USBD_DescriptorsTypeDef *pdesc, uint8_t id)
;;;94     {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;95       USBD_StatusTypeDef ret;
;;;96     
;;;97       /* Check whether the USB Host handle is valid */
;;;98       if (pdev == NULL)
00000a  b914              CBNZ     r4,|L7.18|
;;;99       {
;;;100    #if (USBD_DEBUG_LEVEL > 1U)
;;;101        USBD_ErrLog("Invalid Device handle");
;;;102    #endif /* (USBD_DEBUG_LEVEL > 1U) */
;;;103        return USBD_FAIL;
00000c  2003              MOVS     r0,#3
                  |L7.14|
;;;104      }
;;;105    
;;;106    #ifdef USE_USBD_COMPOSITE
;;;107      /* Parse the table of classes in use */
;;;108      for (uint32_t i = 0; i < USBD_MAX_SUPPORTED_CLASS; i++)
;;;109      {
;;;110        /* Unlink previous class*/
;;;111        pdev->pClass[i] = NULL;
;;;112        pdev->pUserData[i] = NULL;
;;;113    
;;;114        /* Set class as inactive */
;;;115        pdev->tclasslist[i].Active = 0;
;;;116        pdev->NumClasses = 0;
;;;117        pdev->classId = 0;
;;;118      }
;;;119    #else
;;;120      /* Unlink previous class*/
;;;121      pdev->pClass[0] = NULL;
;;;122      pdev->pUserData[0] = NULL;
;;;123    #endif /* USE_USBD_COMPOSITE */
;;;124    
;;;125      pdev->pConfDesc = NULL;
;;;126    
;;;127      /* Assign USBD Descriptors */
;;;128      if (pdesc != NULL)
;;;129      {
;;;130        pdev->pDesc = pdesc;
;;;131      }
;;;132    
;;;133      /* Set Device initial State */
;;;134      pdev->dev_state = USBD_STATE_DEFAULT;
;;;135      pdev->id = id;
;;;136    
;;;137      /* Initialize low level driver */
;;;138      ret = USBD_LL_Init(pdev);
;;;139    
;;;140      return ret;
;;;141    }
00000e  e8bd81f0          POP      {r4-r8,pc}
                  |L7.18|
000012  2000              MOVS     r0,#0                 ;121
000014  f8c402b8          STR      r0,[r4,#0x2b8]        ;121
000018  f8c402c4          STR      r0,[r4,#0x2c4]        ;122
00001c  f8c402d0          STR      r0,[r4,#0x2d0]        ;125
000020  b10d              CBZ      r5,|L7.38|
000022  f8c452b4          STR      r5,[r4,#0x2b4]        ;130
                  |L7.38|
000026  2001              MOVS     r0,#1                 ;134
000028  f884029c          STRB     r0,[r4,#0x29c]        ;134
00002c  7026              STRB     r6,[r4,#0]            ;135
00002e  4620              MOV      r0,r4                 ;138
000030  f7fffffe          BL       USBD_LL_Init
000034  4607              MOV      r7,r0                 ;138
000036  4638              MOV      r0,r7                 ;140
000038  e7e9              B        |L7.14|
;;;142    
                          ENDP


                          AREA ||i.USBD_LL_DataInStage||, CODE, READONLY, ALIGN=1

                  USBD_LL_DataInStage PROC
;;;678      */
;;;679    USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;680                                           uint8_t epnum, uint8_t *pdata)
;;;681    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4691              MOV      r9,r2
;;;682      USBD_EndpointTypeDef *pep;
;;;683      USBD_StatusTypeDef ret;
;;;684      uint8_t idx;
;;;685    
;;;686      if (epnum == 0U)
00000a  2f00              CMP      r7,#0
00000c  d156              BNE      |L8.188|
;;;687      {
;;;688        pep = &pdev->ep_in[0];
00000e  f1040514          ADD      r5,r4,#0x14
;;;689    
;;;690        if (pdev->ep0_state == USBD_EP0_DATA_IN)
000012  f8d40294          LDR      r0,[r4,#0x294]
000016  2802              CMP      r0,#2
000018  d146              BNE      |L8.168|
;;;691        {
;;;692          if (pep->rem_length > pep->maxpacket)
00001a  e9d50102          LDRD     r0,r1,[r5,#8]
00001e  4288              CMP      r0,r1
000020  d90f              BLS      |L8.66|
;;;693          {
;;;694            pep->rem_length -= pep->maxpacket;
000022  e9d50102          LDRD     r0,r1,[r5,#8]
000026  1a40              SUBS     r0,r0,r1
000028  60a8              STR      r0,[r5,#8]
;;;695    
;;;696            (void)USBD_CtlContinueSendData(pdev, pdata, pep->rem_length);
00002a  4649              MOV      r1,r9
00002c  4620              MOV      r0,r4
00002e  68aa              LDR      r2,[r5,#8]
000030  f7fffffe          BL       USBD_CtlContinueSendData
;;;697    
;;;698            /* Prepare endpoint for premature end of transfer */
;;;699            (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
000034  2300              MOVS     r3,#0
000036  461a              MOV      r2,r3
000038  4619              MOV      r1,r3
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       USBD_LL_PrepareReceive
000040  e032              B        |L8.168|
                  |L8.66|
;;;700          }
;;;701          else
;;;702          {
;;;703            /* last packet is MPS multiple, so send ZLP packet */
;;;704            if ((pep->maxpacket == pep->rem_length) &&
000042  e9d51002          LDRD     r1,r0,[r5,#8]
000046  4288              CMP      r0,r1
000048  d117              BNE      |L8.122|
;;;705                (pep->total_length >= pep->maxpacket) &&
00004a  68e9              LDR      r1,[r5,#0xc]
00004c  6868              LDR      r0,[r5,#4]
00004e  4288              CMP      r0,r1
000050  d313              BCC      |L8.122|
;;;706                (pep->total_length < pdev->ep0_data_len))
000052  6868              LDR      r0,[r5,#4]
000054  f8d41298          LDR      r1,[r4,#0x298]
000058  4288              CMP      r0,r1
00005a  d20e              BCS      |L8.122|
;;;707            {
;;;708              (void)USBD_CtlContinueSendData(pdev, NULL, 0U);
00005c  2200              MOVS     r2,#0
00005e  4611              MOV      r1,r2
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       USBD_CtlContinueSendData
;;;709              pdev->ep0_data_len = 0U;
000066  2000              MOVS     r0,#0
000068  f8c40298          STR      r0,[r4,#0x298]
;;;710    
;;;711              /* Prepare endpoint for premature end of transfer */
;;;712              (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
00006c  2300              MOVS     r3,#0
00006e  461a              MOV      r2,r3
000070  4619              MOV      r1,r3
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       USBD_LL_PrepareReceive
000078  e016              B        |L8.168|
                  |L8.122|
;;;713            }
;;;714            else
;;;715            {
;;;716              if (pdev->dev_state == USBD_STATE_CONFIGURED)
00007a  f894029c          LDRB     r0,[r4,#0x29c]
00007e  2803              CMP      r0,#3
000080  d10b              BNE      |L8.154|
;;;717              {
;;;718                if (pdev->pClass[0]->EP0_TxSent != NULL)
000082  f8d402b8          LDR      r0,[r4,#0x2b8]
000086  68c0              LDR      r0,[r0,#0xc]
000088  b138              CBZ      r0,|L8.154|
;;;719                {
;;;720                  pdev->classId = 0U;
00008a  2000              MOVS     r0,#0
00008c  f8c402d4          STR      r0,[r4,#0x2d4]
;;;721                  pdev->pClass[0]->EP0_TxSent(pdev);
000090  f8d402b8          LDR      r0,[r4,#0x2b8]
000094  68c1              LDR      r1,[r0,#0xc]
000096  4620              MOV      r0,r4
000098  4788              BLX      r1
                  |L8.154|
;;;722                }
;;;723              }
;;;724              (void)USBD_LL_StallEP(pdev, 0x80U);
00009a  2180              MOVS     r1,#0x80
00009c  4620              MOV      r0,r4
00009e  f7fffffe          BL       USBD_LL_StallEP
;;;725              (void)USBD_CtlReceiveStatus(pdev);
0000a2  4620              MOV      r0,r4
0000a4  f7fffffe          BL       USBD_CtlReceiveStatus
                  |L8.168|
;;;726            }
;;;727          }
;;;728        }
;;;729        else
;;;730        {
;;;731    #if 0
;;;732          if ((pdev->ep0_state == USBD_EP0_STATUS_IN) ||
;;;733              (pdev->ep0_state == USBD_EP0_IDLE))
;;;734          {
;;;735            (void)USBD_LL_StallEP(pdev, 0x80U);
;;;736          }
;;;737    #endif
;;;738        }
;;;739    
;;;740        if (pdev->dev_test_mode != 0U)
0000a8  f89402a0          LDRB     r0,[r4,#0x2a0]
0000ac  b350              CBZ      r0,|L8.260|
;;;741        {
;;;742          (void)USBD_RunTestMode(pdev);
0000ae  4620              MOV      r0,r4
0000b0  f7fffffe          BL       USBD_RunTestMode
;;;743          pdev->dev_test_mode = 0U;
0000b4  2000              MOVS     r0,#0
0000b6  f88402a0          STRB     r0,[r4,#0x2a0]
0000ba  e023              B        |L8.260|
                  |L8.188|
;;;744        }
;;;745      }
;;;746      else
;;;747      {
;;;748        /* Get the class index relative to this interface */
;;;749        idx = USBD_CoreFindEP(pdev, ((uint8_t)epnum | 0x80U));
0000bc  f0470180          ORR      r1,r7,#0x80
0000c0  4620              MOV      r0,r4
0000c2  f7fffffe          BL       USBD_CoreFindEP
0000c6  4606              MOV      r6,r0
;;;750    
;;;751        if (((uint16_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
0000c8  2eff              CMP      r6,#0xff
0000ca  d01b              BEQ      |L8.260|
0000cc  b9d6              CBNZ     r6,|L8.260|
;;;752        {
;;;753          /* Call the class data out function to manage the request */
;;;754          if (pdev->dev_state == USBD_STATE_CONFIGURED)
0000ce  f894029c          LDRB     r0,[r4,#0x29c]
0000d2  2803              CMP      r0,#3
0000d4  d116              BNE      |L8.260|
;;;755          {
;;;756            if (pdev->pClass[idx]->DataIn != NULL)
0000d6  f504702e          ADD      r0,r4,#0x2b8
0000da  f8500026          LDR      r0,[r0,r6,LSL #2]
0000de  6940              LDR      r0,[r0,#0x14]
0000e0  b180              CBZ      r0,|L8.260|
;;;757            {
;;;758              pdev->classId = idx;
0000e2  f8c462d4          STR      r6,[r4,#0x2d4]
;;;759              ret = (USBD_StatusTypeDef)pdev->pClass[idx]->DataIn(pdev, epnum);
0000e6  f504702e          ADD      r0,r4,#0x2b8
0000ea  f8500026          LDR      r0,[r0,r6,LSL #2]
0000ee  4639              MOV      r1,r7
0000f0  6942              LDR      r2,[r0,#0x14]
0000f2  4620              MOV      r0,r4
0000f4  4790              BLX      r2
0000f6  4680              MOV      r8,r0
;;;760    
;;;761              if (ret != USBD_OK)
0000f8  f1b80f00          CMP      r8,#0
0000fc  d002              BEQ      |L8.260|
;;;762              {
;;;763                return ret;
0000fe  4640              MOV      r0,r8
                  |L8.256|
;;;764              }
;;;765            }
;;;766          }
;;;767        }
;;;768      }
;;;769    
;;;770      return USBD_OK;
;;;771    }
000100  e8bd87f0          POP      {r4-r10,pc}
                  |L8.260|
000104  2000              MOVS     r0,#0                 ;770
000106  e7fb              B        |L8.256|
;;;772    
                          ENDP


                          AREA ||i.USBD_LL_DataOutStage||, CODE, READONLY, ALIGN=1

                  USBD_LL_DataOutStage PROC
;;;571      */
;;;572    USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;573                                            uint8_t epnum, uint8_t *pdata)
;;;574    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
;;;575      USBD_EndpointTypeDef *pep;
;;;576      USBD_StatusTypeDef ret = USBD_OK;
00000a  f04f0900          MOV      r9,#0
;;;577      uint8_t idx;
;;;578    
;;;579      if (epnum == 0U)
00000e  2f00              CMP      r7,#0
000010  d151              BNE      |L9.182|
;;;580      {
;;;581        pep = &pdev->ep_out[0];
000012  f50576aa          ADD      r6,r5,#0x154
;;;582    
;;;583        if (pdev->ep0_state == USBD_EP0_DATA_OUT)
000016  f8d50294          LDR      r0,[r5,#0x294]
00001a  2803              CMP      r0,#3
00001c  d16f              BNE      |L9.254|
;;;584        {
;;;585          if (pep->rem_length > pep->maxpacket)
00001e  e9d60102          LDRD     r0,r1,[r6,#8]
000022  4288              CMP      r0,r1
000024  d910              BLS      |L9.72|
;;;586          {
;;;587            pep->rem_length -= pep->maxpacket;
000026  e9d60102          LDRD     r0,r1,[r6,#8]
00002a  1a40              SUBS     r0,r0,r1
00002c  60b0              STR      r0,[r6,#8]
;;;588    
;;;589            (void)USBD_CtlContinueRx(pdev, pdata, MIN(pep->rem_length, pep->maxpacket));
00002e  e9d60102          LDRD     r0,r1,[r6,#8]
000032  4288              CMP      r0,r1
000034  d201              BCS      |L9.58|
000036  68b0              LDR      r0,[r6,#8]
000038  e000              B        |L9.60|
                  |L9.58|
00003a  68f0              LDR      r0,[r6,#0xc]
                  |L9.60|
00003c  4602              MOV      r2,r0
00003e  4641              MOV      r1,r8
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       USBD_CtlContinueRx
000046  e05a              B        |L9.254|
                  |L9.72|
;;;590          }
;;;591          else
;;;592          {
;;;593            /* Find the class ID relative to the current request */
;;;594            switch (pdev->request.bmRequest & 0x1FU)
000048  f89502aa          LDRB     r0,[r5,#0x2aa]
00004c  f000001f          AND      r0,r0,#0x1f
000050  b120              CBZ      r0,|L9.92|
000052  2801              CMP      r0,#1
000054  d004              BEQ      |L9.96|
000056  2802              CMP      r0,#2
000058  d112              BNE      |L9.128|
00005a  e009              B        |L9.112|
                  |L9.92|
;;;595            {
;;;596              case USB_REQ_RECIPIENT_DEVICE:
;;;597                /* Device requests must be managed by the first instantiated class
;;;598                   (or duplicated by all classes for simplicity) */
;;;599                idx = 0U;
00005c  2400              MOVS     r4,#0
;;;600                break;
00005e  e011              B        |L9.132|
                  |L9.96|
;;;601    
;;;602              case USB_REQ_RECIPIENT_INTERFACE:
;;;603                idx = USBD_CoreFindIF(pdev, LOBYTE(pdev->request.wIndex));
000060  f24020ae          MOV      r0,#0x2ae
000064  5d41              LDRB     r1,[r0,r5]
000066  4628              MOV      r0,r5
000068  f7fffffe          BL       USBD_CoreFindIF
00006c  4604              MOV      r4,r0
;;;604                break;
00006e  e009              B        |L9.132|
                  |L9.112|
;;;605    
;;;606              case USB_REQ_RECIPIENT_ENDPOINT:
;;;607                idx = USBD_CoreFindEP(pdev, LOBYTE(pdev->request.wIndex));
000070  f24020ae          MOV      r0,#0x2ae
000074  5d41              LDRB     r1,[r0,r5]
000076  4628              MOV      r0,r5
000078  f7fffffe          BL       USBD_CoreFindEP
00007c  4604              MOV      r4,r0
;;;608                break;
00007e  e001              B        |L9.132|
                  |L9.128|
;;;609    
;;;610              default:
;;;611                /* Back to the first class in case of doubt */
;;;612                idx = 0U;
000080  2400              MOVS     r4,#0
;;;613                break;
000082  bf00              NOP      
                  |L9.132|
000084  bf00              NOP                            ;600
;;;614            }
;;;615    
;;;616            if (idx < USBD_MAX_SUPPORTED_CLASS)
000086  b994              CBNZ     r4,|L9.174|
;;;617            {
;;;618              /* Setup the class ID and route the request to the relative class function */
;;;619              if (pdev->dev_state == USBD_STATE_CONFIGURED)
000088  f895029c          LDRB     r0,[r5,#0x29c]
00008c  2803              CMP      r0,#3
00008e  d10e              BNE      |L9.174|
;;;620              {
;;;621                if (pdev->pClass[idx]->EP0_RxReady != NULL)
000090  f505702e          ADD      r0,r5,#0x2b8
000094  f8500024          LDR      r0,[r0,r4,LSL #2]
000098  6900              LDR      r0,[r0,#0x10]
00009a  b140              CBZ      r0,|L9.174|
;;;622                {
;;;623                  pdev->classId = idx;
00009c  f8c542d4          STR      r4,[r5,#0x2d4]
;;;624                  pdev->pClass[idx]->EP0_RxReady(pdev);
0000a0  f505702e          ADD      r0,r5,#0x2b8
0000a4  f8500024          LDR      r0,[r0,r4,LSL #2]
0000a8  6901              LDR      r1,[r0,#0x10]
0000aa  4628              MOV      r0,r5
0000ac  4788              BLX      r1
                  |L9.174|
;;;625                }
;;;626              }
;;;627            }
;;;628    
;;;629            (void)USBD_CtlSendStatus(pdev);
0000ae  4628              MOV      r0,r5
0000b0  f7fffffe          BL       USBD_CtlSendStatus
0000b4  e023              B        |L9.254|
                  |L9.182|
;;;630          }
;;;631        }
;;;632        else
;;;633        {
;;;634    #if 0
;;;635          if (pdev->ep0_state == USBD_EP0_STATUS_OUT)
;;;636          {
;;;637            /*
;;;638              * STATUS PHASE completed, update ep0_state to idle
;;;639              */
;;;640            pdev->ep0_state = USBD_EP0_IDLE;
;;;641            (void)USBD_LL_StallEP(pdev, 0U);
;;;642          }
;;;643    #endif
;;;644        }
;;;645      }
;;;646      else
;;;647      {
;;;648        /* Get the class index relative to this interface */
;;;649        idx = USBD_CoreFindEP(pdev, (epnum & 0x7FU));
0000b6  f007017f          AND      r1,r7,#0x7f
0000ba  4628              MOV      r0,r5
0000bc  f7fffffe          BL       USBD_CoreFindEP
0000c0  4604              MOV      r4,r0
;;;650    
;;;651        if (((uint16_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
0000c2  2cff              CMP      r4,#0xff
0000c4  d01b              BEQ      |L9.254|
0000c6  b9d4              CBNZ     r4,|L9.254|
;;;652        {
;;;653          /* Call the class data out function to manage the request */
;;;654          if (pdev->dev_state == USBD_STATE_CONFIGURED)
0000c8  f895029c          LDRB     r0,[r5,#0x29c]
0000cc  2803              CMP      r0,#3
0000ce  d110              BNE      |L9.242|
;;;655          {
;;;656            if (pdev->pClass[idx]->DataOut != NULL)
0000d0  f505702e          ADD      r0,r5,#0x2b8
0000d4  f8500024          LDR      r0,[r0,r4,LSL #2]
0000d8  6980              LDR      r0,[r0,#0x18]
0000da  b150              CBZ      r0,|L9.242|
;;;657            {
;;;658              pdev->classId = idx;
0000dc  f8c542d4          STR      r4,[r5,#0x2d4]
;;;659              ret = (USBD_StatusTypeDef)pdev->pClass[idx]->DataOut(pdev, epnum);
0000e0  f505702e          ADD      r0,r5,#0x2b8
0000e4  f8500024          LDR      r0,[r0,r4,LSL #2]
0000e8  4639              MOV      r1,r7
0000ea  6982              LDR      r2,[r0,#0x18]
0000ec  4628              MOV      r0,r5
0000ee  4790              BLX      r2
0000f0  4681              MOV      r9,r0
                  |L9.242|
;;;660            }
;;;661          }
;;;662          if (ret != USBD_OK)
0000f2  f1b90f00          CMP      r9,#0
0000f6  d002              BEQ      |L9.254|
;;;663          {
;;;664            return ret;
0000f8  4648              MOV      r0,r9
                  |L9.250|
;;;665          }
;;;666        }
;;;667      }
;;;668    
;;;669      return USBD_OK;
;;;670    }
0000fa  e8bd87f0          POP      {r4-r10,pc}
                  |L9.254|
0000fe  2000              MOVS     r0,#0                 ;669
000100  e7fb              B        |L9.250|
;;;671    
                          ENDP


                          AREA ||i.USBD_LL_DevConnected||, CODE, READONLY, ALIGN=1

                  USBD_LL_DevConnected PROC
;;;986      */
;;;987    USBD_StatusTypeDef USBD_LL_DevConnected(USBD_HandleTypeDef *pdev)
000000  4601              MOV      r1,r0
;;;988    {
;;;989      /* Prevent unused argument compilation warning */
;;;990      UNUSED(pdev);
;;;991    
;;;992      return USBD_OK;
000002  2000              MOVS     r0,#0
;;;993    }
000004  4770              BX       lr
;;;994    
                          ENDP


                          AREA ||i.USBD_LL_DevDisconnected||, CODE, READONLY, ALIGN=1

                  USBD_LL_DevDisconnected PROC
;;;1000     */
;;;1001   USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef *pdev)
000000  b570              PUSH     {r4-r6,lr}
;;;1002   {
000002  4604              MOV      r4,r0
;;;1003     USBD_StatusTypeDef   ret = USBD_OK;
000004  2500              MOVS     r5,#0
;;;1004   
;;;1005     /* Free Class Resources */
;;;1006     pdev->dev_state = USBD_STATE_DEFAULT;
000006  2001              MOVS     r0,#1
000008  f884029c          STRB     r0,[r4,#0x29c]
;;;1007   
;;;1008   #ifdef USE_USBD_COMPOSITE
;;;1009     /* Parse the table of classes in use */
;;;1010     for (uint32_t i = 0; i < USBD_MAX_SUPPORTED_CLASS; i++)
;;;1011     {
;;;1012       /* Check if current class is in use */
;;;1013       if ((pdev->tclasslist[i].Active) == 1U)
;;;1014       {
;;;1015         if (pdev->pClass[i] != NULL)
;;;1016         {
;;;1017           pdev->classId = i;
;;;1018           /* Clear configuration  and De-initialize the Class process*/
;;;1019           if (pdev->pClass[i]->DeInit(pdev, (uint8_t)pdev->dev_config) != 0U)
;;;1020           {
;;;1021             ret = USBD_FAIL;
;;;1022           }
;;;1023         }
;;;1024       }
;;;1025     }
;;;1026   #else
;;;1027     if (pdev->pClass[0] != NULL)
00000c  f8d402b8          LDR      r0,[r4,#0x2b8]
000010  b138              CBZ      r0,|L11.34|
;;;1028     {
;;;1029       if (pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config) != 0U)
000012  7921              LDRB     r1,[r4,#4]
000014  f8d402b8          LDR      r0,[r4,#0x2b8]
000018  6842              LDR      r2,[r0,#4]
00001a  4620              MOV      r0,r4
00001c  4790              BLX      r2
00001e  b100              CBZ      r0,|L11.34|
;;;1030       {
;;;1031         ret = USBD_FAIL;
000020  2503              MOVS     r5,#3
                  |L11.34|
;;;1032       }
;;;1033     }
;;;1034   #endif /* USE_USBD_COMPOSITE */
;;;1035   
;;;1036     return ret;
000022  4628              MOV      r0,r5
;;;1037   }
000024  bd70              POP      {r4-r6,pc}
;;;1038   
                          ENDP


                          AREA ||i.USBD_LL_IsoINIncomplete||, CODE, READONLY, ALIGN=1

                  USBD_LL_IsoINIncomplete PROC
;;;936      */
;;;937    USBD_StatusTypeDef USBD_LL_IsoINIncomplete(USBD_HandleTypeDef *pdev,
000000  b570              PUSH     {r4-r6,lr}
;;;938                                               uint8_t epnum)
;;;939    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;940      if (pdev->pClass[pdev->classId] == NULL)
000006  f504702e          ADD      r0,r4,#0x2b8
00000a  f8d412d4          LDR      r1,[r4,#0x2d4]
00000e  f8500021          LDR      r0,[r0,r1,LSL #2]
000012  b908              CBNZ     r0,|L12.24|
;;;941      {
;;;942        return USBD_FAIL;
000014  2003              MOVS     r0,#3
                  |L12.22|
;;;943      }
;;;944    
;;;945      if (pdev->dev_state == USBD_STATE_CONFIGURED)
;;;946      {
;;;947        if (pdev->pClass[pdev->classId]->IsoINIncomplete != NULL)
;;;948        {
;;;949          (void)pdev->pClass[pdev->classId]->IsoINIncomplete(pdev, epnum);
;;;950        }
;;;951      }
;;;952    
;;;953      return USBD_OK;
;;;954    }
000016  bd70              POP      {r4-r6,pc}
                  |L12.24|
000018  f894029c          LDRB     r0,[r4,#0x29c]        ;945
00001c  2803              CMP      r0,#3                 ;945
00001e  d111              BNE      |L12.68|
000020  f504702e          ADD      r0,r4,#0x2b8          ;947
000024  f8d412d4          LDR      r1,[r4,#0x2d4]        ;947
000028  f8500021          LDR      r0,[r0,r1,LSL #2]     ;947
00002c  6a00              LDR      r0,[r0,#0x20]         ;947
00002e  b148              CBZ      r0,|L12.68|
000030  f504702e          ADD      r0,r4,#0x2b8          ;949
000034  f8d412d4          LDR      r1,[r4,#0x2d4]        ;949
000038  f8500021          LDR      r0,[r0,r1,LSL #2]     ;949
00003c  4629              MOV      r1,r5                 ;949
00003e  6a02              LDR      r2,[r0,#0x20]         ;949
000040  4620              MOV      r0,r4                 ;949
000042  4790              BLX      r2                    ;949
                  |L12.68|
000044  2000              MOVS     r0,#0                 ;953
000046  e7e6              B        |L12.22|
;;;955    
                          ENDP


                          AREA ||i.USBD_LL_IsoOUTIncomplete||, CODE, READONLY, ALIGN=1

                  USBD_LL_IsoOUTIncomplete PROC
;;;961      */
;;;962    USBD_StatusTypeDef USBD_LL_IsoOUTIncomplete(USBD_HandleTypeDef *pdev,
000000  b570              PUSH     {r4-r6,lr}
;;;963                                                uint8_t epnum)
;;;964    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;965      if (pdev->pClass[pdev->classId] == NULL)
000006  f504702e          ADD      r0,r4,#0x2b8
00000a  f8d412d4          LDR      r1,[r4,#0x2d4]
00000e  f8500021          LDR      r0,[r0,r1,LSL #2]
000012  b908              CBNZ     r0,|L13.24|
;;;966      {
;;;967        return USBD_FAIL;
000014  2003              MOVS     r0,#3
                  |L13.22|
;;;968      }
;;;969    
;;;970      if (pdev->dev_state == USBD_STATE_CONFIGURED)
;;;971      {
;;;972        if (pdev->pClass[pdev->classId]->IsoOUTIncomplete != NULL)
;;;973        {
;;;974          (void)pdev->pClass[pdev->classId]->IsoOUTIncomplete(pdev, epnum);
;;;975        }
;;;976      }
;;;977    
;;;978      return USBD_OK;
;;;979    }
000016  bd70              POP      {r4-r6,pc}
                  |L13.24|
000018  f894029c          LDRB     r0,[r4,#0x29c]        ;970
00001c  2803              CMP      r0,#3                 ;970
00001e  d111              BNE      |L13.68|
000020  f504702e          ADD      r0,r4,#0x2b8          ;972
000024  f8d412d4          LDR      r1,[r4,#0x2d4]        ;972
000028  f8500021          LDR      r0,[r0,r1,LSL #2]     ;972
00002c  6a40              LDR      r0,[r0,#0x24]         ;972
00002e  b148              CBZ      r0,|L13.68|
000030  f504702e          ADD      r0,r4,#0x2b8          ;974
000034  f8d412d4          LDR      r1,[r4,#0x2d4]        ;974
000038  f8500021          LDR      r0,[r0,r1,LSL #2]     ;974
00003c  4629              MOV      r1,r5                 ;974
00003e  6a42              LDR      r2,[r0,#0x24]         ;974
000040  4620              MOV      r0,r4                 ;974
000042  4790              BLX      r2                    ;974
                  |L13.68|
000044  2000              MOVS     r0,#0                 ;978
000046  e7e6              B        |L13.22|
;;;980    
                          ENDP


                          AREA ||i.USBD_LL_Reset||, CODE, READONLY, ALIGN=1

                  USBD_LL_Reset PROC
;;;779    
;;;780    USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef *pdev)
000000  b570              PUSH     {r4-r6,lr}
;;;781    {
000002  4604              MOV      r4,r0
;;;782      USBD_StatusTypeDef ret = USBD_OK;
000004  2500              MOVS     r5,#0
;;;783    
;;;784      /* Upon Reset call user call back */
;;;785      pdev->dev_state = USBD_STATE_DEFAULT;
000006  2001              MOVS     r0,#1
000008  f884029c          STRB     r0,[r4,#0x29c]
;;;786      pdev->ep0_state = USBD_EP0_IDLE;
00000c  2000              MOVS     r0,#0
00000e  f8c40294          STR      r0,[r4,#0x294]
;;;787      pdev->dev_config = 0U;
000012  6060              STR      r0,[r4,#4]
;;;788      pdev->dev_remote_wakeup = 0U;
000014  f8c402a4          STR      r0,[r4,#0x2a4]
;;;789      pdev->dev_test_mode = 0U;
000018  f88402a0          STRB     r0,[r4,#0x2a0]
;;;790    
;;;791    #ifdef USE_USBD_COMPOSITE
;;;792      /* Parse the table of classes in use */
;;;793      for (uint32_t i = 0U; i < USBD_MAX_SUPPORTED_CLASS; i++)
;;;794      {
;;;795        /* Check if current class is in use */
;;;796        if ((pdev->tclasslist[i].Active) == 1U)
;;;797        {
;;;798          if (pdev->pClass[i] != NULL)
;;;799          {
;;;800            pdev->classId = i;
;;;801            /* Clear configuration  and De-initialize the Class process*/
;;;802    
;;;803            if (pdev->pClass[i]->DeInit != NULL)
;;;804            {
;;;805              if (pdev->pClass[i]->DeInit(pdev, (uint8_t)pdev->dev_config) != USBD_OK)
;;;806              {
;;;807                ret = USBD_FAIL;
;;;808              }
;;;809            }
;;;810          }
;;;811        }
;;;812      }
;;;813    #else
;;;814    
;;;815      if (pdev->pClass[0] != NULL)
00001c  f8d402b8          LDR      r0,[r4,#0x2b8]
000020  b158              CBZ      r0,|L14.58|
;;;816      {
;;;817        if (pdev->pClass[0]->DeInit != NULL)
000022  f8d402b8          LDR      r0,[r4,#0x2b8]
000026  6840              LDR      r0,[r0,#4]
000028  b138              CBZ      r0,|L14.58|
;;;818        {
;;;819          if (pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config) != USBD_OK)
00002a  7921              LDRB     r1,[r4,#4]
00002c  f8d402b8          LDR      r0,[r4,#0x2b8]
000030  6842              LDR      r2,[r0,#4]
000032  4620              MOV      r0,r4
000034  4790              BLX      r2
000036  b100              CBZ      r0,|L14.58|
;;;820          {
;;;821            ret = USBD_FAIL;
000038  2503              MOVS     r5,#3
                  |L14.58|
;;;822          }
;;;823        }
;;;824      }
;;;825    #endif /* USE_USBD_COMPOSITE */
;;;826    
;;;827      /* Open EP0 OUT */
;;;828      (void)USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
00003a  2340              MOVS     r3,#0x40
00003c  2200              MOVS     r2,#0
00003e  4611              MOV      r1,r2
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       USBD_LL_OpenEP
;;;829      pdev->ep_out[0x00U & 0xFU].is_used = 1U;
000046  2101              MOVS     r1,#1
000048  f44f70b2          MOV      r0,#0x164
00004c  5301              STRH     r1,[r0,r4]
;;;830    
;;;831      pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
00004e  2140              MOVS     r1,#0x40
000050  1f00              SUBS     r0,r0,#4
000052  5101              STR      r1,[r0,r4]
;;;832    
;;;833      /* Open EP0 IN */
;;;834      (void)USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
000054  2340              MOVS     r3,#0x40
000056  2200              MOVS     r2,#0
000058  2180              MOVS     r1,#0x80
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       USBD_LL_OpenEP
;;;835      pdev->ep_in[0x80U & 0xFU].is_used = 1U;
000060  2101              MOVS     r1,#1
000062  84a1              STRH     r1,[r4,#0x24]
;;;836    
;;;837      pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
000064  2140              MOVS     r1,#0x40
000066  6221              STR      r1,[r4,#0x20]
;;;838    
;;;839      return ret;
000068  4628              MOV      r0,r5
;;;840    }
00006a  bd70              POP      {r4-r6,pc}
;;;841    
                          ENDP


                          AREA ||i.USBD_LL_Resume||, CODE, READONLY, ALIGN=1

                  USBD_LL_Resume PROC
;;;877    
;;;878    USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef *pdev)
000000  4601              MOV      r1,r0
;;;879    {
;;;880      if (pdev->dev_state == USBD_STATE_SUSPENDED)
000002  f891029c          LDRB     r0,[r1,#0x29c]
000006  2804              CMP      r0,#4
000008  d103              BNE      |L15.18|
;;;881      {
;;;882        pdev->dev_state = pdev->dev_old_state;
00000a  f891029d          LDRB     r0,[r1,#0x29d]
00000e  f881029c          STRB     r0,[r1,#0x29c]
                  |L15.18|
;;;883      }
;;;884    
;;;885      return USBD_OK;
000012  2000              MOVS     r0,#0
;;;886    }
000014  4770              BX       lr
;;;887    
                          ENDP


                          AREA ||i.USBD_LL_SOF||, CODE, READONLY, ALIGN=1

                  USBD_LL_SOF PROC
;;;894    
;;;895    USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef *pdev)
000000  b510              PUSH     {r4,lr}
;;;896    {
000002  4604              MOV      r4,r0
;;;897      /* The SOF event can be distributed for all classes that support it */
;;;898      if (pdev->dev_state == USBD_STATE_CONFIGURED)
000004  f894029c          LDRB     r0,[r4,#0x29c]
000008  2803              CMP      r0,#3
00000a  d10b              BNE      |L16.36|
;;;899      {
;;;900    #ifdef USE_USBD_COMPOSITE
;;;901        /* Parse the table of classes in use */
;;;902        for (uint32_t i = 0; i < USBD_MAX_SUPPORTED_CLASS; i++)
;;;903        {
;;;904          /* Check if current class is in use */
;;;905          if ((pdev->tclasslist[i].Active) == 1U)
;;;906          {
;;;907            if (pdev->pClass[i] != NULL)
;;;908            {
;;;909              if (pdev->pClass[i]->SOF != NULL)
;;;910              {
;;;911                pdev->classId = i;
;;;912                (void)pdev->pClass[i]->SOF(pdev);
;;;913              }
;;;914            }
;;;915          }
;;;916        }
;;;917    #else
;;;918        if (pdev->pClass[0] != NULL)
00000c  f8d402b8          LDR      r0,[r4,#0x2b8]
000010  b140              CBZ      r0,|L16.36|
;;;919        {
;;;920          if (pdev->pClass[0]->SOF != NULL)
000012  f8d402b8          LDR      r0,[r4,#0x2b8]
000016  69c0              LDR      r0,[r0,#0x1c]
000018  b120              CBZ      r0,|L16.36|
;;;921          {
;;;922            (void)pdev->pClass[0]->SOF(pdev);
00001a  f8d402b8          LDR      r0,[r4,#0x2b8]
00001e  69c1              LDR      r1,[r0,#0x1c]
000020  4620              MOV      r0,r4
000022  4788              BLX      r1
                  |L16.36|
;;;923          }
;;;924        }
;;;925    #endif /* USE_USBD_COMPOSITE */
;;;926      }
;;;927    
;;;928      return USBD_OK;
000024  2000              MOVS     r0,#0
;;;929    }
000026  bd10              POP      {r4,pc}
;;;930    
                          ENDP


                          AREA ||i.USBD_LL_SetSpeed||, CODE, READONLY, ALIGN=1

                  USBD_LL_SetSpeed PROC
;;;847      */
;;;848    USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef *pdev,
000000  4602              MOV      r2,r0
;;;849                                        USBD_SpeedTypeDef speed)
;;;850    {
;;;851      pdev->dev_speed = speed;
000002  7411              STRB     r1,[r2,#0x10]
;;;852    
;;;853      return USBD_OK;
000004  2000              MOVS     r0,#0
;;;854    }
000006  4770              BX       lr
;;;855    
                          ENDP


                          AREA ||i.USBD_LL_SetupStage||, CODE, READONLY, ALIGN=1

                  USBD_LL_SetupStage PROC
;;;531      */
;;;532    USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
000000  b570              PUSH     {r4-r6,lr}
;;;533    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;534      USBD_StatusTypeDef ret;
;;;535    
;;;536      USBD_ParseSetupRequest(&pdev->request, psetup);
000006  4629              MOV      r1,r5
000008  f20420aa          ADD      r0,r4,#0x2aa
00000c  f7fffffe          BL       USBD_ParseSetupRequest
;;;537    
;;;538      pdev->ep0_state = USBD_EP0_SETUP;
000010  2001              MOVS     r0,#1
000012  f8c40294          STR      r0,[r4,#0x294]
;;;539    
;;;540      pdev->ep0_data_len = pdev->request.wLength;
000016  f44f702c          MOV      r0,#0x2b0
00001a  5b00              LDRH     r0,[r0,r4]
00001c  f8c40298          STR      r0,[r4,#0x298]
;;;541    
;;;542      switch (pdev->request.bmRequest & 0x1FU)
000020  f89402aa          LDRB     r0,[r4,#0x2aa]
000024  f000001f          AND      r0,r0,#0x1f
000028  b120              CBZ      r0,|L18.52|
00002a  2801              CMP      r0,#1
00002c  d009              BEQ      |L18.66|
00002e  2802              CMP      r0,#2
000030  d115              BNE      |L18.94|
000032  e00d              B        |L18.80|
                  |L18.52|
;;;543      {
;;;544        case USB_REQ_RECIPIENT_DEVICE:
;;;545          ret = USBD_StdDevReq(pdev, &pdev->request);
000034  f20421aa          ADD      r1,r4,#0x2aa
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       USBD_StdDevReq
00003e  4606              MOV      r6,r0
;;;546          break;
000040  e016              B        |L18.112|
                  |L18.66|
;;;547    
;;;548        case USB_REQ_RECIPIENT_INTERFACE:
;;;549          ret = USBD_StdItfReq(pdev, &pdev->request);
000042  f20421aa          ADD      r1,r4,#0x2aa
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       USBD_StdItfReq
00004c  4606              MOV      r6,r0
;;;550          break;
00004e  e00f              B        |L18.112|
                  |L18.80|
;;;551    
;;;552        case USB_REQ_RECIPIENT_ENDPOINT:
;;;553          ret = USBD_StdEPReq(pdev, &pdev->request);
000050  f20421aa          ADD      r1,r4,#0x2aa
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       USBD_StdEPReq
00005a  4606              MOV      r6,r0
;;;554          break;
00005c  e008              B        |L18.112|
                  |L18.94|
;;;555    
;;;556        default:
;;;557          ret = USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
00005e  f89402aa          LDRB     r0,[r4,#0x2aa]
000062  f0000180          AND      r1,r0,#0x80
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       USBD_LL_StallEP
00006c  4606              MOV      r6,r0
;;;558          break;
00006e  bf00              NOP      
                  |L18.112|
000070  bf00              NOP                            ;546
;;;559      }
;;;560    
;;;561      return ret;
000072  4630              MOV      r0,r6
;;;562    }
000074  bd70              POP      {r4-r6,pc}
;;;563    
                          ENDP


                          AREA ||i.USBD_LL_Suspend||, CODE, READONLY, ALIGN=1

                  USBD_LL_Suspend PROC
;;;862    
;;;863    USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef *pdev)
000000  4601              MOV      r1,r0
;;;864    {
;;;865      pdev->dev_old_state = pdev->dev_state;
000002  f891029c          LDRB     r0,[r1,#0x29c]
000006  f881029d          STRB     r0,[r1,#0x29d]
;;;866      pdev->dev_state = USBD_STATE_SUSPENDED;
00000a  2004              MOVS     r0,#4
00000c  f881029c          STRB     r0,[r1,#0x29c]
;;;867    
;;;868      return USBD_OK;
000010  2000              MOVS     r0,#0
;;;869    }
000012  4770              BX       lr
;;;870    
                          ENDP


                          AREA ||i.USBD_RegisterClass||, CODE, READONLY, ALIGN=1

                  USBD_RegisterClass PROC
;;;201      */
;;;202    USBD_StatusTypeDef USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
000000  b538              PUSH     {r3-r5,lr}
;;;203    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;204      uint16_t len = 0U;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;205    
;;;206      if (pclass == NULL)
00000a  b90d              CBNZ     r5,|L20.16|
;;;207      {
;;;208    #if (USBD_DEBUG_LEVEL > 1U)
;;;209        USBD_ErrLog("Invalid Class handle");
;;;210    #endif /* (USBD_DEBUG_LEVEL > 1U) */
;;;211        return USBD_FAIL;
00000c  2003              MOVS     r0,#3
                  |L20.14|
;;;212      }
;;;213    
;;;214      /* link the class to the USB Device handle */
;;;215      pdev->pClass[0] = pclass;
;;;216    
;;;217      /* Get Device Configuration Descriptor */
;;;218    #ifdef USE_USB_HS
;;;219      if (pdev->pClass[pdev->classId]->GetHSConfigDescriptor != NULL)
;;;220      {
;;;221        pdev->pConfDesc = (void *)pdev->pClass[pdev->classId]->GetHSConfigDescriptor(&len);
;;;222      }
;;;223    #else /* Default USE_USB_FS */
;;;224      if (pdev->pClass[pdev->classId]->GetFSConfigDescriptor != NULL)
;;;225      {
;;;226        pdev->pConfDesc = (void *)pdev->pClass[pdev->classId]->GetFSConfigDescriptor(&len);
;;;227      }
;;;228    #endif /* USE_USB_FS */
;;;229    
;;;230      /* Increment the NumClasses */
;;;231      pdev->NumClasses ++;
;;;232    
;;;233      return USBD_OK;
;;;234    }
00000e  bd38              POP      {r3-r5,pc}
                  |L20.16|
000010  f8c452b8          STR      r5,[r4,#0x2b8]        ;215
000014  f504702e          ADD      r0,r4,#0x2b8          ;224
000018  f8d412d4          LDR      r1,[r4,#0x2d4]        ;224
00001c  f8500021          LDR      r0,[r0,r1,LSL #2]     ;224
000020  6ac0              LDR      r0,[r0,#0x2c]         ;224
000022  b150              CBZ      r0,|L20.58|
000024  f504702e          ADD      r0,r4,#0x2b8          ;226
000028  f8d422d4          LDR      r2,[r4,#0x2d4]        ;226
00002c  f8500022          LDR      r0,[r0,r2,LSL #2]     ;226
000030  6ac1              LDR      r1,[r0,#0x2c]         ;226
000032  4668              MOV      r0,sp                 ;226
000034  4788              BLX      r1                    ;226
000036  f8c402d0          STR      r0,[r4,#0x2d0]        ;226
                  |L20.58|
00003a  f8d402d8          LDR      r0,[r4,#0x2d8]        ;231
00003e  1c40              ADDS     r0,r0,#1              ;231
000040  f8c402d8          STR      r0,[r4,#0x2d8]        ;231
000044  2000              MOVS     r0,#0                 ;233
000046  e7e2              B        |L20.14|
;;;235    
                          ENDP


                          AREA ||i.USBD_RunTestMode||, CODE, READONLY, ALIGN=1

                  USBD_RunTestMode PROC
;;;426      */
;;;427    USBD_StatusTypeDef USBD_RunTestMode(USBD_HandleTypeDef *pdev)
000000  4601              MOV      r1,r0
;;;428    {
;;;429    #ifdef USBD_HS_TESTMODE_ENABLE
;;;430      USBD_StatusTypeDef ret;
;;;431    
;;;432      /* Run USB HS test mode */
;;;433      ret = USBD_LL_SetTestMode(pdev, pdev->dev_test_mode);
;;;434    
;;;435      return ret;
;;;436    #else
;;;437      /* Prevent unused argument compilation warning */
;;;438      UNUSED(pdev);
;;;439    
;;;440      return USBD_OK;
000002  2000              MOVS     r0,#0
;;;441    #endif /* USBD_HS_TESTMODE_ENABLE */
;;;442    }
000004  4770              BX       lr
;;;443    
                          ENDP


                          AREA ||i.USBD_SetClassConfig||, CODE, READONLY, ALIGN=1

                  USBD_SetClassConfig PROC
;;;451    
;;;452    USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
000000  b570              PUSH     {r4-r6,lr}
;;;453    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;454      USBD_StatusTypeDef ret = USBD_OK;
000006  2600              MOVS     r6,#0
;;;455    
;;;456    #ifdef USE_USBD_COMPOSITE
;;;457      /* Parse the table of classes in use */
;;;458      for (uint32_t i = 0U; i < USBD_MAX_SUPPORTED_CLASS; i++)
;;;459      {
;;;460        /* Check if current class is in use */
;;;461        if ((pdev->tclasslist[i].Active) == 1U)
;;;462        {
;;;463          if (pdev->pClass[i] != NULL)
;;;464          {
;;;465            pdev->classId = i;
;;;466            /* Set configuration  and Start the Class*/
;;;467            if (pdev->pClass[i]->Init(pdev, cfgidx) != 0U)
;;;468            {
;;;469              ret = USBD_FAIL;
;;;470            }
;;;471          }
;;;472        }
;;;473      }
;;;474    #else
;;;475      if (pdev->pClass[0] != NULL)
000008  f8d402b8          LDR      r0,[r4,#0x2b8]
00000c  b130              CBZ      r0,|L22.28|
;;;476      {
;;;477        /* Set configuration and Start the Class */
;;;478        ret = (USBD_StatusTypeDef)pdev->pClass[0]->Init(pdev, cfgidx);
00000e  f8d402b8          LDR      r0,[r4,#0x2b8]
000012  4629              MOV      r1,r5
000014  6802              LDR      r2,[r0,#0]
000016  4620              MOV      r0,r4
000018  4790              BLX      r2
00001a  4606              MOV      r6,r0
                  |L22.28|
;;;479      }
;;;480    #endif /* USE_USBD_COMPOSITE */
;;;481    
;;;482      return ret;
00001c  4630              MOV      r0,r6
;;;483    }
00001e  bd70              POP      {r4-r6,pc}
;;;484    
                          ENDP


                          AREA ||i.USBD_Start||, CODE, READONLY, ALIGN=1

                  USBD_Start PROC
;;;370      */
;;;371    USBD_StatusTypeDef USBD_Start(USBD_HandleTypeDef *pdev)
000000  b510              PUSH     {r4,lr}
;;;372    {
000002  4604              MOV      r4,r0
;;;373    #ifdef USE_USBD_COMPOSITE
;;;374      pdev->classId = 0U;
;;;375    #endif /* USE_USBD_COMPOSITE */
;;;376    
;;;377      /* Start the low level driver  */
;;;378      return USBD_LL_Start(pdev);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       USBD_LL_Start
;;;379    }
00000a  bd10              POP      {r4,pc}
;;;380    
                          ENDP


                          AREA ||i.USBD_Stop||, CODE, READONLY, ALIGN=1

                  USBD_Stop PROC
;;;386      */
;;;387    USBD_StatusTypeDef USBD_Stop(USBD_HandleTypeDef *pdev)
000000  b510              PUSH     {r4,lr}
;;;388    {
000002  4604              MOV      r4,r0
;;;389      /* Disconnect USB Device */
;;;390      (void)USBD_LL_Stop(pdev);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       USBD_LL_Stop
;;;391    
;;;392      /* Free Class Resources */
;;;393    #ifdef USE_USBD_COMPOSITE
;;;394      /* Parse the table of classes in use */
;;;395      for (uint32_t i = 0U; i < USBD_MAX_SUPPORTED_CLASS; i++)
;;;396      {
;;;397        /* Check if current class is in use */
;;;398        if ((pdev->tclasslist[i].Active) == 1U)
;;;399        {
;;;400          if (pdev->pClass[i] != NULL)
;;;401          {
;;;402            pdev->classId = i;
;;;403            /* Free Class Resources */
;;;404            (void)pdev->pClass[i]->DeInit(pdev, (uint8_t)pdev->dev_config);
;;;405          }
;;;406        }
;;;407      }
;;;408    
;;;409      /* Reset the class ID */
;;;410      pdev->classId = 0U;
;;;411    #else
;;;412      if (pdev->pClass[0] != NULL)
00000a  f8d402b8          LDR      r0,[r4,#0x2b8]
00000e  b128              CBZ      r0,|L24.28|
;;;413      {
;;;414        (void)pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config);
000010  7921              LDRB     r1,[r4,#4]
000012  f8d402b8          LDR      r0,[r4,#0x2b8]
000016  6842              LDR      r2,[r0,#4]
000018  4620              MOV      r0,r4
00001a  4790              BLX      r2
                  |L24.28|
;;;415      }
;;;416    #endif /* USE_USBD_COMPOSITE */
;;;417    
;;;418      return USBD_OK;
00001c  2000              MOVS     r0,#0
;;;419    }
00001e  bd10              POP      {r4,pc}
;;;420    
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Middlewares/ST/STM32_USB_Device_Library/Core/Src/usbd_core.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_usbd_core_c_bf7904d4____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___11_usbd_core_c_bf7904d4____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_usbd_core_c_bf7904d4____REVSH|
#line 478
|__asm___11_usbd_core_c_bf7904d4____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___11_usbd_core_c_bf7904d4____RRX|
#line 665
|__asm___11_usbd_core_c_bf7904d4____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
