; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o4gcamera\stm32f4xx_hal_uart.o --asm_dir=.\ --list_dir=.\ --depend=4gcamera\stm32f4xx_hal_uart.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../USB_DEVICE/App -I../USB_DEVICE/Target -I../Core/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Middlewares/ST/STM32_USB_Device_Library/Core/Inc -I../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 -I../Middlewares/Third_Party/FreeRTOS/Source/portable/RVDS/ARM_CM4F -I../HARDWARE/OV2640 -I../HARDWARE/WS2812B -I../HARDWARE/RING_BUFFER -I../HARDWARE/FLASH -I.\RTE\_4GCAMERA -IC:\Users\czm\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\czm\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=536 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F407xx --omf_browse=4gcamera\stm32f4xx_hal_uart.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_uart.c]
                          THUMB

                          AREA ||i.HAL_HalfDuplex_EnableReceiver||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableReceiver PROC
;;;2868     */
;;;2869   HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2870   {
;;;2871     uint32_t tmpreg = 0x00U;
000002  2200              MOVS     r2,#0
;;;2872   
;;;2873     /* Process Locked */
;;;2874     __HAL_LOCK(huart);
000004  bf00              NOP      
000006  f891003c          LDRB     r0,[r1,#0x3c]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L1.18|
00000e  2002              MOVS     r0,#2
                  |L1.16|
;;;2875   
;;;2876     huart->gState = HAL_UART_STATE_BUSY;
;;;2877   
;;;2878     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;2879     tmpreg = huart->Instance->CR1;
;;;2880   
;;;2881     /* Clear TE and RE bits */
;;;2882     tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
;;;2883   
;;;2884     /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
;;;2885     tmpreg |= (uint32_t)USART_CR1_RE;
;;;2886   
;;;2887     /* Write to USART CR1 */
;;;2888     WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
;;;2889   
;;;2890     huart->gState = HAL_UART_STATE_READY;
;;;2891   
;;;2892     /* Process Unlocked */
;;;2893     __HAL_UNLOCK(huart);
;;;2894   
;;;2895     return HAL_OK;
;;;2896   }
000010  4770              BX       lr
                  |L1.18|
000012  2001              MOVS     r0,#1                 ;2874
000014  f881003c          STRB     r0,[r1,#0x3c]         ;2874
000018  bf00              NOP                            ;2874
00001a  2024              MOVS     r0,#0x24              ;2876
00001c  f881003d          STRB     r0,[r1,#0x3d]         ;2876
000020  6808              LDR      r0,[r1,#0]            ;2879
000022  68c2              LDR      r2,[r0,#0xc]          ;2879
000024  f022020c          BIC      r2,r2,#0xc            ;2882
000028  f0420204          ORR      r2,r2,#4              ;2885
00002c  6808              LDR      r0,[r1,#0]            ;2888
00002e  60c2              STR      r2,[r0,#0xc]          ;2888
000030  2020              MOVS     r0,#0x20              ;2890
000032  f881003d          STRB     r0,[r1,#0x3d]         ;2890
000036  bf00              NOP                            ;2893
000038  2000              MOVS     r0,#0                 ;2893
00003a  f881003c          STRB     r0,[r1,#0x3c]         ;2893
00003e  bf00              NOP                            ;2893
000040  bf00              NOP                            ;2895
000042  e7e5              B        |L1.16|
;;;2897   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_EnableTransmitter||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableTransmitter PROC
;;;2833     */
;;;2834   HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2835   {
;;;2836     uint32_t tmpreg = 0x00U;
000002  2200              MOVS     r2,#0
;;;2837   
;;;2838     /* Process Locked */
;;;2839     __HAL_LOCK(huart);
000004  bf00              NOP      
000006  f891003c          LDRB     r0,[r1,#0x3c]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L2.18|
00000e  2002              MOVS     r0,#2
                  |L2.16|
;;;2840   
;;;2841     huart->gState = HAL_UART_STATE_BUSY;
;;;2842   
;;;2843     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;2844     tmpreg = huart->Instance->CR1;
;;;2845   
;;;2846     /* Clear TE and RE bits */
;;;2847     tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
;;;2848   
;;;2849     /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
;;;2850     tmpreg |= (uint32_t)USART_CR1_TE;
;;;2851   
;;;2852     /* Write to USART CR1 */
;;;2853     WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
;;;2854   
;;;2855     huart->gState = HAL_UART_STATE_READY;
;;;2856   
;;;2857     /* Process Unlocked */
;;;2858     __HAL_UNLOCK(huart);
;;;2859   
;;;2860     return HAL_OK;
;;;2861   }
000010  4770              BX       lr
                  |L2.18|
000012  2001              MOVS     r0,#1                 ;2839
000014  f881003c          STRB     r0,[r1,#0x3c]         ;2839
000018  bf00              NOP                            ;2839
00001a  2024              MOVS     r0,#0x24              ;2841
00001c  f881003d          STRB     r0,[r1,#0x3d]         ;2841
000020  6808              LDR      r0,[r1,#0]            ;2844
000022  68c2              LDR      r2,[r0,#0xc]          ;2844
000024  f022020c          BIC      r2,r2,#0xc            ;2847
000028  f0420208          ORR      r2,r2,#8              ;2850
00002c  6808              LDR      r0,[r1,#0]            ;2853
00002e  60c2              STR      r2,[r0,#0xc]          ;2853
000030  2020              MOVS     r0,#0x20              ;2855
000032  f881003d          STRB     r0,[r1,#0x3d]         ;2855
000036  bf00              NOP                            ;2858
000038  2000              MOVS     r0,#0                 ;2858
00003a  f881003c          STRB     r0,[r1,#0x3c]         ;2858
00003e  bf00              NOP                            ;2858
000040  bf00              NOP                            ;2860
000042  e7e5              B        |L2.16|
;;;2862   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_Init||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_Init PROC
;;;433      */
;;;434    HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;435    {
000002  4604              MOV      r4,r0
;;;436      /* Check the UART handle allocation */
;;;437      if (huart == NULL)
000004  b90c              CBNZ     r4,|L3.10|
;;;438      {
;;;439        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L3.8|
;;;440      }
;;;441    
;;;442      /* Check the parameters */
;;;443      assert_param(IS_UART_HALFDUPLEX_INSTANCE(huart->Instance));
;;;444      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;445      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;446    
;;;447      if (huart->gState == HAL_UART_STATE_RESET)
;;;448      {
;;;449        /* Allocate lock resource and initialize it */
;;;450        huart->Lock = HAL_UNLOCKED;
;;;451    
;;;452    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;453        UART_InitCallbacksToDefault(huart);
;;;454    
;;;455        if (huart->MspInitCallback == NULL)
;;;456        {
;;;457          huart->MspInitCallback = HAL_UART_MspInit;
;;;458        }
;;;459    
;;;460        /* Init the low level hardware */
;;;461        huart->MspInitCallback(huart);
;;;462    #else
;;;463        /* Init the low level hardware : GPIO, CLOCK */
;;;464        HAL_UART_MspInit(huart);
;;;465    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;466      }
;;;467    
;;;468      huart->gState = HAL_UART_STATE_BUSY;
;;;469    
;;;470      /* Disable the peripheral */
;;;471      __HAL_UART_DISABLE(huart);
;;;472    
;;;473      /* Set the UART Communication parameters */
;;;474      UART_SetConfig(huart);
;;;475    
;;;476      /* In half-duplex mode, the following bits must be kept cleared:
;;;477         - LINEN and CLKEN bits in the USART_CR2 register,
;;;478         - SCEN and IREN bits in the USART_CR3 register.*/
;;;479      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;480      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
;;;481    
;;;482      /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;483      SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
;;;484    
;;;485      /* Enable the peripheral */
;;;486      __HAL_UART_ENABLE(huart);
;;;487    
;;;488      /* Initialize the UART state*/
;;;489      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;490      huart->gState = HAL_UART_STATE_READY;
;;;491      huart->RxState = HAL_UART_STATE_READY;
;;;492    
;;;493      return HAL_OK;
;;;494    }
000008  bd10              POP      {r4,pc}
                  |L3.10|
00000a  f894003d          LDRB     r0,[r4,#0x3d]         ;447
00000e  b928              CBNZ     r0,|L3.28|
000010  2000              MOVS     r0,#0                 ;450
000012  f884003c          STRB     r0,[r4,#0x3c]         ;450
000016  4620              MOV      r0,r4                 ;464
000018  f7fffffe          BL       HAL_UART_MspInit
                  |L3.28|
00001c  2024              MOVS     r0,#0x24              ;468
00001e  f884003d          STRB     r0,[r4,#0x3d]         ;468
000022  6820              LDR      r0,[r4,#0]            ;471
000024  68c0              LDR      r0,[r0,#0xc]          ;471
000026  f4205000          BIC      r0,r0,#0x2000         ;471
00002a  6821              LDR      r1,[r4,#0]            ;471
00002c  60c8              STR      r0,[r1,#0xc]          ;471
00002e  4620              MOV      r0,r4                 ;474
000030  f7fffffe          BL       UART_SetConfig
000034  6820              LDR      r0,[r4,#0]            ;479
000036  6900              LDR      r0,[r0,#0x10]         ;479
000038  f4204090          BIC      r0,r0,#0x4800         ;479
00003c  6821              LDR      r1,[r4,#0]            ;479
00003e  6108              STR      r0,[r1,#0x10]         ;479
000040  6820              LDR      r0,[r4,#0]            ;480
000042  6940              LDR      r0,[r0,#0x14]         ;480
000044  f0200022          BIC      r0,r0,#0x22           ;480
000048  6821              LDR      r1,[r4,#0]            ;480
00004a  6148              STR      r0,[r1,#0x14]         ;480
00004c  6820              LDR      r0,[r4,#0]            ;483
00004e  6940              LDR      r0,[r0,#0x14]         ;483
000050  f0400008          ORR      r0,r0,#8              ;483
000054  6821              LDR      r1,[r4,#0]            ;483
000056  6148              STR      r0,[r1,#0x14]         ;483
000058  6820              LDR      r0,[r4,#0]            ;486
00005a  68c0              LDR      r0,[r0,#0xc]          ;486
00005c  f4405000          ORR      r0,r0,#0x2000         ;486
000060  6821              LDR      r1,[r4,#0]            ;486
000062  60c8              STR      r0,[r1,#0xc]          ;486
000064  2000              MOVS     r0,#0                 ;489
000066  6420              STR      r0,[r4,#0x40]         ;489
000068  2020              MOVS     r0,#0x20              ;490
00006a  f884003d          STRB     r0,[r4,#0x3d]         ;490
00006e  f884003e          STRB     r0,[r4,#0x3e]         ;491
000072  2000              MOVS     r0,#0                 ;493
000074  e7c8              B        |L3.8|
;;;495    
                          ENDP


                          AREA ||i.HAL_LIN_Init||, CODE, READONLY, ALIGN=1

                  HAL_LIN_Init PROC
;;;506      */
;;;507    HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
000000  b570              PUSH     {r4-r6,lr}
;;;508    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;509      /* Check the UART handle allocation */
;;;510      if (huart == NULL)
000006  b90c              CBNZ     r4,|L4.12|
;;;511      {
;;;512        return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L4.10|
;;;513      }
;;;514    
;;;515      /* Check the LIN UART instance */
;;;516      assert_param(IS_UART_LIN_INSTANCE(huart->Instance));
;;;517    
;;;518      /* Check the Break detection length parameter */
;;;519      assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
;;;520      assert_param(IS_UART_LIN_WORD_LENGTH(huart->Init.WordLength));
;;;521      assert_param(IS_UART_LIN_OVERSAMPLING(huart->Init.OverSampling));
;;;522    
;;;523      if (huart->gState == HAL_UART_STATE_RESET)
;;;524      {
;;;525        /* Allocate lock resource and initialize it */
;;;526        huart->Lock = HAL_UNLOCKED;
;;;527    
;;;528    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;529        UART_InitCallbacksToDefault(huart);
;;;530    
;;;531        if (huart->MspInitCallback == NULL)
;;;532        {
;;;533          huart->MspInitCallback = HAL_UART_MspInit;
;;;534        }
;;;535    
;;;536        /* Init the low level hardware */
;;;537        huart->MspInitCallback(huart);
;;;538    #else
;;;539        /* Init the low level hardware : GPIO, CLOCK */
;;;540        HAL_UART_MspInit(huart);
;;;541    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;542      }
;;;543    
;;;544      huart->gState = HAL_UART_STATE_BUSY;
;;;545    
;;;546      /* Disable the peripheral */
;;;547      __HAL_UART_DISABLE(huart);
;;;548    
;;;549      /* Set the UART Communication parameters */
;;;550      UART_SetConfig(huart);
;;;551    
;;;552      /* In LIN mode, the following bits must be kept cleared:
;;;553         - CLKEN bits in the USART_CR2 register,
;;;554         - SCEN, HDSEL and IREN bits in the USART_CR3 register.*/
;;;555      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_CLKEN));
;;;556      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
;;;557    
;;;558      /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;559      SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
;;;560    
;;;561      /* Set the USART LIN Break detection length. */
;;;562      CLEAR_BIT(huart->Instance->CR2, USART_CR2_LBDL);
;;;563      SET_BIT(huart->Instance->CR2, BreakDetectLength);
;;;564    
;;;565      /* Enable the peripheral */
;;;566      __HAL_UART_ENABLE(huart);
;;;567    
;;;568      /* Initialize the UART state*/
;;;569      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;570      huart->gState = HAL_UART_STATE_READY;
;;;571      huart->RxState = HAL_UART_STATE_READY;
;;;572    
;;;573      return HAL_OK;
;;;574    }
00000a  bd70              POP      {r4-r6,pc}
                  |L4.12|
00000c  f894003d          LDRB     r0,[r4,#0x3d]         ;523
000010  b928              CBNZ     r0,|L4.30|
000012  2000              MOVS     r0,#0                 ;526
000014  f884003c          STRB     r0,[r4,#0x3c]         ;526
000018  4620              MOV      r0,r4                 ;540
00001a  f7fffffe          BL       HAL_UART_MspInit
                  |L4.30|
00001e  2024              MOVS     r0,#0x24              ;544
000020  f884003d          STRB     r0,[r4,#0x3d]         ;544
000024  6820              LDR      r0,[r4,#0]            ;547
000026  68c0              LDR      r0,[r0,#0xc]          ;547
000028  f4205000          BIC      r0,r0,#0x2000         ;547
00002c  6821              LDR      r1,[r4,#0]            ;547
00002e  60c8              STR      r0,[r1,#0xc]          ;547
000030  4620              MOV      r0,r4                 ;550
000032  f7fffffe          BL       UART_SetConfig
000036  6820              LDR      r0,[r4,#0]            ;555
000038  6900              LDR      r0,[r0,#0x10]         ;555
00003a  f4206000          BIC      r0,r0,#0x800          ;555
00003e  6821              LDR      r1,[r4,#0]            ;555
000040  6108              STR      r0,[r1,#0x10]         ;555
000042  6820              LDR      r0,[r4,#0]            ;556
000044  6940              LDR      r0,[r0,#0x14]         ;556
000046  f020002a          BIC      r0,r0,#0x2a           ;556
00004a  6821              LDR      r1,[r4,#0]            ;556
00004c  6148              STR      r0,[r1,#0x14]         ;556
00004e  6820              LDR      r0,[r4,#0]            ;559
000050  6900              LDR      r0,[r0,#0x10]         ;559
000052  f4404080          ORR      r0,r0,#0x4000         ;559
000056  6821              LDR      r1,[r4,#0]            ;559
000058  6108              STR      r0,[r1,#0x10]         ;559
00005a  6820              LDR      r0,[r4,#0]            ;562
00005c  6900              LDR      r0,[r0,#0x10]         ;562
00005e  f0200020          BIC      r0,r0,#0x20           ;562
000062  6821              LDR      r1,[r4,#0]            ;562
000064  6108              STR      r0,[r1,#0x10]         ;562
000066  6820              LDR      r0,[r4,#0]            ;563
000068  6900              LDR      r0,[r0,#0x10]         ;563
00006a  4328              ORRS     r0,r0,r5              ;563
00006c  6821              LDR      r1,[r4,#0]            ;563
00006e  6108              STR      r0,[r1,#0x10]         ;563
000070  6820              LDR      r0,[r4,#0]            ;566
000072  68c0              LDR      r0,[r0,#0xc]          ;566
000074  f4405000          ORR      r0,r0,#0x2000         ;566
000078  6821              LDR      r1,[r4,#0]            ;566
00007a  60c8              STR      r0,[r1,#0xc]          ;566
00007c  2000              MOVS     r0,#0                 ;569
00007e  6420              STR      r0,[r4,#0x40]         ;569
000080  2020              MOVS     r0,#0x20              ;570
000082  f884003d          STRB     r0,[r4,#0x3d]         ;570
000086  f884003e          STRB     r0,[r4,#0x3e]         ;571
00008a  2000              MOVS     r0,#0                 ;573
00008c  e7bd              B        |L4.10|
;;;575    
                          ENDP


                          AREA ||i.HAL_LIN_SendBreak||, CODE, READONLY, ALIGN=1

                  HAL_LIN_SendBreak PROC
;;;2752     */
;;;2753   HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2754   {
;;;2755     /* Check the parameters */
;;;2756     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;2757   
;;;2758     /* Process Locked */
;;;2759     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  f891003c          LDRB     r0,[r1,#0x3c]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L5.16|
00000c  2002              MOVS     r0,#2
                  |L5.14|
;;;2760   
;;;2761     huart->gState = HAL_UART_STATE_BUSY;
;;;2762   
;;;2763     /* Send break characters */
;;;2764     ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_SBK);
;;;2765   
;;;2766     huart->gState = HAL_UART_STATE_READY;
;;;2767   
;;;2768     /* Process Unlocked */
;;;2769     __HAL_UNLOCK(huart);
;;;2770   
;;;2771     return HAL_OK;
;;;2772   }
00000e  4770              BX       lr
                  |L5.16|
000010  2001              MOVS     r0,#1                 ;2759
000012  f881003c          STRB     r0,[r1,#0x3c]         ;2759
000016  bf00              NOP                            ;2759
000018  2024              MOVS     r0,#0x24              ;2761
00001a  f881003d          STRB     r0,[r1,#0x3d]         ;2761
00001e  bf00              NOP                            ;2764
000020  bf00              NOP                            ;2764
                  |L5.34|
000022  680a              LDR      r2,[r1,#0]            ;2764
000024  320c              ADDS     r2,r2,#0xc            ;2764
000026  e8522f00          LDREX    r2,[r2,#0]            ;2764
00002a  f0420001          ORR      r0,r2,#1              ;2764
00002e  680a              LDR      r2,[r1,#0]            ;2764
000030  320c              ADDS     r2,r2,#0xc            ;2764
000032  e8420300          STREX    r3,r0,[r2,#0]         ;2764
000036  2b00              CMP      r3,#0                 ;2764
000038  d1f3              BNE      |L5.34|
00003a  bf00              NOP                            ;2764
00003c  2020              MOVS     r0,#0x20              ;2766
00003e  f881003d          STRB     r0,[r1,#0x3d]         ;2766
000042  bf00              NOP                            ;2769
000044  2000              MOVS     r0,#0                 ;2769
000046  f881003c          STRB     r0,[r1,#0x3c]         ;2769
00004a  bf00              NOP                            ;2769
00004c  bf00              NOP                            ;2771
00004e  e7de              B        |L5.14|
;;;2773   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnterMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnterMuteMode PROC
;;;2779     */
;;;2780   HAL_StatusTypeDef HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2781   {
;;;2782     /* Check the parameters */
;;;2783     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;2784   
;;;2785     /* Process Locked */
;;;2786     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  f891003c          LDRB     r0,[r1,#0x3c]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L6.16|
00000c  2002              MOVS     r0,#2
                  |L6.14|
;;;2787   
;;;2788     huart->gState = HAL_UART_STATE_BUSY;
;;;2789   
;;;2790     /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;2791     ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RWU);
;;;2792   
;;;2793     huart->gState = HAL_UART_STATE_READY;
;;;2794   
;;;2795     /* Process Unlocked */
;;;2796     __HAL_UNLOCK(huart);
;;;2797   
;;;2798     return HAL_OK;
;;;2799   }
00000e  4770              BX       lr
                  |L6.16|
000010  2001              MOVS     r0,#1                 ;2786
000012  f881003c          STRB     r0,[r1,#0x3c]         ;2786
000016  bf00              NOP                            ;2786
000018  2024              MOVS     r0,#0x24              ;2788
00001a  f881003d          STRB     r0,[r1,#0x3d]         ;2788
00001e  bf00              NOP                            ;2791
000020  bf00              NOP                            ;2791
                  |L6.34|
000022  680a              LDR      r2,[r1,#0]            ;2791
000024  320c              ADDS     r2,r2,#0xc            ;2791
000026  e8522f00          LDREX    r2,[r2,#0]            ;2791
00002a  f0420002          ORR      r0,r2,#2              ;2791
00002e  680a              LDR      r2,[r1,#0]            ;2791
000030  320c              ADDS     r2,r2,#0xc            ;2791
000032  e8420300          STREX    r3,r0,[r2,#0]         ;2791
000036  2b00              CMP      r3,#0                 ;2791
000038  d1f3              BNE      |L6.34|
00003a  bf00              NOP                            ;2791
00003c  2020              MOVS     r0,#0x20              ;2793
00003e  f881003d          STRB     r0,[r1,#0x3d]         ;2793
000042  bf00              NOP                            ;2796
000044  2000              MOVS     r0,#0                 ;2796
000046  f881003c          STRB     r0,[r1,#0x3c]         ;2796
00004a  bf00              NOP                            ;2796
00004c  bf00              NOP                            ;2798
00004e  e7de              B        |L6.14|
;;;2800   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_ExitMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_ExitMuteMode PROC
;;;2806     */
;;;2807   HAL_StatusTypeDef HAL_MultiProcessor_ExitMuteMode(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2808   {
;;;2809     /* Check the parameters */
;;;2810     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;2811   
;;;2812     /* Process Locked */
;;;2813     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  f891003c          LDRB     r0,[r1,#0x3c]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L7.16|
00000c  2002              MOVS     r0,#2
                  |L7.14|
;;;2814   
;;;2815     huart->gState = HAL_UART_STATE_BUSY;
;;;2816   
;;;2817     /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;2818     ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_RWU);
;;;2819   
;;;2820     huart->gState = HAL_UART_STATE_READY;
;;;2821   
;;;2822     /* Process Unlocked */
;;;2823     __HAL_UNLOCK(huart);
;;;2824   
;;;2825     return HAL_OK;
;;;2826   }
00000e  4770              BX       lr
                  |L7.16|
000010  2001              MOVS     r0,#1                 ;2813
000012  f881003c          STRB     r0,[r1,#0x3c]         ;2813
000016  bf00              NOP                            ;2813
000018  2024              MOVS     r0,#0x24              ;2815
00001a  f881003d          STRB     r0,[r1,#0x3d]         ;2815
00001e  bf00              NOP                            ;2818
000020  bf00              NOP                            ;2818
                  |L7.34|
000022  680a              LDR      r2,[r1,#0]            ;2818
000024  320c              ADDS     r2,r2,#0xc            ;2818
000026  e8522f00          LDREX    r2,[r2,#0]            ;2818
00002a  f0220002          BIC      r0,r2,#2              ;2818
00002e  680a              LDR      r2,[r1,#0]            ;2818
000030  320c              ADDS     r2,r2,#0xc            ;2818
000032  e8420300          STREX    r3,r0,[r2,#0]         ;2818
000036  2b00              CMP      r3,#0                 ;2818
000038  d1f3              BNE      |L7.34|
00003a  bf00              NOP                            ;2818
00003c  2020              MOVS     r0,#0x20              ;2820
00003e  f881003d          STRB     r0,[r1,#0x3d]         ;2820
000042  bf00              NOP                            ;2823
000044  2000              MOVS     r0,#0                 ;2823
000046  f881003c          STRB     r0,[r1,#0x3c]         ;2823
00004a  bf00              NOP                            ;2823
00004c  bf00              NOP                            ;2825
00004e  e7de              B        |L7.14|
;;;2827   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_Init||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_Init PROC
;;;587      */
;;;588    HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
000000  b570              PUSH     {r4-r6,lr}
;;;589    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;590      /* Check the UART handle allocation */
;;;591      if (huart == NULL)
000008  b90c              CBNZ     r4,|L8.14|
;;;592      {
;;;593        return HAL_ERROR;
00000a  2001              MOVS     r0,#1
                  |L8.12|
;;;594      }
;;;595    
;;;596      /* Check the parameters */
;;;597      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;598    
;;;599      /* Check the Address & wake up method parameters */
;;;600      assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
;;;601      assert_param(IS_UART_ADDRESS(Address));
;;;602      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;603      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;604    
;;;605      if (huart->gState == HAL_UART_STATE_RESET)
;;;606      {
;;;607        /* Allocate lock resource and initialize it */
;;;608        huart->Lock = HAL_UNLOCKED;
;;;609    
;;;610    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;611        UART_InitCallbacksToDefault(huart);
;;;612    
;;;613        if (huart->MspInitCallback == NULL)
;;;614        {
;;;615          huart->MspInitCallback = HAL_UART_MspInit;
;;;616        }
;;;617    
;;;618        /* Init the low level hardware */
;;;619        huart->MspInitCallback(huart);
;;;620    #else
;;;621        /* Init the low level hardware : GPIO, CLOCK */
;;;622        HAL_UART_MspInit(huart);
;;;623    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;624      }
;;;625    
;;;626      huart->gState = HAL_UART_STATE_BUSY;
;;;627    
;;;628      /* Disable the peripheral */
;;;629      __HAL_UART_DISABLE(huart);
;;;630    
;;;631      /* Set the UART Communication parameters */
;;;632      UART_SetConfig(huart);
;;;633    
;;;634      /* In Multi-Processor mode, the following bits must be kept cleared:
;;;635         - LINEN and CLKEN bits in the USART_CR2 register,
;;;636         - SCEN, HDSEL and IREN  bits in the USART_CR3 register */
;;;637      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;638      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;639    
;;;640      /* Set the USART address node */
;;;641      CLEAR_BIT(huart->Instance->CR2, USART_CR2_ADD);
;;;642      SET_BIT(huart->Instance->CR2, Address);
;;;643    
;;;644      /* Set the wake up method by setting the WAKE bit in the CR1 register */
;;;645      CLEAR_BIT(huart->Instance->CR1, USART_CR1_WAKE);
;;;646      SET_BIT(huart->Instance->CR1, WakeUpMethod);
;;;647    
;;;648      /* Enable the peripheral */
;;;649      __HAL_UART_ENABLE(huart);
;;;650    
;;;651      /* Initialize the UART state */
;;;652      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;653      huart->gState = HAL_UART_STATE_READY;
;;;654      huart->RxState = HAL_UART_STATE_READY;
;;;655    
;;;656      return HAL_OK;
;;;657    }
00000c  bd70              POP      {r4-r6,pc}
                  |L8.14|
00000e  f894003d          LDRB     r0,[r4,#0x3d]         ;605
000012  b928              CBNZ     r0,|L8.32|
000014  2000              MOVS     r0,#0                 ;608
000016  f884003c          STRB     r0,[r4,#0x3c]         ;608
00001a  4620              MOV      r0,r4                 ;622
00001c  f7fffffe          BL       HAL_UART_MspInit
                  |L8.32|
000020  2024              MOVS     r0,#0x24              ;626
000022  f884003d          STRB     r0,[r4,#0x3d]         ;626
000026  6820              LDR      r0,[r4,#0]            ;629
000028  68c0              LDR      r0,[r0,#0xc]          ;629
00002a  f4205000          BIC      r0,r0,#0x2000         ;629
00002e  6821              LDR      r1,[r4,#0]            ;629
000030  60c8              STR      r0,[r1,#0xc]          ;629
000032  4620              MOV      r0,r4                 ;632
000034  f7fffffe          BL       UART_SetConfig
000038  6820              LDR      r0,[r4,#0]            ;637
00003a  6900              LDR      r0,[r0,#0x10]         ;637
00003c  f4204090          BIC      r0,r0,#0x4800         ;637
000040  6821              LDR      r1,[r4,#0]            ;637
000042  6108              STR      r0,[r1,#0x10]         ;637
000044  6820              LDR      r0,[r4,#0]            ;638
000046  6940              LDR      r0,[r0,#0x14]         ;638
000048  f020002a          BIC      r0,r0,#0x2a           ;638
00004c  6821              LDR      r1,[r4,#0]            ;638
00004e  6148              STR      r0,[r1,#0x14]         ;638
000050  6820              LDR      r0,[r4,#0]            ;641
000052  6900              LDR      r0,[r0,#0x10]         ;641
000054  f020000f          BIC      r0,r0,#0xf            ;641
000058  6821              LDR      r1,[r4,#0]            ;641
00005a  6108              STR      r0,[r1,#0x10]         ;641
00005c  6820              LDR      r0,[r4,#0]            ;642
00005e  6900              LDR      r0,[r0,#0x10]         ;642
000060  4328              ORRS     r0,r0,r5              ;642
000062  6821              LDR      r1,[r4,#0]            ;642
000064  6108              STR      r0,[r1,#0x10]         ;642
000066  6820              LDR      r0,[r4,#0]            ;645
000068  68c0              LDR      r0,[r0,#0xc]          ;645
00006a  f4206000          BIC      r0,r0,#0x800          ;645
00006e  6821              LDR      r1,[r4,#0]            ;645
000070  60c8              STR      r0,[r1,#0xc]          ;645
000072  6820              LDR      r0,[r4,#0]            ;646
000074  68c0              LDR      r0,[r0,#0xc]          ;646
000076  4330              ORRS     r0,r0,r6              ;646
000078  6821              LDR      r1,[r4,#0]            ;646
00007a  60c8              STR      r0,[r1,#0xc]          ;646
00007c  6820              LDR      r0,[r4,#0]            ;649
00007e  68c0              LDR      r0,[r0,#0xc]          ;649
000080  f4405000          ORR      r0,r0,#0x2000         ;649
000084  6821              LDR      r1,[r4,#0]            ;649
000086  60c8              STR      r0,[r1,#0xc]          ;649
000088  2000              MOVS     r0,#0                 ;652
00008a  6420              STR      r0,[r4,#0x40]         ;652
00008c  2020              MOVS     r0,#0x20              ;653
00008e  f884003d          STRB     r0,[r4,#0x3d]         ;653
000092  f884003e          STRB     r0,[r4,#0x3e]         ;654
000096  2000              MOVS     r0,#0                 ;656
000098  e7b8              B        |L8.12|
;;;658    
                          ENDP


                          AREA ||i.HAL_UARTEx_ReceiveToIdle||, CODE, READONLY, ALIGN=1

                  HAL_UARTEx_ReceiveToIdle PROC
;;;1623     */
;;;1624   HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint16_t *RxLen,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1625                                              uint32_t Timeout)
;;;1626   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461d              MOV      r5,r3
00000c  f8dda028          LDR      r10,[sp,#0x28]
;;;1627     uint8_t  *pdata8bits;
;;;1628     uint16_t *pdata16bits;
;;;1629     uint32_t tickstart;
;;;1630   
;;;1631     /* Check that a Rx process is not already ongoing */
;;;1632     if (huart->RxState == HAL_UART_STATE_READY)
000010  f894003e          LDRB     r0,[r4,#0x3e]
000014  2820              CMP      r0,#0x20
000016  d17c              BNE      |L9.274|
;;;1633     {
;;;1634       if ((pData == NULL) || (Size == 0U))
000018  b117              CBZ      r7,|L9.32|
00001a  f1b80f00          CMP      r8,#0
00001e  d102              BNE      |L9.38|
                  |L9.32|
;;;1635       {
;;;1636         return  HAL_ERROR;
000020  2001              MOVS     r0,#1
                  |L9.34|
;;;1637       }
;;;1638   
;;;1639       __HAL_LOCK(huart);
;;;1640   
;;;1641       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1642       huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;1643       huart->ReceptionType = HAL_UART_RECEPTION_TOIDLE;
;;;1644   
;;;1645       /* Init tickstart for timeout management */
;;;1646       tickstart = HAL_GetTick();
;;;1647   
;;;1648       huart->RxXferSize  = Size;
;;;1649       huart->RxXferCount = Size;
;;;1650   
;;;1651       /* In case of 9bits/No Parity transfer, pRxData needs to be handled as a uint16_t pointer */
;;;1652       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;1653       {
;;;1654         pdata8bits  = NULL;
;;;1655         pdata16bits = (uint16_t *) pData;
;;;1656       }
;;;1657       else
;;;1658       {
;;;1659         pdata8bits  = pData;
;;;1660         pdata16bits = NULL;
;;;1661       }
;;;1662   
;;;1663       __HAL_UNLOCK(huart);
;;;1664   
;;;1665       /* Initialize output number of received elements */
;;;1666       *RxLen = 0U;
;;;1667   
;;;1668       /* as long as data have to be received */
;;;1669       while (huart->RxXferCount > 0U)
;;;1670       {
;;;1671         /* Check if IDLE flag is set */
;;;1672         if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE))
;;;1673         {
;;;1674           /* Clear IDLE flag in ISR */
;;;1675           __HAL_UART_CLEAR_IDLEFLAG(huart);
;;;1676   
;;;1677           /* If Set, but no data ever received, clear flag without exiting loop */
;;;1678           /* If Set, and data has already been received, this means Idle Event is valid : End reception */
;;;1679           if (*RxLen > 0U)
;;;1680           {
;;;1681             huart->RxState = HAL_UART_STATE_READY;
;;;1682   
;;;1683             return HAL_OK;
;;;1684           }
;;;1685         }
;;;1686   
;;;1687         /* Check if RXNE flag is set */
;;;1688         if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RXNE))
;;;1689         {
;;;1690           if (pdata8bits == NULL)
;;;1691           {
;;;1692             *pdata16bits = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
;;;1693             pdata16bits++;
;;;1694           }
;;;1695           else
;;;1696           {
;;;1697             if ((huart->Init.WordLength == UART_WORDLENGTH_9B) || ((huart->Init.WordLength == UART_WORDLENGTH_8B) && (huart->Init.Parity == UART_PARITY_NONE)))
;;;1698             {
;;;1699               *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
;;;1700             }
;;;1701             else
;;;1702             {
;;;1703               *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
;;;1704             }
;;;1705   
;;;1706             pdata8bits++;
;;;1707           }
;;;1708           /* Increment number of received elements */
;;;1709           *RxLen += 1U;
;;;1710           huart->RxXferCount--;
;;;1711         }
;;;1712   
;;;1713         /* Check for the Timeout */
;;;1714         if (Timeout != HAL_MAX_DELAY)
;;;1715         {
;;;1716           if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
;;;1717           {
;;;1718             huart->RxState = HAL_UART_STATE_READY;
;;;1719   
;;;1720             return HAL_TIMEOUT;
;;;1721           }
;;;1722         }
;;;1723       }
;;;1724   
;;;1725       /* Set number of received elements in output parameter : RxLen */
;;;1726       *RxLen = huart->RxXferSize - huart->RxXferCount;
;;;1727       /* At end of Rx process, restore huart->RxState to Ready */
;;;1728       huart->RxState = HAL_UART_STATE_READY;
;;;1729   
;;;1730       return HAL_OK;
;;;1731     }
;;;1732     else
;;;1733     {
;;;1734       return HAL_BUSY;
;;;1735     }
;;;1736   }
000022  e8bd8ff8          POP      {r3-r11,pc}
                  |L9.38|
000026  bf00              NOP                            ;1639
000028  f894003c          LDRB     r0,[r4,#0x3c]         ;1639
00002c  2801              CMP      r0,#1                 ;1639
00002e  d101              BNE      |L9.52|
000030  2002              MOVS     r0,#2                 ;1639
000032  e7f6              B        |L9.34|
                  |L9.52|
000034  2001              MOVS     r0,#1                 ;1639
000036  f884003c          STRB     r0,[r4,#0x3c]         ;1639
00003a  bf00              NOP                            ;1639
00003c  2000              MOVS     r0,#0                 ;1641
00003e  6420              STR      r0,[r4,#0x40]         ;1641
000040  2022              MOVS     r0,#0x22              ;1642
000042  f884003e          STRB     r0,[r4,#0x3e]         ;1642
000046  2001              MOVS     r0,#1                 ;1643
000048  6320              STR      r0,[r4,#0x30]         ;1643
00004a  f7fffffe          BL       HAL_GetTick
00004e  4683              MOV      r11,r0                ;1646
000050  f8a4802c          STRH     r8,[r4,#0x2c]         ;1648
000054  f8a4802e          STRH     r8,[r4,#0x2e]         ;1649
000058  68a0              LDR      r0,[r4,#8]            ;1652
00005a  f5b05f80          CMP      r0,#0x1000            ;1652
00005e  d104              BNE      |L9.106|
000060  6920              LDR      r0,[r4,#0x10]         ;1652
000062  b910              CBNZ     r0,|L9.106|
000064  2600              MOVS     r6,#0                 ;1654
000066  46b9              MOV      r9,r7                 ;1655
000068  e002              B        |L9.112|
                  |L9.106|
00006a  463e              MOV      r6,r7                 ;1659
00006c  f04f0900          MOV      r9,#0                 ;1660
                  |L9.112|
000070  bf00              NOP                            ;1663
000072  2000              MOVS     r0,#0                 ;1663
000074  f884003c          STRB     r0,[r4,#0x3c]         ;1663
000078  bf00              NOP                            ;1663
00007a  8028              STRH     r0,[r5,#0]            ;1666
00007c  e052              B        |L9.292|
                  |L9.126|
00007e  6820              LDR      r0,[r4,#0]            ;1672
000080  6800              LDR      r0,[r0,#0]            ;1672
000082  f0000010          AND      r0,r0,#0x10           ;1672
000086  2810              CMP      r0,#0x10              ;1672
000088  d111              BNE      |L9.174|
00008a  bf00              NOP                            ;1675
00008c  2000              MOVS     r0,#0                 ;1675
00008e  9000              STR      r0,[sp,#0]            ;1675
000090  6820              LDR      r0,[r4,#0]            ;1675
000092  6800              LDR      r0,[r0,#0]            ;1675
000094  9000              STR      r0,[sp,#0]            ;1675
000096  6820              LDR      r0,[r4,#0]            ;1675
000098  6840              LDR      r0,[r0,#4]            ;1675
00009a  9000              STR      r0,[sp,#0]            ;1675
00009c  bf00              NOP                            ;1675
00009e  bf00              NOP                            ;1675
0000a0  8828              LDRH     r0,[r5,#0]            ;1679
0000a2  b120              CBZ      r0,|L9.174|
0000a4  2020              MOVS     r0,#0x20              ;1681
0000a6  f884003e          STRB     r0,[r4,#0x3e]         ;1681
0000aa  2000              MOVS     r0,#0                 ;1683
0000ac  e7b9              B        |L9.34|
                  |L9.174|
0000ae  6820              LDR      r0,[r4,#0]            ;1688
0000b0  6800              LDR      r0,[r0,#0]            ;1688
0000b2  f0000020          AND      r0,r0,#0x20           ;1688
0000b6  2820              CMP      r0,#0x20              ;1688
0000b8  d121              BNE      |L9.254|
0000ba  b946              CBNZ     r6,|L9.206|
0000bc  6820              LDR      r0,[r4,#0]            ;1692
0000be  6840              LDR      r0,[r0,#4]            ;1692
0000c0  f3c00008          UBFX     r0,r0,#0,#9           ;1692
0000c4  f8a90000          STRH     r0,[r9,#0]            ;1692
0000c8  f1090902          ADD      r9,r9,#2              ;1693
0000cc  e011              B        |L9.242|
                  |L9.206|
0000ce  68a0              LDR      r0,[r4,#8]            ;1697
0000d0  f5b05f80          CMP      r0,#0x1000            ;1697
0000d4  d003              BEQ      |L9.222|
0000d6  68a0              LDR      r0,[r4,#8]            ;1697
0000d8  b928              CBNZ     r0,|L9.230|
0000da  6920              LDR      r0,[r4,#0x10]         ;1697
0000dc  b918              CBNZ     r0,|L9.230|
                  |L9.222|
0000de  6820              LDR      r0,[r4,#0]            ;1699
0000e0  6840              LDR      r0,[r0,#4]            ;1699
0000e2  7030              STRB     r0,[r6,#0]            ;1699
0000e4  e004              B        |L9.240|
                  |L9.230|
0000e6  6820              LDR      r0,[r4,#0]            ;1703
0000e8  6840              LDR      r0,[r0,#4]            ;1703
0000ea  f000007f          AND      r0,r0,#0x7f           ;1703
0000ee  7030              STRB     r0,[r6,#0]            ;1703
                  |L9.240|
0000f0  1c76              ADDS     r6,r6,#1              ;1706
                  |L9.242|
0000f2  8828              LDRH     r0,[r5,#0]            ;1709
0000f4  1c40              ADDS     r0,r0,#1              ;1709
0000f6  8028              STRH     r0,[r5,#0]            ;1709
0000f8  8de0              LDRH     r0,[r4,#0x2e]         ;1710
0000fa  1e40              SUBS     r0,r0,#1              ;1710
0000fc  85e0              STRH     r0,[r4,#0x2e]         ;1710
                  |L9.254|
0000fe  f10a0001          ADD      r0,r10,#1             ;1714
000102  b178              CBZ      r0,|L9.292|
000104  f7fffffe          BL       HAL_GetTick
000108  eba0000b          SUB      r0,r0,r11             ;1716
00010c  4550              CMP      r0,r10                ;1716
00010e  d804              BHI      |L9.282|
000110  e000              B        |L9.276|
                  |L9.274|
000112  e013              B        |L9.316|
                  |L9.276|
000114  f1ba0f00          CMP      r10,#0                ;1716
000118  d104              BNE      |L9.292|
                  |L9.282|
00011a  2020              MOVS     r0,#0x20              ;1718
00011c  f884003e          STRB     r0,[r4,#0x3e]         ;1718
000120  2003              MOVS     r0,#3                 ;1720
000122  e77e              B        |L9.34|
                  |L9.292|
000124  8de0              LDRH     r0,[r4,#0x2e]         ;1669
000126  2800              CMP      r0,#0                 ;1669
000128  d1a9              BNE      |L9.126|
00012a  8da0              LDRH     r0,[r4,#0x2c]         ;1726
00012c  8de1              LDRH     r1,[r4,#0x2e]         ;1726
00012e  1a40              SUBS     r0,r0,r1              ;1726
000130  8028              STRH     r0,[r5,#0]            ;1726
000132  2020              MOVS     r0,#0x20              ;1728
000134  f884003e          STRB     r0,[r4,#0x3e]         ;1728
000138  2000              MOVS     r0,#0                 ;1730
00013a  e772              B        |L9.34|
                  |L9.316|
00013c  2002              MOVS     r0,#2                 ;1734
00013e  e770              B        |L9.34|
;;;1737   
                          ENDP


                          AREA ||i.HAL_UARTEx_ReceiveToIdle_DMA||, CODE, READONLY, ALIGN=1

                  HAL_UARTEx_ReceiveToIdle_DMA PROC
;;;1811     */
;;;1812   HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1813   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;1814     HAL_StatusTypeDef status;
;;;1815   
;;;1816     /* Check that a Rx process is not already ongoing */
;;;1817     if (huart->RxState == HAL_UART_STATE_READY)
000008  f894003e          LDRB     r0,[r4,#0x3e]
00000c  2820              CMP      r0,#0x20
00000e  d136              BNE      |L10.126|
;;;1818     {
;;;1819       if ((pData == NULL) || (Size == 0U))
000010  b106              CBZ      r6,|L10.20|
000012  b90f              CBNZ     r7,|L10.24|
                  |L10.20|
;;;1820       {
;;;1821         return HAL_ERROR;
000014  2001              MOVS     r0,#1
                  |L10.22|
;;;1822       }
;;;1823   
;;;1824       __HAL_LOCK(huart);
;;;1825   
;;;1826       /* Set Reception type to reception till IDLE Event*/
;;;1827       huart->ReceptionType = HAL_UART_RECEPTION_TOIDLE;
;;;1828   
;;;1829       status =  UART_Start_Receive_DMA(huart, pData, Size);
;;;1830   
;;;1831       /* Check Rx process has been successfully started */
;;;1832       if (status == HAL_OK)
;;;1833       {
;;;1834         if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
;;;1835         {
;;;1836           __HAL_UART_CLEAR_IDLEFLAG(huart);
;;;1837           ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
;;;1838         }
;;;1839         else
;;;1840         {
;;;1841           /* In case of errors already pending when reception is started,
;;;1842              Interrupts may have already been raised and lead to reception abortion.
;;;1843              (Overrun error for instance).
;;;1844              In such case Reception Type has been reset to HAL_UART_RECEPTION_STANDARD. */
;;;1845           status = HAL_ERROR;
;;;1846         }
;;;1847       }
;;;1848   
;;;1849       return status;
;;;1850     }
;;;1851     else
;;;1852     {
;;;1853       return HAL_BUSY;
;;;1854     }
;;;1855   }
000016  bdf8              POP      {r3-r7,pc}
                  |L10.24|
000018  bf00              NOP                            ;1824
00001a  f894003c          LDRB     r0,[r4,#0x3c]         ;1824
00001e  2801              CMP      r0,#1                 ;1824
000020  d101              BNE      |L10.38|
000022  2002              MOVS     r0,#2                 ;1824
000024  e7f7              B        |L10.22|
                  |L10.38|
000026  2001              MOVS     r0,#1                 ;1824
000028  f884003c          STRB     r0,[r4,#0x3c]         ;1824
00002c  bf00              NOP                            ;1824
00002e  6320              STR      r0,[r4,#0x30]         ;1827
000030  463a              MOV      r2,r7                 ;1829
000032  4631              MOV      r1,r6                 ;1829
000034  4620              MOV      r0,r4                 ;1829
000036  f7fffffe          BL       UART_Start_Receive_DMA
00003a  4605              MOV      r5,r0                 ;1829
00003c  b9ed              CBNZ     r5,|L10.122|
00003e  6b20              LDR      r0,[r4,#0x30]         ;1834
000040  2801              CMP      r0,#1                 ;1834
000042  d119              BNE      |L10.120|
000044  bf00              NOP                            ;1836
000046  2000              MOVS     r0,#0                 ;1836
000048  9000              STR      r0,[sp,#0]            ;1836
00004a  6820              LDR      r0,[r4,#0]            ;1836
00004c  6800              LDR      r0,[r0,#0]            ;1836
00004e  9000              STR      r0,[sp,#0]            ;1836
000050  6820              LDR      r0,[r4,#0]            ;1836
000052  6840              LDR      r0,[r0,#4]            ;1836
000054  9000              STR      r0,[sp,#0]            ;1836
000056  bf00              NOP                            ;1836
000058  bf00              NOP                            ;1836
00005a  bf00              NOP                            ;1837
00005c  bf00              NOP                            ;1837
                  |L10.94|
00005e  6821              LDR      r1,[r4,#0]            ;1837
000060  310c              ADDS     r1,r1,#0xc            ;1837
000062  e8511f00          LDREX    r1,[r1,#0]            ;1837
000066  f0410010          ORR      r0,r1,#0x10           ;1837
00006a  6821              LDR      r1,[r4,#0]            ;1837
00006c  310c              ADDS     r1,r1,#0xc            ;1837
00006e  e8410200          STREX    r2,r0,[r1,#0]         ;1837
000072  2a00              CMP      r2,#0                 ;1837
000074  d1f3              BNE      |L10.94|
000076  e000              B        |L10.122|
                  |L10.120|
000078  2501              MOVS     r5,#1                 ;1845
                  |L10.122|
00007a  4628              MOV      r0,r5                 ;1849
00007c  e7cb              B        |L10.22|
                  |L10.126|
00007e  2002              MOVS     r0,#2                 ;1853
000080  e7c9              B        |L10.22|
;;;1856   
                          ENDP


                          AREA ||i.HAL_UARTEx_ReceiveToIdle_IT||, CODE, READONLY, ALIGN=1

                  HAL_UARTEx_ReceiveToIdle_IT PROC
;;;1750     */
;;;1751   HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1752   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;1753     HAL_StatusTypeDef status;
;;;1754   
;;;1755     /* Check that a Rx process is not already ongoing */
;;;1756     if (huart->RxState == HAL_UART_STATE_READY)
000008  f894003e          LDRB     r0,[r4,#0x3e]
00000c  2820              CMP      r0,#0x20
00000e  d136              BNE      |L11.126|
;;;1757     {
;;;1758       if ((pData == NULL) || (Size == 0U))
000010  b106              CBZ      r6,|L11.20|
000012  b90f              CBNZ     r7,|L11.24|
                  |L11.20|
;;;1759       {
;;;1760         return HAL_ERROR;
000014  2001              MOVS     r0,#1
                  |L11.22|
;;;1761       }
;;;1762   
;;;1763       __HAL_LOCK(huart);
;;;1764   
;;;1765       /* Set Reception type to reception till IDLE Event*/
;;;1766       huart->ReceptionType = HAL_UART_RECEPTION_TOIDLE;
;;;1767   
;;;1768       status =  UART_Start_Receive_IT(huart, pData, Size);
;;;1769   
;;;1770       /* Check Rx process has been successfully started */
;;;1771       if (status == HAL_OK)
;;;1772       {
;;;1773         if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
;;;1774         {
;;;1775           __HAL_UART_CLEAR_IDLEFLAG(huart);
;;;1776           ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
;;;1777         }
;;;1778         else
;;;1779         {
;;;1780           /* In case of errors already pending when reception is started,
;;;1781              Interrupts may have already been raised and lead to reception abortion.
;;;1782              (Overrun error for instance).
;;;1783              In such case Reception Type has been reset to HAL_UART_RECEPTION_STANDARD. */
;;;1784           status = HAL_ERROR;
;;;1785         }
;;;1786       }
;;;1787   
;;;1788       return status;
;;;1789     }
;;;1790     else
;;;1791     {
;;;1792       return HAL_BUSY;
;;;1793     }
;;;1794   }
000016  bdf8              POP      {r3-r7,pc}
                  |L11.24|
000018  bf00              NOP                            ;1763
00001a  f894003c          LDRB     r0,[r4,#0x3c]         ;1763
00001e  2801              CMP      r0,#1                 ;1763
000020  d101              BNE      |L11.38|
000022  2002              MOVS     r0,#2                 ;1763
000024  e7f7              B        |L11.22|
                  |L11.38|
000026  2001              MOVS     r0,#1                 ;1763
000028  f884003c          STRB     r0,[r4,#0x3c]         ;1763
00002c  bf00              NOP                            ;1763
00002e  6320              STR      r0,[r4,#0x30]         ;1766
000030  463a              MOV      r2,r7                 ;1768
000032  4631              MOV      r1,r6                 ;1768
000034  4620              MOV      r0,r4                 ;1768
000036  f7fffffe          BL       UART_Start_Receive_IT
00003a  4605              MOV      r5,r0                 ;1768
00003c  b9ed              CBNZ     r5,|L11.122|
00003e  6b20              LDR      r0,[r4,#0x30]         ;1773
000040  2801              CMP      r0,#1                 ;1773
000042  d119              BNE      |L11.120|
000044  bf00              NOP                            ;1775
000046  2000              MOVS     r0,#0                 ;1775
000048  9000              STR      r0,[sp,#0]            ;1775
00004a  6820              LDR      r0,[r4,#0]            ;1775
00004c  6800              LDR      r0,[r0,#0]            ;1775
00004e  9000              STR      r0,[sp,#0]            ;1775
000050  6820              LDR      r0,[r4,#0]            ;1775
000052  6840              LDR      r0,[r0,#4]            ;1775
000054  9000              STR      r0,[sp,#0]            ;1775
000056  bf00              NOP                            ;1775
000058  bf00              NOP                            ;1775
00005a  bf00              NOP                            ;1776
00005c  bf00              NOP                            ;1776
                  |L11.94|
00005e  6821              LDR      r1,[r4,#0]            ;1776
000060  310c              ADDS     r1,r1,#0xc            ;1776
000062  e8511f00          LDREX    r1,[r1,#0]            ;1776
000066  f0410010          ORR      r0,r1,#0x10           ;1776
00006a  6821              LDR      r1,[r4,#0]            ;1776
00006c  310c              ADDS     r1,r1,#0xc            ;1776
00006e  e8410200          STREX    r2,r0,[r1,#0]         ;1776
000072  2a00              CMP      r2,#0                 ;1776
000074  d1f3              BNE      |L11.94|
000076  e000              B        |L11.122|
                  |L11.120|
000078  2501              MOVS     r5,#1                 ;1784
                  |L11.122|
00007a  4628              MOV      r0,r5                 ;1788
00007c  e7cb              B        |L11.22|
                  |L11.126|
00007e  2002              MOVS     r0,#2                 ;1792
000080  e7c9              B        |L11.22|
;;;1795   
                          ENDP


                          AREA ||i.HAL_UARTEx_RxEventCallback||, CODE, READONLY, ALIGN=1

                  HAL_UARTEx_RxEventCallback PROC
;;;2712     */
;;;2713   __weak void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
000000  4770              BX       lr
;;;2714   {
;;;2715     /* Prevent unused argument(s) compilation warning */
;;;2716     UNUSED(huart);
;;;2717     UNUSED(Size);
;;;2718   
;;;2719     /* NOTE : This function should not be modified, when the callback is needed,
;;;2720               the HAL_UARTEx_RxEventCallback can be implemented in the user file.
;;;2721      */
;;;2722   }
;;;2723   
                          ENDP


                          AREA ||i.HAL_UART_Abort||, CODE, READONLY, ALIGN=1

                  HAL_UART_Abort PROC
;;;1868     */
;;;1869   HAL_StatusTypeDef HAL_UART_Abort(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1870   {
000002  4604              MOV      r4,r0
;;;1871     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1872     ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000004  bf00              NOP      
000006  bf00              NOP      
                  |L13.8|
000008  6821              LDR      r1,[r4,#0]
00000a  310c              ADDS     r1,r1,#0xc
00000c  e8511f00          LDREX    r1,[r1,#0]
000010  f42170f0          BIC      r0,r1,#0x1e0
000014  6821              LDR      r1,[r4,#0]
000016  310c              ADDS     r1,r1,#0xc
000018  e8410200          STREX    r2,r0,[r1,#0]
00001c  2a00              CMP      r2,#0
00001e  d1f3              BNE      |L13.8|
000020  bf00              NOP      
;;;1873     ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000022  bf00              NOP      
000024  bf00              NOP      
                  |L13.38|
000026  6821              LDR      r1,[r4,#0]
000028  3114              ADDS     r1,r1,#0x14
00002a  e8511f00          LDREX    r1,[r1,#0]
00002e  f0210001          BIC      r0,r1,#1
000032  6821              LDR      r1,[r4,#0]
000034  3114              ADDS     r1,r1,#0x14
000036  e8410200          STREX    r2,r0,[r1,#0]
00003a  2a00              CMP      r2,#0
00003c  d1f3              BNE      |L13.38|
00003e  bf00              NOP      
;;;1874   
;;;1875     /* If Reception till IDLE event was ongoing, disable IDLEIE interrupt */
;;;1876     if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
000040  6b20              LDR      r0,[r4,#0x30]
000042  2801              CMP      r0,#1
000044  d10e              BNE      |L13.100|
;;;1877     {
;;;1878       ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));
000046  bf00              NOP      
000048  bf00              NOP      
                  |L13.74|
00004a  6821              LDR      r1,[r4,#0]
00004c  310c              ADDS     r1,r1,#0xc
00004e  e8511f00          LDREX    r1,[r1,#0]
000052  f0210010          BIC      r0,r1,#0x10
000056  6821              LDR      r1,[r4,#0]
000058  310c              ADDS     r1,r1,#0xc
00005a  e8410200          STREX    r2,r0,[r1,#0]
00005e  2a00              CMP      r2,#0
000060  d1f3              BNE      |L13.74|
000062  bf00              NOP      
                  |L13.100|
;;;1879     }
;;;1880   
;;;1881     /* Disable the UART DMA Tx request if enabled */
;;;1882     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000064  6820              LDR      r0,[r4,#0]
000066  6940              LDR      r0,[r0,#0x14]
000068  f0000080          AND      r0,r0,#0x80
00006c  2880              CMP      r0,#0x80
00006e  d120              BNE      |L13.178|
;;;1883     {
;;;1884       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000070  bf00              NOP      
000072  bf00              NOP      
                  |L13.116|
000074  6821              LDR      r1,[r4,#0]
000076  3114              ADDS     r1,r1,#0x14
000078  e8511f00          LDREX    r1,[r1,#0]
00007c  f0210080          BIC      r0,r1,#0x80
000080  6821              LDR      r1,[r4,#0]
000082  3114              ADDS     r1,r1,#0x14
000084  e8410200          STREX    r2,r0,[r1,#0]
000088  2a00              CMP      r2,#0
00008a  d1f3              BNE      |L13.116|
00008c  bf00              NOP      
;;;1885   
;;;1886       /* Abort the UART DMA Tx stream: use blocking DMA Abort API (no callback) */
;;;1887       if (huart->hdmatx != NULL)
00008e  6b60              LDR      r0,[r4,#0x34]
000090  b178              CBZ      r0,|L13.178|
;;;1888       {
;;;1889         /* Set the UART DMA Abort callback to Null.
;;;1890            No call back execution at end of DMA abort procedure */
;;;1891         huart->hdmatx->XferAbortCallback = NULL;
000092  2000              MOVS     r0,#0
000094  6b61              LDR      r1,[r4,#0x34]
000096  6508              STR      r0,[r1,#0x50]
;;;1892   
;;;1893         if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)
000098  6b60              LDR      r0,[r4,#0x34]
00009a  f7fffffe          BL       HAL_DMA_Abort
00009e  b140              CBZ      r0,|L13.178|
;;;1894         {
;;;1895           if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
0000a0  6b60              LDR      r0,[r4,#0x34]
0000a2  f7fffffe          BL       HAL_DMA_GetError
0000a6  2820              CMP      r0,#0x20
0000a8  d103              BNE      |L13.178|
;;;1896           {
;;;1897             /* Set error code to DMA */
;;;1898             huart->ErrorCode = HAL_UART_ERROR_DMA;
0000aa  2010              MOVS     r0,#0x10
0000ac  6420              STR      r0,[r4,#0x40]
;;;1899   
;;;1900             return HAL_TIMEOUT;
0000ae  2003              MOVS     r0,#3
                  |L13.176|
;;;1901           }
;;;1902         }
;;;1903       }
;;;1904     }
;;;1905   
;;;1906     /* Disable the UART DMA Rx request if enabled */
;;;1907     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
;;;1908     {
;;;1909       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1910   
;;;1911       /* Abort the UART DMA Rx stream: use blocking DMA Abort API (no callback) */
;;;1912       if (huart->hdmarx != NULL)
;;;1913       {
;;;1914         /* Set the UART DMA Abort callback to Null.
;;;1915            No call back execution at end of DMA abort procedure */
;;;1916         huart->hdmarx->XferAbortCallback = NULL;
;;;1917   
;;;1918         if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)
;;;1919         {
;;;1920           if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
;;;1921           {
;;;1922             /* Set error code to DMA */
;;;1923             huart->ErrorCode = HAL_UART_ERROR_DMA;
;;;1924   
;;;1925             return HAL_TIMEOUT;
;;;1926           }
;;;1927         }
;;;1928       }
;;;1929     }
;;;1930   
;;;1931     /* Reset Tx and Rx transfer counters */
;;;1932     huart->TxXferCount = 0x00U;
;;;1933     huart->RxXferCount = 0x00U;
;;;1934   
;;;1935     /* Reset ErrorCode */
;;;1936     huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1937   
;;;1938     /* Restore huart->RxState and huart->gState to Ready */
;;;1939     huart->RxState = HAL_UART_STATE_READY;
;;;1940     huart->gState = HAL_UART_STATE_READY;
;;;1941     huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;1942   
;;;1943     return HAL_OK;
;;;1944   }
0000b0  bd10              POP      {r4,pc}
                  |L13.178|
0000b2  6820              LDR      r0,[r4,#0]            ;1907
0000b4  6940              LDR      r0,[r0,#0x14]         ;1907
0000b6  f0000040          AND      r0,r0,#0x40           ;1907
0000ba  2840              CMP      r0,#0x40              ;1907
0000bc  d120              BNE      |L13.256|
0000be  bf00              NOP                            ;1909
0000c0  bf00              NOP                            ;1909
                  |L13.194|
0000c2  6821              LDR      r1,[r4,#0]            ;1909
0000c4  3114              ADDS     r1,r1,#0x14           ;1909
0000c6  e8511f00          LDREX    r1,[r1,#0]            ;1909
0000ca  f0210040          BIC      r0,r1,#0x40           ;1909
0000ce  6821              LDR      r1,[r4,#0]            ;1909
0000d0  3114              ADDS     r1,r1,#0x14           ;1909
0000d2  e8410200          STREX    r2,r0,[r1,#0]         ;1909
0000d6  2a00              CMP      r2,#0                 ;1909
0000d8  d1f3              BNE      |L13.194|
0000da  bf00              NOP                            ;1909
0000dc  6ba0              LDR      r0,[r4,#0x38]         ;1912
0000de  b178              CBZ      r0,|L13.256|
0000e0  2000              MOVS     r0,#0                 ;1916
0000e2  6ba1              LDR      r1,[r4,#0x38]         ;1916
0000e4  6508              STR      r0,[r1,#0x50]         ;1916
0000e6  6ba0              LDR      r0,[r4,#0x38]         ;1918
0000e8  f7fffffe          BL       HAL_DMA_Abort
0000ec  b140              CBZ      r0,|L13.256|
0000ee  6ba0              LDR      r0,[r4,#0x38]         ;1920
0000f0  f7fffffe          BL       HAL_DMA_GetError
0000f4  2820              CMP      r0,#0x20              ;1920
0000f6  d103              BNE      |L13.256|
0000f8  2010              MOVS     r0,#0x10              ;1923
0000fa  6420              STR      r0,[r4,#0x40]         ;1923
0000fc  2003              MOVS     r0,#3                 ;1925
0000fe  e7d7              B        |L13.176|
                  |L13.256|
000100  2000              MOVS     r0,#0                 ;1932
000102  84e0              STRH     r0,[r4,#0x26]         ;1932
000104  85e0              STRH     r0,[r4,#0x2e]         ;1933
000106  6420              STR      r0,[r4,#0x40]         ;1936
000108  2020              MOVS     r0,#0x20              ;1939
00010a  f884003e          STRB     r0,[r4,#0x3e]         ;1939
00010e  f884003d          STRB     r0,[r4,#0x3d]         ;1940
000112  2000              MOVS     r0,#0                 ;1941
000114  6320              STR      r0,[r4,#0x30]         ;1941
000116  bf00              NOP                            ;1943
000118  e7ca              B        |L13.176|
;;;1945   
                          ENDP


                          AREA ||i.HAL_UART_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortCpltCallback PROC
;;;2665     */
;;;2666   __weak void HAL_UART_AbortCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2667   {
;;;2668     /* Prevent unused argument(s) compilation warning */
;;;2669     UNUSED(huart);
;;;2670   
;;;2671     /* NOTE : This function should not be modified, when the callback is needed,
;;;2672               the HAL_UART_AbortCpltCallback can be implemented in the user file.
;;;2673      */
;;;2674   }
;;;2675   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceive PROC
;;;2008     */
;;;2009   HAL_StatusTypeDef HAL_UART_AbortReceive(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;2010   {
000002  4604              MOV      r4,r0
;;;2011     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2012     ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  bf00              NOP      
000006  bf00              NOP      
                  |L15.8|
000008  6821              LDR      r1,[r4,#0]
00000a  310c              ADDS     r1,r1,#0xc
00000c  e8511f00          LDREX    r1,[r1,#0]
000010  f4217090          BIC      r0,r1,#0x120
000014  6821              LDR      r1,[r4,#0]
000016  310c              ADDS     r1,r1,#0xc
000018  e8410200          STREX    r2,r0,[r1,#0]
00001c  2a00              CMP      r2,#0
00001e  d1f3              BNE      |L15.8|
000020  bf00              NOP      
;;;2013     ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000022  bf00              NOP      
000024  bf00              NOP      
                  |L15.38|
000026  6821              LDR      r1,[r4,#0]
000028  3114              ADDS     r1,r1,#0x14
00002a  e8511f00          LDREX    r1,[r1,#0]
00002e  f0210001          BIC      r0,r1,#1
000032  6821              LDR      r1,[r4,#0]
000034  3114              ADDS     r1,r1,#0x14
000036  e8410200          STREX    r2,r0,[r1,#0]
00003a  2a00              CMP      r2,#0
00003c  d1f3              BNE      |L15.38|
00003e  bf00              NOP      
;;;2014   
;;;2015     /* If Reception till IDLE event was ongoing, disable IDLEIE interrupt */
;;;2016     if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
000040  6b20              LDR      r0,[r4,#0x30]
000042  2801              CMP      r0,#1
000044  d10e              BNE      |L15.100|
;;;2017     {
;;;2018       ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));
000046  bf00              NOP      
000048  bf00              NOP      
                  |L15.74|
00004a  6821              LDR      r1,[r4,#0]
00004c  310c              ADDS     r1,r1,#0xc
00004e  e8511f00          LDREX    r1,[r1,#0]
000052  f0210010          BIC      r0,r1,#0x10
000056  6821              LDR      r1,[r4,#0]
000058  310c              ADDS     r1,r1,#0xc
00005a  e8410200          STREX    r2,r0,[r1,#0]
00005e  2a00              CMP      r2,#0
000060  d1f3              BNE      |L15.74|
000062  bf00              NOP      
                  |L15.100|
;;;2019     }
;;;2020   
;;;2021     /* Disable the UART DMA Rx request if enabled */
;;;2022     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000064  6820              LDR      r0,[r4,#0]
000066  6940              LDR      r0,[r0,#0x14]
000068  f0000040          AND      r0,r0,#0x40
00006c  2840              CMP      r0,#0x40
00006e  d120              BNE      |L15.178|
;;;2023     {
;;;2024       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000070  bf00              NOP      
000072  bf00              NOP      
                  |L15.116|
000074  6821              LDR      r1,[r4,#0]
000076  3114              ADDS     r1,r1,#0x14
000078  e8511f00          LDREX    r1,[r1,#0]
00007c  f0210040          BIC      r0,r1,#0x40
000080  6821              LDR      r1,[r4,#0]
000082  3114              ADDS     r1,r1,#0x14
000084  e8410200          STREX    r2,r0,[r1,#0]
000088  2a00              CMP      r2,#0
00008a  d1f3              BNE      |L15.116|
00008c  bf00              NOP      
;;;2025   
;;;2026       /* Abort the UART DMA Rx stream : use blocking DMA Abort API (no callback) */
;;;2027       if (huart->hdmarx != NULL)
00008e  6ba0              LDR      r0,[r4,#0x38]
000090  b178              CBZ      r0,|L15.178|
;;;2028       {
;;;2029         /* Set the UART DMA Abort callback to Null.
;;;2030            No call back execution at end of DMA abort procedure */
;;;2031         huart->hdmarx->XferAbortCallback = NULL;
000092  2000              MOVS     r0,#0
000094  6ba1              LDR      r1,[r4,#0x38]
000096  6508              STR      r0,[r1,#0x50]
;;;2032   
;;;2033         if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)
000098  6ba0              LDR      r0,[r4,#0x38]
00009a  f7fffffe          BL       HAL_DMA_Abort
00009e  b140              CBZ      r0,|L15.178|
;;;2034         {
;;;2035           if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
0000a0  6ba0              LDR      r0,[r4,#0x38]
0000a2  f7fffffe          BL       HAL_DMA_GetError
0000a6  2820              CMP      r0,#0x20
0000a8  d103              BNE      |L15.178|
;;;2036           {
;;;2037             /* Set error code to DMA */
;;;2038             huart->ErrorCode = HAL_UART_ERROR_DMA;
0000aa  2010              MOVS     r0,#0x10
0000ac  6420              STR      r0,[r4,#0x40]
;;;2039   
;;;2040             return HAL_TIMEOUT;
0000ae  2003              MOVS     r0,#3
                  |L15.176|
;;;2041           }
;;;2042         }
;;;2043       }
;;;2044     }
;;;2045   
;;;2046     /* Reset Rx transfer counter */
;;;2047     huart->RxXferCount = 0x00U;
;;;2048   
;;;2049     /* Restore huart->RxState to Ready */
;;;2050     huart->RxState = HAL_UART_STATE_READY;
;;;2051     huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;2052   
;;;2053     return HAL_OK;
;;;2054   }
0000b0  bd10              POP      {r4,pc}
                  |L15.178|
0000b2  2000              MOVS     r0,#0                 ;2047
0000b4  85e0              STRH     r0,[r4,#0x2e]         ;2047
0000b6  2020              MOVS     r0,#0x20              ;2050
0000b8  f884003e          STRB     r0,[r4,#0x3e]         ;2050
0000bc  2000              MOVS     r0,#0                 ;2051
0000be  6320              STR      r0,[r4,#0x30]         ;2051
0000c0  bf00              NOP                            ;2053
0000c2  e7f5              B        |L15.176|
;;;2055   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceiveCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceiveCpltCallback PROC
;;;2695     */
;;;2696   __weak void HAL_UART_AbortReceiveCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2697   {
;;;2698     /* Prevent unused argument(s) compilation warning */
;;;2699     UNUSED(huart);
;;;2700   
;;;2701     /* NOTE : This function should not be modified, when the callback is needed,
;;;2702               the HAL_UART_AbortReceiveCpltCallback can be implemented in the user file.
;;;2703      */
;;;2704   }
;;;2705   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortReceive_IT PROC
;;;2281     */
;;;2282   HAL_StatusTypeDef HAL_UART_AbortReceive_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;2283   {
000002  4604              MOV      r4,r0
;;;2284     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2285     ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  bf00              NOP      
000006  bf00              NOP      
                  |L17.8|
000008  6821              LDR      r1,[r4,#0]
00000a  310c              ADDS     r1,r1,#0xc
00000c  e8511f00          LDREX    r1,[r1,#0]
000010  f4217090          BIC      r0,r1,#0x120
000014  6821              LDR      r1,[r4,#0]
000016  310c              ADDS     r1,r1,#0xc
000018  e8410200          STREX    r2,r0,[r1,#0]
00001c  2a00              CMP      r2,#0
00001e  d1f3              BNE      |L17.8|
000020  bf00              NOP      
;;;2286     ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000022  bf00              NOP      
000024  bf00              NOP      
                  |L17.38|
000026  6821              LDR      r1,[r4,#0]
000028  3114              ADDS     r1,r1,#0x14
00002a  e8511f00          LDREX    r1,[r1,#0]
00002e  f0210001          BIC      r0,r1,#1
000032  6821              LDR      r1,[r4,#0]
000034  3114              ADDS     r1,r1,#0x14
000036  e8410200          STREX    r2,r0,[r1,#0]
00003a  2a00              CMP      r2,#0
00003c  d1f3              BNE      |L17.38|
00003e  bf00              NOP      
;;;2287   
;;;2288     /* If Reception till IDLE event was ongoing, disable IDLEIE interrupt */
;;;2289     if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
000040  6b20              LDR      r0,[r4,#0x30]
000042  2801              CMP      r0,#1
000044  d10e              BNE      |L17.100|
;;;2290     {
;;;2291       ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));
000046  bf00              NOP      
000048  bf00              NOP      
                  |L17.74|
00004a  6821              LDR      r1,[r4,#0]
00004c  310c              ADDS     r1,r1,#0xc
00004e  e8511f00          LDREX    r1,[r1,#0]
000052  f0210010          BIC      r0,r1,#0x10
000056  6821              LDR      r1,[r4,#0]
000058  310c              ADDS     r1,r1,#0xc
00005a  e8410200          STREX    r2,r0,[r1,#0]
00005e  2a00              CMP      r2,#0
000060  d1f3              BNE      |L17.74|
000062  bf00              NOP      
                  |L17.100|
;;;2292     }
;;;2293   
;;;2294     /* Disable the UART DMA Rx request if enabled */
;;;2295     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000064  6820              LDR      r0,[r4,#0]
000066  6940              LDR      r0,[r0,#0x14]
000068  f0000040          AND      r0,r0,#0x40
00006c  2840              CMP      r0,#0x40
00006e  d126              BNE      |L17.190|
;;;2296     {
;;;2297       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000070  bf00              NOP      
000072  bf00              NOP      
                  |L17.116|
000074  6821              LDR      r1,[r4,#0]
000076  3114              ADDS     r1,r1,#0x14
000078  e8511f00          LDREX    r1,[r1,#0]
00007c  f0210040          BIC      r0,r1,#0x40
000080  6821              LDR      r1,[r4,#0]
000082  3114              ADDS     r1,r1,#0x14
000084  e8410200          STREX    r2,r0,[r1,#0]
000088  2a00              CMP      r2,#0
00008a  d1f3              BNE      |L17.116|
00008c  bf00              NOP      
;;;2298   
;;;2299       /* Abort the UART DMA Rx stream : use blocking DMA Abort API (no callback) */
;;;2300       if (huart->hdmarx != NULL)
00008e  6ba0              LDR      r0,[r4,#0x38]
000090  b150              CBZ      r0,|L17.168|
;;;2301       {
;;;2302         /* Set the UART DMA Abort callback :
;;;2303            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;2304         huart->hdmarx->XferAbortCallback = UART_DMARxOnlyAbortCallback;
000092  4811              LDR      r0,|L17.216|
000094  6ba1              LDR      r1,[r4,#0x38]
000096  6508              STR      r0,[r1,#0x50]
;;;2305   
;;;2306         /* Abort DMA RX */
;;;2307         if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
000098  6ba0              LDR      r0,[r4,#0x38]
00009a  f7fffffe          BL       HAL_DMA_Abort_IT
00009e  b1c0              CBZ      r0,|L17.210|
;;;2308         {
;;;2309           /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
;;;2310           huart->hdmarx->XferAbortCallback(huart->hdmarx);
0000a0  6ba0              LDR      r0,[r4,#0x38]
0000a2  6d01              LDR      r1,[r0,#0x50]
0000a4  4788              BLX      r1
0000a6  e014              B        |L17.210|
                  |L17.168|
;;;2311         }
;;;2312       }
;;;2313       else
;;;2314       {
;;;2315         /* Reset Rx transfer counter */
;;;2316         huart->RxXferCount = 0x00U;
0000a8  2000              MOVS     r0,#0
0000aa  85e0              STRH     r0,[r4,#0x2e]
;;;2317   
;;;2318         /* Restore huart->RxState to Ready */
;;;2319         huart->RxState = HAL_UART_STATE_READY;
0000ac  2020              MOVS     r0,#0x20
0000ae  f884003e          STRB     r0,[r4,#0x3e]
;;;2320         huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
0000b2  2000              MOVS     r0,#0
0000b4  6320              STR      r0,[r4,#0x30]
;;;2321   
;;;2322         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2323   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2324         /* Call registered Abort Receive Complete Callback */
;;;2325         huart->AbortReceiveCpltCallback(huart);
;;;2326   #else
;;;2327         /* Call legacy weak Abort Receive Complete Callback */
;;;2328         HAL_UART_AbortReceiveCpltCallback(huart);
0000b6  4620              MOV      r0,r4
0000b8  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
0000bc  e009              B        |L17.210|
                  |L17.190|
;;;2329   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2330       }
;;;2331     }
;;;2332     else
;;;2333     {
;;;2334       /* Reset Rx transfer counter */
;;;2335       huart->RxXferCount = 0x00U;
0000be  2000              MOVS     r0,#0
0000c0  85e0              STRH     r0,[r4,#0x2e]
;;;2336   
;;;2337       /* Restore huart->RxState to Ready */
;;;2338       huart->RxState = HAL_UART_STATE_READY;
0000c2  2020              MOVS     r0,#0x20
0000c4  f884003e          STRB     r0,[r4,#0x3e]
;;;2339       huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
0000c8  2000              MOVS     r0,#0
0000ca  6320              STR      r0,[r4,#0x30]
;;;2340   
;;;2341       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2342   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2343       /* Call registered Abort Receive Complete Callback */
;;;2344       huart->AbortReceiveCpltCallback(huart);
;;;2345   #else
;;;2346       /* Call legacy weak Abort Receive Complete Callback */
;;;2347       HAL_UART_AbortReceiveCpltCallback(huart);
0000cc  4620              MOV      r0,r4
0000ce  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
                  |L17.210|
;;;2348   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2349     }
;;;2350   
;;;2351     return HAL_OK;
0000d2  2000              MOVS     r0,#0
;;;2352   }
0000d4  bd10              POP      {r4,pc}
;;;2353   
                          ENDP

0000d6  0000              DCW      0x0000
                  |L17.216|
                          DCD      UART_DMARxOnlyAbortCallback

                          AREA ||i.HAL_UART_AbortTransmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmit PROC
;;;1957     */
;;;1958   HAL_StatusTypeDef HAL_UART_AbortTransmit(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1959   {
000002  4604              MOV      r4,r0
;;;1960     /* Disable TXEIE and TCIE interrupts */
;;;1961     ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  bf00              NOP      
000006  bf00              NOP      
                  |L18.8|
000008  6821              LDR      r1,[r4,#0]
00000a  310c              ADDS     r1,r1,#0xc
00000c  e8511f00          LDREX    r1,[r1,#0]
000010  f02100c0          BIC      r0,r1,#0xc0
000014  6821              LDR      r1,[r4,#0]
000016  310c              ADDS     r1,r1,#0xc
000018  e8410200          STREX    r2,r0,[r1,#0]
00001c  2a00              CMP      r2,#0
00001e  d1f3              BNE      |L18.8|
000020  bf00              NOP      
;;;1962   
;;;1963     /* Disable the UART DMA Tx request if enabled */
;;;1964     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000022  6820              LDR      r0,[r4,#0]
000024  6940              LDR      r0,[r0,#0x14]
000026  f0000080          AND      r0,r0,#0x80
00002a  2880              CMP      r0,#0x80
00002c  d120              BNE      |L18.112|
;;;1965     {
;;;1966       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00002e  bf00              NOP      
000030  bf00              NOP      
                  |L18.50|
000032  6821              LDR      r1,[r4,#0]
000034  3114              ADDS     r1,r1,#0x14
000036  e8511f00          LDREX    r1,[r1,#0]
00003a  f0210080          BIC      r0,r1,#0x80
00003e  6821              LDR      r1,[r4,#0]
000040  3114              ADDS     r1,r1,#0x14
000042  e8410200          STREX    r2,r0,[r1,#0]
000046  2a00              CMP      r2,#0
000048  d1f3              BNE      |L18.50|
00004a  bf00              NOP      
;;;1967   
;;;1968       /* Abort the UART DMA Tx stream : use blocking DMA Abort API (no callback) */
;;;1969       if (huart->hdmatx != NULL)
00004c  6b60              LDR      r0,[r4,#0x34]
00004e  b178              CBZ      r0,|L18.112|
;;;1970       {
;;;1971         /* Set the UART DMA Abort callback to Null.
;;;1972            No call back execution at end of DMA abort procedure */
;;;1973         huart->hdmatx->XferAbortCallback = NULL;
000050  2000              MOVS     r0,#0
000052  6b61              LDR      r1,[r4,#0x34]
000054  6508              STR      r0,[r1,#0x50]
;;;1974   
;;;1975         if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)
000056  6b60              LDR      r0,[r4,#0x34]
000058  f7fffffe          BL       HAL_DMA_Abort
00005c  b140              CBZ      r0,|L18.112|
;;;1976         {
;;;1977           if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
00005e  6b60              LDR      r0,[r4,#0x34]
000060  f7fffffe          BL       HAL_DMA_GetError
000064  2820              CMP      r0,#0x20
000066  d103              BNE      |L18.112|
;;;1978           {
;;;1979             /* Set error code to DMA */
;;;1980             huart->ErrorCode = HAL_UART_ERROR_DMA;
000068  2010              MOVS     r0,#0x10
00006a  6420              STR      r0,[r4,#0x40]
;;;1981   
;;;1982             return HAL_TIMEOUT;
00006c  2003              MOVS     r0,#3
                  |L18.110|
;;;1983           }
;;;1984         }
;;;1985       }
;;;1986     }
;;;1987   
;;;1988     /* Reset Tx transfer counter */
;;;1989     huart->TxXferCount = 0x00U;
;;;1990   
;;;1991     /* Restore huart->gState to Ready */
;;;1992     huart->gState = HAL_UART_STATE_READY;
;;;1993   
;;;1994     return HAL_OK;
;;;1995   }
00006e  bd10              POP      {r4,pc}
                  |L18.112|
000070  2000              MOVS     r0,#0                 ;1989
000072  84e0              STRH     r0,[r4,#0x26]         ;1989
000074  2020              MOVS     r0,#0x20              ;1992
000076  f884003d          STRB     r0,[r4,#0x3d]         ;1992
00007a  2000              MOVS     r0,#0                 ;1994
00007c  e7f7              B        |L18.110|
;;;1996   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmitCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmitCpltCallback PROC
;;;2680     */
;;;2681   __weak void HAL_UART_AbortTransmitCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2682   {
;;;2683     /* Prevent unused argument(s) compilation warning */
;;;2684     UNUSED(huart);
;;;2685   
;;;2686     /* NOTE : This function should not be modified, when the callback is needed,
;;;2687               the HAL_UART_AbortTransmitCpltCallback can be implemented in the user file.
;;;2688      */
;;;2689   }
;;;2690   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortTransmit_IT PROC
;;;2204     */
;;;2205   HAL_StatusTypeDef HAL_UART_AbortTransmit_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;2206   {
000002  4604              MOV      r4,r0
;;;2207     /* Disable TXEIE and TCIE interrupts */
;;;2208     ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  bf00              NOP      
000006  bf00              NOP      
                  |L20.8|
000008  6821              LDR      r1,[r4,#0]
00000a  310c              ADDS     r1,r1,#0xc
00000c  e8511f00          LDREX    r1,[r1,#0]
000010  f02100c0          BIC      r0,r1,#0xc0
000014  6821              LDR      r1,[r4,#0]
000016  310c              ADDS     r1,r1,#0xc
000018  e8410200          STREX    r2,r0,[r1,#0]
00001c  2a00              CMP      r2,#0
00001e  d1f3              BNE      |L20.8|
000020  bf00              NOP      
;;;2209   
;;;2210     /* Disable the UART DMA Tx request if enabled */
;;;2211     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000022  6820              LDR      r0,[r4,#0]
000024  6940              LDR      r0,[r0,#0x14]
000026  f0000080          AND      r0,r0,#0x80
00002a  2880              CMP      r0,#0x80
00002c  d124              BNE      |L20.120|
;;;2212     {
;;;2213       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00002e  bf00              NOP      
000030  bf00              NOP      
                  |L20.50|
000032  6821              LDR      r1,[r4,#0]
000034  3114              ADDS     r1,r1,#0x14
000036  e8511f00          LDREX    r1,[r1,#0]
00003a  f0210080          BIC      r0,r1,#0x80
00003e  6821              LDR      r1,[r4,#0]
000040  3114              ADDS     r1,r1,#0x14
000042  e8410200          STREX    r2,r0,[r1,#0]
000046  2a00              CMP      r2,#0
000048  d1f3              BNE      |L20.50|
00004a  bf00              NOP      
;;;2214   
;;;2215       /* Abort the UART DMA Tx stream : use blocking DMA Abort API (no callback) */
;;;2216       if (huart->hdmatx != NULL)
00004c  6b60              LDR      r0,[r4,#0x34]
00004e  b150              CBZ      r0,|L20.102|
;;;2217       {
;;;2218         /* Set the UART DMA Abort callback :
;;;2219            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;2220         huart->hdmatx->XferAbortCallback = UART_DMATxOnlyAbortCallback;
000050  480e              LDR      r0,|L20.140|
000052  6b61              LDR      r1,[r4,#0x34]
000054  6508              STR      r0,[r1,#0x50]
;;;2221   
;;;2222         /* Abort DMA TX */
;;;2223         if (HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
000056  6b60              LDR      r0,[r4,#0x34]
000058  f7fffffe          BL       HAL_DMA_Abort_IT
00005c  b1a0              CBZ      r0,|L20.136|
;;;2224         {
;;;2225           /* Call Directly huart->hdmatx->XferAbortCallback function in case of error */
;;;2226           huart->hdmatx->XferAbortCallback(huart->hdmatx);
00005e  6b60              LDR      r0,[r4,#0x34]
000060  6d01              LDR      r1,[r0,#0x50]
000062  4788              BLX      r1
000064  e010              B        |L20.136|
                  |L20.102|
;;;2227         }
;;;2228       }
;;;2229       else
;;;2230       {
;;;2231         /* Reset Tx transfer counter */
;;;2232         huart->TxXferCount = 0x00U;
000066  2000              MOVS     r0,#0
000068  84e0              STRH     r0,[r4,#0x26]
;;;2233   
;;;2234         /* Restore huart->gState to Ready */
;;;2235         huart->gState = HAL_UART_STATE_READY;
00006a  2020              MOVS     r0,#0x20
00006c  f884003d          STRB     r0,[r4,#0x3d]
;;;2236   
;;;2237         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2238   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2239         /* Call registered Abort Transmit Complete Callback */
;;;2240         huart->AbortTransmitCpltCallback(huart);
;;;2241   #else
;;;2242         /* Call legacy weak Abort Transmit Complete Callback */
;;;2243         HAL_UART_AbortTransmitCpltCallback(huart);
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
000076  e007              B        |L20.136|
                  |L20.120|
;;;2244   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2245       }
;;;2246     }
;;;2247     else
;;;2248     {
;;;2249       /* Reset Tx transfer counter */
;;;2250       huart->TxXferCount = 0x00U;
000078  2000              MOVS     r0,#0
00007a  84e0              STRH     r0,[r4,#0x26]
;;;2251   
;;;2252       /* Restore huart->gState to Ready */
;;;2253       huart->gState = HAL_UART_STATE_READY;
00007c  2020              MOVS     r0,#0x20
00007e  f884003d          STRB     r0,[r4,#0x3d]
;;;2254   
;;;2255       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2256   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2257       /* Call registered Abort Transmit Complete Callback */
;;;2258       huart->AbortTransmitCpltCallback(huart);
;;;2259   #else
;;;2260       /* Call legacy weak Abort Transmit Complete Callback */
;;;2261       HAL_UART_AbortTransmitCpltCallback(huart);
000082  4620              MOV      r0,r4
000084  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
                  |L20.136|
;;;2262   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2263     }
;;;2264   
;;;2265     return HAL_OK;
000088  2000              MOVS     r0,#0
;;;2266   }
00008a  bd10              POP      {r4,pc}
;;;2267   
                          ENDP

                  |L20.140|
                          DCD      UART_DMATxOnlyAbortCallback

                          AREA ||i.HAL_UART_Abort_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_Abort_IT PROC
;;;2069     */
;;;2070   HAL_StatusTypeDef HAL_UART_Abort_IT(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;2071   {
000002  4604              MOV      r4,r0
;;;2072     uint32_t AbortCplt = 0x01U;
000004  2501              MOVS     r5,#1
;;;2073   
;;;2074     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2075     ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000006  bf00              NOP      
000008  bf00              NOP      
                  |L21.10|
00000a  6821              LDR      r1,[r4,#0]
00000c  310c              ADDS     r1,r1,#0xc
00000e  e8511f00          LDREX    r1,[r1,#0]
000012  f42170f0          BIC      r0,r1,#0x1e0
000016  6821              LDR      r1,[r4,#0]
000018  310c              ADDS     r1,r1,#0xc
00001a  e8410200          STREX    r2,r0,[r1,#0]
00001e  2a00              CMP      r2,#0
000020  d1f3              BNE      |L21.10|
000022  bf00              NOP      
;;;2076     ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000024  bf00              NOP      
000026  bf00              NOP      
                  |L21.40|
000028  6821              LDR      r1,[r4,#0]
00002a  3114              ADDS     r1,r1,#0x14
00002c  e8511f00          LDREX    r1,[r1,#0]
000030  f0210001          BIC      r0,r1,#1
000034  6821              LDR      r1,[r4,#0]
000036  3114              ADDS     r1,r1,#0x14
000038  e8410200          STREX    r2,r0,[r1,#0]
00003c  2a00              CMP      r2,#0
00003e  d1f3              BNE      |L21.40|
000040  bf00              NOP      
;;;2077   
;;;2078     /* If Reception till IDLE event was ongoing, disable IDLEIE interrupt */
;;;2079     if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
000042  6b20              LDR      r0,[r4,#0x30]
000044  2801              CMP      r0,#1
000046  d10e              BNE      |L21.102|
;;;2080     {
;;;2081       ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));
000048  bf00              NOP      
00004a  bf00              NOP      
                  |L21.76|
00004c  6821              LDR      r1,[r4,#0]
00004e  310c              ADDS     r1,r1,#0xc
000050  e8511f00          LDREX    r1,[r1,#0]
000054  f0210010          BIC      r0,r1,#0x10
000058  6821              LDR      r1,[r4,#0]
00005a  310c              ADDS     r1,r1,#0xc
00005c  e8410200          STREX    r2,r0,[r1,#0]
000060  2a00              CMP      r2,#0
000062  d1f3              BNE      |L21.76|
000064  bf00              NOP      
                  |L21.102|
;;;2082     }
;;;2083   
;;;2084     /* If DMA Tx and/or DMA Rx Handles are associated to UART Handle, DMA Abort complete callbacks should be initialised
;;;2085        before any call to DMA Abort functions */
;;;2086     /* DMA Tx Handle is valid */
;;;2087     if (huart->hdmatx != NULL)
000066  6b60              LDR      r0,[r4,#0x34]
000068  b160              CBZ      r0,|L21.132|
;;;2088     {
;;;2089       /* Set DMA Abort Complete callback if UART DMA Tx request if enabled.
;;;2090          Otherwise, set it to NULL */
;;;2091       if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00006a  6820              LDR      r0,[r4,#0]
00006c  6940              LDR      r0,[r0,#0x14]
00006e  f0000080          AND      r0,r0,#0x80
000072  2880              CMP      r0,#0x80
000074  d103              BNE      |L21.126|
;;;2092       {
;;;2093         huart->hdmatx->XferAbortCallback = UART_DMATxAbortCallback;
000076  4834              LDR      r0,|L21.328|
000078  6b61              LDR      r1,[r4,#0x34]
00007a  6508              STR      r0,[r1,#0x50]
00007c  e002              B        |L21.132|
                  |L21.126|
;;;2094       }
;;;2095       else
;;;2096       {
;;;2097         huart->hdmatx->XferAbortCallback = NULL;
00007e  2000              MOVS     r0,#0
000080  6b61              LDR      r1,[r4,#0x34]
000082  6508              STR      r0,[r1,#0x50]
                  |L21.132|
;;;2098       }
;;;2099     }
;;;2100     /* DMA Rx Handle is valid */
;;;2101     if (huart->hdmarx != NULL)
000084  6ba0              LDR      r0,[r4,#0x38]
000086  b160              CBZ      r0,|L21.162|
;;;2102     {
;;;2103       /* Set DMA Abort Complete callback if UART DMA Rx request if enabled.
;;;2104          Otherwise, set it to NULL */
;;;2105       if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000088  6820              LDR      r0,[r4,#0]
00008a  6940              LDR      r0,[r0,#0x14]
00008c  f0000040          AND      r0,r0,#0x40
000090  2840              CMP      r0,#0x40
000092  d103              BNE      |L21.156|
;;;2106       {
;;;2107         huart->hdmarx->XferAbortCallback = UART_DMARxAbortCallback;
000094  482d              LDR      r0,|L21.332|
000096  6ba1              LDR      r1,[r4,#0x38]
000098  6508              STR      r0,[r1,#0x50]
00009a  e002              B        |L21.162|
                  |L21.156|
;;;2108       }
;;;2109       else
;;;2110       {
;;;2111         huart->hdmarx->XferAbortCallback = NULL;
00009c  2000              MOVS     r0,#0
00009e  6ba1              LDR      r1,[r4,#0x38]
0000a0  6508              STR      r0,[r1,#0x50]
                  |L21.162|
;;;2112       }
;;;2113     }
;;;2114   
;;;2115     /* Disable the UART DMA Tx request if enabled */
;;;2116     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
0000a2  6820              LDR      r0,[r4,#0]
0000a4  6940              LDR      r0,[r0,#0x14]
0000a6  f0000080          AND      r0,r0,#0x80
0000aa  2880              CMP      r0,#0x80
0000ac  d119              BNE      |L21.226|
;;;2117     {
;;;2118       /* Disable DMA Tx at UART level */
;;;2119       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
0000ae  bf00              NOP      
0000b0  bf00              NOP      
                  |L21.178|
0000b2  6821              LDR      r1,[r4,#0]
0000b4  3114              ADDS     r1,r1,#0x14
0000b6  e8511f00          LDREX    r1,[r1,#0]
0000ba  f0210080          BIC      r0,r1,#0x80
0000be  6821              LDR      r1,[r4,#0]
0000c0  3114              ADDS     r1,r1,#0x14
0000c2  e8410200          STREX    r2,r0,[r1,#0]
0000c6  2a00              CMP      r2,#0
0000c8  d1f3              BNE      |L21.178|
0000ca  bf00              NOP      
;;;2120   
;;;2121       /* Abort the UART DMA Tx stream : use non blocking DMA Abort API (callback) */
;;;2122       if (huart->hdmatx != NULL)
0000cc  6b60              LDR      r0,[r4,#0x34]
0000ce  b140              CBZ      r0,|L21.226|
;;;2123       {
;;;2124         /* UART Tx DMA Abort callback has already been initialised :
;;;2125            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;2126   
;;;2127         /* Abort DMA TX */
;;;2128         if (HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
0000d0  6b60              LDR      r0,[r4,#0x34]
0000d2  f7fffffe          BL       HAL_DMA_Abort_IT
0000d6  b118              CBZ      r0,|L21.224|
;;;2129         {
;;;2130           huart->hdmatx->XferAbortCallback = NULL;
0000d8  2000              MOVS     r0,#0
0000da  6b61              LDR      r1,[r4,#0x34]
0000dc  6508              STR      r0,[r1,#0x50]
0000de  e000              B        |L21.226|
                  |L21.224|
;;;2131         }
;;;2132         else
;;;2133         {
;;;2134           AbortCplt = 0x00U;
0000e0  2500              MOVS     r5,#0
                  |L21.226|
;;;2135         }
;;;2136       }
;;;2137     }
;;;2138   
;;;2139     /* Disable the UART DMA Rx request if enabled */
;;;2140     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
0000e2  6820              LDR      r0,[r4,#0]
0000e4  6940              LDR      r0,[r0,#0x14]
0000e6  f0000040          AND      r0,r0,#0x40
0000ea  2840              CMP      r0,#0x40
0000ec  d11a              BNE      |L21.292|
;;;2141     {
;;;2142       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
0000ee  bf00              NOP      
0000f0  bf00              NOP      
                  |L21.242|
0000f2  6821              LDR      r1,[r4,#0]
0000f4  3114              ADDS     r1,r1,#0x14
0000f6  e8511f00          LDREX    r1,[r1,#0]
0000fa  f0210040          BIC      r0,r1,#0x40
0000fe  6821              LDR      r1,[r4,#0]
000100  3114              ADDS     r1,r1,#0x14
000102  e8410200          STREX    r2,r0,[r1,#0]
000106  2a00              CMP      r2,#0
000108  d1f3              BNE      |L21.242|
00010a  bf00              NOP      
;;;2143   
;;;2144       /* Abort the UART DMA Rx stream : use non blocking DMA Abort API (callback) */
;;;2145       if (huart->hdmarx != NULL)
00010c  6ba0              LDR      r0,[r4,#0x38]
00010e  b148              CBZ      r0,|L21.292|
;;;2146       {
;;;2147         /* UART Rx DMA Abort callback has already been initialised :
;;;2148            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;2149   
;;;2150         /* Abort DMA RX */
;;;2151         if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
000110  6ba0              LDR      r0,[r4,#0x38]
000112  f7fffffe          BL       HAL_DMA_Abort_IT
000116  b120              CBZ      r0,|L21.290|
;;;2152         {
;;;2153           huart->hdmarx->XferAbortCallback = NULL;
000118  2000              MOVS     r0,#0
00011a  6ba1              LDR      r1,[r4,#0x38]
00011c  6508              STR      r0,[r1,#0x50]
;;;2154           AbortCplt = 0x01U;
00011e  2501              MOVS     r5,#1
000120  e000              B        |L21.292|
                  |L21.290|
;;;2155         }
;;;2156         else
;;;2157         {
;;;2158           AbortCplt = 0x00U;
000122  2500              MOVS     r5,#0
                  |L21.292|
;;;2159         }
;;;2160       }
;;;2161     }
;;;2162   
;;;2163     /* if no DMA abort complete callback execution is required => call user Abort Complete callback */
;;;2164     if (AbortCplt == 0x01U)
000124  2d01              CMP      r5,#1
000126  d10d              BNE      |L21.324|
;;;2165     {
;;;2166       /* Reset Tx and Rx transfer counters */
;;;2167       huart->TxXferCount = 0x00U;
000128  2000              MOVS     r0,#0
00012a  84e0              STRH     r0,[r4,#0x26]
;;;2168       huart->RxXferCount = 0x00U;
00012c  85e0              STRH     r0,[r4,#0x2e]
;;;2169   
;;;2170       /* Reset ErrorCode */
;;;2171       huart->ErrorCode = HAL_UART_ERROR_NONE;
00012e  6420              STR      r0,[r4,#0x40]
;;;2172   
;;;2173       /* Restore huart->gState and huart->RxState to Ready */
;;;2174       huart->gState  = HAL_UART_STATE_READY;
000130  2020              MOVS     r0,#0x20
000132  f884003d          STRB     r0,[r4,#0x3d]
;;;2175       huart->RxState = HAL_UART_STATE_READY;
000136  f884003e          STRB     r0,[r4,#0x3e]
;;;2176       huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
00013a  2000              MOVS     r0,#0
00013c  6320              STR      r0,[r4,#0x30]
;;;2177   
;;;2178       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2179   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2180       /* Call registered Abort complete callback */
;;;2181       huart->AbortCpltCallback(huart);
;;;2182   #else
;;;2183       /* Call legacy weak Abort complete callback */
;;;2184       HAL_UART_AbortCpltCallback(huart);
00013e  4620              MOV      r0,r4
000140  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L21.324|
;;;2185   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2186     }
;;;2187   
;;;2188     return HAL_OK;
000144  2000              MOVS     r0,#0
;;;2189   }
000146  bd70              POP      {r4-r6,pc}
;;;2190   
                          ENDP

                  |L21.328|
                          DCD      UART_DMATxAbortCallback
                  |L21.332|
                          DCD      UART_DMARxAbortCallback

                          AREA ||i.HAL_UART_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAPause PROC
;;;1492     */
;;;1493   HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1494   {
000002  4601              MOV      r1,r0
;;;1495     uint32_t dmarequest = 0x00U;
000004  2200              MOVS     r2,#0
;;;1496   
;;;1497     /* Process Locked */
;;;1498     __HAL_LOCK(huart);
000006  bf00              NOP      
000008  f891003c          LDRB     r0,[r1,#0x3c]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L22.20|
000010  2002              MOVS     r0,#2
                  |L22.18|
;;;1499   
;;;1500     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
;;;1501     if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
;;;1502     {
;;;1503       /* Disable the UART DMA Tx request */
;;;1504       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1505     }
;;;1506   
;;;1507     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
;;;1508     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
;;;1509     {
;;;1510       /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1511       ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1512       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1513   
;;;1514       /* Disable the UART DMA Rx request */
;;;1515       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1516     }
;;;1517   
;;;1518     /* Process Unlocked */
;;;1519     __HAL_UNLOCK(huart);
;;;1520   
;;;1521     return HAL_OK;
;;;1522   }
000012  bd10              POP      {r4,pc}
                  |L22.20|
000014  2001              MOVS     r0,#1                 ;1498
000016  f881003c          STRB     r0,[r1,#0x3c]         ;1498
00001a  bf00              NOP                            ;1498
00001c  6808              LDR      r0,[r1,#0]            ;1500
00001e  6940              LDR      r0,[r0,#0x14]         ;1500
000020  f3c012c0          UBFX     r2,r0,#7,#1           ;1500
000024  f891003d          LDRB     r0,[r1,#0x3d]         ;1501
000028  2821              CMP      r0,#0x21              ;1501
00002a  d10f              BNE      |L22.76|
00002c  b172              CBZ      r2,|L22.76|
00002e  bf00              NOP                            ;1504
000030  bf00              NOP                            ;1504
                  |L22.50|
000032  680b              LDR      r3,[r1,#0]            ;1504
000034  3314              ADDS     r3,r3,#0x14           ;1504
000036  e8533f00          LDREX    r3,[r3,#0]            ;1504
00003a  f0230080          BIC      r0,r3,#0x80           ;1504
00003e  680b              LDR      r3,[r1,#0]            ;1504
000040  3314              ADDS     r3,r3,#0x14           ;1504
000042  e8430400          STREX    r4,r0,[r3,#0]         ;1504
000046  2c00              CMP      r4,#0                 ;1504
000048  d1f3              BNE      |L22.50|
00004a  bf00              NOP                            ;1504
                  |L22.76|
00004c  6808              LDR      r0,[r1,#0]            ;1507
00004e  6940              LDR      r0,[r0,#0x14]         ;1507
000050  f3c01280          UBFX     r2,r0,#6,#1           ;1507
000054  f891003e          LDRB     r0,[r1,#0x3e]         ;1508
000058  2822              CMP      r0,#0x22              ;1508
00005a  d12d              BNE      |L22.184|
00005c  b362              CBZ      r2,|L22.184|
00005e  bf00              NOP                            ;1511
000060  bf00              NOP                            ;1511
                  |L22.98|
000062  680b              LDR      r3,[r1,#0]            ;1511
000064  330c              ADDS     r3,r3,#0xc            ;1511
000066  e8533f00          LDREX    r3,[r3,#0]            ;1511
00006a  f4237080          BIC      r0,r3,#0x100          ;1511
00006e  680b              LDR      r3,[r1,#0]            ;1511
000070  330c              ADDS     r3,r3,#0xc            ;1511
000072  e8430400          STREX    r4,r0,[r3,#0]         ;1511
000076  2c00              CMP      r4,#0                 ;1511
000078  d1f3              BNE      |L22.98|
00007a  bf00              NOP                            ;1511
00007c  bf00              NOP                            ;1512
00007e  bf00              NOP                            ;1512
                  |L22.128|
000080  680b              LDR      r3,[r1,#0]            ;1512
000082  3314              ADDS     r3,r3,#0x14           ;1512
000084  e8533f00          LDREX    r3,[r3,#0]            ;1512
000088  f0230001          BIC      r0,r3,#1              ;1512
00008c  680b              LDR      r3,[r1,#0]            ;1512
00008e  3314              ADDS     r3,r3,#0x14           ;1512
000090  e8430400          STREX    r4,r0,[r3,#0]         ;1512
000094  2c00              CMP      r4,#0                 ;1512
000096  d1f3              BNE      |L22.128|
000098  bf00              NOP                            ;1512
00009a  bf00              NOP                            ;1515
00009c  bf00              NOP                            ;1515
                  |L22.158|
00009e  680b              LDR      r3,[r1,#0]            ;1515
0000a0  3314              ADDS     r3,r3,#0x14           ;1515
0000a2  e8533f00          LDREX    r3,[r3,#0]            ;1515
0000a6  f0230040          BIC      r0,r3,#0x40           ;1515
0000aa  680b              LDR      r3,[r1,#0]            ;1515
0000ac  3314              ADDS     r3,r3,#0x14           ;1515
0000ae  e8430400          STREX    r4,r0,[r3,#0]         ;1515
0000b2  2c00              CMP      r4,#0                 ;1515
0000b4  d1f3              BNE      |L22.158|
0000b6  bf00              NOP                            ;1515
                  |L22.184|
0000b8  bf00              NOP                            ;1519
0000ba  2000              MOVS     r0,#0                 ;1519
0000bc  f881003c          STRB     r0,[r1,#0x3c]         ;1519
0000c0  bf00              NOP                            ;1519
0000c2  bf00              NOP                            ;1521
0000c4  e7a5              B        |L22.18|
;;;1523   
                          ENDP


                          AREA ||i.HAL_UART_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAResume PROC
;;;1529     */
;;;1530   HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
000000  b508              PUSH     {r3,lr}
;;;1531   {
000002  4601              MOV      r1,r0
;;;1532     /* Process Locked */
;;;1533     __HAL_LOCK(huart);
000004  bf00              NOP      
000006  f891003c          LDRB     r0,[r1,#0x3c]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L23.18|
00000e  2002              MOVS     r0,#2
                  |L23.16|
;;;1534   
;;;1535     if (huart->gState == HAL_UART_STATE_BUSY_TX)
;;;1536     {
;;;1537       /* Enable the UART DMA Tx request */
;;;1538       ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1539     }
;;;1540   
;;;1541     if (huart->RxState == HAL_UART_STATE_BUSY_RX)
;;;1542     {
;;;1543       /* Clear the Overrun flag before resuming the Rx transfer*/
;;;1544       __HAL_UART_CLEAR_OREFLAG(huart);
;;;1545   
;;;1546       /* Re-enable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1547       if (huart->Init.Parity != UART_PARITY_NONE)
;;;1548       {
;;;1549         ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1550       }
;;;1551       ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1552   
;;;1553       /* Enable the UART DMA Rx request */
;;;1554       ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1555     }
;;;1556   
;;;1557     /* Process Unlocked */
;;;1558     __HAL_UNLOCK(huart);
;;;1559   
;;;1560     return HAL_OK;
;;;1561   }
000010  bd08              POP      {r3,pc}
                  |L23.18|
000012  2001              MOVS     r0,#1                 ;1533
000014  f881003c          STRB     r0,[r1,#0x3c]         ;1533
000018  bf00              NOP                            ;1533
00001a  f891003d          LDRB     r0,[r1,#0x3d]         ;1535
00001e  2821              CMP      r0,#0x21              ;1535
000020  d10e              BNE      |L23.64|
000022  bf00              NOP                            ;1538
000024  bf00              NOP                            ;1538
                  |L23.38|
000026  680a              LDR      r2,[r1,#0]            ;1538
000028  3214              ADDS     r2,r2,#0x14           ;1538
00002a  e8522f00          LDREX    r2,[r2,#0]            ;1538
00002e  f0420080          ORR      r0,r2,#0x80           ;1538
000032  680a              LDR      r2,[r1,#0]            ;1538
000034  3214              ADDS     r2,r2,#0x14           ;1538
000036  e8420300          STREX    r3,r0,[r2,#0]         ;1538
00003a  2b00              CMP      r3,#0                 ;1538
00003c  d1f3              BNE      |L23.38|
00003e  bf00              NOP                            ;1538
                  |L23.64|
000040  f891003e          LDRB     r0,[r1,#0x3e]         ;1541
000044  2822              CMP      r0,#0x22              ;1541
000046  d139              BNE      |L23.188|
000048  bf00              NOP                            ;1544
00004a  2000              MOVS     r0,#0                 ;1544
00004c  9000              STR      r0,[sp,#0]            ;1544
00004e  6808              LDR      r0,[r1,#0]            ;1544
000050  6800              LDR      r0,[r0,#0]            ;1544
000052  9000              STR      r0,[sp,#0]            ;1544
000054  6808              LDR      r0,[r1,#0]            ;1544
000056  6840              LDR      r0,[r0,#4]            ;1544
000058  9000              STR      r0,[sp,#0]            ;1544
00005a  bf00              NOP                            ;1544
00005c  bf00              NOP                            ;1544
00005e  6908              LDR      r0,[r1,#0x10]         ;1547
000060  b170              CBZ      r0,|L23.128|
000062  bf00              NOP                            ;1549
000064  bf00              NOP                            ;1549
                  |L23.102|
000066  680a              LDR      r2,[r1,#0]            ;1549
000068  320c              ADDS     r2,r2,#0xc            ;1549
00006a  e8522f00          LDREX    r2,[r2,#0]            ;1549
00006e  f4427080          ORR      r0,r2,#0x100          ;1549
000072  680a              LDR      r2,[r1,#0]            ;1549
000074  320c              ADDS     r2,r2,#0xc            ;1549
000076  e8420300          STREX    r3,r0,[r2,#0]         ;1549
00007a  2b00              CMP      r3,#0                 ;1549
00007c  d1f3              BNE      |L23.102|
00007e  bf00              NOP                            ;1549
                  |L23.128|
000080  bf00              NOP                            ;1551
000082  bf00              NOP                            ;1551
                  |L23.132|
000084  680a              LDR      r2,[r1,#0]            ;1551
000086  3214              ADDS     r2,r2,#0x14           ;1551
000088  e8522f00          LDREX    r2,[r2,#0]            ;1551
00008c  f0420001          ORR      r0,r2,#1              ;1551
000090  680a              LDR      r2,[r1,#0]            ;1551
000092  3214              ADDS     r2,r2,#0x14           ;1551
000094  e8420300          STREX    r3,r0,[r2,#0]         ;1551
000098  2b00              CMP      r3,#0                 ;1551
00009a  d1f3              BNE      |L23.132|
00009c  bf00              NOP                            ;1551
00009e  bf00              NOP                            ;1554
0000a0  bf00              NOP                            ;1554
                  |L23.162|
0000a2  680a              LDR      r2,[r1,#0]            ;1554
0000a4  3214              ADDS     r2,r2,#0x14           ;1554
0000a6  e8522f00          LDREX    r2,[r2,#0]            ;1554
0000aa  f0420040          ORR      r0,r2,#0x40           ;1554
0000ae  680a              LDR      r2,[r1,#0]            ;1554
0000b0  3214              ADDS     r2,r2,#0x14           ;1554
0000b2  e8420300          STREX    r3,r0,[r2,#0]         ;1554
0000b6  2b00              CMP      r3,#0                 ;1554
0000b8  d1f3              BNE      |L23.162|
0000ba  bf00              NOP                            ;1554
                  |L23.188|
0000bc  bf00              NOP                            ;1558
0000be  2000              MOVS     r0,#0                 ;1558
0000c0  f881003c          STRB     r0,[r1,#0x3c]         ;1558
0000c4  bf00              NOP                            ;1558
0000c6  bf00              NOP                            ;1560
0000c8  e7a2              B        |L23.16|
;;;1562   
                          ENDP


                          AREA ||i.HAL_UART_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAStop PROC
;;;1568     */
;;;1569   HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1570   {
000002  4604              MOV      r4,r0
;;;1571     uint32_t dmarequest = 0x00U;
000004  2500              MOVS     r5,#0
;;;1572     /* The Lock is not implemented on this API to allow the user application
;;;1573        to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback():
;;;1574        when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
;;;1575        and the correspond call back is executed HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback()
;;;1576        */
;;;1577   
;;;1578     /* Stop UART DMA Tx request if ongoing */
;;;1579     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
000006  6820              LDR      r0,[r4,#0]
000008  6940              LDR      r0,[r0,#0x14]
00000a  f3c015c0          UBFX     r5,r0,#7,#1
;;;1580     if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
00000e  f894003d          LDRB     r0,[r4,#0x3d]
000012  2821              CMP      r0,#0x21
000014  d117              BNE      |L24.70|
000016  b1b5              CBZ      r5,|L24.70|
;;;1581     {
;;;1582       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L24.28|
00001c  6821              LDR      r1,[r4,#0]
00001e  3114              ADDS     r1,r1,#0x14
000020  e8511f00          LDREX    r1,[r1,#0]
000024  f0210080          BIC      r0,r1,#0x80
000028  6821              LDR      r1,[r4,#0]
00002a  3114              ADDS     r1,r1,#0x14
00002c  e8410200          STREX    r2,r0,[r1,#0]
000030  2a00              CMP      r2,#0
000032  d1f3              BNE      |L24.28|
000034  bf00              NOP      
;;;1583   
;;;1584       /* Abort the UART DMA Tx stream */
;;;1585       if (huart->hdmatx != NULL)
000036  6b60              LDR      r0,[r4,#0x34]
000038  b110              CBZ      r0,|L24.64|
;;;1586       {
;;;1587         HAL_DMA_Abort(huart->hdmatx);
00003a  6b60              LDR      r0,[r4,#0x34]
00003c  f7fffffe          BL       HAL_DMA_Abort
                  |L24.64|
;;;1588       }
;;;1589       UART_EndTxTransfer(huart);
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       UART_EndTxTransfer
                  |L24.70|
;;;1590     }
;;;1591   
;;;1592     /* Stop UART DMA Rx request if ongoing */
;;;1593     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
000046  6820              LDR      r0,[r4,#0]
000048  6940              LDR      r0,[r0,#0x14]
00004a  f3c01580          UBFX     r5,r0,#6,#1
;;;1594     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
00004e  f894003e          LDRB     r0,[r4,#0x3e]
000052  2822              CMP      r0,#0x22
000054  d117              BNE      |L24.134|
000056  b1b5              CBZ      r5,|L24.134|
;;;1595     {
;;;1596       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000058  bf00              NOP      
00005a  bf00              NOP      
                  |L24.92|
00005c  6821              LDR      r1,[r4,#0]
00005e  3114              ADDS     r1,r1,#0x14
000060  e8511f00          LDREX    r1,[r1,#0]
000064  f0210040          BIC      r0,r1,#0x40
000068  6821              LDR      r1,[r4,#0]
00006a  3114              ADDS     r1,r1,#0x14
00006c  e8410200          STREX    r2,r0,[r1,#0]
000070  2a00              CMP      r2,#0
000072  d1f3              BNE      |L24.92|
000074  bf00              NOP      
;;;1597   
;;;1598       /* Abort the UART DMA Rx stream */
;;;1599       if (huart->hdmarx != NULL)
000076  6ba0              LDR      r0,[r4,#0x38]
000078  b110              CBZ      r0,|L24.128|
;;;1600       {
;;;1601         HAL_DMA_Abort(huart->hdmarx);
00007a  6ba0              LDR      r0,[r4,#0x38]
00007c  f7fffffe          BL       HAL_DMA_Abort
                  |L24.128|
;;;1602       }
;;;1603       UART_EndRxTransfer(huart);
000080  4620              MOV      r0,r4
000082  f7fffffe          BL       UART_EndRxTransfer
                  |L24.134|
;;;1604     }
;;;1605   
;;;1606     return HAL_OK;
000086  2000              MOVS     r0,#0
;;;1607   }
000088  bd70              POP      {r4-r6,pc}
;;;1608   
                          ENDP


                          AREA ||i.HAL_UART_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_DeInit PROC
;;;664      */
;;;665    HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;666    {
000002  4604              MOV      r4,r0
;;;667      /* Check the UART handle allocation */
;;;668      if (huart == NULL)
000004  b90c              CBNZ     r4,|L25.10|
;;;669      {
;;;670        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L25.8|
;;;671      }
;;;672    
;;;673      /* Check the parameters */
;;;674      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;675    
;;;676      huart->gState = HAL_UART_STATE_BUSY;
;;;677    
;;;678      /* Disable the Peripheral */
;;;679      __HAL_UART_DISABLE(huart);
;;;680    
;;;681    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;682      if (huart->MspDeInitCallback == NULL)
;;;683      {
;;;684        huart->MspDeInitCallback = HAL_UART_MspDeInit;
;;;685      }
;;;686      /* DeInit the low level hardware */
;;;687      huart->MspDeInitCallback(huart);
;;;688    #else
;;;689      /* DeInit the low level hardware */
;;;690      HAL_UART_MspDeInit(huart);
;;;691    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;692    
;;;693      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;694      huart->gState = HAL_UART_STATE_RESET;
;;;695      huart->RxState = HAL_UART_STATE_RESET;
;;;696      huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;697    
;;;698      /* Process Unlock */
;;;699      __HAL_UNLOCK(huart);
;;;700    
;;;701      return HAL_OK;
;;;702    }
000008  bd10              POP      {r4,pc}
                  |L25.10|
00000a  2024              MOVS     r0,#0x24              ;676
00000c  f884003d          STRB     r0,[r4,#0x3d]         ;676
000010  6820              LDR      r0,[r4,#0]            ;679
000012  68c0              LDR      r0,[r0,#0xc]          ;679
000014  f4205000          BIC      r0,r0,#0x2000         ;679
000018  6821              LDR      r1,[r4,#0]            ;679
00001a  60c8              STR      r0,[r1,#0xc]          ;679
00001c  4620              MOV      r0,r4                 ;690
00001e  f7fffffe          BL       HAL_UART_MspDeInit
000022  2000              MOVS     r0,#0                 ;693
000024  6420              STR      r0,[r4,#0x40]         ;693
000026  f884003d          STRB     r0,[r4,#0x3d]         ;694
00002a  f884003e          STRB     r0,[r4,#0x3e]         ;695
00002e  6320              STR      r0,[r4,#0x30]         ;696
000030  bf00              NOP                            ;699
000032  f884003c          STRB     r0,[r4,#0x3c]         ;699
000036  bf00              NOP                            ;699
000038  bf00              NOP                            ;701
00003a  e7e5              B        |L25.8|
;;;703    
                          ENDP


                          AREA ||i.HAL_UART_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_ErrorCallback PROC
;;;2651     */
;;;2652   __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2653   {
;;;2654     /* Prevent unused argument(s) compilation warning */
;;;2655     UNUSED(huart);
;;;2656     /* NOTE: This function should not be modified, when the callback is needed,
;;;2657              the HAL_UART_ErrorCallback could be implemented in the user file
;;;2658      */
;;;2659   }
;;;2660   
                          ENDP


                          AREA ||i.HAL_UART_GetError||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetError PROC
;;;2940     */
;;;2941   uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2942   {
;;;2943     return huart->ErrorCode;
000002  6c08              LDR      r0,[r1,#0x40]
;;;2944   }
000004  4770              BX       lr
;;;2945   
                          ENDP


                          AREA ||i.HAL_UART_GetState||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetState PROC
;;;2925     */
;;;2926   HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2927   {
;;;2928     uint32_t temp1 = 0x00U, temp2 = 0x00U;
000002  2200              MOVS     r2,#0
000004  2300              MOVS     r3,#0
;;;2929     temp1 = huart->gState;
000006  f891203d          LDRB     r2,[r1,#0x3d]
;;;2930     temp2 = huart->RxState;
00000a  f891303e          LDRB     r3,[r1,#0x3e]
;;;2931   
;;;2932     return (HAL_UART_StateTypeDef)(temp1 | temp2);
00000e  ea420003          ORR      r0,r2,r3
;;;2933   }
000012  4770              BX       lr
;;;2934   
                          ENDP


                          AREA ||i.HAL_UART_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_UART_IRQHandler PROC
;;;2359     */
;;;2360   void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;2361   {
000004  4604              MOV      r4,r0
;;;2362     uint32_t isrflags   = READ_REG(huart->Instance->SR);
000006  6820              LDR      r0,[r4,#0]
000008  6805              LDR      r5,[r0,#0]
;;;2363     uint32_t cr1its     = READ_REG(huart->Instance->CR1);
00000a  6820              LDR      r0,[r4,#0]
00000c  68c6              LDR      r6,[r0,#0xc]
;;;2364     uint32_t cr3its     = READ_REG(huart->Instance->CR3);
00000e  6820              LDR      r0,[r4,#0]
000010  6947              LDR      r7,[r0,#0x14]
;;;2365     uint32_t errorflags = 0x00U;
000012  f04f0900          MOV      r9,#0
;;;2366     uint32_t dmarequest = 0x00U;
000016  46ca              MOV      r10,r9
;;;2367   
;;;2368     /* If no error occurs */
;;;2369     errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
000018  f005090f          AND      r9,r5,#0xf
;;;2370     if (errorflags == RESET)
00001c  f1b90f00          CMP      r9,#0
000020  d10a              BNE      |L29.56|
;;;2371     {
;;;2372       /* UART in mode Receiver -------------------------------------------------*/
;;;2373       if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
000022  f0050020          AND      r0,r5,#0x20
000026  b138              CBZ      r0,|L29.56|
000028  f0060020          AND      r0,r6,#0x20
00002c  b120              CBZ      r0,|L29.56|
;;;2374       {
;;;2375         UART_Receive_IT(huart);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       UART_Receive_IT
                  |L29.52|
;;;2376         return;
;;;2377       }
;;;2378     }
;;;2379   
;;;2380     /* If some errors occur */
;;;2381     if ((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET)
;;;2382                                   || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
;;;2383     {
;;;2384       /* UART parity error interrupt occurred ----------------------------------*/
;;;2385       if (((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
;;;2386       {
;;;2387         huart->ErrorCode |= HAL_UART_ERROR_PE;
;;;2388       }
;;;2389   
;;;2390       /* UART noise error interrupt occurred -----------------------------------*/
;;;2391       if (((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
;;;2392       {
;;;2393         huart->ErrorCode |= HAL_UART_ERROR_NE;
;;;2394       }
;;;2395   
;;;2396       /* UART frame error interrupt occurred -----------------------------------*/
;;;2397       if (((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
;;;2398       {
;;;2399         huart->ErrorCode |= HAL_UART_ERROR_FE;
;;;2400       }
;;;2401   
;;;2402       /* UART Over-Run interrupt occurred --------------------------------------*/
;;;2403       if (((isrflags & USART_SR_ORE) != RESET) && (((cr1its & USART_CR1_RXNEIE) != RESET)
;;;2404                                                    || ((cr3its & USART_CR3_EIE) != RESET)))
;;;2405       {
;;;2406         huart->ErrorCode |= HAL_UART_ERROR_ORE;
;;;2407       }
;;;2408   
;;;2409       /* Call UART Error Call back function if need be --------------------------*/
;;;2410       if (huart->ErrorCode != HAL_UART_ERROR_NONE)
;;;2411       {
;;;2412         /* UART in mode Receiver -----------------------------------------------*/
;;;2413         if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
;;;2414         {
;;;2415           UART_Receive_IT(huart);
;;;2416         }
;;;2417   
;;;2418         /* If Overrun error occurs, or if any error occurs in DMA mode reception,
;;;2419            consider error as blocking */
;;;2420         dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
;;;2421         if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
;;;2422         {
;;;2423           /* Blocking error : transfer is aborted
;;;2424              Set the UART state ready to be able to start again the process,
;;;2425              Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
;;;2426           UART_EndRxTransfer(huart);
;;;2427   
;;;2428           /* Disable the UART DMA Rx request if enabled */
;;;2429           if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
;;;2430           {
;;;2431             ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;2432   
;;;2433             /* Abort the UART DMA Rx stream */
;;;2434             if (huart->hdmarx != NULL)
;;;2435             {
;;;2436               /* Set the UART DMA Abort callback :
;;;2437                  will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
;;;2438               huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
;;;2439               if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
;;;2440               {
;;;2441                 /* Call Directly XferAbortCallback function in case of error */
;;;2442                 huart->hdmarx->XferAbortCallback(huart->hdmarx);
;;;2443               }
;;;2444             }
;;;2445             else
;;;2446             {
;;;2447               /* Call user error callback */
;;;2448   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2449               /*Call registered error callback*/
;;;2450               huart->ErrorCallback(huart);
;;;2451   #else
;;;2452               /*Call legacy weak error callback*/
;;;2453               HAL_UART_ErrorCallback(huart);
;;;2454   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2455             }
;;;2456           }
;;;2457           else
;;;2458           {
;;;2459             /* Call user error callback */
;;;2460   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2461             /*Call registered error callback*/
;;;2462             huart->ErrorCallback(huart);
;;;2463   #else
;;;2464             /*Call legacy weak error callback*/
;;;2465             HAL_UART_ErrorCallback(huart);
;;;2466   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2467           }
;;;2468         }
;;;2469         else
;;;2470         {
;;;2471           /* Non Blocking error : transfer could go on.
;;;2472              Error is notified to user through user error callback */
;;;2473   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2474           /*Call registered error callback*/
;;;2475           huart->ErrorCallback(huart);
;;;2476   #else
;;;2477           /*Call legacy weak error callback*/
;;;2478           HAL_UART_ErrorCallback(huart);
;;;2479   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2480   
;;;2481           huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;2482         }
;;;2483       }
;;;2484       return;
;;;2485     } /* End if some error occurs */
;;;2486   
;;;2487     /* Check current reception Mode :
;;;2488        If Reception till IDLE event has been selected : */
;;;2489     if ((huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
;;;2490         && ((isrflags & USART_SR_IDLE) != 0U)
;;;2491         && ((cr1its & USART_SR_IDLE) != 0U))
;;;2492     {
;;;2493       __HAL_UART_CLEAR_IDLEFLAG(huart);
;;;2494   
;;;2495       /* Check if DMA mode is enabled in UART */
;;;2496       if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
;;;2497       {
;;;2498         /* DMA mode enabled */
;;;2499         /* Check received length : If all expected data are received, do nothing,
;;;2500            (DMA cplt callback will be called).
;;;2501            Otherwise, if at least one data has already been received, IDLE event is to be notified to user */
;;;2502         uint16_t nb_remaining_rx_data = (uint16_t) __HAL_DMA_GET_COUNTER(huart->hdmarx);
;;;2503         if ((nb_remaining_rx_data > 0U)
;;;2504             && (nb_remaining_rx_data < huart->RxXferSize))
;;;2505         {
;;;2506           /* Reception is not complete */
;;;2507           huart->RxXferCount = nb_remaining_rx_data;
;;;2508   
;;;2509           /* In Normal mode, end DMA xfer and HAL UART Rx process*/
;;;2510           if (huart->hdmarx->Init.Mode != DMA_CIRCULAR)
;;;2511           {
;;;2512             /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2513             ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;2514             ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;2515   
;;;2516             /* Disable the DMA transfer for the receiver request by resetting the DMAR bit
;;;2517                in the UART CR3 register */
;;;2518             ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;2519   
;;;2520             /* At end of Rx process, restore huart->RxState to Ready */
;;;2521             huart->RxState = HAL_UART_STATE_READY;
;;;2522             huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;2523   
;;;2524             ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
;;;2525   
;;;2526             /* Last bytes received, so no need as the abort is immediate */
;;;2527             (void)HAL_DMA_Abort(huart->hdmarx);
;;;2528           }
;;;2529   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2530           /*Call registered Rx Event callback*/
;;;2531           huart->RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
;;;2532   #else
;;;2533           /*Call legacy weak Rx Event callback*/
;;;2534           HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
;;;2535   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2536         }
;;;2537         return;
;;;2538       }
;;;2539       else
;;;2540       {
;;;2541         /* DMA mode not enabled */
;;;2542         /* Check received length : If all expected data are received, do nothing.
;;;2543            Otherwise, if at least one data has already been received, IDLE event is to be notified to user */
;;;2544         uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
;;;2545         if ((huart->RxXferCount > 0U)
;;;2546             && (nb_rx_data > 0U))
;;;2547         {
;;;2548           /* Disable the UART Parity Error Interrupt and RXNE interrupts */
;;;2549           ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
;;;2550   
;;;2551           /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;2552           ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;2553   
;;;2554           /* Rx process is completed, restore huart->RxState to Ready */
;;;2555           huart->RxState = HAL_UART_STATE_READY;
;;;2556           huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;2557   
;;;2558           ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
;;;2559   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2560           /*Call registered Rx complete callback*/
;;;2561           huart->RxEventCallback(huart, nb_rx_data);
;;;2562   #else
;;;2563           /*Call legacy weak Rx Event callback*/
;;;2564           HAL_UARTEx_RxEventCallback(huart, nb_rx_data);
;;;2565   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2566         }
;;;2567         return;
;;;2568       }
;;;2569     }
;;;2570   
;;;2571     /* UART in mode Transmitter ------------------------------------------------*/
;;;2572     if (((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
;;;2573     {
;;;2574       UART_Transmit_IT(huart);
;;;2575       return;
;;;2576     }
;;;2577   
;;;2578     /* UART in mode Transmitter end --------------------------------------------*/
;;;2579     if (((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
;;;2580     {
;;;2581       UART_EndTransmit_IT(huart);
;;;2582       return;
;;;2583     }
;;;2584   }
000034  e8bd8ff8          POP      {r3-r11,pc}
                  |L29.56|
000038  f1b90f00          CMP      r9,#0                 ;2381
00003c  d07c              BEQ      |L29.312|
00003e  f0070001          AND      r0,r7,#1              ;2381
000042  b918              CBNZ     r0,|L29.76|
000044  f4067090          AND      r0,r6,#0x120          ;2382
000048  2800              CMP      r0,#0                 ;2382
00004a  d075              BEQ      |L29.312|
                  |L29.76|
00004c  f0050001          AND      r0,r5,#1              ;2385
000050  b130              CBZ      r0,|L29.96|
000052  f4067080          AND      r0,r6,#0x100          ;2385
000056  b118              CBZ      r0,|L29.96|
000058  6c20              LDR      r0,[r4,#0x40]         ;2387
00005a  f0400001          ORR      r0,r0,#1              ;2387
00005e  6420              STR      r0,[r4,#0x40]         ;2387
                  |L29.96|
000060  f0050004          AND      r0,r5,#4              ;2391
000064  b130              CBZ      r0,|L29.116|
000066  f0070001          AND      r0,r7,#1              ;2391
00006a  b118              CBZ      r0,|L29.116|
00006c  6c20              LDR      r0,[r4,#0x40]         ;2393
00006e  f0400002          ORR      r0,r0,#2              ;2393
000072  6420              STR      r0,[r4,#0x40]         ;2393
                  |L29.116|
000074  f0050002          AND      r0,r5,#2              ;2397
000078  b130              CBZ      r0,|L29.136|
00007a  f0070001          AND      r0,r7,#1              ;2397
00007e  b118              CBZ      r0,|L29.136|
000080  6c20              LDR      r0,[r4,#0x40]         ;2399
000082  f0400004          ORR      r0,r0,#4              ;2399
000086  6420              STR      r0,[r4,#0x40]         ;2399
                  |L29.136|
000088  f0050008          AND      r0,r5,#8              ;2403
00008c  b148              CBZ      r0,|L29.162|
00008e  f0060020          AND      r0,r6,#0x20           ;2403
000092  b910              CBNZ     r0,|L29.154|
000094  f0070001          AND      r0,r7,#1              ;2404
000098  b118              CBZ      r0,|L29.162|
                  |L29.154|
00009a  6c20              LDR      r0,[r4,#0x40]         ;2406
00009c  f0400008          ORR      r0,r0,#8              ;2406
0000a0  6420              STR      r0,[r4,#0x40]         ;2406
                  |L29.162|
0000a2  6c20              LDR      r0,[r4,#0x40]         ;2410
0000a4  2800              CMP      r0,#0                 ;2410
0000a6  d046              BEQ      |L29.310|
0000a8  f0050020          AND      r0,r5,#0x20           ;2413
0000ac  b128              CBZ      r0,|L29.186|
0000ae  f0060020          AND      r0,r6,#0x20           ;2413
0000b2  b110              CBZ      r0,|L29.186|
0000b4  4620              MOV      r0,r4                 ;2415
0000b6  f7fffffe          BL       UART_Receive_IT
                  |L29.186|
0000ba  6820              LDR      r0,[r4,#0]            ;2420
0000bc  6940              LDR      r0,[r0,#0x14]         ;2420
0000be  f3c01a80          UBFX     r10,r0,#6,#1          ;2420
0000c2  6c20              LDR      r0,[r4,#0x40]         ;2421
0000c4  f0000008          AND      r0,r0,#8              ;2421
0000c8  b910              CBNZ     r0,|L29.208|
0000ca  f1ba0f00          CMP      r10,#0                ;2421
0000ce  d02d              BEQ      |L29.300|
                  |L29.208|
0000d0  4620              MOV      r0,r4                 ;2426
0000d2  f7fffffe          BL       UART_EndRxTransfer
0000d6  6820              LDR      r0,[r4,#0]            ;2429
0000d8  6940              LDR      r0,[r0,#0x14]         ;2429
0000da  f0000040          AND      r0,r0,#0x40           ;2429
0000de  2840              CMP      r0,#0x40              ;2429
0000e0  d120              BNE      |L29.292|
0000e2  bf00              NOP                            ;2431
0000e4  bf00              NOP                            ;2431
                  |L29.230|
0000e6  6821              LDR      r1,[r4,#0]            ;2431
0000e8  3114              ADDS     r1,r1,#0x14           ;2431
0000ea  e8511f00          LDREX    r1,[r1,#0]            ;2431
0000ee  f0210040          BIC      r0,r1,#0x40           ;2431
0000f2  6821              LDR      r1,[r4,#0]            ;2431
0000f4  3114              ADDS     r1,r1,#0x14           ;2431
0000f6  e8410200          STREX    r2,r0,[r1,#0]         ;2431
0000fa  2a00              CMP      r2,#0                 ;2431
0000fc  d1f3              BNE      |L29.230|
0000fe  bf00              NOP                            ;2431
000100  6ba0              LDR      r0,[r4,#0x38]         ;2434
000102  b150              CBZ      r0,|L29.282|
000104  4875              LDR      r0,|L29.732|
000106  6ba1              LDR      r1,[r4,#0x38]         ;2438
000108  6508              STR      r0,[r1,#0x50]         ;2438
00010a  6ba0              LDR      r0,[r4,#0x38]         ;2439
00010c  f7fffffe          BL       HAL_DMA_Abort_IT
000110  b188              CBZ      r0,|L29.310|
000112  6ba0              LDR      r0,[r4,#0x38]         ;2442
000114  6d01              LDR      r1,[r0,#0x50]         ;2442
000116  4788              BLX      r1                    ;2442
000118  e00d              B        |L29.310|
                  |L29.282|
00011a  4620              MOV      r0,r4                 ;2453
00011c  f7fffffe          BL       HAL_UART_ErrorCallback
000120  e009              B        |L29.310|
000122  e009              B        |L29.312|
                  |L29.292|
000124  4620              MOV      r0,r4                 ;2465
000126  f7fffffe          BL       HAL_UART_ErrorCallback
00012a  e004              B        |L29.310|
                  |L29.300|
00012c  4620              MOV      r0,r4                 ;2478
00012e  f7fffffe          BL       HAL_UART_ErrorCallback
000132  2000              MOVS     r0,#0                 ;2481
000134  6420              STR      r0,[r4,#0x40]         ;2481
                  |L29.310|
000136  e77d              B        |L29.52|
                  |L29.312|
000138  6b20              LDR      r0,[r4,#0x30]         ;2489
00013a  2801              CMP      r0,#1                 ;2489
00013c  d176              BNE      |L29.556|
00013e  f0050010          AND      r0,r5,#0x10           ;2490
000142  2800              CMP      r0,#0                 ;2490
                  |L29.324|
000144  d072              BEQ      |L29.556|
000146  f0060010          AND      r0,r6,#0x10           ;2491
00014a  2800              CMP      r0,#0                 ;2491
00014c  d0fa              BEQ      |L29.324|
00014e  bf00              NOP                            ;2493
000150  2000              MOVS     r0,#0                 ;2493
000152  9000              STR      r0,[sp,#0]            ;2493
000154  6820              LDR      r0,[r4,#0]            ;2493
000156  6800              LDR      r0,[r0,#0]            ;2493
000158  9000              STR      r0,[sp,#0]            ;2493
00015a  6820              LDR      r0,[r4,#0]            ;2493
00015c  6840              LDR      r0,[r0,#4]            ;2493
00015e  9000              STR      r0,[sp,#0]            ;2493
000160  bf00              NOP                            ;2493
000162  bf00              NOP                            ;2493
000164  6820              LDR      r0,[r4,#0]            ;2496
000166  6940              LDR      r0,[r0,#0x14]         ;2496
000168  f0000040          AND      r0,r0,#0x40           ;2496
00016c  2840              CMP      r0,#0x40              ;2496
00016e  d15e              BNE      |L29.558|
000170  6ba0              LDR      r0,[r4,#0x38]         ;2502
000172  6800              LDR      r0,[r0,#0]            ;2502
000174  6840              LDR      r0,[r0,#4]            ;2502
000176  fa1ff880          UXTH     r8,r0                 ;2502
00017a  f1b80f00          CMP      r8,#0                 ;2503
00017e  d054              BEQ      |L29.554|
000180  8da0              LDRH     r0,[r4,#0x2c]         ;2504
000182  4540              CMP      r0,r8                 ;2504
000184  dd51              BLE      |L29.554|
000186  f8a4802e          STRH     r8,[r4,#0x2e]         ;2507
00018a  6ba0              LDR      r0,[r4,#0x38]         ;2510
00018c  69c0              LDR      r0,[r0,#0x1c]         ;2510
00018e  f5b07f80          CMP      r0,#0x100             ;2510
000192  d043              BEQ      |L29.540|
000194  bf00              NOP                            ;2513
000196  bf00              NOP                            ;2513
                  |L29.408|
000198  6821              LDR      r1,[r4,#0]            ;2513
00019a  310c              ADDS     r1,r1,#0xc            ;2513
00019c  e8511f00          LDREX    r1,[r1,#0]            ;2513
0001a0  f4217080          BIC      r0,r1,#0x100          ;2513
0001a4  6821              LDR      r1,[r4,#0]            ;2513
0001a6  310c              ADDS     r1,r1,#0xc            ;2513
0001a8  e8410200          STREX    r2,r0,[r1,#0]         ;2513
0001ac  2a00              CMP      r2,#0                 ;2513
0001ae  d1f3              BNE      |L29.408|
0001b0  bf00              NOP                            ;2513
0001b2  bf00              NOP                            ;2514
0001b4  bf00              NOP                            ;2514
                  |L29.438|
0001b6  6821              LDR      r1,[r4,#0]            ;2514
0001b8  3114              ADDS     r1,r1,#0x14           ;2514
0001ba  e8511f00          LDREX    r1,[r1,#0]            ;2514
0001be  f0210001          BIC      r0,r1,#1              ;2514
0001c2  6821              LDR      r1,[r4,#0]            ;2514
0001c4  3114              ADDS     r1,r1,#0x14           ;2514
0001c6  e8410200          STREX    r2,r0,[r1,#0]         ;2514
0001ca  2a00              CMP      r2,#0                 ;2514
0001cc  d1f3              BNE      |L29.438|
0001ce  bf00              NOP                            ;2514
0001d0  bf00              NOP                            ;2518
0001d2  bf00              NOP                            ;2518
                  |L29.468|
0001d4  6821              LDR      r1,[r4,#0]            ;2518
0001d6  3114              ADDS     r1,r1,#0x14           ;2518
0001d8  e8511f00          LDREX    r1,[r1,#0]            ;2518
0001dc  f0210040          BIC      r0,r1,#0x40           ;2518
0001e0  6821              LDR      r1,[r4,#0]            ;2518
0001e2  3114              ADDS     r1,r1,#0x14           ;2518
0001e4  e8410200          STREX    r2,r0,[r1,#0]         ;2518
0001e8  2a00              CMP      r2,#0                 ;2518
0001ea  d1f3              BNE      |L29.468|
0001ec  bf00              NOP                            ;2518
0001ee  2020              MOVS     r0,#0x20              ;2521
0001f0  f884003e          STRB     r0,[r4,#0x3e]         ;2521
0001f4  2000              MOVS     r0,#0                 ;2522
0001f6  6320              STR      r0,[r4,#0x30]         ;2522
0001f8  bf00              NOP                            ;2524
0001fa  bf00              NOP                            ;2524
                  |L29.508|
0001fc  6821              LDR      r1,[r4,#0]            ;2524
0001fe  310c              ADDS     r1,r1,#0xc            ;2524
000200  e8511f00          LDREX    r1,[r1,#0]            ;2524
000204  f0210010          BIC      r0,r1,#0x10           ;2524
000208  6821              LDR      r1,[r4,#0]            ;2524
00020a  310c              ADDS     r1,r1,#0xc            ;2524
00020c  e8410200          STREX    r2,r0,[r1,#0]         ;2524
000210  2a00              CMP      r2,#0                 ;2524
000212  d1f3              BNE      |L29.508|
000214  bf00              NOP                            ;2524
000216  6ba0              LDR      r0,[r4,#0x38]         ;2527
000218  f7fffffe          BL       HAL_DMA_Abort
                  |L29.540|
00021c  8da0              LDRH     r0,[r4,#0x2c]         ;2534
00021e  8de2              LDRH     r2,[r4,#0x2e]         ;2534
000220  1a80              SUBS     r0,r0,r2              ;2534
000222  b281              UXTH     r1,r0                 ;2534
000224  4620              MOV      r0,r4                 ;2534
000226  f7fffffe          BL       HAL_UARTEx_RxEventCallback
                  |L29.554|
00022a  e703              B        |L29.52|
                  |L29.556|
00022c  e040              B        |L29.688|
                  |L29.558|
00022e  8da0              LDRH     r0,[r4,#0x2c]         ;2544
000230  8de1              LDRH     r1,[r4,#0x2e]         ;2544
000232  1a40              SUBS     r0,r0,r1              ;2544
000234  fa1ff880          UXTH     r8,r0                 ;2544
000238  8de0              LDRH     r0,[r4,#0x2e]         ;2545
00023a  b3c0              CBZ      r0,|L29.686|
00023c  f1b80f00          CMP      r8,#0                 ;2546
000240  d035              BEQ      |L29.686|
000242  bf00              NOP                            ;2549
000244  bf00              NOP                            ;2549
                  |L29.582|
000246  6821              LDR      r1,[r4,#0]            ;2549
000248  310c              ADDS     r1,r1,#0xc            ;2549
00024a  e8511f00          LDREX    r1,[r1,#0]            ;2549
00024e  f4217090          BIC      r0,r1,#0x120          ;2549
000252  6821              LDR      r1,[r4,#0]            ;2549
000254  310c              ADDS     r1,r1,#0xc            ;2549
000256  e8410200          STREX    r2,r0,[r1,#0]         ;2549
00025a  2a00              CMP      r2,#0                 ;2549
00025c  d1f3              BNE      |L29.582|
00025e  bf00              NOP                            ;2549
000260  bf00              NOP                            ;2552
000262  bf00              NOP                            ;2552
                  |L29.612|
000264  6821              LDR      r1,[r4,#0]            ;2552
000266  3114              ADDS     r1,r1,#0x14           ;2552
000268  e8511f00          LDREX    r1,[r1,#0]            ;2552
00026c  f0210001          BIC      r0,r1,#1              ;2552
000270  6821              LDR      r1,[r4,#0]            ;2552
000272  3114              ADDS     r1,r1,#0x14           ;2552
000274  e8410200          STREX    r2,r0,[r1,#0]         ;2552
000278  2a00              CMP      r2,#0                 ;2552
00027a  d1f3              BNE      |L29.612|
00027c  bf00              NOP                            ;2552
00027e  2020              MOVS     r0,#0x20              ;2555
000280  f884003e          STRB     r0,[r4,#0x3e]         ;2555
000284  2000              MOVS     r0,#0                 ;2556
000286  6320              STR      r0,[r4,#0x30]         ;2556
000288  bf00              NOP                            ;2558
00028a  bf00              NOP                            ;2558
                  |L29.652|
00028c  6821              LDR      r1,[r4,#0]            ;2558
00028e  310c              ADDS     r1,r1,#0xc            ;2558
000290  e8511f00          LDREX    r1,[r1,#0]            ;2558
000294  f0210010          BIC      r0,r1,#0x10           ;2558
000298  6821              LDR      r1,[r4,#0]            ;2558
00029a  310c              ADDS     r1,r1,#0xc            ;2558
00029c  e8410200          STREX    r2,r0,[r1,#0]         ;2558
0002a0  2a00              CMP      r2,#0                 ;2558
0002a2  d1f3              BNE      |L29.652|
0002a4  bf00              NOP                            ;2558
0002a6  4641              MOV      r1,r8                 ;2564
0002a8  4620              MOV      r0,r4                 ;2564
0002aa  f7fffffe          BL       HAL_UARTEx_RxEventCallback
                  |L29.686|
0002ae  e6c1              B        |L29.52|
                  |L29.688|
0002b0  f0050080          AND      r0,r5,#0x80           ;2572
0002b4  b130              CBZ      r0,|L29.708|
0002b6  f0060080          AND      r0,r6,#0x80           ;2572
0002ba  b118              CBZ      r0,|L29.708|
0002bc  4620              MOV      r0,r4                 ;2574
0002be  f7fffffe          BL       UART_Transmit_IT
0002c2  e6b7              B        |L29.52|
                  |L29.708|
0002c4  f0050040          AND      r0,r5,#0x40           ;2579
0002c8  b130              CBZ      r0,|L29.728|
0002ca  f0060040          AND      r0,r6,#0x40           ;2579
0002ce  b118              CBZ      r0,|L29.728|
0002d0  4620              MOV      r0,r4                 ;2581
0002d2  f7fffffe          BL       UART_EndTransmit_IT
0002d6  e6ad              B        |L29.52|
                  |L29.728|
0002d8  bf00              NOP      
0002da  e6ab              B        |L29.52|
;;;2585   
                          ENDP

                  |L29.732|
                          DCD      UART_DMAAbortOnError

                          AREA ||i.HAL_UART_Init||, CODE, READONLY, ALIGN=1

                  HAL_UART_Init PROC
;;;356      */
;;;357    HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;358    {
000002  4604              MOV      r4,r0
;;;359      /* Check the UART handle allocation */
;;;360      if (huart == NULL)
000004  b90c              CBNZ     r4,|L30.10|
;;;361      {
;;;362        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L30.8|
;;;363      }
;;;364    
;;;365      /* Check the parameters */
;;;366      if (huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
;;;367      {
;;;368        /* The hardware flow control is available only for USART1, USART2, USART3 and USART6.
;;;369           Except for STM32F446xx devices, that is available for USART1, USART2, USART3, USART6, UART4 and UART5.
;;;370        */
;;;371        assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
;;;372        assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
;;;373      }
;;;374      else
;;;375      {
;;;376        assert_param(IS_UART_INSTANCE(huart->Instance));
;;;377      }
;;;378      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;379      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;380    
;;;381      if (huart->gState == HAL_UART_STATE_RESET)
;;;382      {
;;;383        /* Allocate lock resource and initialize it */
;;;384        huart->Lock = HAL_UNLOCKED;
;;;385    
;;;386    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;387        UART_InitCallbacksToDefault(huart);
;;;388    
;;;389        if (huart->MspInitCallback == NULL)
;;;390        {
;;;391          huart->MspInitCallback = HAL_UART_MspInit;
;;;392        }
;;;393    
;;;394        /* Init the low level hardware */
;;;395        huart->MspInitCallback(huart);
;;;396    #else
;;;397        /* Init the low level hardware : GPIO, CLOCK */
;;;398        HAL_UART_MspInit(huart);
;;;399    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;400      }
;;;401    
;;;402      huart->gState = HAL_UART_STATE_BUSY;
;;;403    
;;;404      /* Disable the peripheral */
;;;405      __HAL_UART_DISABLE(huart);
;;;406    
;;;407      /* Set the UART Communication parameters */
;;;408      UART_SetConfig(huart);
;;;409    
;;;410      /* In asynchronous mode, the following bits must be kept cleared:
;;;411         - LINEN and CLKEN bits in the USART_CR2 register,
;;;412         - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
;;;413      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;414      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;415    
;;;416      /* Enable the peripheral */
;;;417      __HAL_UART_ENABLE(huart);
;;;418    
;;;419      /* Initialize the UART state */
;;;420      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;421      huart->gState = HAL_UART_STATE_READY;
;;;422      huart->RxState = HAL_UART_STATE_READY;
;;;423    
;;;424      return HAL_OK;
;;;425    }
000008  bd10              POP      {r4,pc}
                  |L30.10|
00000a  69a0              LDR      r0,[r4,#0x18]         ;366
00000c  b100              CBZ      r0,|L30.16|
00000e  e000              B        |L30.18|
                  |L30.16|
000010  bf00              NOP                            ;376
                  |L30.18|
000012  f894003d          LDRB     r0,[r4,#0x3d]         ;381
000016  b928              CBNZ     r0,|L30.36|
000018  2000              MOVS     r0,#0                 ;384
00001a  f884003c          STRB     r0,[r4,#0x3c]         ;384
00001e  4620              MOV      r0,r4                 ;398
000020  f7fffffe          BL       HAL_UART_MspInit
                  |L30.36|
000024  2024              MOVS     r0,#0x24              ;402
000026  f884003d          STRB     r0,[r4,#0x3d]         ;402
00002a  6820              LDR      r0,[r4,#0]            ;405
00002c  68c0              LDR      r0,[r0,#0xc]          ;405
00002e  f4205000          BIC      r0,r0,#0x2000         ;405
000032  6821              LDR      r1,[r4,#0]            ;405
000034  60c8              STR      r0,[r1,#0xc]          ;405
000036  4620              MOV      r0,r4                 ;408
000038  f7fffffe          BL       UART_SetConfig
00003c  6820              LDR      r0,[r4,#0]            ;413
00003e  6900              LDR      r0,[r0,#0x10]         ;413
000040  f4204090          BIC      r0,r0,#0x4800         ;413
000044  6821              LDR      r1,[r4,#0]            ;413
000046  6108              STR      r0,[r1,#0x10]         ;413
000048  6820              LDR      r0,[r4,#0]            ;414
00004a  6940              LDR      r0,[r0,#0x14]         ;414
00004c  f020002a          BIC      r0,r0,#0x2a           ;414
000050  6821              LDR      r1,[r4,#0]            ;414
000052  6148              STR      r0,[r1,#0x14]         ;414
000054  6820              LDR      r0,[r4,#0]            ;417
000056  68c0              LDR      r0,[r0,#0xc]          ;417
000058  f4405000          ORR      r0,r0,#0x2000         ;417
00005c  6821              LDR      r1,[r4,#0]            ;417
00005e  60c8              STR      r0,[r1,#0xc]          ;417
000060  2000              MOVS     r0,#0                 ;420
000062  6420              STR      r0,[r4,#0x40]         ;420
000064  2020              MOVS     r0,#0x20              ;421
000066  f884003d          STRB     r0,[r4,#0x3d]         ;421
00006a  f884003e          STRB     r0,[r4,#0x3e]         ;422
00006e  2000              MOVS     r0,#0                 ;424
000070  e7ca              B        |L30.8|
;;;426    
                          ENDP


                          AREA ||i.HAL_UART_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspDeInit PROC
;;;724      */
;;;725    __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;726    {
;;;727      /* Prevent unused argument(s) compilation warning */
;;;728      UNUSED(huart);
;;;729      /* NOTE: This function should not be modified, when the callback is needed,
;;;730               the HAL_UART_MspDeInit could be implemented in the user file
;;;731       */
;;;732    }
;;;733    
                          ENDP


                          AREA ||i.HAL_UART_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspInit PROC
;;;709      */
;;;710    __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;711    {
;;;712      /* Prevent unused argument(s) compilation warning */
;;;713      UNUSED(huart);
;;;714      /* NOTE: This function should not be modified, when the callback is needed,
;;;715               the HAL_UART_MspInit could be implemented in the user file
;;;716       */
;;;717    }
;;;718    
                          ENDP


                          AREA ||i.HAL_UART_Receive||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive PROC
;;;1223     */
;;;1224   HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1225   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4699              MOV      r9,r3
;;;1226     uint8_t  *pdata8bits;
;;;1227     uint16_t *pdata16bits;
;;;1228     uint32_t tickstart = 0U;
00000c  f04f0a00          MOV      r10,#0
;;;1229   
;;;1230     /* Check that a Rx process is not already ongoing */
;;;1231     if (huart->RxState == HAL_UART_STATE_READY)
000010  f894003e          LDRB     r0,[r4,#0x3e]
000014  2820              CMP      r0,#0x20
000016  d15f              BNE      |L33.216|
;;;1232     {
;;;1233       if ((pData == NULL) || (Size == 0U))
000018  b106              CBZ      r6,|L33.28|
00001a  b917              CBNZ     r7,|L33.34|
                  |L33.28|
;;;1234       {
;;;1235         return  HAL_ERROR;
00001c  2001              MOVS     r0,#1
                  |L33.30|
;;;1236       }
;;;1237   
;;;1238       /* Process Locked */
;;;1239       __HAL_LOCK(huart);
;;;1240   
;;;1241       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1242       huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;1243       huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;1244   
;;;1245       /* Init tickstart for timeout management */
;;;1246       tickstart = HAL_GetTick();
;;;1247   
;;;1248       huart->RxXferSize = Size;
;;;1249       huart->RxXferCount = Size;
;;;1250   
;;;1251       /* In case of 9bits/No Parity transfer, pRxData needs to be handled as a uint16_t pointer */
;;;1252       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;1253       {
;;;1254         pdata8bits  = NULL;
;;;1255         pdata16bits = (uint16_t *) pData;
;;;1256       }
;;;1257       else
;;;1258       {
;;;1259         pdata8bits  = pData;
;;;1260         pdata16bits = NULL;
;;;1261       }
;;;1262   
;;;1263       /* Process Unlocked */
;;;1264       __HAL_UNLOCK(huart);
;;;1265   
;;;1266       /* Check the remain data to be received */
;;;1267       while (huart->RxXferCount > 0U)
;;;1268       {
;;;1269         if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;1270         {
;;;1271           return HAL_TIMEOUT;
;;;1272         }
;;;1273         if (pdata8bits == NULL)
;;;1274         {
;;;1275           *pdata16bits = (uint16_t)(huart->Instance->DR & 0x01FF);
;;;1276           pdata16bits++;
;;;1277         }
;;;1278         else
;;;1279         {
;;;1280           if ((huart->Init.WordLength == UART_WORDLENGTH_9B) || ((huart->Init.WordLength == UART_WORDLENGTH_8B) && (huart->Init.Parity == UART_PARITY_NONE)))
;;;1281           {
;;;1282             *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
;;;1283           }
;;;1284           else
;;;1285           {
;;;1286             *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
;;;1287           }
;;;1288           pdata8bits++;
;;;1289         }
;;;1290         huart->RxXferCount--;
;;;1291       }
;;;1292   
;;;1293       /* At end of Rx process, restore huart->RxState to Ready */
;;;1294       huart->RxState = HAL_UART_STATE_READY;
;;;1295   
;;;1296       return HAL_OK;
;;;1297     }
;;;1298     else
;;;1299     {
;;;1300       return HAL_BUSY;
;;;1301     }
;;;1302   }
00001e  e8bd8ff8          POP      {r3-r11,pc}
                  |L33.34|
000022  bf00              NOP                            ;1239
000024  f894003c          LDRB     r0,[r4,#0x3c]         ;1239
000028  2801              CMP      r0,#1                 ;1239
00002a  d101              BNE      |L33.48|
00002c  2002              MOVS     r0,#2                 ;1239
00002e  e7f6              B        |L33.30|
                  |L33.48|
000030  2001              MOVS     r0,#1                 ;1239
000032  f884003c          STRB     r0,[r4,#0x3c]         ;1239
000036  bf00              NOP                            ;1239
000038  2000              MOVS     r0,#0                 ;1241
00003a  6420              STR      r0,[r4,#0x40]         ;1241
00003c  2022              MOVS     r0,#0x22              ;1242
00003e  f884003e          STRB     r0,[r4,#0x3e]         ;1242
000042  2000              MOVS     r0,#0                 ;1243
000044  6320              STR      r0,[r4,#0x30]         ;1243
000046  f7fffffe          BL       HAL_GetTick
00004a  4682              MOV      r10,r0                ;1246
00004c  85a7              STRH     r7,[r4,#0x2c]         ;1248
00004e  85e7              STRH     r7,[r4,#0x2e]         ;1249
000050  68a0              LDR      r0,[r4,#8]            ;1252
000052  f5b05f80          CMP      r0,#0x1000            ;1252
000056  d104              BNE      |L33.98|
000058  6920              LDR      r0,[r4,#0x10]         ;1252
00005a  b910              CBNZ     r0,|L33.98|
00005c  2500              MOVS     r5,#0                 ;1254
00005e  46b0              MOV      r8,r6                 ;1255
000060  e002              B        |L33.104|
                  |L33.98|
000062  4635              MOV      r5,r6                 ;1259
000064  f04f0800          MOV      r8,#0                 ;1260
                  |L33.104|
000068  bf00              NOP                            ;1264
00006a  2000              MOVS     r0,#0                 ;1264
00006c  f884003c          STRB     r0,[r4,#0x3c]         ;1264
000070  bf00              NOP                            ;1264
000072  e029              B        |L33.200|
                  |L33.116|
000074  4653              MOV      r3,r10                ;1269
000076  2200              MOVS     r2,#0                 ;1269
000078  2120              MOVS     r1,#0x20              ;1269
00007a  4620              MOV      r0,r4                 ;1269
00007c  f8cd9000          STR      r9,[sp,#0]            ;1269
000080  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000084  b108              CBZ      r0,|L33.138|
000086  2003              MOVS     r0,#3                 ;1271
000088  e7c9              B        |L33.30|
                  |L33.138|
00008a  b945              CBNZ     r5,|L33.158|
00008c  6820              LDR      r0,[r4,#0]            ;1275
00008e  6840              LDR      r0,[r0,#4]            ;1275
000090  f3c00008          UBFX     r0,r0,#0,#9           ;1275
000094  f8a80000          STRH     r0,[r8,#0]            ;1275
000098  f1080802          ADD      r8,r8,#2              ;1276
00009c  e011              B        |L33.194|
                  |L33.158|
00009e  68a0              LDR      r0,[r4,#8]            ;1280
0000a0  f5b05f80          CMP      r0,#0x1000            ;1280
0000a4  d003              BEQ      |L33.174|
0000a6  68a0              LDR      r0,[r4,#8]            ;1280
0000a8  b928              CBNZ     r0,|L33.182|
0000aa  6920              LDR      r0,[r4,#0x10]         ;1280
0000ac  b918              CBNZ     r0,|L33.182|
                  |L33.174|
0000ae  6820              LDR      r0,[r4,#0]            ;1282
0000b0  6840              LDR      r0,[r0,#4]            ;1282
0000b2  7028              STRB     r0,[r5,#0]            ;1282
0000b4  e004              B        |L33.192|
                  |L33.182|
0000b6  6820              LDR      r0,[r4,#0]            ;1286
0000b8  6840              LDR      r0,[r0,#4]            ;1286
0000ba  f000007f          AND      r0,r0,#0x7f           ;1286
0000be  7028              STRB     r0,[r5,#0]            ;1286
                  |L33.192|
0000c0  1c6d              ADDS     r5,r5,#1              ;1288
                  |L33.194|
0000c2  8de0              LDRH     r0,[r4,#0x2e]         ;1290
0000c4  1e40              SUBS     r0,r0,#1              ;1290
0000c6  85e0              STRH     r0,[r4,#0x2e]         ;1290
                  |L33.200|
0000c8  8de0              LDRH     r0,[r4,#0x2e]         ;1267
0000ca  2800              CMP      r0,#0                 ;1267
0000cc  d1d2              BNE      |L33.116|
0000ce  2020              MOVS     r0,#0x20              ;1294
0000d0  f884003e          STRB     r0,[r4,#0x3e]         ;1294
0000d4  2000              MOVS     r0,#0                 ;1296
0000d6  e7a2              B        |L33.30|
                  |L33.216|
0000d8  2002              MOVS     r0,#2                 ;1300
0000da  e7a0              B        |L33.30|
;;;1303   
                          ENDP


                          AREA ||i.HAL_UART_Receive_DMA||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive_DMA PROC
;;;1462     */
;;;1463   HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;1464   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1465     /* Check that a Rx process is not already ongoing */
;;;1466     if (huart->RxState == HAL_UART_STATE_READY)
000008  f894003e          LDRB     r0,[r4,#0x3e]
00000c  2820              CMP      r0,#0x20
00000e  d116              BNE      |L34.62|
;;;1467     {
;;;1468       if ((pData == NULL) || (Size == 0U))
000010  b105              CBZ      r5,|L34.20|
000012  b90e              CBNZ     r6,|L34.24|
                  |L34.20|
;;;1469       {
;;;1470         return HAL_ERROR;
000014  2001              MOVS     r0,#1
                  |L34.22|
;;;1471       }
;;;1472   
;;;1473       /* Process Locked */
;;;1474       __HAL_LOCK(huart);
;;;1475   
;;;1476       /* Set Reception type to Standard reception */
;;;1477       huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;1478   
;;;1479       return (UART_Start_Receive_DMA(huart, pData, Size));
;;;1480     }
;;;1481     else
;;;1482     {
;;;1483       return HAL_BUSY;
;;;1484     }
;;;1485   }
000016  bd70              POP      {r4-r6,pc}
                  |L34.24|
000018  bf00              NOP                            ;1474
00001a  f894003c          LDRB     r0,[r4,#0x3c]         ;1474
00001e  2801              CMP      r0,#1                 ;1474
000020  d101              BNE      |L34.38|
000022  2002              MOVS     r0,#2                 ;1474
000024  e7f7              B        |L34.22|
                  |L34.38|
000026  2001              MOVS     r0,#1                 ;1474
000028  f884003c          STRB     r0,[r4,#0x3c]         ;1474
00002c  bf00              NOP                            ;1474
00002e  2000              MOVS     r0,#0                 ;1477
000030  6320              STR      r0,[r4,#0x30]         ;1477
000032  4632              MOV      r2,r6                 ;1479
000034  4629              MOV      r1,r5                 ;1479
000036  4620              MOV      r0,r4                 ;1479
000038  f7fffffe          BL       UART_Start_Receive_DMA
00003c  e7eb              B        |L34.22|
                  |L34.62|
00003e  2002              MOVS     r0,#2                 ;1483
000040  e7e9              B        |L34.22|
;;;1486   
                          ENDP


                          AREA ||i.HAL_UART_Receive_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive_IT PROC
;;;1359     */
;;;1360   HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;1361   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1362     /* Check that a Rx process is not already ongoing */
;;;1363     if (huart->RxState == HAL_UART_STATE_READY)
000008  f894003e          LDRB     r0,[r4,#0x3e]
00000c  2820              CMP      r0,#0x20
00000e  d116              BNE      |L35.62|
;;;1364     {
;;;1365       if ((pData == NULL) || (Size == 0U))
000010  b105              CBZ      r5,|L35.20|
000012  b90e              CBNZ     r6,|L35.24|
                  |L35.20|
;;;1366       {
;;;1367         return HAL_ERROR;
000014  2001              MOVS     r0,#1
                  |L35.22|
;;;1368       }
;;;1369   
;;;1370       /* Process Locked */
;;;1371       __HAL_LOCK(huart);
;;;1372   
;;;1373       /* Set Reception type to Standard reception */
;;;1374       huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;1375   
;;;1376       return (UART_Start_Receive_IT(huart, pData, Size));
;;;1377     }
;;;1378     else
;;;1379     {
;;;1380       return HAL_BUSY;
;;;1381     }
;;;1382   }
000016  bd70              POP      {r4-r6,pc}
                  |L35.24|
000018  bf00              NOP                            ;1371
00001a  f894003c          LDRB     r0,[r4,#0x3c]         ;1371
00001e  2801              CMP      r0,#1                 ;1371
000020  d101              BNE      |L35.38|
000022  2002              MOVS     r0,#2                 ;1371
000024  e7f7              B        |L35.22|
                  |L35.38|
000026  2001              MOVS     r0,#1                 ;1371
000028  f884003c          STRB     r0,[r4,#0x3c]         ;1371
00002c  bf00              NOP                            ;1371
00002e  2000              MOVS     r0,#0                 ;1374
000030  6320              STR      r0,[r4,#0x30]         ;1374
000032  4632              MOV      r2,r6                 ;1376
000034  4629              MOV      r1,r5                 ;1376
000036  4620              MOV      r0,r4                 ;1376
000038  f7fffffe          BL       UART_Start_Receive_IT
00003c  e7eb              B        |L35.22|
                  |L35.62|
00003e  2002              MOVS     r0,#2                 ;1380
000040  e7e9              B        |L35.22|
;;;1383   
                          ENDP


                          AREA ||i.HAL_UART_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxCpltCallback PROC
;;;2621     */
;;;2622   __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2623   {
;;;2624     /* Prevent unused argument(s) compilation warning */
;;;2625     UNUSED(huart);
;;;2626     /* NOTE: This function should not be modified, when the callback is needed,
;;;2627              the HAL_UART_RxCpltCallback could be implemented in the user file
;;;2628      */
;;;2629   }
;;;2630   
                          ENDP


                          AREA ||i.HAL_UART_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxHalfCpltCallback PROC
;;;2636     */
;;;2637   __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2638   {
;;;2639     /* Prevent unused argument(s) compilation warning */
;;;2640     UNUSED(huart);
;;;2641     /* NOTE: This function should not be modified, when the callback is needed,
;;;2642              the HAL_UART_RxHalfCpltCallback could be implemented in the user file
;;;2643      */
;;;2644   }
;;;2645   
                          ENDP


                          AREA ||i.HAL_UART_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit PROC
;;;1135     */
;;;1136   HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1137   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4699              MOV      r9,r3
;;;1138     const uint8_t  *pdata8bits;
;;;1139     const uint16_t *pdata16bits;
;;;1140     uint32_t tickstart = 0U;
00000c  f04f0a00          MOV      r10,#0
;;;1141   
;;;1142     /* Check that a Tx process is not already ongoing */
;;;1143     if (huart->gState == HAL_UART_STATE_READY)
000010  f894003d          LDRB     r0,[r4,#0x3d]
000014  2820              CMP      r0,#0x20
000016  d15a              BNE      |L38.206|
;;;1144     {
;;;1145       if ((pData == NULL) || (Size == 0U))
000018  b106              CBZ      r6,|L38.28|
00001a  b917              CBNZ     r7,|L38.34|
                  |L38.28|
;;;1146       {
;;;1147         return  HAL_ERROR;
00001c  2001              MOVS     r0,#1
                  |L38.30|
;;;1148       }
;;;1149   
;;;1150       /* Process Locked */
;;;1151       __HAL_LOCK(huart);
;;;1152   
;;;1153       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1154       huart->gState = HAL_UART_STATE_BUSY_TX;
;;;1155   
;;;1156       /* Init tickstart for timeout management */
;;;1157       tickstart = HAL_GetTick();
;;;1158   
;;;1159       huart->TxXferSize = Size;
;;;1160       huart->TxXferCount = Size;
;;;1161   
;;;1162       /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
;;;1163       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;1164       {
;;;1165         pdata8bits  = NULL;
;;;1166         pdata16bits = (const uint16_t *) pData;
;;;1167       }
;;;1168       else
;;;1169       {
;;;1170         pdata8bits  = pData;
;;;1171         pdata16bits = NULL;
;;;1172       }
;;;1173   
;;;1174       /* Process Unlocked */
;;;1175       __HAL_UNLOCK(huart);
;;;1176   
;;;1177       while (huart->TxXferCount > 0U)
;;;1178       {
;;;1179         if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;1180         {
;;;1181           return HAL_TIMEOUT;
;;;1182         }
;;;1183         if (pdata8bits == NULL)
;;;1184         {
;;;1185           huart->Instance->DR = (uint16_t)(*pdata16bits & 0x01FFU);
;;;1186           pdata16bits++;
;;;1187         }
;;;1188         else
;;;1189         {
;;;1190           huart->Instance->DR = (uint8_t)(*pdata8bits & 0xFFU);
;;;1191           pdata8bits++;
;;;1192         }
;;;1193         huart->TxXferCount--;
;;;1194       }
;;;1195   
;;;1196       if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;1197       {
;;;1198         return HAL_TIMEOUT;
;;;1199       }
;;;1200   
;;;1201       /* At end of Tx process, restore huart->gState to Ready */
;;;1202       huart->gState = HAL_UART_STATE_READY;
;;;1203   
;;;1204       return HAL_OK;
;;;1205     }
;;;1206     else
;;;1207     {
;;;1208       return HAL_BUSY;
;;;1209     }
;;;1210   }
00001e  e8bd8ff8          POP      {r3-r11,pc}
                  |L38.34|
000022  bf00              NOP                            ;1151
000024  f894003c          LDRB     r0,[r4,#0x3c]         ;1151
000028  2801              CMP      r0,#1                 ;1151
00002a  d101              BNE      |L38.48|
00002c  2002              MOVS     r0,#2                 ;1151
00002e  e7f6              B        |L38.30|
                  |L38.48|
000030  2001              MOVS     r0,#1                 ;1151
000032  f884003c          STRB     r0,[r4,#0x3c]         ;1151
000036  bf00              NOP                            ;1151
000038  2000              MOVS     r0,#0                 ;1153
00003a  6420              STR      r0,[r4,#0x40]         ;1153
00003c  2021              MOVS     r0,#0x21              ;1154
00003e  f884003d          STRB     r0,[r4,#0x3d]         ;1154
000042  f7fffffe          BL       HAL_GetTick
000046  4682              MOV      r10,r0                ;1157
000048  84a7              STRH     r7,[r4,#0x24]         ;1159
00004a  84e7              STRH     r7,[r4,#0x26]         ;1160
00004c  68a0              LDR      r0,[r4,#8]            ;1163
00004e  f5b05f80          CMP      r0,#0x1000            ;1163
000052  d104              BNE      |L38.94|
000054  6920              LDR      r0,[r4,#0x10]         ;1163
000056  b910              CBNZ     r0,|L38.94|
000058  2500              MOVS     r5,#0                 ;1165
00005a  46b0              MOV      r8,r6                 ;1166
00005c  e002              B        |L38.100|
                  |L38.94|
00005e  4635              MOV      r5,r6                 ;1170
000060  f04f0800          MOV      r8,#0                 ;1171
                  |L38.100|
000064  bf00              NOP                            ;1175
000066  2000              MOVS     r0,#0                 ;1175
000068  f884003c          STRB     r0,[r4,#0x3c]         ;1175
00006c  bf00              NOP                            ;1175
00006e  e01b              B        |L38.168|
                  |L38.112|
000070  4653              MOV      r3,r10                ;1179
000072  2200              MOVS     r2,#0                 ;1179
000074  2180              MOVS     r1,#0x80              ;1179
000076  4620              MOV      r0,r4                 ;1179
000078  f8cd9000          STR      r9,[sp,#0]            ;1179
00007c  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000080  b108              CBZ      r0,|L38.134|
000082  2003              MOVS     r0,#3                 ;1181
000084  e7cb              B        |L38.30|
                  |L38.134|
000086  b945              CBNZ     r5,|L38.154|
000088  f8b80000          LDRH     r0,[r8,#0]            ;1185
00008c  f3c00008          UBFX     r0,r0,#0,#9           ;1185
000090  6821              LDR      r1,[r4,#0]            ;1185
000092  6048              STR      r0,[r1,#4]            ;1185
000094  f1080802          ADD      r8,r8,#2              ;1186
000098  e003              B        |L38.162|
                  |L38.154|
00009a  7828              LDRB     r0,[r5,#0]            ;1190
00009c  6821              LDR      r1,[r4,#0]            ;1190
00009e  6048              STR      r0,[r1,#4]            ;1190
0000a0  1c6d              ADDS     r5,r5,#1              ;1191
                  |L38.162|
0000a2  8ce0              LDRH     r0,[r4,#0x26]         ;1193
0000a4  1e40              SUBS     r0,r0,#1              ;1193
0000a6  84e0              STRH     r0,[r4,#0x26]         ;1193
                  |L38.168|
0000a8  8ce0              LDRH     r0,[r4,#0x26]         ;1177
0000aa  2800              CMP      r0,#0                 ;1177
0000ac  d1e0              BNE      |L38.112|
0000ae  4653              MOV      r3,r10                ;1196
0000b0  2200              MOVS     r2,#0                 ;1196
0000b2  2140              MOVS     r1,#0x40              ;1196
0000b4  4620              MOV      r0,r4                 ;1196
0000b6  f8cd9000          STR      r9,[sp,#0]            ;1196
0000ba  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
0000be  b108              CBZ      r0,|L38.196|
0000c0  2003              MOVS     r0,#3                 ;1198
0000c2  e7ac              B        |L38.30|
                  |L38.196|
0000c4  2020              MOVS     r0,#0x20              ;1202
0000c6  f884003d          STRB     r0,[r4,#0x3d]         ;1202
0000ca  2000              MOVS     r0,#0                 ;1204
0000cc  e7a7              B        |L38.30|
                  |L38.206|
0000ce  2002              MOVS     r0,#2                 ;1208
0000d0  e7a5              B        |L38.30|
;;;1211   
                          ENDP


                          AREA ||i.HAL_UART_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit_DMA PROC
;;;1394     */
;;;1395   HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;1396   {
000002  4604              MOV      r4,r0
000004  4615              MOV      r5,r2
;;;1397     const uint32_t *tmp;
;;;1398   
;;;1399     /* Check that a Tx process is not already ongoing */
;;;1400     if (huart->gState == HAL_UART_STATE_READY)
000006  f894003d          LDRB     r0,[r4,#0x3d]
00000a  2820              CMP      r0,#0x20
00000c  d146              BNE      |L39.156|
;;;1401     {
;;;1402       if ((pData == NULL) || (Size == 0U))
00000e  9801              LDR      r0,[sp,#4]
000010  b100              CBZ      r0,|L39.20|
000012  b90d              CBNZ     r5,|L39.24|
                  |L39.20|
;;;1403       {
;;;1404         return HAL_ERROR;
000014  2001              MOVS     r0,#1
                  |L39.22|
;;;1405       }
;;;1406   
;;;1407       /* Process Locked */
;;;1408       __HAL_LOCK(huart);
;;;1409   
;;;1410       huart->pTxBuffPtr = pData;
;;;1411       huart->TxXferSize = Size;
;;;1412       huart->TxXferCount = Size;
;;;1413   
;;;1414       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1415       huart->gState = HAL_UART_STATE_BUSY_TX;
;;;1416   
;;;1417       /* Set the UART DMA transfer complete callback */
;;;1418       huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
;;;1419   
;;;1420       /* Set the UART DMA Half transfer complete callback */
;;;1421       huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
;;;1422   
;;;1423       /* Set the DMA error callback */
;;;1424       huart->hdmatx->XferErrorCallback = UART_DMAError;
;;;1425   
;;;1426       /* Set the DMA abort callback */
;;;1427       huart->hdmatx->XferAbortCallback = NULL;
;;;1428   
;;;1429       /* Enable the UART transmit DMA stream */
;;;1430       tmp = (const uint32_t *)&pData;
;;;1431       HAL_DMA_Start_IT(huart->hdmatx, *(const uint32_t *)tmp, (uint32_t)&huart->Instance->DR, Size);
;;;1432   
;;;1433       /* Clear the TC flag in the SR register by writing 0 to it */
;;;1434       __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
;;;1435   
;;;1436       /* Process Unlocked */
;;;1437       __HAL_UNLOCK(huart);
;;;1438   
;;;1439       /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;1440          in the UART CR3 register */
;;;1441       ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1442   
;;;1443       return HAL_OK;
;;;1444     }
;;;1445     else
;;;1446     {
;;;1447       return HAL_BUSY;
;;;1448     }
;;;1449   }
000016  bdfe              POP      {r1-r7,pc}
                  |L39.24|
000018  bf00              NOP                            ;1408
00001a  f894003c          LDRB     r0,[r4,#0x3c]         ;1408
00001e  2801              CMP      r0,#1                 ;1408
000020  d101              BNE      |L39.38|
000022  2002              MOVS     r0,#2                 ;1408
000024  e7f7              B        |L39.22|
                  |L39.38|
000026  2001              MOVS     r0,#1                 ;1408
000028  f884003c          STRB     r0,[r4,#0x3c]         ;1408
00002c  bf00              NOP                            ;1408
00002e  9801              LDR      r0,[sp,#4]            ;1410
000030  6220              STR      r0,[r4,#0x20]         ;1410
000032  84a5              STRH     r5,[r4,#0x24]         ;1411
000034  84e5              STRH     r5,[r4,#0x26]         ;1412
000036  2000              MOVS     r0,#0                 ;1414
000038  6420              STR      r0,[r4,#0x40]         ;1414
00003a  2021              MOVS     r0,#0x21              ;1415
00003c  f884003d          STRB     r0,[r4,#0x3d]         ;1415
000040  4817              LDR      r0,|L39.160|
000042  6b61              LDR      r1,[r4,#0x34]         ;1418
000044  63c8              STR      r0,[r1,#0x3c]         ;1418
000046  4817              LDR      r0,|L39.164|
000048  6b61              LDR      r1,[r4,#0x34]         ;1421
00004a  6408              STR      r0,[r1,#0x40]         ;1421
00004c  4816              LDR      r0,|L39.168|
00004e  6b61              LDR      r1,[r4,#0x34]         ;1424
000050  64c8              STR      r0,[r1,#0x4c]         ;1424
000052  2000              MOVS     r0,#0                 ;1427
000054  6b61              LDR      r1,[r4,#0x34]         ;1427
000056  6508              STR      r0,[r1,#0x50]         ;1427
000058  ae01              ADD      r6,sp,#4              ;1430
00005a  6823              LDR      r3,[r4,#0]            ;1431
00005c  1d1a              ADDS     r2,r3,#4              ;1431
00005e  6831              LDR      r1,[r6,#0]            ;1431
000060  462b              MOV      r3,r5                 ;1431
000062  6b60              LDR      r0,[r4,#0x34]         ;1431
000064  f7fffffe          BL       HAL_DMA_Start_IT
000068  f06f0040          MVN      r0,#0x40              ;1434
00006c  6821              LDR      r1,[r4,#0]            ;1434
00006e  6008              STR      r0,[r1,#0]            ;1434
000070  bf00              NOP                            ;1437
000072  2000              MOVS     r0,#0                 ;1437
000074  f884003c          STRB     r0,[r4,#0x3c]         ;1437
000078  bf00              NOP                            ;1437
00007a  bf00              NOP                            ;1441
00007c  bf00              NOP                            ;1441
                  |L39.126|
00007e  6821              LDR      r1,[r4,#0]            ;1441
000080  3114              ADDS     r1,r1,#0x14           ;1441
000082  e8511f00          LDREX    r1,[r1,#0]            ;1441
000086  f0410080          ORR      r0,r1,#0x80           ;1441
00008a  6821              LDR      r1,[r4,#0]            ;1441
00008c  3114              ADDS     r1,r1,#0x14           ;1441
00008e  e8410200          STREX    r2,r0,[r1,#0]         ;1441
000092  2a00              CMP      r2,#0                 ;1441
000094  d1f3              BNE      |L39.126|
000096  bf00              NOP                            ;1441
000098  2000              MOVS     r0,#0                 ;1443
00009a  e7bc              B        |L39.22|
                  |L39.156|
00009c  2002              MOVS     r0,#2                 ;1447
00009e  e7ba              B        |L39.22|
;;;1450   
                          ENDP

                  |L39.160|
                          DCD      UART_DMATransmitCplt
                  |L39.164|
                          DCD      UART_DMATxHalfCplt
                  |L39.168|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit_IT PROC
;;;1314     */
;;;1315   HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;1316   {
000002  4603              MOV      r3,r0
;;;1317     /* Check that a Tx process is not already ongoing */
;;;1318     if (huart->gState == HAL_UART_STATE_READY)
000004  f893003d          LDRB     r0,[r3,#0x3d]
000008  2820              CMP      r0,#0x20
00000a  d123              BNE      |L40.84|
;;;1319     {
;;;1320       if ((pData == NULL) || (Size == 0U))
00000c  b101              CBZ      r1,|L40.16|
00000e  b90a              CBNZ     r2,|L40.20|
                  |L40.16|
;;;1321       {
;;;1322         return HAL_ERROR;
000010  2001              MOVS     r0,#1
                  |L40.18|
;;;1323       }
;;;1324   
;;;1325       /* Process Locked */
;;;1326       __HAL_LOCK(huart);
;;;1327   
;;;1328       huart->pTxBuffPtr = pData;
;;;1329       huart->TxXferSize = Size;
;;;1330       huart->TxXferCount = Size;
;;;1331   
;;;1332       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1333       huart->gState = HAL_UART_STATE_BUSY_TX;
;;;1334   
;;;1335       /* Process Unlocked */
;;;1336       __HAL_UNLOCK(huart);
;;;1337   
;;;1338       /* Enable the UART Transmit data register empty Interrupt */
;;;1339       __HAL_UART_ENABLE_IT(huart, UART_IT_TXE);
;;;1340   
;;;1341       return HAL_OK;
;;;1342     }
;;;1343     else
;;;1344     {
;;;1345       return HAL_BUSY;
;;;1346     }
;;;1347   }
000012  bd10              POP      {r4,pc}
                  |L40.20|
000014  bf00              NOP                            ;1326
000016  f893003c          LDRB     r0,[r3,#0x3c]         ;1326
00001a  2801              CMP      r0,#1                 ;1326
00001c  d101              BNE      |L40.34|
00001e  2002              MOVS     r0,#2                 ;1326
000020  e7f7              B        |L40.18|
                  |L40.34|
000022  2001              MOVS     r0,#1                 ;1326
000024  f883003c          STRB     r0,[r3,#0x3c]         ;1326
000028  bf00              NOP                            ;1326
00002a  6219              STR      r1,[r3,#0x20]         ;1328
00002c  849a              STRH     r2,[r3,#0x24]         ;1329
00002e  84da              STRH     r2,[r3,#0x26]         ;1330
000030  2000              MOVS     r0,#0                 ;1332
000032  6418              STR      r0,[r3,#0x40]         ;1332
000034  2021              MOVS     r0,#0x21              ;1333
000036  f883003d          STRB     r0,[r3,#0x3d]         ;1333
00003a  bf00              NOP                            ;1336
00003c  2000              MOVS     r0,#0                 ;1336
00003e  f883003c          STRB     r0,[r3,#0x3c]         ;1336
000042  bf00              NOP                            ;1336
000044  6818              LDR      r0,[r3,#0]            ;1339
000046  68c0              LDR      r0,[r0,#0xc]          ;1339
000048  f0400080          ORR      r0,r0,#0x80           ;1339
00004c  681c              LDR      r4,[r3,#0]            ;1339
00004e  60e0              STR      r0,[r4,#0xc]          ;1339
000050  2000              MOVS     r0,#0                 ;1341
000052  e7de              B        |L40.18|
                  |L40.84|
000054  2002              MOVS     r0,#2                 ;1345
000056  e7dc              B        |L40.18|
;;;1348   
                          ENDP


                          AREA ||i.HAL_UART_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxCpltCallback PROC
;;;2591     */
;;;2592   __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2593   {
;;;2594     /* Prevent unused argument(s) compilation warning */
;;;2595     UNUSED(huart);
;;;2596     /* NOTE: This function should not be modified, when the callback is needed,
;;;2597              the HAL_UART_TxCpltCallback could be implemented in the user file
;;;2598      */
;;;2599   }
;;;2600   
                          ENDP


                          AREA ||i.HAL_UART_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxHalfCpltCallback PROC
;;;2606     */
;;;2607   __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2608   {
;;;2609     /* Prevent unused argument(s) compilation warning */
;;;2610     UNUSED(huart);
;;;2611     /* NOTE: This function should not be modified, when the callback is needed,
;;;2612              the HAL_UART_TxHalfCpltCallback could be implemented in the user file
;;;2613      */
;;;2614   }
;;;2615   
                          ENDP


                          AREA ||i.UART_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  UART_DMAAbortOnError PROC
;;;3341     */
;;;3342   static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;3343   {
000002  4605              MOV      r5,r0
;;;3344     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;3345     huart->RxXferCount = 0x00U;
000006  2000              MOVS     r0,#0
000008  85e0              STRH     r0,[r4,#0x2e]
;;;3346     huart->TxXferCount = 0x00U;
00000a  84e0              STRH     r0,[r4,#0x26]
;;;3347   
;;;3348   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3349     /*Call registered error callback*/
;;;3350     huart->ErrorCallback(huart);
;;;3351   #else
;;;3352     /*Call legacy weak error callback*/
;;;3353     HAL_UART_ErrorCallback(huart);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       HAL_UART_ErrorCallback
;;;3354   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3355   }
000012  bd70              POP      {r4-r6,pc}
;;;3356   
                          ENDP


                          AREA ||i.UART_DMAError||, CODE, READONLY, ALIGN=1

                  UART_DMAError PROC
;;;3131     */
;;;3132   static void UART_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;3133   {
000002  4606              MOV      r6,r0
;;;3134     uint32_t dmarequest = 0x00U;
000004  2500              MOVS     r5,#0
;;;3135     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000006  6bb4              LDR      r4,[r6,#0x38]
;;;3136   
;;;3137     /* Stop UART DMA Tx request if ongoing */
;;;3138     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
000008  6820              LDR      r0,[r4,#0]
00000a  6940              LDR      r0,[r0,#0x14]
00000c  f3c015c0          UBFX     r5,r0,#7,#1
;;;3139     if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
000010  f894003d          LDRB     r0,[r4,#0x3d]
000014  2821              CMP      r0,#0x21
000016  d105              BNE      |L44.36|
000018  b125              CBZ      r5,|L44.36|
;;;3140     {
;;;3141       huart->TxXferCount = 0x00U;
00001a  2000              MOVS     r0,#0
00001c  84e0              STRH     r0,[r4,#0x26]
;;;3142       UART_EndTxTransfer(huart);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       UART_EndTxTransfer
                  |L44.36|
;;;3143     }
;;;3144   
;;;3145     /* Stop UART DMA Rx request if ongoing */
;;;3146     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
000024  6820              LDR      r0,[r4,#0]
000026  6940              LDR      r0,[r0,#0x14]
000028  f3c01580          UBFX     r5,r0,#6,#1
;;;3147     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
00002c  f894003e          LDRB     r0,[r4,#0x3e]
000030  2822              CMP      r0,#0x22
000032  d105              BNE      |L44.64|
000034  b125              CBZ      r5,|L44.64|
;;;3148     {
;;;3149       huart->RxXferCount = 0x00U;
000036  2000              MOVS     r0,#0
000038  85e0              STRH     r0,[r4,#0x2e]
;;;3150       UART_EndRxTransfer(huart);
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       UART_EndRxTransfer
                  |L44.64|
;;;3151     }
;;;3152   
;;;3153     huart->ErrorCode |= HAL_UART_ERROR_DMA;
000040  6c20              LDR      r0,[r4,#0x40]
000042  f0400010          ORR      r0,r0,#0x10
000046  6420              STR      r0,[r4,#0x40]
;;;3154   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3155     /*Call registered error callback*/
;;;3156     huart->ErrorCallback(huart);
;;;3157   #else
;;;3158     /*Call legacy weak error callback*/
;;;3159     HAL_UART_ErrorCallback(huart);
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       HAL_UART_ErrorCallback
;;;3160   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3161   }
00004e  bd70              POP      {r4-r6,pc}
;;;3162   
                          ENDP


                          AREA ||i.UART_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  UART_DMAReceiveCplt PROC
;;;3039     */
;;;3040   static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;3041   {
000002  4605              MOV      r5,r0
;;;3042     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;3043     /* DMA Normal mode*/
;;;3044     if ((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
000006  6828              LDR      r0,[r5,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  f4007080          AND      r0,r0,#0x100
00000e  2800              CMP      r0,#0
000010  d142              BNE      |L45.152|
;;;3045     {
;;;3046       huart->RxXferCount = 0U;
000012  85e0              STRH     r0,[r4,#0x2e]
;;;3047   
;;;3048       /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;3049       ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
000014  bf00              NOP      
000016  bf00              NOP      
                  |L45.24|
000018  6821              LDR      r1,[r4,#0]
00001a  310c              ADDS     r1,r1,#0xc
00001c  e8511f00          LDREX    r1,[r1,#0]
000020  f4217080          BIC      r0,r1,#0x100
000024  6821              LDR      r1,[r4,#0]
000026  310c              ADDS     r1,r1,#0xc
000028  e8410200          STREX    r2,r0,[r1,#0]
00002c  2a00              CMP      r2,#0
00002e  d1f3              BNE      |L45.24|
000030  bf00              NOP      
;;;3050       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000032  bf00              NOP      
000034  bf00              NOP      
                  |L45.54|
000036  6821              LDR      r1,[r4,#0]
000038  3114              ADDS     r1,r1,#0x14
00003a  e8511f00          LDREX    r1,[r1,#0]
00003e  f0210001          BIC      r0,r1,#1
000042  6821              LDR      r1,[r4,#0]
000044  3114              ADDS     r1,r1,#0x14
000046  e8410200          STREX    r2,r0,[r1,#0]
00004a  2a00              CMP      r2,#0
00004c  d1f3              BNE      |L45.54|
00004e  bf00              NOP      
;;;3051   
;;;3052       /* Disable the DMA transfer for the receiver request by setting the DMAR bit
;;;3053          in the UART CR3 register */
;;;3054       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000050  bf00              NOP      
000052  bf00              NOP      
                  |L45.84|
000054  6821              LDR      r1,[r4,#0]
000056  3114              ADDS     r1,r1,#0x14
000058  e8511f00          LDREX    r1,[r1,#0]
00005c  f0210040          BIC      r0,r1,#0x40
000060  6821              LDR      r1,[r4,#0]
000062  3114              ADDS     r1,r1,#0x14
000064  e8410200          STREX    r2,r0,[r1,#0]
000068  2a00              CMP      r2,#0
00006a  d1f3              BNE      |L45.84|
00006c  bf00              NOP      
;;;3055   
;;;3056       /* At end of Rx process, restore huart->RxState to Ready */
;;;3057       huart->RxState = HAL_UART_STATE_READY;
00006e  2020              MOVS     r0,#0x20
000070  f884003e          STRB     r0,[r4,#0x3e]
;;;3058   
;;;3059       /* If Reception till IDLE event has been selected, Disable IDLE Interrupt */
;;;3060       if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
000074  6b20              LDR      r0,[r4,#0x30]
000076  2801              CMP      r0,#1
000078  d10e              BNE      |L45.152|
;;;3061       {
;;;3062         ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
00007a  bf00              NOP      
00007c  bf00              NOP      
                  |L45.126|
00007e  6821              LDR      r1,[r4,#0]
000080  310c              ADDS     r1,r1,#0xc
000082  e8511f00          LDREX    r1,[r1,#0]
000086  f0210010          BIC      r0,r1,#0x10
00008a  6821              LDR      r1,[r4,#0]
00008c  310c              ADDS     r1,r1,#0xc
00008e  e8410200          STREX    r2,r0,[r1,#0]
000092  2a00              CMP      r2,#0
000094  d1f3              BNE      |L45.126|
000096  bf00              NOP      
                  |L45.152|
;;;3063       }
;;;3064     }
;;;3065   
;;;3066     /* Check current reception Mode :
;;;3067        If Reception till IDLE event has been selected : use Rx Event callback */
;;;3068     if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
000098  6b20              LDR      r0,[r4,#0x30]
00009a  2801              CMP      r0,#1
00009c  d104              BNE      |L45.168|
;;;3069     {
;;;3070   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3071       /*Call registered Rx Event callback*/
;;;3072       huart->RxEventCallback(huart, huart->RxXferSize);
;;;3073   #else
;;;3074       /*Call legacy weak Rx Event callback*/
;;;3075       HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
00009e  8da1              LDRH     r1,[r4,#0x2c]
0000a0  4620              MOV      r0,r4
0000a2  f7fffffe          BL       HAL_UARTEx_RxEventCallback
0000a6  e002              B        |L45.174|
                  |L45.168|
;;;3076   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3077     }
;;;3078     else
;;;3079     {
;;;3080       /* In other cases : use Rx Complete callback */
;;;3081   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3082       /*Call registered Rx complete callback*/
;;;3083       huart->RxCpltCallback(huart);
;;;3084   #else
;;;3085       /*Call legacy weak Rx complete callback*/
;;;3086       HAL_UART_RxCpltCallback(huart);
0000a8  4620              MOV      r0,r4
0000aa  f7fffffe          BL       HAL_UART_RxCpltCallback
                  |L45.174|
;;;3087   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3088     }
;;;3089   }
0000ae  bd70              POP      {r4-r6,pc}
;;;3090   
                          ENDP


                          AREA ||i.UART_DMARxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxAbortCallback PROC
;;;3411     */
;;;3412   static void UART_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;3413   {
000002  4605              MOV      r5,r0
;;;3414     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;3415   
;;;3416     huart->hdmarx->XferAbortCallback = NULL;
000006  2000              MOVS     r0,#0
000008  6ba1              LDR      r1,[r4,#0x38]
00000a  6508              STR      r0,[r1,#0x50]
;;;3417   
;;;3418     /* Check if an Abort process is still ongoing */
;;;3419     if (huart->hdmatx != NULL)
00000c  6b60              LDR      r0,[r4,#0x34]
00000e  b118              CBZ      r0,|L46.24|
;;;3420     {
;;;3421       if (huart->hdmatx->XferAbortCallback != NULL)
000010  6b60              LDR      r0,[r4,#0x34]
000012  6d00              LDR      r0,[r0,#0x50]
000014  b100              CBZ      r0,|L46.24|
                  |L46.22|
;;;3422       {
;;;3423         return;
;;;3424       }
;;;3425     }
;;;3426   
;;;3427     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;3428     huart->TxXferCount = 0x00U;
;;;3429     huart->RxXferCount = 0x00U;
;;;3430   
;;;3431     /* Reset ErrorCode */
;;;3432     huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;3433   
;;;3434     /* Restore huart->gState and huart->RxState to Ready */
;;;3435     huart->gState  = HAL_UART_STATE_READY;
;;;3436     huart->RxState = HAL_UART_STATE_READY;
;;;3437     huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;3438   
;;;3439     /* Call user Abort complete callback */
;;;3440   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3441     /* Call registered Abort complete callback */
;;;3442     huart->AbortCpltCallback(huart);
;;;3443   #else
;;;3444     /* Call legacy weak Abort complete callback */
;;;3445     HAL_UART_AbortCpltCallback(huart);
;;;3446   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3447   }
000016  bd70              POP      {r4-r6,pc}
                  |L46.24|
000018  2000              MOVS     r0,#0                 ;3428
00001a  84e0              STRH     r0,[r4,#0x26]         ;3428
00001c  85e0              STRH     r0,[r4,#0x2e]         ;3429
00001e  6420              STR      r0,[r4,#0x40]         ;3432
000020  2020              MOVS     r0,#0x20              ;3435
000022  f884003d          STRB     r0,[r4,#0x3d]         ;3435
000026  f884003e          STRB     r0,[r4,#0x3e]         ;3436
00002a  2000              MOVS     r0,#0                 ;3437
00002c  6320              STR      r0,[r4,#0x30]         ;3437
00002e  4620              MOV      r0,r4                 ;3445
000030  f7fffffe          BL       HAL_UART_AbortCpltCallback
000034  bf00              NOP      
000036  e7ee              B        |L46.22|
;;;3448   
                          ENDP


                          AREA ||i.UART_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMARxHalfCplt PROC
;;;3096     */
;;;3097   static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;3098   {
000002  4605              MOV      r5,r0
;;;3099     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;3100   
;;;3101     /* Check current reception Mode :
;;;3102        If Reception till IDLE event has been selected : use Rx Event callback */
;;;3103     if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
000006  6b20              LDR      r0,[r4,#0x30]
000008  2801              CMP      r0,#1
00000a  d105              BNE      |L47.24|
;;;3104     {
;;;3105   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3106       /*Call registered Rx Event callback*/
;;;3107       huart->RxEventCallback(huart, huart->RxXferSize / 2U);
;;;3108   #else
;;;3109       /*Call legacy weak Rx Event callback*/
;;;3110       HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize / 2U);
00000c  8da0              LDRH     r0,[r4,#0x2c]
00000e  0841              LSRS     r1,r0,#1
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       HAL_UARTEx_RxEventCallback
000016  e002              B        |L47.30|
                  |L47.24|
;;;3111   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3112     }
;;;3113     else
;;;3114     {
;;;3115       /* In other cases : use Rx Half Complete callback */
;;;3116   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3117       /*Call registered Rx Half complete callback*/
;;;3118       huart->RxHalfCpltCallback(huart);
;;;3119   #else
;;;3120       /*Call legacy weak Rx Half complete callback*/
;;;3121       HAL_UART_RxHalfCpltCallback(huart);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       HAL_UART_RxHalfCpltCallback
                  |L47.30|
;;;3122   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3123     }
;;;3124   }
00001e  bd70              POP      {r4-r6,pc}
;;;3125   
                          ENDP


                          AREA ||i.UART_DMARxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxOnlyAbortCallback PROC
;;;3485     */
;;;3486   static void UART_DMARxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;3487   {
000002  4605              MOV      r5,r0
;;;3488     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;3489   
;;;3490     huart->RxXferCount = 0x00U;
000006  2000              MOVS     r0,#0
000008  85e0              STRH     r0,[r4,#0x2e]
;;;3491   
;;;3492     /* Restore huart->RxState to Ready */
;;;3493     huart->RxState = HAL_UART_STATE_READY;
00000a  2020              MOVS     r0,#0x20
00000c  f884003e          STRB     r0,[r4,#0x3e]
;;;3494     huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
000010  2000              MOVS     r0,#0
000012  6320              STR      r0,[r4,#0x30]
;;;3495   
;;;3496     /* Call user Abort complete callback */
;;;3497   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3498     /* Call registered Abort Receive Complete Callback */
;;;3499     huart->AbortReceiveCpltCallback(huart);
;;;3500   #else
;;;3501     /* Call legacy weak Abort Receive Complete Callback */
;;;3502     HAL_UART_AbortReceiveCpltCallback(huart);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
;;;3503   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3504   }
00001a  bd70              POP      {r4-r6,pc}
;;;3505   
                          ENDP


                          AREA ||i.UART_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATransmitCplt PROC
;;;2985     */
;;;2986   static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2987   {
000002  4605              MOV      r5,r0
;;;2988     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;2989     /* DMA Normal mode*/
;;;2990     if ((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
000006  6828              LDR      r0,[r5,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  f4007080          AND      r0,r0,#0x100
00000e  b9f8              CBNZ     r0,|L49.80|
;;;2991     {
;;;2992       huart->TxXferCount = 0x00U;
000010  2000              MOVS     r0,#0
000012  84e0              STRH     r0,[r4,#0x26]
;;;2993   
;;;2994       /* Disable the DMA transfer for transmit request by setting the DMAT bit
;;;2995          in the UART CR3 register */
;;;2996       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000014  bf00              NOP      
000016  bf00              NOP      
                  |L49.24|
000018  6821              LDR      r1,[r4,#0]
00001a  3114              ADDS     r1,r1,#0x14
00001c  e8511f00          LDREX    r1,[r1,#0]
000020  f0210080          BIC      r0,r1,#0x80
000024  6821              LDR      r1,[r4,#0]
000026  3114              ADDS     r1,r1,#0x14
000028  e8410200          STREX    r2,r0,[r1,#0]
00002c  2a00              CMP      r2,#0
00002e  d1f3              BNE      |L49.24|
000030  bf00              NOP      
;;;2997   
;;;2998       /* Enable the UART Transmit Complete Interrupt */
;;;2999       ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
000032  bf00              NOP      
000034  bf00              NOP      
                  |L49.54|
000036  6821              LDR      r1,[r4,#0]
000038  310c              ADDS     r1,r1,#0xc
00003a  e8511f00          LDREX    r1,[r1,#0]
00003e  f0410040          ORR      r0,r1,#0x40
000042  6821              LDR      r1,[r4,#0]
000044  310c              ADDS     r1,r1,#0xc
000046  e8410200          STREX    r2,r0,[r1,#0]
00004a  2a00              CMP      r2,#0
00004c  d1f3              BNE      |L49.54|
00004e  e002              B        |L49.86|
                  |L49.80|
;;;3000   
;;;3001     }
;;;3002     /* DMA Circular mode */
;;;3003     else
;;;3004     {
;;;3005   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3006       /*Call registered Tx complete callback*/
;;;3007       huart->TxCpltCallback(huart);
;;;3008   #else
;;;3009       /*Call legacy weak Tx complete callback*/
;;;3010       HAL_UART_TxCpltCallback(huart);
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       HAL_UART_TxCpltCallback
                  |L49.86|
;;;3011   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3012     }
;;;3013   }
000056  bd70              POP      {r4-r6,pc}
;;;3014   
                          ENDP


                          AREA ||i.UART_DMATxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxAbortCallback PROC
;;;3365     */
;;;3366   static void UART_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;3367   {
000002  4605              MOV      r5,r0
;;;3368     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;3369   
;;;3370     huart->hdmatx->XferAbortCallback = NULL;
000006  2000              MOVS     r0,#0
000008  6b61              LDR      r1,[r4,#0x34]
00000a  6508              STR      r0,[r1,#0x50]
;;;3371   
;;;3372     /* Check if an Abort process is still ongoing */
;;;3373     if (huart->hdmarx != NULL)
00000c  6ba0              LDR      r0,[r4,#0x38]
00000e  b118              CBZ      r0,|L50.24|
;;;3374     {
;;;3375       if (huart->hdmarx->XferAbortCallback != NULL)
000010  6ba0              LDR      r0,[r4,#0x38]
000012  6d00              LDR      r0,[r0,#0x50]
000014  b100              CBZ      r0,|L50.24|
                  |L50.22|
;;;3376       {
;;;3377         return;
;;;3378       }
;;;3379     }
;;;3380   
;;;3381     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;3382     huart->TxXferCount = 0x00U;
;;;3383     huart->RxXferCount = 0x00U;
;;;3384   
;;;3385     /* Reset ErrorCode */
;;;3386     huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;3387   
;;;3388     /* Restore huart->gState and huart->RxState to Ready */
;;;3389     huart->gState  = HAL_UART_STATE_READY;
;;;3390     huart->RxState = HAL_UART_STATE_READY;
;;;3391     huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;3392   
;;;3393     /* Call user Abort complete callback */
;;;3394   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3395     /* Call registered Abort complete callback */
;;;3396     huart->AbortCpltCallback(huart);
;;;3397   #else
;;;3398     /* Call legacy weak Abort complete callback */
;;;3399     HAL_UART_AbortCpltCallback(huart);
;;;3400   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3401   }
000016  bd70              POP      {r4-r6,pc}
                  |L50.24|
000018  2000              MOVS     r0,#0                 ;3382
00001a  84e0              STRH     r0,[r4,#0x26]         ;3382
00001c  85e0              STRH     r0,[r4,#0x2e]         ;3383
00001e  6420              STR      r0,[r4,#0x40]         ;3386
000020  2020              MOVS     r0,#0x20              ;3389
000022  f884003d          STRB     r0,[r4,#0x3d]         ;3389
000026  f884003e          STRB     r0,[r4,#0x3e]         ;3390
00002a  2000              MOVS     r0,#0                 ;3391
00002c  6320              STR      r0,[r4,#0x30]         ;3391
00002e  4620              MOV      r0,r4                 ;3399
000030  f7fffffe          BL       HAL_UART_AbortCpltCallback
000034  bf00              NOP      
000036  e7ee              B        |L50.22|
;;;3402   
                          ENDP


                          AREA ||i.UART_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATxHalfCplt PROC
;;;3020     */
;;;3021   static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;3022   {
000002  4604              MOV      r4,r0
;;;3023     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;3024   
;;;3025   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3026     /*Call registered Tx complete callback*/
;;;3027     huart->TxHalfCpltCallback(huart);
;;;3028   #else
;;;3029     /*Call legacy weak Tx complete callback*/
;;;3030     HAL_UART_TxHalfCpltCallback(huart);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_UART_TxHalfCpltCallback
;;;3031   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3032   }
00000c  bd70              POP      {r4-r6,pc}
;;;3033   
                          ENDP


                          AREA ||i.UART_DMATxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxOnlyAbortCallback PROC
;;;3457     */
;;;3458   static void UART_DMATxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;3459   {
000002  4605              MOV      r5,r0
;;;3460     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;3461   
;;;3462     huart->TxXferCount = 0x00U;
000006  2000              MOVS     r0,#0
000008  84e0              STRH     r0,[r4,#0x26]
;;;3463   
;;;3464     /* Restore huart->gState to Ready */
;;;3465     huart->gState = HAL_UART_STATE_READY;
00000a  2020              MOVS     r0,#0x20
00000c  f884003d          STRB     r0,[r4,#0x3d]
;;;3466   
;;;3467     /* Call user Abort complete callback */
;;;3468   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3469     /* Call registered Abort Transmit Complete Callback */
;;;3470     huart->AbortTransmitCpltCallback(huart);
;;;3471   #else
;;;3472     /* Call legacy weak Abort Transmit Complete Callback */
;;;3473     HAL_UART_AbortTransmitCpltCallback(huart);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
;;;3474   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3475   }
000016  bd70              POP      {r4-r6,pc}
;;;3476   
                          ENDP


                          AREA ||i.UART_EndRxTransfer||, CODE, READONLY, ALIGN=1

                  UART_EndRxTransfer PROC
;;;3317     */
;;;3318   static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
000000  bf00              NOP      
;;;3319   {
;;;3320     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;3321     ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000002  bf00              NOP      
                  |L53.4|
000004  6802              LDR      r2,[r0,#0]
000006  320c              ADDS     r2,r2,#0xc
000008  e8522f00          LDREX    r2,[r2,#0]
00000c  f4227190          BIC      r1,r2,#0x120
000010  6802              LDR      r2,[r0,#0]
000012  320c              ADDS     r2,r2,#0xc
000014  e8421300          STREX    r3,r1,[r2,#0]
000018  2b00              CMP      r3,#0
00001a  d1f3              BNE      |L53.4|
00001c  bf00              NOP      
;;;3322     ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00001e  bf00              NOP      
000020  bf00              NOP      
                  |L53.34|
000022  6802              LDR      r2,[r0,#0]
000024  3214              ADDS     r2,r2,#0x14
000026  e8522f00          LDREX    r2,[r2,#0]
00002a  f0220101          BIC      r1,r2,#1
00002e  6802              LDR      r2,[r0,#0]
000030  3214              ADDS     r2,r2,#0x14
000032  e8421300          STREX    r3,r1,[r2,#0]
000036  2b00              CMP      r3,#0
000038  d1f3              BNE      |L53.34|
00003a  bf00              NOP      
;;;3323   
;;;3324     /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
;;;3325     if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
00003c  6b01              LDR      r1,[r0,#0x30]
00003e  2901              CMP      r1,#1
000040  d10e              BNE      |L53.96|
;;;3326     {
;;;3327       ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
000042  bf00              NOP      
000044  bf00              NOP      
                  |L53.70|
000046  6802              LDR      r2,[r0,#0]
000048  320c              ADDS     r2,r2,#0xc
00004a  e8522f00          LDREX    r2,[r2,#0]
00004e  f0220110          BIC      r1,r2,#0x10
000052  6802              LDR      r2,[r0,#0]
000054  320c              ADDS     r2,r2,#0xc
000056  e8421300          STREX    r3,r1,[r2,#0]
00005a  2b00              CMP      r3,#0
00005c  d1f3              BNE      |L53.70|
00005e  bf00              NOP      
                  |L53.96|
;;;3328     }
;;;3329   
;;;3330     /* At end of Rx process, restore huart->RxState to Ready */
;;;3331     huart->RxState = HAL_UART_STATE_READY;
000060  2120              MOVS     r1,#0x20
000062  f880103e          STRB     r1,[r0,#0x3e]
;;;3332     huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
000066  2100              MOVS     r1,#0
000068  6301              STR      r1,[r0,#0x30]
;;;3333   }
00006a  4770              BX       lr
;;;3334   
                          ENDP


                          AREA ||i.UART_EndTransmit_IT||, CODE, READONLY, ALIGN=1

                  UART_EndTransmit_IT PROC
;;;3551     */
;;;3552   static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;3553   {
000002  4604              MOV      r4,r0
;;;3554     /* Disable the UART Transmit Complete Interrupt */
;;;3555     __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
000008  f0200040          BIC      r0,r0,#0x40
00000c  6821              LDR      r1,[r4,#0]
00000e  60c8              STR      r0,[r1,#0xc]
;;;3556   
;;;3557     /* Tx process is ended, restore huart->gState to Ready */
;;;3558     huart->gState = HAL_UART_STATE_READY;
000010  2020              MOVS     r0,#0x20
000012  f884003d          STRB     r0,[r4,#0x3d]
;;;3559   
;;;3560   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3561     /*Call registered Tx complete callback*/
;;;3562     huart->TxCpltCallback(huart);
;;;3563   #else
;;;3564     /*Call legacy weak Tx complete callback*/
;;;3565     HAL_UART_TxCpltCallback(huart);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       HAL_UART_TxCpltCallback
;;;3566   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3567   
;;;3568     return HAL_OK;
00001c  2000              MOVS     r0,#0
;;;3569   }
00001e  bd10              POP      {r4,pc}
;;;3570   
                          ENDP


                          AREA ||i.UART_EndTxTransfer||, CODE, READONLY, ALIGN=1

                  UART_EndTxTransfer PROC
;;;3303     */
;;;3304   static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
000000  bf00              NOP      
;;;3305   {
;;;3306     /* Disable TXEIE and TCIE interrupts */
;;;3307     ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000002  bf00              NOP      
                  |L55.4|
000004  6802              LDR      r2,[r0,#0]
000006  320c              ADDS     r2,r2,#0xc
000008  e8522f00          LDREX    r2,[r2,#0]
00000c  f02201c0          BIC      r1,r2,#0xc0
000010  6802              LDR      r2,[r0,#0]
000012  320c              ADDS     r2,r2,#0xc
000014  e8421300          STREX    r3,r1,[r2,#0]
000018  2b00              CMP      r3,#0
00001a  d1f3              BNE      |L55.4|
00001c  bf00              NOP      
;;;3308   
;;;3309     /* At end of Tx process, restore huart->gState to Ready */
;;;3310     huart->gState = HAL_UART_STATE_READY;
00001e  2120              MOVS     r1,#0x20
000020  f880103d          STRB     r1,[r0,#0x3d]
;;;3311   }
000024  4770              BX       lr
;;;3312   
                          ENDP


                          AREA ||i.UART_Receive_IT||, CODE, READONLY, ALIGN=1

                  UART_Receive_IT PROC
;;;3576     */
;;;3577   static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
000000  b5f8              PUSH     {r3-r7,lr}
;;;3578   {
000002  4604              MOV      r4,r0
;;;3579     uint8_t  *pdata8bits;
;;;3580     uint16_t *pdata16bits;
;;;3581   
;;;3582     /* Check that a Rx process is ongoing */
;;;3583     if (huart->RxState == HAL_UART_STATE_BUSY_RX)
000004  f894003e          LDRB     r0,[r4,#0x3e]
000008  2822              CMP      r0,#0x22
00000a  d173              BNE      |L56.244|
;;;3584     {
;;;3585       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
00000c  68a0              LDR      r0,[r4,#8]
00000e  f5b05f80          CMP      r0,#0x1000
000012  d10c              BNE      |L56.46|
000014  6920              LDR      r0,[r4,#0x10]
000016  b950              CBNZ     r0,|L56.46|
;;;3586       {
;;;3587         pdata8bits  = NULL;
000018  2500              MOVS     r5,#0
;;;3588         pdata16bits = (uint16_t *) huart->pRxBuffPtr;
00001a  6aa6              LDR      r6,[r4,#0x28]
;;;3589         *pdata16bits = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
00001c  6820              LDR      r0,[r4,#0]
00001e  6840              LDR      r0,[r0,#4]
000020  f3c00008          UBFX     r0,r0,#0,#9
000024  8030              STRH     r0,[r6,#0]
;;;3590         huart->pRxBuffPtr += 2U;
000026  6aa0              LDR      r0,[r4,#0x28]
000028  1c80              ADDS     r0,r0,#2
00002a  62a0              STR      r0,[r4,#0x28]
00002c  e015              B        |L56.90|
                  |L56.46|
;;;3591       }
;;;3592       else
;;;3593       {
;;;3594         pdata8bits = (uint8_t *) huart->pRxBuffPtr;
00002e  6aa5              LDR      r5,[r4,#0x28]
;;;3595         pdata16bits  = NULL;
000030  2600              MOVS     r6,#0
;;;3596   
;;;3597         if ((huart->Init.WordLength == UART_WORDLENGTH_9B) || ((huart->Init.WordLength == UART_WORDLENGTH_8B) && (huart->Init.Parity == UART_PARITY_NONE)))
000032  68a0              LDR      r0,[r4,#8]
000034  f5b05f80          CMP      r0,#0x1000
000038  d003              BEQ      |L56.66|
00003a  68a0              LDR      r0,[r4,#8]
00003c  b928              CBNZ     r0,|L56.74|
00003e  6920              LDR      r0,[r4,#0x10]
000040  b918              CBNZ     r0,|L56.74|
                  |L56.66|
;;;3598         {
;;;3599           *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
000042  6820              LDR      r0,[r4,#0]
000044  6840              LDR      r0,[r0,#4]
000046  7028              STRB     r0,[r5,#0]
000048  e004              B        |L56.84|
                  |L56.74|
;;;3600         }
;;;3601         else
;;;3602         {
;;;3603           *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
00004a  6820              LDR      r0,[r4,#0]
00004c  6840              LDR      r0,[r0,#4]
00004e  f000007f          AND      r0,r0,#0x7f
000052  7028              STRB     r0,[r5,#0]
                  |L56.84|
;;;3604         }
;;;3605         huart->pRxBuffPtr += 1U;
000054  6aa0              LDR      r0,[r4,#0x28]
000056  1c40              ADDS     r0,r0,#1
000058  62a0              STR      r0,[r4,#0x28]
                  |L56.90|
;;;3606       }
;;;3607   
;;;3608       if (--huart->RxXferCount == 0U)
00005a  8de0              LDRH     r0,[r4,#0x2e]
00005c  1e40              SUBS     r0,r0,#1
00005e  b280              UXTH     r0,r0
000060  85e0              STRH     r0,[r4,#0x2e]
000062  2800              CMP      r0,#0
000064  d144              BNE      |L56.240|
;;;3609       {
;;;3610         /* Disable the UART Data Register not empty Interrupt */
;;;3611         __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
000066  6820              LDR      r0,[r4,#0]
000068  68c0              LDR      r0,[r0,#0xc]
00006a  f0200020          BIC      r0,r0,#0x20
00006e  6821              LDR      r1,[r4,#0]
000070  60c8              STR      r0,[r1,#0xc]
;;;3612   
;;;3613         /* Disable the UART Parity Error Interrupt */
;;;3614         __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
000072  6820              LDR      r0,[r4,#0]
000074  68c0              LDR      r0,[r0,#0xc]
000076  f4207080          BIC      r0,r0,#0x100
00007a  6821              LDR      r1,[r4,#0]
00007c  60c8              STR      r0,[r1,#0xc]
;;;3615   
;;;3616         /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;3617         __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
00007e  6820              LDR      r0,[r4,#0]
000080  6940              LDR      r0,[r0,#0x14]
000082  f0200001          BIC      r0,r0,#1
000086  6821              LDR      r1,[r4,#0]
000088  6148              STR      r0,[r1,#0x14]
;;;3618   
;;;3619         /* Rx process is completed, restore huart->RxState to Ready */
;;;3620         huart->RxState = HAL_UART_STATE_READY;
00008a  2020              MOVS     r0,#0x20
00008c  f884003e          STRB     r0,[r4,#0x3e]
;;;3621   
;;;3622         /* Check current reception Mode :
;;;3623            If Reception till IDLE event has been selected : */
;;;3624         if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
000090  6b20              LDR      r0,[r4,#0x30]
000092  2801              CMP      r0,#1
000094  d126              BNE      |L56.228|
;;;3625         {
;;;3626           /* Set reception type to Standard */
;;;3627           huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
000096  2000              MOVS     r0,#0
000098  6320              STR      r0,[r4,#0x30]
;;;3628   
;;;3629           /* Disable IDLE interrupt */
;;;3630           ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
00009a  bf00              NOP      
00009c  bf00              NOP      
                  |L56.158|
00009e  6821              LDR      r1,[r4,#0]
0000a0  310c              ADDS     r1,r1,#0xc
0000a2  e8511f00          LDREX    r1,[r1,#0]
0000a6  f0210010          BIC      r0,r1,#0x10
0000aa  6821              LDR      r1,[r4,#0]
0000ac  310c              ADDS     r1,r1,#0xc
0000ae  e8410200          STREX    r2,r0,[r1,#0]
0000b2  2a00              CMP      r2,#0
0000b4  d1f3              BNE      |L56.158|
0000b6  bf00              NOP      
;;;3631   
;;;3632           /* Check if IDLE flag is set */
;;;3633           if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE))
0000b8  6820              LDR      r0,[r4,#0]
0000ba  6800              LDR      r0,[r0,#0]
0000bc  f0000010          AND      r0,r0,#0x10
0000c0  2810              CMP      r0,#0x10
0000c2  d10a              BNE      |L56.218|
;;;3634           {
;;;3635             /* Clear IDLE flag in ISR */
;;;3636             __HAL_UART_CLEAR_IDLEFLAG(huart);
0000c4  bf00              NOP      
0000c6  2000              MOVS     r0,#0
0000c8  9000              STR      r0,[sp,#0]
0000ca  6820              LDR      r0,[r4,#0]
0000cc  6800              LDR      r0,[r0,#0]
0000ce  9000              STR      r0,[sp,#0]
0000d0  6820              LDR      r0,[r4,#0]
0000d2  6840              LDR      r0,[r0,#4]
0000d4  9000              STR      r0,[sp,#0]
0000d6  bf00              NOP      
0000d8  bf00              NOP      
                  |L56.218|
;;;3637           }
;;;3638   
;;;3639   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3640           /*Call registered Rx Event callback*/
;;;3641           huart->RxEventCallback(huart, huart->RxXferSize);
;;;3642   #else
;;;3643           /*Call legacy weak Rx Event callback*/
;;;3644           HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
0000da  8da1              LDRH     r1,[r4,#0x2c]
0000dc  4620              MOV      r0,r4
0000de  f7fffffe          BL       HAL_UARTEx_RxEventCallback
0000e2  e002              B        |L56.234|
                  |L56.228|
;;;3645   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3646         }
;;;3647         else
;;;3648         {
;;;3649           /* Standard reception API called */
;;;3650   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3651           /*Call registered Rx complete callback*/
;;;3652           huart->RxCpltCallback(huart);
;;;3653   #else
;;;3654           /*Call legacy weak Rx complete callback*/
;;;3655           HAL_UART_RxCpltCallback(huart);
0000e4  4620              MOV      r0,r4
0000e6  f7fffffe          BL       HAL_UART_RxCpltCallback
                  |L56.234|
;;;3656   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3657         }
;;;3658   
;;;3659         return HAL_OK;
0000ea  2000              MOVS     r0,#0
                  |L56.236|
;;;3660       }
;;;3661       return HAL_OK;
;;;3662     }
;;;3663     else
;;;3664     {
;;;3665       return HAL_BUSY;
;;;3666     }
;;;3667   }
0000ec  bdf8              POP      {r3-r7,pc}
0000ee  e001              B        |L56.244|
                  |L56.240|
0000f0  2000              MOVS     r0,#0                 ;3661
0000f2  e7fb              B        |L56.236|
                  |L56.244|
0000f4  2002              MOVS     r0,#2                 ;3665
0000f6  e7f9              B        |L56.236|
;;;3668   
                          ENDP


                          AREA ||i.UART_SetConfig||, CODE, READONLY, ALIGN=2

                  UART_SetConfig PROC
;;;3674     */
;;;3675   static void UART_SetConfig(UART_HandleTypeDef *huart)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;3676   {
000004  4604              MOV      r4,r0
;;;3677     uint32_t tmpreg;
;;;3678     uint32_t pclk;
;;;3679   
;;;3680     /* Check the parameters */
;;;3681     assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
;;;3682     assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
;;;3683     assert_param(IS_UART_PARITY(huart->Init.Parity));
;;;3684     assert_param(IS_UART_MODE(huart->Init.Mode));
;;;3685   
;;;3686     /*-------------------------- USART CR2 Configuration -----------------------*/
;;;3687     /* Configure the UART Stop Bits: Set STOP[13:12] bits
;;;3688        according to huart->Init.StopBits value */
;;;3689     MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
000006  6820              LDR      r0,[r4,#0]
000008  6900              LDR      r0,[r0,#0x10]
00000a  f4205040          BIC      r0,r0,#0x3000
00000e  68e1              LDR      r1,[r4,#0xc]
000010  4308              ORRS     r0,r0,r1
000012  6821              LDR      r1,[r4,#0]
000014  6108              STR      r0,[r1,#0x10]
;;;3690   
;;;3691     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;3692     /* Configure the UART Word Length, Parity and mode:
;;;3693        Set the M bits according to huart->Init.WordLength value
;;;3694        Set PCE and PS bits according to huart->Init.Parity value
;;;3695        Set TE and RE bits according to huart->Init.Mode value
;;;3696        Set OVER8 bit according to huart->Init.OverSampling value */
;;;3697   
;;;3698     tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
000016  6921              LDR      r1,[r4,#0x10]
000018  68a0              LDR      r0,[r4,#8]
00001a  4308              ORRS     r0,r0,r1
00001c  6961              LDR      r1,[r4,#0x14]
00001e  4308              ORRS     r0,r0,r1
000020  69e1              LDR      r1,[r4,#0x1c]
000022  4308              ORRS     r0,r0,r1
000024  9000              STR      r0,[sp,#0]
;;;3699     MODIFY_REG(huart->Instance->CR1,
000026  6820              LDR      r0,[r4,#0]
000028  68c0              LDR      r0,[r0,#0xc]
00002a  f249610c          MOV      r1,#0x960c
00002e  4388              BICS     r0,r0,r1
000030  9900              LDR      r1,[sp,#0]
000032  4308              ORRS     r0,r0,r1
000034  6821              LDR      r1,[r4,#0]
000036  60c8              STR      r0,[r1,#0xc]
;;;3700                (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
;;;3701                tmpreg);
;;;3702   
;;;3703     /*-------------------------- USART CR3 Configuration -----------------------*/
;;;3704     /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
;;;3705     MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
000038  6820              LDR      r0,[r4,#0]
00003a  6940              LDR      r0,[r0,#0x14]
00003c  f4207040          BIC      r0,r0,#0x300
000040  69a1              LDR      r1,[r4,#0x18]
000042  4308              ORRS     r0,r0,r1
000044  6821              LDR      r1,[r4,#0]
000046  6148              STR      r0,[r1,#0x14]
;;;3706   
;;;3707   
;;;3708   #if defined(USART6) && defined(UART9) && defined(UART10)
;;;3709       if ((huart->Instance == USART1) || (huart->Instance == USART6) || (huart->Instance == UART9) || (huart->Instance == UART10))
;;;3710       {
;;;3711         pclk = HAL_RCC_GetPCLK2Freq();
;;;3712       }
;;;3713   #elif defined(USART6)
;;;3714       if ((huart->Instance == USART1) || (huart->Instance == USART6))
000048  4976              LDR      r1,|L57.548|
00004a  6820              LDR      r0,[r4,#0]
00004c  4288              CMP      r0,r1
00004e  d003              BEQ      |L57.88|
000050  4975              LDR      r1,|L57.552|
000052  6820              LDR      r0,[r4,#0]
000054  4288              CMP      r0,r1
000056  d103              BNE      |L57.96|
                  |L57.88|
;;;3715       {
;;;3716         pclk = HAL_RCC_GetPCLK2Freq();
000058  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00005c  4681              MOV      r9,r0
00005e  e002              B        |L57.102|
                  |L57.96|
;;;3717       }
;;;3718   #else
;;;3719       if (huart->Instance == USART1)
;;;3720       {
;;;3721         pclk = HAL_RCC_GetPCLK2Freq();
;;;3722       }
;;;3723   #endif /* USART6 */
;;;3724       else
;;;3725       {
;;;3726         pclk = HAL_RCC_GetPCLK1Freq();
000060  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000064  4681              MOV      r9,r0
                  |L57.102|
;;;3727       }
;;;3728     /*-------------------------- USART BRR Configuration ---------------------*/
;;;3729     if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
000066  69e0              LDR      r0,[r4,#0x1c]
000068  f5b04f00          CMP      r0,#0x8000
00006c  d16c              BNE      |L57.328|
;;;3730     {
;;;3731       huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
00006e  2002              MOVS     r0,#2
000070  6861              LDR      r1,[r4,#4]
000072  fba05001          UMULL    r5,r0,r0,r1
000076  4603              MOV      r3,r0
000078  2019              MOVS     r0,#0x19
00007a  fba97000          UMULL    r7,r0,r9,r0
00007e  4601              MOV      r1,r0
000080  462a              MOV      r2,r5
000082  4638              MOV      r0,r7
000084  f7fffffe          BL       __aeabi_uldivmod
000088  2164              MOVS     r1,#0x64
00008a  fbb0f0f1          UDIV     r0,r0,r1
00008e  ea4f1a00          LSL      r10,r0,#4
000092  2002              MOVS     r0,#2
000094  6861              LDR      r1,[r4,#4]
000096  fba05101          UMULL    r5,r1,r0,r1
00009a  460b              MOV      r3,r1
00009c  2019              MOVS     r0,#0x19
00009e  fba97100          UMULL    r7,r1,r9,r0
0000a2  462a              MOV      r2,r5
0000a4  4638              MOV      r0,r7
0000a6  f7fffffe          BL       __aeabi_uldivmod
0000aa  4683              MOV      r11,r0
0000ac  2002              MOVS     r0,#2
0000ae  6861              LDR      r1,[r4,#4]
0000b0  fba05001          UMULL    r5,r0,r0,r1
0000b4  4603              MOV      r3,r0
0000b6  2019              MOVS     r0,#0x19
0000b8  fba97100          UMULL    r7,r1,r9,r0
0000bc  462a              MOV      r2,r5
0000be  4638              MOV      r0,r7
0000c0  f7fffffe          BL       __aeabi_uldivmod
0000c4  2164              MOVS     r1,#0x64
0000c6  fbb0f0f1          UDIV     r0,r0,r1
0000ca  eb0001c0          ADD      r1,r0,r0,LSL #3
0000ce  eb011000          ADD      r0,r1,r0,LSL #4
0000d2  ebab0080          SUB      r0,r11,r0,LSL #2
0000d6  2132              MOVS     r1,#0x32
0000d8  eb0100c0          ADD      r0,r1,r0,LSL #3
0000dc  2164              MOVS     r1,#0x64
0000de  fbb0f0f1          UDIV     r0,r0,r1
0000e2  f00000f8          AND      r0,r0,#0xf8
0000e6  eb0a0a40          ADD      r10,r10,r0,LSL #1
0000ea  2002              MOVS     r0,#2
0000ec  6861              LDR      r1,[r4,#4]
0000ee  fba05001          UMULL    r5,r0,r0,r1
0000f2  4603              MOV      r3,r0
0000f4  2019              MOVS     r0,#0x19
0000f6  fba97000          UMULL    r7,r0,r9,r0
0000fa  4601              MOV      r1,r0
0000fc  462a              MOV      r2,r5
0000fe  4638              MOV      r0,r7
000100  f7fffffe          BL       __aeabi_uldivmod
000104  4683              MOV      r11,r0
000106  2002              MOVS     r0,#2
000108  6861              LDR      r1,[r4,#4]
00010a  fba05001          UMULL    r5,r0,r0,r1
00010e  4603              MOV      r3,r0
000110  2019              MOVS     r0,#0x19
000112  fba97100          UMULL    r7,r1,r9,r0
000116  462a              MOV      r2,r5
000118  4638              MOV      r0,r7
00011a  f7fffffe          BL       __aeabi_uldivmod
00011e  2164              MOVS     r1,#0x64
000120  fbb0f0f1          UDIV     r0,r0,r1
000124  eb0001c0          ADD      r1,r0,r0,LSL #3
000128  eb011000          ADD      r0,r1,r0,LSL #4
00012c  ebab0080          SUB      r0,r11,r0,LSL #2
000130  2132              MOVS     r1,#0x32
000132  eb0100c0          ADD      r0,r1,r0,LSL #3
000136  2164              MOVS     r1,#0x64
000138  fbb0f0f1          UDIV     r0,r0,r1
00013c  f0000007          AND      r0,r0,#7
000140  4450              ADD      r0,r0,r10
000142  6821              LDR      r1,[r4,#0]
000144  6088              STR      r0,[r1,#8]
000146  e06a              B        |L57.542|
                  |L57.328|
;;;3732     }
;;;3733     else
;;;3734     {
;;;3735       huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
000148  2004              MOVS     r0,#4
00014a  6861              LDR      r1,[r4,#4]
00014c  fba05001          UMULL    r5,r0,r0,r1
000150  4603              MOV      r3,r0
000152  2019              MOVS     r0,#0x19
000154  fba97000          UMULL    r7,r0,r9,r0
000158  4601              MOV      r1,r0
00015a  462a              MOV      r2,r5
00015c  4638              MOV      r0,r7
00015e  f7fffffe          BL       __aeabi_uldivmod
000162  4682              MOV      r10,r0
000164  2004              MOVS     r0,#4
000166  6861              LDR      r1,[r4,#4]
000168  fba05001          UMULL    r5,r0,r0,r1
00016c  4603              MOV      r3,r0
00016e  2019              MOVS     r0,#0x19
000170  fba97000          UMULL    r7,r0,r9,r0
000174  4601              MOV      r1,r0
000176  462a              MOV      r2,r5
000178  4638              MOV      r0,r7
00017a  f7fffffe          BL       __aeabi_uldivmod
00017e  2164              MOVS     r1,#0x64
000180  fbb0f0f1          UDIV     r0,r0,r1
000184  eb0001c0          ADD      r1,r0,r0,LSL #3
000188  eb011000          ADD      r0,r1,r0,LSL #4
00018c  ebaa0080          SUB      r0,r10,r0,LSL #2
000190  2132              MOVS     r1,#0x32
000192  eb011000          ADD      r0,r1,r0,LSL #4
000196  2164              MOVS     r1,#0x64
000198  fbb0f0f1          UDIV     r0,r0,r1
00019c  f0000af0          AND      r10,r0,#0xf0
0001a0  2004              MOVS     r0,#4
0001a2  6861              LDR      r1,[r4,#4]
0001a4  fba07001          UMULL    r7,r0,r0,r1
0001a8  4603              MOV      r3,r0
0001aa  2019              MOVS     r0,#0x19
0001ac  fba95100          UMULL    r5,r1,r9,r0
0001b0  463a              MOV      r2,r7
0001b2  4628              MOV      r0,r5
0001b4  f7fffffe          BL       __aeabi_uldivmod
0001b8  2164              MOVS     r1,#0x64
0001ba  fbb0f0f1          UDIV     r0,r0,r1
0001be  eb0a1a00          ADD      r10,r10,r0,LSL #4
0001c2  2004              MOVS     r0,#4
0001c4  6861              LDR      r1,[r4,#4]
0001c6  fba05101          UMULL    r5,r1,r0,r1
0001ca  460b              MOV      r3,r1
0001cc  2019              MOVS     r0,#0x19
0001ce  fba97100          UMULL    r7,r1,r9,r0
0001d2  462a              MOV      r2,r5
0001d4  4638              MOV      r0,r7
0001d6  f7fffffe          BL       __aeabi_uldivmod
0001da  4683              MOV      r11,r0
0001dc  2004              MOVS     r0,#4
0001de  6861              LDR      r1,[r4,#4]
0001e0  fba05001          UMULL    r5,r0,r0,r1
0001e4  4603              MOV      r3,r0
0001e6  2019              MOVS     r0,#0x19
0001e8  fba97000          UMULL    r7,r0,r9,r0
0001ec  4601              MOV      r1,r0
0001ee  462a              MOV      r2,r5
0001f0  4638              MOV      r0,r7
0001f2  f7fffffe          BL       __aeabi_uldivmod
0001f6  2164              MOVS     r1,#0x64
0001f8  fbb0f0f1          UDIV     r0,r0,r1
0001fc  eb0001c0          ADD      r1,r0,r0,LSL #3
000200  eb011000          ADD      r0,r1,r0,LSL #4
000204  ebab0080          SUB      r0,r11,r0,LSL #2
000208  2132              MOVS     r1,#0x32
00020a  eb011000          ADD      r0,r1,r0,LSL #4
00020e  2164              MOVS     r1,#0x64
000210  fbb0f0f1          UDIV     r0,r0,r1
000214  f000000f          AND      r0,r0,#0xf
000218  4450              ADD      r0,r0,r10
00021a  6821              LDR      r1,[r4,#0]
00021c  6088              STR      r0,[r1,#8]
                  |L57.542|
;;;3736     }
;;;3737   }
00021e  e8bd8ff8          POP      {r3-r11,pc}
;;;3738   
                          ENDP

000222  0000              DCW      0x0000
                  |L57.548|
                          DCD      0x40011000
                  |L57.552|
                          DCD      0x40011400

                          AREA ||i.UART_Start_Receive_DMA||, CODE, READONLY, ALIGN=2

                  UART_Start_Receive_DMA PROC
;;;3250     */
;;;3251   HAL_StatusTypeDef UART_Start_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b577              PUSH     {r0-r2,r4-r6,lr}
;;;3252   {
000002  b081              SUB      sp,sp,#4
000004  4604              MOV      r4,r0
000006  4615              MOV      r5,r2
;;;3253     uint32_t *tmp;
;;;3254   
;;;3255     huart->pRxBuffPtr = pData;
000008  9802              LDR      r0,[sp,#8]
00000a  62a0              STR      r0,[r4,#0x28]
;;;3256     huart->RxXferSize = Size;
00000c  85a5              STRH     r5,[r4,#0x2c]
;;;3257   
;;;3258     huart->ErrorCode = HAL_UART_ERROR_NONE;
00000e  2000              MOVS     r0,#0
000010  6420              STR      r0,[r4,#0x40]
;;;3259     huart->RxState = HAL_UART_STATE_BUSY_RX;
000012  2022              MOVS     r0,#0x22
000014  f884003e          STRB     r0,[r4,#0x3e]
;;;3260   
;;;3261     /* Set the UART DMA transfer complete callback */
;;;3262     huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
000018  482a              LDR      r0,|L58.196|
00001a  6ba1              LDR      r1,[r4,#0x38]
00001c  63c8              STR      r0,[r1,#0x3c]
;;;3263   
;;;3264     /* Set the UART DMA Half transfer complete callback */
;;;3265     huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
00001e  482a              LDR      r0,|L58.200|
000020  6ba1              LDR      r1,[r4,#0x38]
000022  6408              STR      r0,[r1,#0x40]
;;;3266   
;;;3267     /* Set the DMA error callback */
;;;3268     huart->hdmarx->XferErrorCallback = UART_DMAError;
000024  4829              LDR      r0,|L58.204|
000026  6ba1              LDR      r1,[r4,#0x38]
000028  64c8              STR      r0,[r1,#0x4c]
;;;3269   
;;;3270     /* Set the DMA abort callback */
;;;3271     huart->hdmarx->XferAbortCallback = NULL;
00002a  2000              MOVS     r0,#0
00002c  6ba1              LDR      r1,[r4,#0x38]
00002e  6508              STR      r0,[r1,#0x50]
;;;3272   
;;;3273     /* Enable the DMA stream */
;;;3274     tmp = (uint32_t *)&pData;
000030  ae02              ADD      r6,sp,#8
;;;3275     HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t *)tmp, Size);
000032  6832              LDR      r2,[r6,#0]
000034  6823              LDR      r3,[r4,#0]
000036  1d19              ADDS     r1,r3,#4
000038  462b              MOV      r3,r5
00003a  6ba0              LDR      r0,[r4,#0x38]
00003c  f7fffffe          BL       HAL_DMA_Start_IT
;;;3276   
;;;3277     /* Clear the Overrun flag just before enabling the DMA Rx request: can be mandatory for the second transfer */
;;;3278     __HAL_UART_CLEAR_OREFLAG(huart);
000040  bf00              NOP      
000042  2000              MOVS     r0,#0
000044  9000              STR      r0,[sp,#0]
000046  6820              LDR      r0,[r4,#0]
000048  6800              LDR      r0,[r0,#0]
00004a  9000              STR      r0,[sp,#0]
00004c  6820              LDR      r0,[r4,#0]
00004e  6840              LDR      r0,[r0,#4]
000050  9000              STR      r0,[sp,#0]
000052  bf00              NOP      
000054  bf00              NOP      
;;;3279   
;;;3280     /* Process Unlocked */
;;;3281     __HAL_UNLOCK(huart);
000056  bf00              NOP      
000058  2000              MOVS     r0,#0
00005a  f884003c          STRB     r0,[r4,#0x3c]
00005e  bf00              NOP      
;;;3282   
;;;3283     if (huart->Init.Parity != UART_PARITY_NONE)
000060  6920              LDR      r0,[r4,#0x10]
000062  b170              CBZ      r0,|L58.130|
;;;3284     {
;;;3285       /* Enable the UART Parity Error Interrupt */
;;;3286       ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
000064  bf00              NOP      
000066  bf00              NOP      
                  |L58.104|
000068  6821              LDR      r1,[r4,#0]
00006a  310c              ADDS     r1,r1,#0xc
00006c  e8511f00          LDREX    r1,[r1,#0]
000070  f4417080          ORR      r0,r1,#0x100
000074  6821              LDR      r1,[r4,#0]
000076  310c              ADDS     r1,r1,#0xc
000078  e8410200          STREX    r2,r0,[r1,#0]
00007c  2a00              CMP      r2,#0
00007e  d1f3              BNE      |L58.104|
000080  bf00              NOP      
                  |L58.130|
;;;3287     }
;;;3288   
;;;3289     /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;3290     ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
000082  bf00              NOP      
000084  bf00              NOP      
                  |L58.134|
000086  6821              LDR      r1,[r4,#0]
000088  3114              ADDS     r1,r1,#0x14
00008a  e8511f00          LDREX    r1,[r1,#0]
00008e  f0410001          ORR      r0,r1,#1
000092  6821              LDR      r1,[r4,#0]
000094  3114              ADDS     r1,r1,#0x14
000096  e8410200          STREX    r2,r0,[r1,#0]
00009a  2a00              CMP      r2,#0
00009c  d1f3              BNE      |L58.134|
00009e  bf00              NOP      
;;;3291   
;;;3292     /* Enable the DMA transfer for the receiver request by setting the DMAR bit
;;;3293     in the UART CR3 register */
;;;3294     ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
0000a0  bf00              NOP      
0000a2  bf00              NOP      
                  |L58.164|
0000a4  6821              LDR      r1,[r4,#0]
0000a6  3114              ADDS     r1,r1,#0x14
0000a8  e8511f00          LDREX    r1,[r1,#0]
0000ac  f0410040          ORR      r0,r1,#0x40
0000b0  6821              LDR      r1,[r4,#0]
0000b2  3114              ADDS     r1,r1,#0x14
0000b4  e8410200          STREX    r2,r0,[r1,#0]
0000b8  2a00              CMP      r2,#0
0000ba  d1f3              BNE      |L58.164|
0000bc  bf00              NOP      
;;;3295   
;;;3296     return HAL_OK;
0000be  2000              MOVS     r0,#0
;;;3297   }
0000c0  b004              ADD      sp,sp,#0x10
0000c2  bd70              POP      {r4-r6,pc}
;;;3298   
                          ENDP

                  |L58.196|
                          DCD      UART_DMAReceiveCplt
                  |L58.200|
                          DCD      UART_DMARxHalfCplt
                  |L58.204|
                          DCD      UART_DMAError

                          AREA ||i.UART_Start_Receive_IT||, CODE, READONLY, ALIGN=1

                  UART_Start_Receive_IT PROC
;;;3212     */
;;;3213   HAL_StatusTypeDef UART_Start_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;3214   {
000002  4603              MOV      r3,r0
;;;3215     huart->pRxBuffPtr = pData;
000004  6299              STR      r1,[r3,#0x28]
;;;3216     huart->RxXferSize = Size;
000006  859a              STRH     r2,[r3,#0x2c]
;;;3217     huart->RxXferCount = Size;
000008  85da              STRH     r2,[r3,#0x2e]
;;;3218   
;;;3219     huart->ErrorCode = HAL_UART_ERROR_NONE;
00000a  2000              MOVS     r0,#0
00000c  6418              STR      r0,[r3,#0x40]
;;;3220     huart->RxState = HAL_UART_STATE_BUSY_RX;
00000e  2022              MOVS     r0,#0x22
000010  f883003e          STRB     r0,[r3,#0x3e]
;;;3221   
;;;3222     /* Process Unlocked */
;;;3223     __HAL_UNLOCK(huart);
000014  bf00              NOP      
000016  2000              MOVS     r0,#0
000018  f883003c          STRB     r0,[r3,#0x3c]
00001c  bf00              NOP      
;;;3224   
;;;3225     if (huart->Init.Parity != UART_PARITY_NONE)
00001e  6918              LDR      r0,[r3,#0x10]
000020  b128              CBZ      r0,|L59.46|
;;;3226     {
;;;3227       /* Enable the UART Parity Error Interrupt */
;;;3228       __HAL_UART_ENABLE_IT(huart, UART_IT_PE);
000022  6818              LDR      r0,[r3,#0]
000024  68c0              LDR      r0,[r0,#0xc]
000026  f4407080          ORR      r0,r0,#0x100
00002a  681c              LDR      r4,[r3,#0]
00002c  60e0              STR      r0,[r4,#0xc]
                  |L59.46|
;;;3229     }
;;;3230   
;;;3231     /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;3232     __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
00002e  6818              LDR      r0,[r3,#0]
000030  6940              LDR      r0,[r0,#0x14]
000032  f0400001          ORR      r0,r0,#1
000036  681c              LDR      r4,[r3,#0]
000038  6160              STR      r0,[r4,#0x14]
;;;3233   
;;;3234     /* Enable the UART Data Register not empty Interrupt */
;;;3235     __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);
00003a  6818              LDR      r0,[r3,#0]
00003c  68c0              LDR      r0,[r0,#0xc]
00003e  f0400020          ORR      r0,r0,#0x20
000042  681c              LDR      r4,[r3,#0]
000044  60e0              STR      r0,[r4,#0xc]
;;;3236   
;;;3237     return HAL_OK;
000046  2000              MOVS     r0,#0
;;;3238   }
000048  bd10              POP      {r4,pc}
;;;3239   
                          ENDP


                          AREA ||i.UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  UART_Transmit_IT PROC
;;;3511     */
;;;3512   static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;3513   {
;;;3514     const uint16_t *tmp;
;;;3515   
;;;3516     /* Check that a Tx process is ongoing */
;;;3517     if (huart->gState == HAL_UART_STATE_BUSY_TX)
000002  f891003d          LDRB     r0,[r1,#0x3d]
000006  2821              CMP      r0,#0x21
000008  d128              BNE      |L60.92|
;;;3518     {
;;;3519       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
00000a  6888              LDR      r0,[r1,#8]
00000c  f5b05f80          CMP      r0,#0x1000
000010  d10b              BNE      |L60.42|
000012  6908              LDR      r0,[r1,#0x10]
000014  b948              CBNZ     r0,|L60.42|
;;;3520       {
;;;3521         tmp = (const uint16_t *) huart->pTxBuffPtr;
000016  6a0a              LDR      r2,[r1,#0x20]
;;;3522         huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
000018  8810              LDRH     r0,[r2,#0]
00001a  f3c00008          UBFX     r0,r0,#0,#9
00001e  680b              LDR      r3,[r1,#0]
000020  6058              STR      r0,[r3,#4]
;;;3523         huart->pTxBuffPtr += 2U;
000022  6a08              LDR      r0,[r1,#0x20]
000024  1c80              ADDS     r0,r0,#2
000026  6208              STR      r0,[r1,#0x20]
000028  e005              B        |L60.54|
                  |L60.42|
;;;3524       }
;;;3525       else
;;;3526       {
;;;3527         huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
00002a  6a0b              LDR      r3,[r1,#0x20]
00002c  1c58              ADDS     r0,r3,#1
00002e  6208              STR      r0,[r1,#0x20]
000030  7818              LDRB     r0,[r3,#0]
000032  680b              LDR      r3,[r1,#0]
000034  6058              STR      r0,[r3,#4]
                  |L60.54|
;;;3528       }
;;;3529   
;;;3530       if (--huart->TxXferCount == 0U)
000036  8cc8              LDRH     r0,[r1,#0x26]
000038  1e40              SUBS     r0,r0,#1
00003a  b280              UXTH     r0,r0
00003c  84c8              STRH     r0,[r1,#0x26]
00003e  b958              CBNZ     r0,|L60.88|
;;;3531       {
;;;3532         /* Disable the UART Transmit Data Register Empty Interrupt */
;;;3533         __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
000040  6808              LDR      r0,[r1,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f0200080          BIC      r0,r0,#0x80
000048  680b              LDR      r3,[r1,#0]
00004a  60d8              STR      r0,[r3,#0xc]
;;;3534   
;;;3535         /* Enable the UART Transmit Complete Interrupt */
;;;3536         __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
00004c  6808              LDR      r0,[r1,#0]
00004e  68c0              LDR      r0,[r0,#0xc]
000050  f0400040          ORR      r0,r0,#0x40
000054  680b              LDR      r3,[r1,#0]
000056  60d8              STR      r0,[r3,#0xc]
                  |L60.88|
;;;3537       }
;;;3538       return HAL_OK;
000058  2000              MOVS     r0,#0
                  |L60.90|
;;;3539     }
;;;3540     else
;;;3541     {
;;;3542       return HAL_BUSY;
;;;3543     }
;;;3544   }
00005a  4770              BX       lr
                  |L60.92|
00005c  2002              MOVS     r0,#2                 ;3542
00005e  e7fc              B        |L60.90|
;;;3545   
                          ENDP


                          AREA ||i.UART_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  UART_WaitOnFlagUntilTimeout PROC
;;;3173     */
;;;3174   static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3175                                                        uint32_t Tickstart, uint32_t Timeout)
;;;3176   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  9e06              LDR      r6,[sp,#0x18]
;;;3177     /* Wait until flag is set */
;;;3178     while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
00000e  e034              B        |L61.122|
                  |L61.16|
;;;3179     {
;;;3180       /* Check for the Timeout */
;;;3181       if (Timeout != HAL_MAX_DELAY)
000010  1c70              ADDS     r0,r6,#1
000012  b388              CBZ      r0,|L61.120|
;;;3182       {
;;;3183         if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
000014  b12e              CBZ      r6,|L61.34|
000016  f7fffffe          BL       HAL_GetTick
00001a  eba00008          SUB      r0,r0,r8
00001e  42b0              CMP      r0,r6
000020  d92b              BLS      |L61.122|
                  |L61.34|
;;;3184         {
;;;3185           /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;3186           ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
000022  bf00              NOP      
000024  bf00              NOP      
                  |L61.38|
000026  6821              LDR      r1,[r4,#0]
000028  310c              ADDS     r1,r1,#0xc
00002a  e8511f00          LDREX    r1,[r1,#0]
00002e  f42170d0          BIC      r0,r1,#0x1a0
000032  6821              LDR      r1,[r4,#0]
000034  310c              ADDS     r1,r1,#0xc
000036  e8410200          STREX    r2,r0,[r1,#0]
00003a  2a00              CMP      r2,#0
00003c  d1f3              BNE      |L61.38|
00003e  bf00              NOP      
;;;3187           ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000040  bf00              NOP      
000042  bf00              NOP      
                  |L61.68|
000044  6821              LDR      r1,[r4,#0]
000046  3114              ADDS     r1,r1,#0x14
000048  e8511f00          LDREX    r1,[r1,#0]
00004c  f0210001          BIC      r0,r1,#1
000050  6821              LDR      r1,[r4,#0]
000052  3114              ADDS     r1,r1,#0x14
000054  e8410200          STREX    r2,r0,[r1,#0]
000058  2a00              CMP      r2,#0
00005a  d1f3              BNE      |L61.68|
00005c  bf00              NOP      
;;;3188   
;;;3189           huart->gState  = HAL_UART_STATE_READY;
00005e  2020              MOVS     r0,#0x20
000060  f884003d          STRB     r0,[r4,#0x3d]
;;;3190           huart->RxState = HAL_UART_STATE_READY;
000064  f884003e          STRB     r0,[r4,#0x3e]
;;;3191   
;;;3192           /* Process Unlocked */
;;;3193           __HAL_UNLOCK(huart);
000068  bf00              NOP      
00006a  2000              MOVS     r0,#0
00006c  f884003c          STRB     r0,[r4,#0x3c]
000070  bf00              NOP      
;;;3194   
;;;3195           return HAL_TIMEOUT;
000072  2003              MOVS     r0,#3
                  |L61.116|
;;;3196         }
;;;3197       }
;;;3198     }
;;;3199     return HAL_OK;
;;;3200   }
000074  e8bd81f0          POP      {r4-r8,pc}
                  |L61.120|
000078  e7ff              B        |L61.122|
                  |L61.122|
00007a  6820              LDR      r0,[r4,#0]            ;3178
00007c  6800              LDR      r0,[r0,#0]            ;3178
00007e  4028              ANDS     r0,r0,r5              ;3178
000080  42a8              CMP      r0,r5                 ;3178
000082  d101              BNE      |L61.136|
000084  2001              MOVS     r0,#1                 ;3178
000086  e000              B        |L61.138|
                  |L61.136|
000088  2000              MOVS     r0,#0                 ;3178
                  |L61.138|
00008a  42b8              CMP      r0,r7                 ;3178
00008c  d0c0              BEQ      |L61.16|
00008e  2000              MOVS     r0,#0                 ;3199
000090  e7f0              B        |L61.116|
;;;3201   
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_uart_c_d497114f____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___20_stm32f4xx_hal_uart_c_d497114f____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_uart_c_d497114f____REVSH|
#line 478
|__asm___20_stm32f4xx_hal_uart_c_d497114f____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_uart_c_d497114f____RRX|
#line 665
|__asm___20_stm32f4xx_hal_uart_c_d497114f____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
