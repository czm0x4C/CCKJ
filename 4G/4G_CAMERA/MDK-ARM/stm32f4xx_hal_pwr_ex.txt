; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o4gcamera\stm32f4xx_hal_pwr_ex.o --asm_dir=.\ --list_dir=.\ --depend=4gcamera\stm32f4xx_hal_pwr_ex.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../USB_DEVICE/App -I../USB_DEVICE/Target -I../Core/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Middlewares/ST/STM32_USB_Device_Library/Core/Inc -I../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 -I../Middlewares/Third_Party/FreeRTOS/Source/portable/RVDS/ARM_CM4F -I../HARDWARE/OV2640 -I../HARDWARE/WS2812B -I../HARDWARE/RING_BUFFER -I../HARDWARE/FLASH -I.\RTE\_4GCAMERA -IC:\Users\czm\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\czm\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=536 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F407xx --omf_browse=4gcamera\stm32f4xx_hal_pwr_ex.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_pwr_ex.c]
                          THUMB

                          AREA ||i.HAL_PWREx_ControlVoltageScaling||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_ControlVoltageScaling PROC
;;;231      */
;;;232    HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
000000  b538              PUSH     {r3-r5,lr}
;;;233    {
000002  4604              MOV      r4,r0
;;;234      uint32_t tickstart = 0U;
000004  2500              MOVS     r5,#0
;;;235      
;;;236      assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));
;;;237      
;;;238      /* Enable PWR RCC Clock Peripheral */
;;;239      __HAL_RCC_PWR_CLK_ENABLE();
000006  bf00              NOP      
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
00000c  4818              LDR      r0,|L1.112|
00000e  6800              LDR      r0,[r0,#0]
000010  f0405080          ORR      r0,r0,#0x10000000
000014  4916              LDR      r1,|L1.112|
000016  6008              STR      r0,[r1,#0]
000018  4608              MOV      r0,r1
00001a  6800              LDR      r0,[r0,#0]
00001c  f0005080          AND      r0,r0,#0x10000000
000020  9000              STR      r0,[sp,#0]
000022  bf00              NOP      
000024  bf00              NOP      
;;;240      
;;;241      /* Set Range */
;;;242      __HAL_PWR_VOLTAGESCALING_CONFIG(VoltageScaling);
000026  bf00              NOP      
000028  2000              MOVS     r0,#0
00002a  9000              STR      r0,[sp,#0]
00002c  4811              LDR      r0,|L1.116|
00002e  6800              LDR      r0,[r0,#0]
000030  f4204080          BIC      r0,r0,#0x4000
000034  4320              ORRS     r0,r0,r4
000036  490f              LDR      r1,|L1.116|
000038  6008              STR      r0,[r1,#0]
00003a  4608              MOV      r0,r1
00003c  6800              LDR      r0,[r0,#0]
00003e  f4004080          AND      r0,r0,#0x4000
000042  9000              STR      r0,[sp,#0]
000044  bf00              NOP      
000046  bf00              NOP      
;;;243      
;;;244      /* Get Start Tick*/
;;;245      tickstart = HAL_GetTick();
000048  f7fffffe          BL       HAL_GetTick
00004c  4605              MOV      r5,r0
;;;246      while((__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY) == RESET))
00004e  e007              B        |L1.96|
                  |L1.80|
;;;247      {
;;;248        if((HAL_GetTick() - tickstart ) > PWR_VOSRDY_TIMEOUT_VALUE)
000050  f7fffffe          BL       HAL_GetTick
000054  1b40              SUBS     r0,r0,r5
000056  f5b07f7a          CMP      r0,#0x3e8
00005a  d901              BLS      |L1.96|
;;;249        {
;;;250          return HAL_TIMEOUT;
00005c  2003              MOVS     r0,#3
                  |L1.94|
;;;251        } 
;;;252      }
;;;253    
;;;254      return HAL_OK;
;;;255    }
00005e  bd38              POP      {r3-r5,pc}
                  |L1.96|
000060  4804              LDR      r0,|L1.116|
000062  6840              LDR      r0,[r0,#4]            ;246
000064  f3c03080          UBFX     r0,r0,#14,#1          ;246
000068  2800              CMP      r0,#0                 ;246
00006a  d0f1              BEQ      |L1.80|
00006c  2000              MOVS     r0,#0                 ;254
00006e  e7f6              B        |L1.94|
;;;256    
                          ENDP

                  |L1.112|
                          DCD      0x40023840
                  |L1.116|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableBkUpReg||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableBkUpReg PROC
;;;164      */
;;;165    HAL_StatusTypeDef HAL_PWREx_DisableBkUpReg(void)
000000  b510              PUSH     {r4,lr}
;;;166    {
;;;167      uint32_t tickstart = 0U;
000002  2400              MOVS     r4,#0
;;;168    
;;;169      *(__IO uint32_t *) CSR_BRE_BB = (uint32_t)DISABLE;
000004  2000              MOVS     r0,#0
000006  490b              LDR      r1,|L2.52|
000008  6008              STR      r0,[r1,#0]
;;;170    
;;;171      /* Get tick */
;;;172      tickstart = HAL_GetTick();
00000a  f7fffffe          BL       HAL_GetTick
00000e  4604              MOV      r4,r0
;;;173    
;;;174      /* Wait till Backup regulator ready flag is set */  
;;;175      while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) != RESET)
000010  e007              B        |L2.34|
                  |L2.18|
;;;176      {
;;;177        if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)
000012  f7fffffe          BL       HAL_GetTick
000016  1b00              SUBS     r0,r0,r4
000018  f5b07f7a          CMP      r0,#0x3e8
00001c  d901              BLS      |L2.34|
;;;178        {
;;;179          return HAL_TIMEOUT;
00001e  2003              MOVS     r0,#3
                  |L2.32|
;;;180        } 
;;;181      }
;;;182      return HAL_OK;
;;;183    }
000020  bd10              POP      {r4,pc}
                  |L2.34|
000022  4805              LDR      r0,|L2.56|
000024  6840              LDR      r0,[r0,#4]            ;175
000026  f3c000c0          UBFX     r0,r0,#3,#1           ;175
00002a  2800              CMP      r0,#0                 ;175
00002c  d1f1              BNE      |L2.18|
00002e  bf00              NOP                            ;182
000030  e7f6              B        |L2.32|
;;;184    
                          ENDP

000032  0000              DCW      0x0000
                  |L2.52|
                          DCD      0x420e00a4
                  |L2.56|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableFlashPowerDown||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableFlashPowerDown PROC
;;;197      */
;;;198    void HAL_PWREx_DisableFlashPowerDown(void)
000000  2000              MOVS     r0,#0
;;;199    {
;;;200      *(__IO uint32_t *) CR_FPDS_BB = (uint32_t)DISABLE;
000002  4901              LDR      r1,|L3.8|
000004  6248              STR      r0,[r1,#0x24]
;;;201    }
000006  4770              BX       lr
;;;202    
                          ENDP

                  |L3.8|
                          DCD      0x420e0000

                          AREA ||i.HAL_PWREx_EnableBkUpReg||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableBkUpReg PROC
;;;140      */
;;;141    HAL_StatusTypeDef HAL_PWREx_EnableBkUpReg(void)
000000  b510              PUSH     {r4,lr}
;;;142    {
;;;143      uint32_t tickstart = 0U;
000002  2400              MOVS     r4,#0
;;;144    
;;;145      *(__IO uint32_t *) CSR_BRE_BB = (uint32_t)ENABLE;
000004  2001              MOVS     r0,#1
000006  490b              LDR      r1,|L4.52|
000008  6008              STR      r0,[r1,#0]
;;;146    
;;;147      /* Get tick */
;;;148      tickstart = HAL_GetTick();
00000a  f7fffffe          BL       HAL_GetTick
00000e  4604              MOV      r4,r0
;;;149    
;;;150      /* Wait till Backup regulator ready flag is set */  
;;;151      while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) == RESET)
000010  e007              B        |L4.34|
                  |L4.18|
;;;152      {
;;;153        if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)
000012  f7fffffe          BL       HAL_GetTick
000016  1b00              SUBS     r0,r0,r4
000018  f5b07f7a          CMP      r0,#0x3e8
00001c  d901              BLS      |L4.34|
;;;154        {
;;;155          return HAL_TIMEOUT;
00001e  2003              MOVS     r0,#3
                  |L4.32|
;;;156        } 
;;;157      }
;;;158      return HAL_OK;
;;;159    }
000020  bd10              POP      {r4,pc}
                  |L4.34|
000022  4805              LDR      r0,|L4.56|
000024  6840              LDR      r0,[r0,#4]            ;151
000026  f3c000c0          UBFX     r0,r0,#3,#1           ;151
00002a  2800              CMP      r0,#0                 ;151
00002c  d0f1              BEQ      |L4.18|
00002e  2000              MOVS     r0,#0                 ;158
000030  e7f6              B        |L4.32|
;;;160    
                          ENDP

000032  0000              DCW      0x0000
                  |L4.52|
                          DCD      0x420e00a4
                  |L4.56|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableFlashPowerDown||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableFlashPowerDown PROC
;;;188      */
;;;189    void HAL_PWREx_EnableFlashPowerDown(void)
000000  2001              MOVS     r0,#1
;;;190    {
;;;191      *(__IO uint32_t *) CR_FPDS_BB = (uint32_t)ENABLE;
000002  4901              LDR      r1,|L5.8|
000004  6248              STR      r0,[r1,#0x24]
;;;192    }
000006  4770              BX       lr
;;;193    
                          ENDP

                  |L5.8|
                          DCD      0x420e0000

                          AREA ||i.HAL_PWREx_GetVoltageRange||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_GetVoltageRange PROC
;;;210      */  
;;;211    uint32_t HAL_PWREx_GetVoltageRange(void)
000000  4802              LDR      r0,|L6.12|
;;;212    {
;;;213      return (PWR->CR & PWR_CR_VOS);
000002  6800              LDR      r0,[r0,#0]
000004  f4004080          AND      r0,r0,#0x4000
;;;214    }
000008  4770              BX       lr
;;;215    
                          ENDP

00000a  0000              DCW      0x0000
                  |L6.12|
                          DCD      0x40007000

;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_pwr_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f4xx_hal_pwr_ex_c_1028ebfa____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___22_stm32f4xx_hal_pwr_ex_c_1028ebfa____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f4xx_hal_pwr_ex_c_1028ebfa____REVSH|
#line 478
|__asm___22_stm32f4xx_hal_pwr_ex_c_1028ebfa____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f4xx_hal_pwr_ex_c_1028ebfa____RRX|
#line 665
|__asm___22_stm32f4xx_hal_pwr_ex_c_1028ebfa____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
