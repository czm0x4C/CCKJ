; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o4gcamera\stream_buffer.o --asm_dir=.\ --list_dir=.\ --depend=4gcamera\stream_buffer.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../USB_DEVICE/App -I../USB_DEVICE/Target -I../Core/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Middlewares/ST/STM32_USB_Device_Library/Core/Inc -I../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 -I../Middlewares/Third_Party/FreeRTOS/Source/portable/RVDS/ARM_CM4F -I../HARDWARE/OV2640 -I../HARDWARE/WS2812B -I../HARDWARE/RING_BUFFER -I../HARDWARE/FLASH -I.\RTE\_4GCAMERA -IC:\Users\czm\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\czm\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=536 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F407xx --omf_browse=4gcamera\stream_buffer.crf ../Middlewares/Third_Party/FreeRTOS/Source/stream_buffer.c]
                          THUMB

                          AREA ||i.prvBytesInBuffer||, CODE, READONLY, ALIGN=1

                  prvBytesInBuffer PROC
;;;1188   
;;;1189   static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
000000  4601              MOV      r1,r0
;;;1190   {
;;;1191   /* Returns the distance between xTail and xHead. */
;;;1192   size_t xCount;
;;;1193   
;;;1194   	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
000002  e9d13201          LDRD     r3,r2,[r1,#4]
000006  18d0              ADDS     r0,r2,r3
;;;1195   	xCount -= pxStreamBuffer->xTail;
000008  680a              LDR      r2,[r1,#0]
00000a  1a80              SUBS     r0,r0,r2
;;;1196   	if ( xCount >= pxStreamBuffer->xLength )
00000c  688a              LDR      r2,[r1,#8]
00000e  4282              CMP      r2,r0
000010  d801              BHI      |L1.22|
;;;1197   	{
;;;1198   		xCount -= pxStreamBuffer->xLength;
000012  688a              LDR      r2,[r1,#8]
000014  1a80              SUBS     r0,r0,r2
                  |L1.22|
;;;1199   	}
;;;1200   	else
;;;1201   	{
;;;1202   		mtCOVERAGE_TEST_MARKER();
;;;1203   	}
;;;1204   
;;;1205   	return xCount;
;;;1206   }
000016  4770              BX       lr
;;;1207   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvInitialiseNewStreamBuffer||, CODE, READONLY, ALIGN=1

                  prvInitialiseNewStreamBuffer PROC
;;;1208   
;;;1209   static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1210   										  uint8_t * const pucBuffer,
;;;1211   										  size_t xBufferSizeBytes,
;;;1212   										  size_t xTriggerLevelBytes,
;;;1213   										  uint8_t ucFlags )
;;;1214   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;1215   	/* Assert here is deliberately writing to the entire buffer to ensure it can
;;;1216   	be written to without generating exceptions, and is setting the buffer to a
;;;1217   	known value to assist in development/debugging. */
;;;1218   	#if( configASSERT_DEFINED == 1 )
;;;1219   	{
;;;1220   		/* The value written just has to be identifiable when looking at the
;;;1221   		memory.  Don't use 0xA5 as that is the stack fill value and could
;;;1222   		result in confusion as to what is actually being observed. */
;;;1223   		const BaseType_t xWriteValue = 0x55;
000010  f04f0955          MOV      r9,#0x55
;;;1224   		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
000014  4632              MOV      r2,r6
000016  2155              MOVS     r1,#0x55
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       memset
00001e  42a8              CMP      r0,r5
000020  d101              BNE      |L2.38|
000022  2001              MOVS     r0,#1
000024  e000              B        |L2.40|
                  |L2.38|
000026  2000              MOVS     r0,#0
                  |L2.40|
000028  b950              CBNZ     r0,|L2.64|
00002a  bf00              NOP      
00002c  2050              MOVS     r0,#0x50
00002e  f3808811          MSR      BASEPRI,r0
000032  f3bf8f4f          DSB      
000036  f3bf8f6f          ISB      
00003a  bf00              NOP      
00003c  bf00              NOP      
                  |L2.62|
00003e  e7fe              B        |L2.62|
                  |L2.64|
;;;1225   	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
;;;1226   	#endif
;;;1227   
;;;1228   	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
000040  2124              MOVS     r1,#0x24
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       __aeabi_memclr4
;;;1229   	pxStreamBuffer->pucBuffer = pucBuffer;
000048  61a5              STR      r5,[r4,#0x18]
;;;1230   	pxStreamBuffer->xLength = xBufferSizeBytes;
00004a  60a6              STR      r6,[r4,#8]
;;;1231   	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
00004c  60e7              STR      r7,[r4,#0xc]
;;;1232   	pxStreamBuffer->ucFlags = ucFlags;
00004e  f884801c          STRB     r8,[r4,#0x1c]
;;;1233   }
000052  e8bd87f0          POP      {r4-r10,pc}
;;;1234   
                          ENDP


                          AREA ||i.prvReadBytesFromBuffer||, CODE, READONLY, ALIGN=1

                  prvReadBytesFromBuffer PROC
;;;1133   
;;;1134   static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1135   {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4690              MOV      r8,r2
00000a  469a              MOV      r10,r3
;;;1136   size_t xCount, xFirstLength, xNextTail;
;;;1137   
;;;1138   	/* Use the minimum of the wanted bytes and the available bytes. */
;;;1139   	xCount = configMIN( xBytesAvailable, xMaxCount );
00000c  45c2              CMP      r10,r8
00000e  d201              BCS      |L3.20|
000010  4650              MOV      r0,r10
000012  e000              B        |L3.22|
                  |L3.20|
000014  4640              MOV      r0,r8
                  |L3.22|
000016  4606              MOV      r6,r0
;;;1140   
;;;1141   	if( xCount > ( size_t ) 0 )
000018  2e00              CMP      r6,#0
00001a  d053              BEQ      |L3.196|
;;;1142   	{
;;;1143   		xNextTail = pxStreamBuffer->xTail;
00001c  6825              LDR      r5,[r4,#0]
;;;1144   
;;;1145   		/* Calculate the number of bytes that can be read - which may be
;;;1146   		less than the number wanted if the data wraps around to the start of
;;;1147   		the buffer. */
;;;1148   		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
00001e  68a0              LDR      r0,[r4,#8]
000020  1b40              SUBS     r0,r0,r5
000022  42b0              CMP      r0,r6
000024  d202              BCS      |L3.44|
000026  68a0              LDR      r0,[r4,#8]
000028  1b40              SUBS     r0,r0,r5
00002a  e000              B        |L3.46|
                  |L3.44|
00002c  4630              MOV      r0,r6
                  |L3.46|
00002e  4607              MOV      r7,r0
;;;1149   
;;;1150   		/* Obtain the number of bytes it is possible to obtain in the first
;;;1151   		read.  Asserts check bounds of read and write. */
;;;1152   		configASSERT( xFirstLength <= xMaxCount );
000030  4547              CMP      r7,r8
000032  d801              BHI      |L3.56|
000034  2001              MOVS     r0,#1
000036  e000              B        |L3.58|
                  |L3.56|
000038  2000              MOVS     r0,#0
                  |L3.58|
00003a  b950              CBNZ     r0,|L3.82|
00003c  bf00              NOP      
00003e  2050              MOVS     r0,#0x50
000040  f3808811          MSR      BASEPRI,r0
000044  f3bf8f4f          DSB      
000048  f3bf8f6f          ISB      
00004c  bf00              NOP      
00004e  bf00              NOP      
                  |L3.80|
000050  e7fe              B        |L3.80|
                  |L3.82|
;;;1153   		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
000052  19e8              ADDS     r0,r5,r7
000054  68a1              LDR      r1,[r4,#8]
000056  4288              CMP      r0,r1
000058  d801              BHI      |L3.94|
00005a  2001              MOVS     r0,#1
00005c  e000              B        |L3.96|
                  |L3.94|
00005e  2000              MOVS     r0,#0
                  |L3.96|
000060  b950              CBNZ     r0,|L3.120|
000062  bf00              NOP      
000064  2050              MOVS     r0,#0x50
000066  f3808811          MSR      BASEPRI,r0
00006a  f3bf8f4f          DSB      
00006e  f3bf8f6f          ISB      
000072  bf00              NOP      
000074  bf00              NOP      
                  |L3.118|
000076  e7fe              B        |L3.118|
                  |L3.120|
;;;1154   		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
000078  69a0              LDR      r0,[r4,#0x18]
00007a  1941              ADDS     r1,r0,r5
00007c  463a              MOV      r2,r7
00007e  4648              MOV      r0,r9
000080  f7fffffe          BL       __aeabi_memcpy
;;;1155   
;;;1156   		/* If the total number of wanted bytes is greater than the number
;;;1157   		that could be read in the first read... */
;;;1158   		if( xCount > xFirstLength )
000084  42be              CMP      r6,r7
000086  d916              BLS      |L3.182|
;;;1159   		{
;;;1160   			/*...then read the remaining bytes from the start of the buffer. */
;;;1161   			configASSERT( xCount <= xMaxCount );
000088  4546              CMP      r6,r8
00008a  d801              BHI      |L3.144|
00008c  2001              MOVS     r0,#1
00008e  e000              B        |L3.146|
                  |L3.144|
000090  2000              MOVS     r0,#0
                  |L3.146|
000092  b950              CBNZ     r0,|L3.170|
000094  bf00              NOP      
000096  2050              MOVS     r0,#0x50
000098  f3808811          MSR      BASEPRI,r0
00009c  f3bf8f4f          DSB      
0000a0  f3bf8f6f          ISB      
0000a4  bf00              NOP      
0000a6  bf00              NOP      
                  |L3.168|
0000a8  e7fe              B        |L3.168|
                  |L3.170|
;;;1162   			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
0000aa  1bf2              SUBS     r2,r6,r7
0000ac  eb090007          ADD      r0,r9,r7
0000b0  69a1              LDR      r1,[r4,#0x18]
0000b2  f7fffffe          BL       __aeabi_memcpy
                  |L3.182|
;;;1163   		}
;;;1164   		else
;;;1165   		{
;;;1166   			mtCOVERAGE_TEST_MARKER();
;;;1167   		}
;;;1168   
;;;1169   		/* Move the tail pointer to effectively remove the data read from
;;;1170   		the buffer. */
;;;1171   		xNextTail += xCount;
0000b6  4435              ADD      r5,r5,r6
;;;1172   
;;;1173   		if( xNextTail >= pxStreamBuffer->xLength )
0000b8  68a0              LDR      r0,[r4,#8]
0000ba  42a8              CMP      r0,r5
0000bc  d801              BHI      |L3.194|
;;;1174   		{
;;;1175   			xNextTail -= pxStreamBuffer->xLength;
0000be  68a0              LDR      r0,[r4,#8]
0000c0  1a2d              SUBS     r5,r5,r0
                  |L3.194|
;;;1176   		}
;;;1177   
;;;1178   		pxStreamBuffer->xTail = xNextTail;
0000c2  6025              STR      r5,[r4,#0]
                  |L3.196|
;;;1179   	}
;;;1180   	else
;;;1181   	{
;;;1182   		mtCOVERAGE_TEST_MARKER();
;;;1183   	}
;;;1184   
;;;1185   	return xCount;
0000c4  4630              MOV      r0,r6
;;;1186   }
0000c6  e8bd87f0          POP      {r4-r10,pc}
;;;1187   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvReadMessageFromBuffer||, CODE, READONLY, ALIGN=1

                  prvReadMessageFromBuffer PROC
;;;917    
;;;918    static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;919    										void *pvRxData,
;;;920    										size_t xBufferLengthBytes,
;;;921    										size_t xBytesAvailable,
;;;922    										size_t xBytesToStoreMessageLength )
;;;923    {
000004  4605              MOV      r5,r0
000006  468a              MOV      r10,r1
000008  4616              MOV      r6,r2
00000a  4698              MOV      r8,r3
00000c  9f0a              LDR      r7,[sp,#0x28]
;;;924    size_t xOriginalTail, xReceivedLength, xNextMessageLength;
;;;925    configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;
;;;926    
;;;927    	if( xBytesToStoreMessageLength != ( size_t ) 0 )
00000e  b187              CBZ      r7,|L4.50|
;;;928    	{
;;;929    		/* A discrete message is being received.  First receive the length
;;;930    		of the message.  A copy of the tail is stored so the buffer can be
;;;931    		returned to its prior state if the length of the message is too
;;;932    		large for the provided buffer. */
;;;933    		xOriginalTail = pxStreamBuffer->xTail;
000010  f8d59000          LDR      r9,[r5,#0]
;;;934    		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
000014  4643              MOV      r3,r8
000016  463a              MOV      r2,r7
000018  4669              MOV      r1,sp
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       prvReadBytesFromBuffer
;;;935    		xNextMessageLength = ( size_t ) xTempNextMessageLength;
000020  9c00              LDR      r4,[sp,#0]
;;;936    
;;;937    		/* Reduce the number of bytes available by the number of bytes just
;;;938    		read out. */
;;;939    		xBytesAvailable -= xBytesToStoreMessageLength;
000022  eba80807          SUB      r8,r8,r7
;;;940    
;;;941    		/* Check there is enough space in the buffer provided by the
;;;942    		user. */
;;;943    		if( xNextMessageLength > xBufferLengthBytes )
000026  42b4              CMP      r4,r6
000028  d904              BLS      |L4.52|
;;;944    		{
;;;945    			/* The user has provided insufficient space to read the message
;;;946    			so return the buffer to its previous state (so the length of
;;;947    			the message is in the buffer again). */
;;;948    			pxStreamBuffer->xTail = xOriginalTail;
00002a  f8c59000          STR      r9,[r5,#0]
;;;949    			xNextMessageLength = 0;
00002e  2400              MOVS     r4,#0
000030  e000              B        |L4.52|
                  |L4.50|
;;;950    		}
;;;951    		else
;;;952    		{
;;;953    			mtCOVERAGE_TEST_MARKER();
;;;954    		}
;;;955    	}
;;;956    	else
;;;957    	{
;;;958    		/* A stream of bytes is being received (as opposed to a discrete
;;;959    		message), so read as many bytes as possible. */
;;;960    		xNextMessageLength = xBufferLengthBytes;
000032  4634              MOV      r4,r6
                  |L4.52|
;;;961    	}
;;;962    
;;;963    	/* Read the actual data. */
;;;964    	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
000034  4643              MOV      r3,r8
000036  4622              MOV      r2,r4
000038  4651              MOV      r1,r10
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       prvReadBytesFromBuffer
000040  4683              MOV      r11,r0
;;;965    
;;;966    	return xReceivedLength;
000042  4658              MOV      r0,r11
;;;967    }
000044  e8bd8ff8          POP      {r3-r11,pc}
;;;968    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvWriteBytesToBuffer||, CODE, READONLY, ALIGN=1

                  prvWriteBytesToBuffer PROC
;;;1087   
;;;1088   static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1089   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
;;;1090   size_t xNextHead, xFirstLength;
;;;1091   
;;;1092   	configASSERT( xCount > ( size_t ) 0 );
00000a  b10e              CBZ      r6,|L5.16|
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L5.18|
                  |L5.16|
000010  2000              MOVS     r0,#0
                  |L5.18|
000012  b950              CBNZ     r0,|L5.42|
000014  bf00              NOP      
000016  2050              MOVS     r0,#0x50
000018  f3808811          MSR      BASEPRI,r0
00001c  f3bf8f4f          DSB      
000020  f3bf8f6f          ISB      
000024  bf00              NOP      
000026  bf00              NOP      
                  |L5.40|
000028  e7fe              B        |L5.40|
                  |L5.42|
;;;1093   
;;;1094   	xNextHead = pxStreamBuffer->xHead;
00002a  6865              LDR      r5,[r4,#4]
;;;1095   
;;;1096   	/* Calculate the number of bytes that can be added in the first write -
;;;1097   	which may be less than the total number of bytes that need to be added if
;;;1098   	the buffer will wrap back to the beginning. */
;;;1099   	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
00002c  68a0              LDR      r0,[r4,#8]
00002e  1b40              SUBS     r0,r0,r5
000030  42b0              CMP      r0,r6
000032  d202              BCS      |L5.58|
000034  68a0              LDR      r0,[r4,#8]
000036  1b40              SUBS     r0,r0,r5
000038  e000              B        |L5.60|
                  |L5.58|
00003a  4630              MOV      r0,r6
                  |L5.60|
00003c  4607              MOV      r7,r0
;;;1100   
;;;1101   	/* Write as many bytes as can be written in the first write. */
;;;1102   	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
00003e  19e8              ADDS     r0,r5,r7
000040  68a1              LDR      r1,[r4,#8]
000042  4288              CMP      r0,r1
000044  d801              BHI      |L5.74|
000046  2001              MOVS     r0,#1
000048  e000              B        |L5.76|
                  |L5.74|
00004a  2000              MOVS     r0,#0
                  |L5.76|
00004c  b950              CBNZ     r0,|L5.100|
00004e  bf00              NOP      
000050  2050              MOVS     r0,#0x50
000052  f3808811          MSR      BASEPRI,r0
000056  f3bf8f4f          DSB      
00005a  f3bf8f6f          ISB      
00005e  bf00              NOP      
000060  bf00              NOP      
                  |L5.98|
000062  e7fe              B        |L5.98|
                  |L5.100|
;;;1103   	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
000064  69a1              LDR      r1,[r4,#0x18]
000066  1948              ADDS     r0,r1,r5
000068  463a              MOV      r2,r7
00006a  4641              MOV      r1,r8
00006c  f7fffffe          BL       __aeabi_memcpy
;;;1104   
;;;1105   	/* If the number of bytes written was less than the number that could be
;;;1106   	written in the first write... */
;;;1107   	if( xCount > xFirstLength )
000070  42be              CMP      r6,r7
000072  d918              BLS      |L5.166|
;;;1108   	{
;;;1109   		/* ...then write the remaining bytes to the start of the buffer. */
;;;1110   		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
000074  1bf0              SUBS     r0,r6,r7
000076  68a1              LDR      r1,[r4,#8]
000078  4288              CMP      r0,r1
00007a  d801              BHI      |L5.128|
00007c  2001              MOVS     r0,#1
00007e  e000              B        |L5.130|
                  |L5.128|
000080  2000              MOVS     r0,#0
                  |L5.130|
000082  b950              CBNZ     r0,|L5.154|
000084  bf00              NOP      
000086  2050              MOVS     r0,#0x50
000088  f3808811          MSR      BASEPRI,r0
00008c  f3bf8f4f          DSB      
000090  f3bf8f6f          ISB      
000094  bf00              NOP      
000096  bf00              NOP      
                  |L5.152|
000098  e7fe              B        |L5.152|
                  |L5.154|
;;;1111   		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
00009a  1bf2              SUBS     r2,r6,r7
00009c  eb080107          ADD      r1,r8,r7
0000a0  69a0              LDR      r0,[r4,#0x18]
0000a2  f7fffffe          BL       __aeabi_memcpy
                  |L5.166|
;;;1112   	}
;;;1113   	else
;;;1114   	{
;;;1115   		mtCOVERAGE_TEST_MARKER();
;;;1116   	}
;;;1117   
;;;1118   	xNextHead += xCount;
0000a6  4435              ADD      r5,r5,r6
;;;1119   	if( xNextHead >= pxStreamBuffer->xLength )
0000a8  68a0              LDR      r0,[r4,#8]
0000aa  42a8              CMP      r0,r5
0000ac  d801              BHI      |L5.178|
;;;1120   	{
;;;1121   		xNextHead -= pxStreamBuffer->xLength;
0000ae  68a0              LDR      r0,[r4,#8]
0000b0  1a2d              SUBS     r5,r5,r0
                  |L5.178|
;;;1122   	}
;;;1123   	else
;;;1124   	{
;;;1125   		mtCOVERAGE_TEST_MARKER();
;;;1126   	}
;;;1127   
;;;1128   	pxStreamBuffer->xHead = xNextHead;
0000b2  6065              STR      r5,[r4,#4]
;;;1129   
;;;1130   	return xCount;
0000b4  4630              MOV      r0,r6
;;;1131   }
0000b6  e8bd81f0          POP      {r4-r8,pc}
;;;1132   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvWriteMessageToBuffer||, CODE, READONLY, ALIGN=1

                  prvWriteMessageToBuffer PROC
;;;660    
;;;661    static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;662    									   const void * pvTxData,
;;;663    									   size_t xDataLengthBytes,
;;;664    									   size_t xSpace,
;;;665    									   size_t xRequiredSpace )
;;;666    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  461d              MOV      r5,r3
00000a  f8dd9030          LDR      r9,[sp,#0x30]
;;;667    	BaseType_t xShouldWrite;
;;;668    	size_t xReturn;
;;;669    
;;;670    	if( xSpace == ( size_t ) 0 )
00000e  b90d              CBNZ     r5,|L6.20|
;;;671    	{
;;;672    		/* Doesn't matter if this is a stream buffer or a message buffer, there
;;;673    		is no space to write. */
;;;674    		xShouldWrite = pdFALSE;
000010  2400              MOVS     r4,#0
000012  e016              B        |L6.66|
                  |L6.20|
;;;675    	}
;;;676    	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
000014  7f38              LDRB     r0,[r7,#0x1c]
000016  f0000001          AND      r0,r0,#1
00001a  b940              CBNZ     r0,|L6.46|
;;;677    	{
;;;678    		/* This is a stream buffer, as opposed to a message buffer, so writing a
;;;679    		stream of bytes rather than discrete messages.  Write as many bytes as
;;;680    		possible. */
;;;681    		xShouldWrite = pdTRUE;
00001c  2401              MOVS     r4,#1
;;;682    		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
00001e  9802              LDR      r0,[sp,#8]
000020  42a8              CMP      r0,r5
000022  d201              BCS      |L6.40|
000024  9802              LDR      r0,[sp,#8]
000026  e000              B        |L6.42|
                  |L6.40|
000028  4628              MOV      r0,r5
                  |L6.42|
00002a  9002              STR      r0,[sp,#8]
00002c  e009              B        |L6.66|
                  |L6.46|
;;;683    	}
;;;684    	else if( xSpace >= xRequiredSpace )
00002e  454d              CMP      r5,r9
000030  d306              BCC      |L6.64|
;;;685    	{
;;;686    		/* This is a message buffer, as opposed to a stream buffer, and there
;;;687    		is enough space to write both the message length and the message itself
;;;688    		into the buffer.  Start by writing the length of the data, the data
;;;689    		itself will be written later in this function. */
;;;690    		xShouldWrite = pdTRUE;
000032  2401              MOVS     r4,#1
;;;691    		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
000034  2204              MOVS     r2,#4
000036  a902              ADD      r1,sp,#8
000038  4638              MOV      r0,r7
00003a  f7fffffe          BL       prvWriteBytesToBuffer
00003e  e000              B        |L6.66|
                  |L6.64|
;;;692    	}
;;;693    	else
;;;694    	{
;;;695    		/* There is space available, but not enough space. */
;;;696    		xShouldWrite = pdFALSE;
000040  2400              MOVS     r4,#0
                  |L6.66|
;;;697    	}
;;;698    
;;;699    	if( xShouldWrite != pdFALSE )
000042  b134              CBZ      r4,|L6.82|
;;;700    	{
;;;701    		/* Writes the data itself. */
;;;702    		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
000044  4641              MOV      r1,r8
000046  4638              MOV      r0,r7
000048  9a02              LDR      r2,[sp,#8]
00004a  f7fffffe          BL       prvWriteBytesToBuffer
00004e  4606              MOV      r6,r0
000050  e000              B        |L6.84|
                  |L6.82|
;;;703    	}
;;;704    	else
;;;705    	{
;;;706    		xReturn = 0;
000052  2600              MOVS     r6,#0
                  |L6.84|
;;;707    	}
;;;708    
;;;709    	return xReturn;
000054  4630              MOV      r0,r6
;;;710    }
000056  b004              ADD      sp,sp,#0x10
000058  e8bd87f0          POP      {r4-r10,pc}
;;;711    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.ucStreamBufferGetStreamBufferType||, CODE, READONLY, ALIGN=1

                  ucStreamBufferGetStreamBufferType PROC
;;;1256   
;;;1257   	uint8_t ucStreamBufferGetStreamBufferType( StreamBufferHandle_t xStreamBuffer )
000000  4601              MOV      r1,r0
;;;1258   	{
;;;1259   		return ( xStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER );
000002  7f08              LDRB     r0,[r1,#0x1c]
000004  f0000001          AND      r0,r0,#1
;;;1260   	}
000008  4770              BX       lr
;;;1261   
                          ENDP


                          AREA ||i.uxStreamBufferGetStreamBufferNumber||, CODE, READONLY, ALIGN=1

                  uxStreamBufferGetStreamBufferNumber PROC
;;;1236   
;;;1237   	UBaseType_t uxStreamBufferGetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer )
000000  4601              MOV      r1,r0
;;;1238   	{
;;;1239   		return xStreamBuffer->uxStreamBufferNumber;
000002  6a08              LDR      r0,[r1,#0x20]
;;;1240   	}
000004  4770              BX       lr
;;;1241   
                          ENDP


                          AREA ||i.vStreamBufferDelete||, CODE, READONLY, ALIGN=1

                  vStreamBufferDelete PROC
;;;358    
;;;359    void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
000000  b570              PUSH     {r4-r6,lr}
;;;360    {
000002  4604              MOV      r4,r0
;;;361    StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
000004  4625              MOV      r5,r4
;;;362    
;;;363    	configASSERT( pxStreamBuffer );
000006  b955              CBNZ     r5,|L9.30|
000008  bf00              NOP      
00000a  2050              MOVS     r0,#0x50
00000c  f3808811          MSR      BASEPRI,r0
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L9.28|
00001c  e7fe              B        |L9.28|
                  |L9.30|
;;;364    
;;;365    	traceSTREAM_BUFFER_DELETE( xStreamBuffer );
;;;366    
;;;367    	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
00001e  7f28              LDRB     r0,[r5,#0x1c]
000020  f0000002          AND      r0,r0,#2
000024  b918              CBNZ     r0,|L9.46|
;;;368    	{
;;;369    		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
;;;370    		{
;;;371    			/* Both the structure and the buffer were allocated using a single call
;;;372    			to pvPortMalloc(), hence only one call to vPortFree() is required. */
;;;373    			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       vPortFree
00002c  e003              B        |L9.54|
                  |L9.46|
;;;374    		}
;;;375    		#else
;;;376    		{
;;;377    			/* Should not be possible to get here, ucFlags must be corrupt.
;;;378    			Force an assert. */
;;;379    			configASSERT( xStreamBuffer == ( StreamBufferHandle_t ) ~0 );
;;;380    		}
;;;381    		#endif
;;;382    	}
;;;383    	else
;;;384    	{
;;;385    		/* The structure and buffer were not allocated dynamically and cannot be
;;;386    		freed - just scrub the structure so future use will assert. */
;;;387    		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
00002e  2124              MOVS     r1,#0x24
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       __aeabi_memclr4
                  |L9.54|
;;;388    	}
;;;389    }
000036  bd70              POP      {r4-r6,pc}
;;;390    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vStreamBufferSetStreamBufferNumber||, CODE, READONLY, ALIGN=1

                  vStreamBufferSetStreamBufferNumber PROC
;;;1246   
;;;1247   	void vStreamBufferSetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer, UBaseType_t uxStreamBufferNumber )
000000  6201              STR      r1,[r0,#0x20]
;;;1248   	{
;;;1249   		xStreamBuffer->uxStreamBufferNumber = uxStreamBufferNumber;
;;;1250   	}
000002  4770              BX       lr
;;;1251   
                          ENDP


                          AREA ||i.xStreamBufferBytesAvailable||, CODE, READONLY, ALIGN=1

                  xStreamBufferBytesAvailable PROC
;;;493    
;;;494    size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
000000  b570              PUSH     {r4-r6,lr}
;;;495    {
000002  4604              MOV      r4,r0
;;;496    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
000004  4625              MOV      r5,r4
;;;497    size_t xReturn;
;;;498    
;;;499    	configASSERT( pxStreamBuffer );
000006  b955              CBNZ     r5,|L11.30|
000008  bf00              NOP      
00000a  2050              MOVS     r0,#0x50
00000c  f3808811          MSR      BASEPRI,r0
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L11.28|
00001c  e7fe              B        |L11.28|
                  |L11.30|
;;;500    
;;;501    	xReturn = prvBytesInBuffer( pxStreamBuffer );
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       prvBytesInBuffer
000024  4606              MOV      r6,r0
;;;502    	return xReturn;
000026  4630              MOV      r0,r6
;;;503    }
000028  bd70              POP      {r4-r6,pc}
;;;504    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xStreamBufferGenericCreate||, CODE, READONLY, ALIGN=1

                  xStreamBufferGenericCreate PROC
;;;218    
;;;219    	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;220    	{
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4690              MOV      r8,r2
;;;221    	uint8_t *pucAllocatedMemory;
;;;222    	uint8_t ucFlags;
;;;223    
;;;224    		/* In case the stream buffer is going to be used as a message buffer
;;;225    		(that is, it will hold discrete messages with a little meta data that
;;;226    		says how big the next message is) check the buffer will be large enough
;;;227    		to hold at least one message. */
;;;228    		if( xIsMessageBuffer == pdTRUE )
00000a  f1b80f01          CMP      r8,#1
00000e  d111              BNE      |L12.52|
;;;229    		{
;;;230    			/* Is a message buffer but not statically allocated. */
;;;231    			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
000010  2701              MOVS     r7,#1
;;;232    			configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
000012  2c04              CMP      r4,#4
000014  d901              BLS      |L12.26|
000016  2001              MOVS     r0,#1
000018  e000              B        |L12.28|
                  |L12.26|
00001a  2000              MOVS     r0,#0
                  |L12.28|
00001c  b9d8              CBNZ     r0,|L12.86|
00001e  bf00              NOP      
000020  2050              MOVS     r0,#0x50
000022  f3808811          MSR      BASEPRI,r0
000026  f3bf8f4f          DSB      
00002a  f3bf8f6f          ISB      
00002e  bf00              NOP      
000030  bf00              NOP      
                  |L12.50|
000032  e7fe              B        |L12.50|
                  |L12.52|
;;;233    		}
;;;234    		else
;;;235    		{
;;;236    			/* Not a message buffer and not statically allocated. */
;;;237    			ucFlags = 0;
000034  2700              MOVS     r7,#0
;;;238    			configASSERT( xBufferSizeBytes > 0 );
000036  b10c              CBZ      r4,|L12.60|
000038  2001              MOVS     r0,#1
00003a  e000              B        |L12.62|
                  |L12.60|
00003c  2000              MOVS     r0,#0
                  |L12.62|
00003e  b950              CBNZ     r0,|L12.86|
000040  bf00              NOP      
000042  2050              MOVS     r0,#0x50
000044  f3808811          MSR      BASEPRI,r0
000048  f3bf8f4f          DSB      
00004c  f3bf8f6f          ISB      
000050  bf00              NOP      
000052  bf00              NOP      
                  |L12.84|
000054  e7fe              B        |L12.84|
                  |L12.86|
;;;239    		}
;;;240    		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );
000056  42a5              CMP      r5,r4
000058  d801              BHI      |L12.94|
00005a  2001              MOVS     r0,#1
00005c  e000              B        |L12.96|
                  |L12.94|
00005e  2000              MOVS     r0,#0
                  |L12.96|
000060  b950              CBNZ     r0,|L12.120|
000062  bf00              NOP      
000064  2050              MOVS     r0,#0x50
000066  f3808811          MSR      BASEPRI,r0
00006a  f3bf8f4f          DSB      
00006e  f3bf8f6f          ISB      
000072  bf00              NOP      
000074  bf00              NOP      
                  |L12.118|
000076  e7fe              B        |L12.118|
                  |L12.120|
;;;241    
;;;242    		/* A trigger level of 0 would cause a waiting task to unblock even when
;;;243    		the buffer was empty. */
;;;244    		if( xTriggerLevelBytes == ( size_t ) 0 )
000078  b905              CBNZ     r5,|L12.124|
;;;245    		{
;;;246    			xTriggerLevelBytes = ( size_t ) 1;
00007a  2501              MOVS     r5,#1
                  |L12.124|
;;;247    		}
;;;248    
;;;249    		/* A stream buffer requires a StreamBuffer_t structure and a buffer.
;;;250    		Both are allocated in a single call to pvPortMalloc().  The
;;;251    		StreamBuffer_t structure is placed at the start of the allocated memory
;;;252    		and the buffer follows immediately after.  The requested size is
;;;253    		incremented so the free space is returned as the user would expect -
;;;254    		this is a quirk of the implementation that means otherwise the free
;;;255    		space would be reported as one byte smaller than would be logically
;;;256    		expected. */
;;;257    		xBufferSizeBytes++;
00007c  1c64              ADDS     r4,r4,#1
;;;258    		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
00007e  f1040024          ADD      r0,r4,#0x24
000082  f7fffffe          BL       pvPortMalloc
000086  4606              MOV      r6,r0
;;;259    
;;;260    		if( pucAllocatedMemory != NULL )
000088  b13e              CBZ      r6,|L12.154|
;;;261    		{
;;;262    			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
00008a  462b              MOV      r3,r5
00008c  4622              MOV      r2,r4
00008e  f1060124          ADD      r1,r6,#0x24
000092  4630              MOV      r0,r6
000094  9700              STR      r7,[sp,#0]
000096  f7fffffe          BL       prvInitialiseNewStreamBuffer
                  |L12.154|
;;;263    										   pucAllocatedMemory + sizeof( StreamBuffer_t ),  /* Storage area follows. */ /*lint !e9016 Indexing past structure valid for uint8_t pointer, also storage area has no alignment requirement. */
;;;264    										   xBufferSizeBytes,
;;;265    										   xTriggerLevelBytes,
;;;266    										   ucFlags );
;;;267    
;;;268    			traceSTREAM_BUFFER_CREATE( ( ( StreamBuffer_t * ) pucAllocatedMemory ), xIsMessageBuffer );
;;;269    		}
;;;270    		else
;;;271    		{
;;;272    			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
;;;273    		}
;;;274    
;;;275    		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
00009a  4630              MOV      r0,r6
;;;276    	}
00009c  e8bd83f8          POP      {r3-r9,pc}
;;;277    
                          ENDP


                          AREA ||i.xStreamBufferGenericCreateStatic||, CODE, READONLY, ALIGN=1

                  xStreamBufferGenericCreateStatic PROC
;;;282    
;;;283    	StreamBufferHandle_t xStreamBufferGenericCreateStatic( size_t xBufferSizeBytes,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;284    														   size_t xTriggerLevelBytes,
;;;285    														   BaseType_t xIsMessageBuffer,
;;;286    														   uint8_t * const pucStreamBufferStorageArea,
;;;287    														   StaticStreamBuffer_t * const pxStaticStreamBuffer )
;;;288    	{
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4693              MOV      r11,r2
00000a  461e              MOV      r6,r3
00000c  9f0a              LDR      r7,[sp,#0x28]
;;;289    	StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) pxStaticStreamBuffer; /*lint !e740 !e9087 Safe cast as StaticStreamBuffer_t is opaque Streambuffer_t. */
00000e  46b8              MOV      r8,r7
;;;290    	StreamBufferHandle_t xReturn;
;;;291    	uint8_t ucFlags;
;;;292    
;;;293    		configASSERT( pucStreamBufferStorageArea );
000010  b956              CBNZ     r6,|L13.40|
000012  bf00              NOP      
000014  2050              MOVS     r0,#0x50
000016  f3808811          MSR      BASEPRI,r0
00001a  f3bf8f4f          DSB      
00001e  f3bf8f6f          ISB      
000022  bf00              NOP      
000024  bf00              NOP      
                  |L13.38|
000026  e7fe              B        |L13.38|
                  |L13.40|
;;;294    		configASSERT( pxStaticStreamBuffer );
000028  b957              CBNZ     r7,|L13.64|
00002a  bf00              NOP      
00002c  2050              MOVS     r0,#0x50
00002e  f3808811          MSR      BASEPRI,r0
000032  f3bf8f4f          DSB      
000036  f3bf8f6f          ISB      
00003a  bf00              NOP      
00003c  bf00              NOP      
                  |L13.62|
00003e  e7fe              B        |L13.62|
                  |L13.64|
;;;295    		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );
000040  42a5              CMP      r5,r4
000042  d801              BHI      |L13.72|
000044  2001              MOVS     r0,#1
000046  e000              B        |L13.74|
                  |L13.72|
000048  2000              MOVS     r0,#0
                  |L13.74|
00004a  b950              CBNZ     r0,|L13.98|
00004c  bf00              NOP      
00004e  2050              MOVS     r0,#0x50
000050  f3808811          MSR      BASEPRI,r0
000054  f3bf8f4f          DSB      
000058  f3bf8f6f          ISB      
00005c  bf00              NOP      
00005e  bf00              NOP      
                  |L13.96|
000060  e7fe              B        |L13.96|
                  |L13.98|
;;;296    
;;;297    		/* A trigger level of 0 would cause a waiting task to unblock even when
;;;298    		the buffer was empty. */
;;;299    		if( xTriggerLevelBytes == ( size_t ) 0 )
000062  b905              CBNZ     r5,|L13.102|
;;;300    		{
;;;301    			xTriggerLevelBytes = ( size_t ) 1;
000064  2501              MOVS     r5,#1
                  |L13.102|
;;;302    		}
;;;303    
;;;304    		if( xIsMessageBuffer != pdFALSE )
000066  f1bb0f00          CMP      r11,#0
00006a  d002              BEQ      |L13.114|
;;;305    		{
;;;306    			/* Statically allocated message buffer. */
;;;307    			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER | sbFLAGS_IS_STATICALLY_ALLOCATED;
00006c  f04f0a03          MOV      r10,#3
000070  e001              B        |L13.118|
                  |L13.114|
;;;308    		}
;;;309    		else
;;;310    		{
;;;311    			/* Statically allocated stream buffer. */
;;;312    			ucFlags = sbFLAGS_IS_STATICALLY_ALLOCATED;
000072  f04f0a02          MOV      r10,#2
                  |L13.118|
;;;313    		}
;;;314    
;;;315    		/* In case the stream buffer is going to be used as a message buffer
;;;316    		(that is, it will hold discrete messages with a little meta data that
;;;317    		says how big the next message is) check the buffer will be large enough
;;;318    		to hold at least one message. */
;;;319    		configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
000076  2c04              CMP      r4,#4
000078  d901              BLS      |L13.126|
00007a  2001              MOVS     r0,#1
00007c  e000              B        |L13.128|
                  |L13.126|
00007e  2000              MOVS     r0,#0
                  |L13.128|
000080  b950              CBNZ     r0,|L13.152|
000082  bf00              NOP      
000084  2050              MOVS     r0,#0x50
000086  f3808811          MSR      BASEPRI,r0
00008a  f3bf8f4f          DSB      
00008e  f3bf8f6f          ISB      
000092  bf00              NOP      
000094  bf00              NOP      
                  |L13.150|
000096  e7fe              B        |L13.150|
                  |L13.152|
;;;320    
;;;321    		#if( configASSERT_DEFINED == 1 )
;;;322    		{
;;;323    			/* Sanity check that the size of the structure used to declare a
;;;324    			variable of type StaticStreamBuffer_t equals the size of the real
;;;325    			message buffer structure. */
;;;326    			volatile size_t xSize = sizeof( StaticStreamBuffer_t );
000098  2024              MOVS     r0,#0x24
00009a  9000              STR      r0,[sp,#0]
;;;327    			configASSERT( xSize == sizeof( StreamBuffer_t ) );
00009c  9800              LDR      r0,[sp,#0]
00009e  2824              CMP      r0,#0x24
0000a0  d101              BNE      |L13.166|
0000a2  2001              MOVS     r0,#1
0000a4  e000              B        |L13.168|
                  |L13.166|
0000a6  2000              MOVS     r0,#0
                  |L13.168|
0000a8  b950              CBNZ     r0,|L13.192|
0000aa  bf00              NOP      
0000ac  2050              MOVS     r0,#0x50
0000ae  f3808811          MSR      BASEPRI,r0
0000b2  f3bf8f4f          DSB      
0000b6  f3bf8f6f          ISB      
0000ba  bf00              NOP      
0000bc  bf00              NOP      
                  |L13.190|
0000be  e7fe              B        |L13.190|
                  |L13.192|
;;;328    		} /*lint !e529 xSize is referenced is configASSERT() is defined. */
;;;329    		#endif /* configASSERT_DEFINED */
;;;330    
;;;331    		if( ( pucStreamBufferStorageArea != NULL ) && ( pxStaticStreamBuffer != NULL ) )
0000c0  b186              CBZ      r6,|L13.228|
0000c2  b17f              CBZ      r7,|L13.228|
;;;332    		{
;;;333    			prvInitialiseNewStreamBuffer( pxStreamBuffer,
0000c4  462b              MOV      r3,r5
0000c6  4622              MOV      r2,r4
0000c8  4631              MOV      r1,r6
0000ca  4640              MOV      r0,r8
0000cc  f8cda000          STR      r10,[sp,#0]
0000d0  f7fffffe          BL       prvInitialiseNewStreamBuffer
;;;334    										  pucStreamBufferStorageArea,
;;;335    										  xBufferSizeBytes,
;;;336    										  xTriggerLevelBytes,
;;;337    										  ucFlags );
;;;338    
;;;339    			/* Remember this was statically allocated in case it is ever deleted
;;;340    			again. */
;;;341    			pxStreamBuffer->ucFlags |= sbFLAGS_IS_STATICALLY_ALLOCATED;
0000d4  f898001c          LDRB     r0,[r8,#0x1c]
0000d8  f0400002          ORR      r0,r0,#2
0000dc  f888001c          STRB     r0,[r8,#0x1c]
;;;342    
;;;343    			traceSTREAM_BUFFER_CREATE( pxStreamBuffer, xIsMessageBuffer );
;;;344    
;;;345    			xReturn = ( StreamBufferHandle_t ) pxStaticStreamBuffer; /*lint !e9087 Data hiding requires cast to opaque type. */
0000e0  46b9              MOV      r9,r7
0000e2  e001              B        |L13.232|
                  |L13.228|
;;;346    		}
;;;347    		else
;;;348    		{
;;;349    			xReturn = NULL;
0000e4  f04f0900          MOV      r9,#0
                  |L13.232|
;;;350    			traceSTREAM_BUFFER_CREATE_STATIC_FAILED( xReturn, xIsMessageBuffer );
;;;351    		}
;;;352    
;;;353    		return xReturn;
0000e8  4648              MOV      r0,r9
;;;354    	}
0000ea  e8bd8ff8          POP      {r3-r11,pc}
;;;355    
                          ENDP


                          AREA ||i.xStreamBufferIsEmpty||, CODE, READONLY, ALIGN=1

                  xStreamBufferIsEmpty PROC
;;;969    
;;;970    BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
000000  b530              PUSH     {r4,r5,lr}
;;;971    {
000002  4601              MOV      r1,r0
;;;972    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
000004  460a              MOV      r2,r1
;;;973    BaseType_t xReturn;
;;;974    size_t xTail;
;;;975    
;;;976    	configASSERT( pxStreamBuffer );
000006  b952              CBNZ     r2,|L14.30|
000008  bf00              NOP      
00000a  2450              MOVS     r4,#0x50
00000c  f3848811          MSR      BASEPRI,r4
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L14.28|
00001c  e7fe              B        |L14.28|
                  |L14.30|
;;;977    
;;;978    	/* True if no bytes are available. */
;;;979    	xTail = pxStreamBuffer->xTail;
00001e  6813              LDR      r3,[r2,#0]
;;;980    	if( pxStreamBuffer->xHead == xTail )
000020  6854              LDR      r4,[r2,#4]
000022  429c              CMP      r4,r3
000024  d101              BNE      |L14.42|
;;;981    	{
;;;982    		xReturn = pdTRUE;
000026  2001              MOVS     r0,#1
000028  e000              B        |L14.44|
                  |L14.42|
;;;983    	}
;;;984    	else
;;;985    	{
;;;986    		xReturn = pdFALSE;
00002a  2000              MOVS     r0,#0
                  |L14.44|
;;;987    	}
;;;988    
;;;989    	return xReturn;
;;;990    }
00002c  bd30              POP      {r4,r5,pc}
;;;991    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xStreamBufferIsFull||, CODE, READONLY, ALIGN=1

                  xStreamBufferIsFull PROC
;;;992    
;;;993    BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
000000  b5f0              PUSH     {r4-r7,lr}
;;;994    {
000002  4604              MOV      r4,r0
;;;995    BaseType_t xReturn;
;;;996    size_t xBytesToStoreMessageLength;
;;;997    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
000004  4627              MOV      r7,r4
;;;998    
;;;999    	configASSERT( pxStreamBuffer );
000006  b957              CBNZ     r7,|L15.30|
000008  bf00              NOP      
00000a  2050              MOVS     r0,#0x50
00000c  f3808811          MSR      BASEPRI,r0
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L15.28|
00001c  e7fe              B        |L15.28|
                  |L15.30|
;;;1000   
;;;1001   	/* This generic version of the receive function is used by both message
;;;1002   	buffers, which store discrete messages, and stream buffers, which store a
;;;1003   	continuous stream of bytes.  Discrete messages include an additional
;;;1004   	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
;;;1005   	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
00001e  7f38              LDRB     r0,[r7,#0x1c]
000020  f0000001          AND      r0,r0,#1
000024  b108              CBZ      r0,|L15.42|
;;;1006   	{
;;;1007   		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
000026  2604              MOVS     r6,#4
000028  e000              B        |L15.44|
                  |L15.42|
;;;1008   	}
;;;1009   	else
;;;1010   	{
;;;1011   		xBytesToStoreMessageLength = 0;
00002a  2600              MOVS     r6,#0
                  |L15.44|
;;;1012   	}
;;;1013   
;;;1014   	/* True if the available space equals zero. */
;;;1015   	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       xStreamBufferSpacesAvailable
000032  42b0              CMP      r0,r6
000034  d801              BHI      |L15.58|
;;;1016   	{
;;;1017   		xReturn = pdTRUE;
000036  2501              MOVS     r5,#1
000038  e000              B        |L15.60|
                  |L15.58|
;;;1018   	}
;;;1019   	else
;;;1020   	{
;;;1021   		xReturn = pdFALSE;
00003a  2500              MOVS     r5,#0
                  |L15.60|
;;;1022   	}
;;;1023   
;;;1024   	return xReturn;
00003c  4628              MOV      r0,r5
;;;1025   }
00003e  bdf0              POP      {r4-r7,pc}
;;;1026   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xStreamBufferNextMessageLengthBytes||, CODE, READONLY, ALIGN=1

                  xStreamBufferNextMessageLengthBytes PROC
;;;816    
;;;817    size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;818    {
000004  4607              MOV      r7,r0
;;;819    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
000006  463c              MOV      r4,r7
;;;820    size_t xReturn, xBytesAvailable, xOriginalTail;
;;;821    configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;
;;;822    
;;;823    	configASSERT( pxStreamBuffer );
000008  b954              CBNZ     r4,|L16.32|
00000a  bf00              NOP      
00000c  2050              MOVS     r0,#0x50
00000e  f3808811          MSR      BASEPRI,r0
000012  f3bf8f4f          DSB      
000016  f3bf8f6f          ISB      
00001a  bf00              NOP      
00001c  bf00              NOP      
                  |L16.30|
00001e  e7fe              B        |L16.30|
                  |L16.32|
;;;824    
;;;825    	/* Ensure the stream buffer is being used as a message buffer. */
;;;826    	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
000020  7f20              LDRB     r0,[r4,#0x1c]
000022  f0000001          AND      r0,r0,#1
000026  b318              CBZ      r0,|L16.112|
;;;827    	{
;;;828    		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       prvBytesInBuffer
00002e  4605              MOV      r5,r0
;;;829    		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
000030  2d04              CMP      r5,#4
000032  d90b              BLS      |L16.76|
;;;830    		{
;;;831    			/* The number of bytes available is greater than the number of bytes
;;;832    			required to hold the length of the next message, so another message
;;;833    			is available.  Return its length without removing the length bytes
;;;834    			from the buffer.  A copy of the tail is stored so the buffer can be
;;;835    			returned to its prior state as the message is not actually being
;;;836    			removed from the buffer. */
;;;837    			xOriginalTail = pxStreamBuffer->xTail;
000034  f8d48000          LDR      r8,[r4,#0]
;;;838    			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
000038  462b              MOV      r3,r5
00003a  2204              MOVS     r2,#4
00003c  4669              MOV      r1,sp
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       prvReadBytesFromBuffer
;;;839    			xReturn = ( size_t ) xTempReturn;
000044  9e00              LDR      r6,[sp,#0]
;;;840    			pxStreamBuffer->xTail = xOriginalTail;
000046  f8c48000          STR      r8,[r4,#0]
00004a  e012              B        |L16.114|
                  |L16.76|
;;;841    		}
;;;842    		else
;;;843    		{
;;;844    			/* The minimum amount of bytes in a message buffer is
;;;845    			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
;;;846    			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
;;;847    			value is 0. */
;;;848    			configASSERT( xBytesAvailable == 0 );
00004c  b90d              CBNZ     r5,|L16.82|
00004e  2001              MOVS     r0,#1
000050  e000              B        |L16.84|
                  |L16.82|
000052  2000              MOVS     r0,#0
                  |L16.84|
000054  b950              CBNZ     r0,|L16.108|
000056  bf00              NOP      
000058  2050              MOVS     r0,#0x50
00005a  f3808811          MSR      BASEPRI,r0
00005e  f3bf8f4f          DSB      
000062  f3bf8f6f          ISB      
000066  bf00              NOP      
000068  bf00              NOP      
                  |L16.106|
00006a  e7fe              B        |L16.106|
                  |L16.108|
;;;849    			xReturn = 0;
00006c  2600              MOVS     r6,#0
00006e  e000              B        |L16.114|
                  |L16.112|
;;;850    		}
;;;851    	}
;;;852    	else
;;;853    	{
;;;854    		xReturn = 0;
000070  2600              MOVS     r6,#0
                  |L16.114|
;;;855    	}
;;;856    
;;;857    	return xReturn;
000072  4630              MOV      r0,r6
;;;858    }
000074  e8bd83f8          POP      {r3-r9,pc}
;;;859    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xStreamBufferReceive||, CODE, READONLY, ALIGN=1

                  xStreamBufferReceive PROC
;;;712    
;;;713    size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;714    							 void *pvRxData,
;;;715    							 size_t xBufferLengthBytes,
;;;716    							 TickType_t xTicksToWait )
;;;717    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4693              MOV      r11,r2
00000a  4699              MOV      r9,r3
;;;718    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
00000c  463c              MOV      r4,r7
;;;719    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
00000e  f04f0a00          MOV      r10,#0
;;;720    
;;;721    	configASSERT( pvRxData );
000012  f1b80f00          CMP      r8,#0
000016  d10a              BNE      |L17.46|
000018  bf00              NOP      
00001a  2050              MOVS     r0,#0x50
00001c  f3808811          MSR      BASEPRI,r0
000020  f3bf8f4f          DSB      
000024  f3bf8f6f          ISB      
000028  bf00              NOP      
00002a  bf00              NOP      
                  |L17.44|
00002c  e7fe              B        |L17.44|
                  |L17.46|
;;;722    	configASSERT( pxStreamBuffer );
00002e  b954              CBNZ     r4,|L17.70|
000030  bf00              NOP      
000032  2050              MOVS     r0,#0x50
000034  f3808811          MSR      BASEPRI,r0
000038  f3bf8f4f          DSB      
00003c  f3bf8f6f          ISB      
000040  bf00              NOP      
000042  bf00              NOP      
                  |L17.68|
000044  e7fe              B        |L17.68|
                  |L17.70|
;;;723    
;;;724    	/* This receive function is used by both message buffers, which store
;;;725    	discrete messages, and stream buffers, which store a continuous stream of
;;;726    	bytes.  Discrete messages include an additional
;;;727    	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
;;;728    	message. */
;;;729    	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
000046  7f20              LDRB     r0,[r4,#0x1c]
000048  f0000001          AND      r0,r0,#1
00004c  b108              CBZ      r0,|L17.82|
;;;730    	{
;;;731    		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
00004e  2604              MOVS     r6,#4
000050  e000              B        |L17.84|
                  |L17.82|
;;;732    	}
;;;733    	else
;;;734    	{
;;;735    		xBytesToStoreMessageLength = 0;
000052  2600              MOVS     r6,#0
                  |L17.84|
;;;736    	}
;;;737    
;;;738    	if( xTicksToWait != ( TickType_t ) 0 )
000054  f1b90f00          CMP      r9,#0
000058  d02f              BEQ      |L17.186|
;;;739    	{
;;;740    		/* Checking if there is data and clearing the notification state must be
;;;741    		performed atomically. */
;;;742    		taskENTER_CRITICAL();
00005a  f7fffffe          BL       vPortEnterCritical
;;;743    		{
;;;744    			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       prvBytesInBuffer
000064  4605              MOV      r5,r0
;;;745    
;;;746    			/* If this function was invoked by a message buffer read then
;;;747    			xBytesToStoreMessageLength holds the number of bytes used to hold
;;;748    			the length of the next discrete message.  If this function was
;;;749    			invoked by a stream buffer read then xBytesToStoreMessageLength will
;;;750    			be 0. */
;;;751    			if( xBytesAvailable <= xBytesToStoreMessageLength )
000066  42b5              CMP      r5,r6
000068  d816              BHI      |L17.152|
;;;752    			{
;;;753    				/* Clear notification state as going to wait for data. */
;;;754    				( void ) xTaskNotifyStateClear( NULL );
00006a  2000              MOVS     r0,#0
00006c  f7fffffe          BL       xTaskNotifyStateClear
;;;755    
;;;756    				/* Should only be one reader. */
;;;757    				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
000070  6920              LDR      r0,[r4,#0x10]
000072  b908              CBNZ     r0,|L17.120|
000074  2001              MOVS     r0,#1
000076  e000              B        |L17.122|
                  |L17.120|
000078  2000              MOVS     r0,#0
                  |L17.122|
00007a  b950              CBNZ     r0,|L17.146|
00007c  bf00              NOP      
00007e  2050              MOVS     r0,#0x50
000080  f3808811          MSR      BASEPRI,r0
000084  f3bf8f4f          DSB      
000088  f3bf8f6f          ISB      
00008c  bf00              NOP      
00008e  bf00              NOP      
                  |L17.144|
000090  e7fe              B        |L17.144|
                  |L17.146|
;;;758    				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
000092  f7fffffe          BL       xTaskGetCurrentTaskHandle
000096  6120              STR      r0,[r4,#0x10]
                  |L17.152|
;;;759    			}
;;;760    			else
;;;761    			{
;;;762    				mtCOVERAGE_TEST_MARKER();
;;;763    			}
;;;764    		}
;;;765    		taskEXIT_CRITICAL();
000098  f7fffffe          BL       vPortExitCritical
;;;766    
;;;767    		if( xBytesAvailable <= xBytesToStoreMessageLength )
00009c  42b5              CMP      r5,r6
00009e  d810              BHI      |L17.194|
;;;768    		{
;;;769    			/* Wait for data to be available. */
;;;770    			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
;;;771    			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
0000a0  464b              MOV      r3,r9
0000a2  2200              MOVS     r2,#0
0000a4  4611              MOV      r1,r2
0000a6  4610              MOV      r0,r2
0000a8  f7fffffe          BL       xTaskNotifyWait
;;;772    			pxStreamBuffer->xTaskWaitingToReceive = NULL;
0000ac  2000              MOVS     r0,#0
0000ae  6120              STR      r0,[r4,#0x10]
;;;773    
;;;774    			/* Recheck the data available after blocking. */
;;;775    			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
0000b0  4620              MOV      r0,r4
0000b2  f7fffffe          BL       prvBytesInBuffer
0000b6  4605              MOV      r5,r0
0000b8  e003              B        |L17.194|
                  |L17.186|
;;;776    		}
;;;777    		else
;;;778    		{
;;;779    			mtCOVERAGE_TEST_MARKER();
;;;780    		}
;;;781    	}
;;;782    	else
;;;783    	{
;;;784    		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
0000ba  4620              MOV      r0,r4
0000bc  f7fffffe          BL       prvBytesInBuffer
0000c0  4605              MOV      r5,r0
                  |L17.194|
;;;785    	}
;;;786    
;;;787    	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
;;;788    	holds the number of bytes used to store the message length) or a stream of
;;;789    	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
;;;790    	available must be greater than xBytesToStoreMessageLength to be able to
;;;791    	read bytes from the buffer. */
;;;792    	if( xBytesAvailable > xBytesToStoreMessageLength )
0000c2  42b5              CMP      r5,r6
0000c4  d918              BLS      |L17.248|
;;;793    	{
;;;794    		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
0000c6  462b              MOV      r3,r5
0000c8  465a              MOV      r2,r11
0000ca  4641              MOV      r1,r8
0000cc  4620              MOV      r0,r4
0000ce  9600              STR      r6,[sp,#0]
0000d0  f7fffffe          BL       prvReadMessageFromBuffer
0000d4  4682              MOV      r10,r0
;;;795    
;;;796    		/* Was a task waiting for space in the buffer? */
;;;797    		if( xReceivedLength != ( size_t ) 0 )
0000d6  f1ba0f00          CMP      r10,#0
0000da  d00d              BEQ      |L17.248|
;;;798    		{
;;;799    			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
;;;800    			sbRECEIVE_COMPLETED( pxStreamBuffer );
0000dc  f7fffffe          BL       vTaskSuspendAll
0000e0  6960              LDR      r0,[r4,#0x14]
0000e2  b138              CBZ      r0,|L17.244|
0000e4  6960              LDR      r0,[r4,#0x14]
0000e6  2300              MOVS     r3,#0
0000e8  461a              MOV      r2,r3
0000ea  4619              MOV      r1,r3
0000ec  f7fffffe          BL       xTaskGenericNotify
0000f0  2000              MOVS     r0,#0
0000f2  6160              STR      r0,[r4,#0x14]
                  |L17.244|
0000f4  f7fffffe          BL       xTaskResumeAll
                  |L17.248|
;;;801    		}
;;;802    		else
;;;803    		{
;;;804    			mtCOVERAGE_TEST_MARKER();
;;;805    		}
;;;806    	}
;;;807    	else
;;;808    	{
;;;809    		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
;;;810    		mtCOVERAGE_TEST_MARKER();
;;;811    	}
;;;812    
;;;813    	return xReceivedLength;
0000f8  4650              MOV      r0,r10
;;;814    }
0000fa  e8bd8ff8          POP      {r3-r11,pc}
;;;815    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xStreamBufferReceiveCompletedFromISR||, CODE, READONLY, ALIGN=1

                  xStreamBufferReceiveCompletedFromISR PROC
;;;1057   
;;;1058   BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1059   {
000004  4606              MOV      r6,r0
000006  4688              MOV      r8,r1
;;;1060   StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
000008  4635              MOV      r5,r6
;;;1061   BaseType_t xReturn;
;;;1062   UBaseType_t uxSavedInterruptStatus;
;;;1063   
;;;1064   	configASSERT( pxStreamBuffer );
00000a  b955              CBNZ     r5,|L18.34|
00000c  bf00              NOP      
00000e  2050              MOVS     r0,#0x50
000010  f3808811          MSR      BASEPRI,r0
000014  f3bf8f4f          DSB      
000018  f3bf8f6f          ISB      
00001c  bf00              NOP      
00001e  bf00              NOP      
                  |L18.32|
000020  e7fe              B        |L18.32|
                  |L18.34|
;;;1065   
;;;1066   	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
000022  bf00              NOP      
000024  2150              MOVS     r1,#0x50
000026  f3ef8011          MRS      r0,BASEPRI
00002a  f3818811          MSR      BASEPRI,r1
00002e  f3bf8f4f          DSB      
000032  f3bf8f6f          ISB      
000036  bf00              NOP      
000038  4604              MOV      r4,r0
;;;1067   	{
;;;1068   		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
00003a  6968              LDR      r0,[r5,#0x14]
00003c  b158              CBZ      r0,|L18.86|
;;;1069   		{
;;;1070   			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
00003e  f8cd8000          STR      r8,[sp,#0]
000042  6968              LDR      r0,[r5,#0x14]
000044  2300              MOVS     r3,#0
000046  461a              MOV      r2,r3
000048  4619              MOV      r1,r3
00004a  f7fffffe          BL       xTaskGenericNotifyFromISR
;;;1071   										 ( uint32_t ) 0,
;;;1072   										 eNoAction,
;;;1073   										 pxHigherPriorityTaskWoken );
;;;1074   			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
00004e  2000              MOVS     r0,#0
000050  6168              STR      r0,[r5,#0x14]
;;;1075   			xReturn = pdTRUE;
000052  2701              MOVS     r7,#1
000054  e000              B        |L18.88|
                  |L18.86|
;;;1076   		}
;;;1077   		else
;;;1078   		{
;;;1079   			xReturn = pdFALSE;
000056  2700              MOVS     r7,#0
                  |L18.88|
;;;1080   		}
;;;1081   	}
;;;1082   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000058  bf00              NOP      
00005a  f3848811          MSR      BASEPRI,r4
00005e  bf00              NOP      
;;;1083   
;;;1084   	return xReturn;
000060  4638              MOV      r0,r7
;;;1085   }
000062  e8bd83f8          POP      {r3-r9,pc}
;;;1086   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xStreamBufferReceiveFromISR||, CODE, READONLY, ALIGN=1

                  xStreamBufferReceiveFromISR PROC
;;;860    
;;;861    size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;862    									void *pvRxData,
;;;863    									size_t xBufferLengthBytes,
;;;864    									BaseType_t * const pxHigherPriorityTaskWoken )
;;;865    {
000004  b081              SUB      sp,sp,#4
000006  4680              MOV      r8,r0
000008  4689              MOV      r9,r1
00000a  469a              MOV      r10,r3
;;;866    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
00000c  4644              MOV      r4,r8
;;;867    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
00000e  f04f0b00          MOV      r11,#0
;;;868    
;;;869    	configASSERT( pvRxData );
000012  f1b90f00          CMP      r9,#0
000016  d10a              BNE      |L19.46|
000018  bf00              NOP      
00001a  2050              MOVS     r0,#0x50
00001c  f3808811          MSR      BASEPRI,r0
000020  f3bf8f4f          DSB      
000024  f3bf8f6f          ISB      
000028  bf00              NOP      
00002a  bf00              NOP      
                  |L19.44|
00002c  e7fe              B        |L19.44|
                  |L19.46|
;;;870    	configASSERT( pxStreamBuffer );
00002e  b954              CBNZ     r4,|L19.70|
000030  bf00              NOP      
000032  2050              MOVS     r0,#0x50
000034  f3808811          MSR      BASEPRI,r0
000038  f3bf8f4f          DSB      
00003c  f3bf8f6f          ISB      
000040  bf00              NOP      
000042  bf00              NOP      
                  |L19.68|
000044  e7fe              B        |L19.68|
                  |L19.70|
;;;871    
;;;872    	/* This receive function is used by both message buffers, which store
;;;873    	discrete messages, and stream buffers, which store a continuous stream of
;;;874    	bytes.  Discrete messages include an additional
;;;875    	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
;;;876    	message. */
;;;877    	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
000046  7f20              LDRB     r0,[r4,#0x1c]
000048  f0000001          AND      r0,r0,#1
00004c  b108              CBZ      r0,|L19.82|
;;;878    	{
;;;879    		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
00004e  2604              MOVS     r6,#4
000050  e000              B        |L19.84|
                  |L19.82|
;;;880    	}
;;;881    	else
;;;882    	{
;;;883    		xBytesToStoreMessageLength = 0;
000052  2600              MOVS     r6,#0
                  |L19.84|
;;;884    	}
;;;885    
;;;886    	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       prvBytesInBuffer
00005a  4605              MOV      r5,r0
;;;887    
;;;888    	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
;;;889    	holds the number of bytes used to store the message length) or a stream of
;;;890    	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
;;;891    	available must be greater than xBytesToStoreMessageLength to be able to
;;;892    	read bytes from the buffer. */
;;;893    	if( xBytesAvailable > xBytesToStoreMessageLength )
00005c  42b5              CMP      r5,r6
00005e  d927              BLS      |L19.176|
;;;894    	{
;;;895    		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
000060  462b              MOV      r3,r5
000062  9600              STR      r6,[sp,#0]
000064  4649              MOV      r1,r9
000066  4620              MOV      r0,r4
000068  9a03              LDR      r2,[sp,#0xc]
00006a  f7fffffe          BL       prvReadMessageFromBuffer
00006e  4683              MOV      r11,r0
;;;896    
;;;897    		/* Was a task waiting for space in the buffer? */
;;;898    		if( xReceivedLength != ( size_t ) 0 )
000070  f1bb0f00          CMP      r11,#0
000074  d01c              BEQ      |L19.176|
;;;899    		{
;;;900    			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
000076  bf00              NOP      
000078  2150              MOVS     r1,#0x50
00007a  f3ef8011          MRS      r0,BASEPRI
00007e  f3818811          MSR      BASEPRI,r1
000082  f3bf8f4f          DSB      
000086  f3bf8f6f          ISB      
00008a  bf00              NOP      
00008c  4607              MOV      r7,r0
00008e  6960              LDR      r0,[r4,#0x14]
000090  b148              CBZ      r0,|L19.166|
000092  f8cda000          STR      r10,[sp,#0]
000096  6960              LDR      r0,[r4,#0x14]
000098  2300              MOVS     r3,#0
00009a  461a              MOV      r2,r3
00009c  4619              MOV      r1,r3
00009e  f7fffffe          BL       xTaskGenericNotifyFromISR
0000a2  2000              MOVS     r0,#0
0000a4  6160              STR      r0,[r4,#0x14]
                  |L19.166|
0000a6  bf00              NOP      
0000a8  f3878811          MSR      BASEPRI,r7
0000ac  bf00              NOP      
0000ae  bf00              NOP      
                  |L19.176|
;;;901    		}
;;;902    		else
;;;903    		{
;;;904    			mtCOVERAGE_TEST_MARKER();
;;;905    		}
;;;906    	}
;;;907    	else
;;;908    	{
;;;909    		mtCOVERAGE_TEST_MARKER();
;;;910    	}
;;;911    
;;;912    	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );
;;;913    
;;;914    	return xReceivedLength;
0000b0  4658              MOV      r0,r11
;;;915    }
0000b2  b005              ADD      sp,sp,#0x14
0000b4  e8bd8ff0          POP      {r4-r11,pc}
;;;916    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xStreamBufferReset||, CODE, READONLY, ALIGN=1

                  xStreamBufferReset PROC
;;;391    
;;;392    BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
000000  b5f8              PUSH     {r3-r7,lr}
;;;393    {
000002  4605              MOV      r5,r0
;;;394    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
000004  462c              MOV      r4,r5
;;;395    BaseType_t xReturn = pdFAIL;
000006  2700              MOVS     r7,#0
;;;396    
;;;397    #if( configUSE_TRACE_FACILITY == 1 )
;;;398    	UBaseType_t uxStreamBufferNumber;
;;;399    #endif
;;;400    
;;;401    	configASSERT( pxStreamBuffer );
000008  b954              CBNZ     r4,|L20.32|
00000a  bf00              NOP      
00000c  2050              MOVS     r0,#0x50
00000e  f3808811          MSR      BASEPRI,r0
000012  f3bf8f4f          DSB      
000016  f3bf8f6f          ISB      
00001a  bf00              NOP      
00001c  bf00              NOP      
                  |L20.30|
00001e  e7fe              B        |L20.30|
                  |L20.32|
;;;402    
;;;403    	#if( configUSE_TRACE_FACILITY == 1 )
;;;404    	{
;;;405    		/* Store the stream buffer number so it can be restored after the
;;;406    		reset. */
;;;407    		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
000020  6a26              LDR      r6,[r4,#0x20]
;;;408    	}
;;;409    	#endif
;;;410    
;;;411    	/* Can only reset a message buffer if there are no tasks blocked on it. */
;;;412    	taskENTER_CRITICAL();
000022  f7fffffe          BL       vPortEnterCritical
;;;413    	{
;;;414    		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
000026  6920              LDR      r0,[r4,#0x10]
000028  b958              CBNZ     r0,|L20.66|
;;;415    		{
;;;416    			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
00002a  6960              LDR      r0,[r4,#0x14]
00002c  b948              CBNZ     r0,|L20.66|
;;;417    			{
;;;418    				prvInitialiseNewStreamBuffer( pxStreamBuffer,
00002e  7f20              LDRB     r0,[r4,#0x1c]
000030  9000              STR      r0,[sp,#0]
000032  4620              MOV      r0,r4
000034  e9d42302          LDRD     r2,r3,[r4,#8]
000038  69a1              LDR      r1,[r4,#0x18]
00003a  f7fffffe          BL       prvInitialiseNewStreamBuffer
;;;419    											  pxStreamBuffer->pucBuffer,
;;;420    											  pxStreamBuffer->xLength,
;;;421    											  pxStreamBuffer->xTriggerLevelBytes,
;;;422    											  pxStreamBuffer->ucFlags );
;;;423    				xReturn = pdPASS;
00003e  2701              MOVS     r7,#1
;;;424    
;;;425    				#if( configUSE_TRACE_FACILITY == 1 )
;;;426    				{
;;;427    					pxStreamBuffer->uxStreamBufferNumber = uxStreamBufferNumber;
000040  6226              STR      r6,[r4,#0x20]
                  |L20.66|
;;;428    				}
;;;429    				#endif
;;;430    
;;;431    				traceSTREAM_BUFFER_RESET( xStreamBuffer );
;;;432    			}
;;;433    		}
;;;434    	}
;;;435    	taskEXIT_CRITICAL();
000042  f7fffffe          BL       vPortExitCritical
;;;436    
;;;437    	return xReturn;
000046  4638              MOV      r0,r7
;;;438    }
000048  bdf8              POP      {r3-r7,pc}
;;;439    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xStreamBufferSend||, CODE, READONLY, ALIGN=1

                  xStreamBufferSend PROC
;;;505    
;;;506    size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;507    						  const void *pvTxData,
;;;508    						  size_t xDataLengthBytes,
;;;509    						  TickType_t xTicksToWait )
;;;510    {
000004  b084              SUB      sp,sp,#0x10
000006  4681              MOV      r9,r0
000008  468a              MOV      r10,r1
00000a  4616              MOV      r6,r2
;;;511    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
00000c  464c              MOV      r4,r9
;;;512    size_t xReturn, xSpace = 0;
00000e  f04f0800          MOV      r8,#0
;;;513    size_t xRequiredSpace = xDataLengthBytes;
000012  4635              MOV      r5,r6
;;;514    TimeOut_t xTimeOut;
;;;515    
;;;516    	configASSERT( pvTxData );
000014  f1ba0f00          CMP      r10,#0
000018  d10a              BNE      |L21.48|
00001a  bf00              NOP      
00001c  2050              MOVS     r0,#0x50
00001e  f3808811          MSR      BASEPRI,r0
000022  f3bf8f4f          DSB      
000026  f3bf8f6f          ISB      
00002a  bf00              NOP      
00002c  bf00              NOP      
                  |L21.46|
00002e  e7fe              B        |L21.46|
                  |L21.48|
;;;517    	configASSERT( pxStreamBuffer );
000030  b954              CBNZ     r4,|L21.72|
000032  bf00              NOP      
000034  2050              MOVS     r0,#0x50
000036  f3808811          MSR      BASEPRI,r0
00003a  f3bf8f4f          DSB      
00003e  f3bf8f6f          ISB      
000042  bf00              NOP      
000044  bf00              NOP      
                  |L21.70|
000046  e7fe              B        |L21.70|
                  |L21.72|
;;;518    
;;;519    	/* This send function is used to write to both message buffers and stream
;;;520    	buffers.  If this is a message buffer then the space needed must be
;;;521    	increased by the amount of bytes needed to store the length of the
;;;522    	message. */
;;;523    	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
000048  7f20              LDRB     r0,[r4,#0x1c]
00004a  f0000001          AND      r0,r0,#1
00004e  b188              CBZ      r0,|L21.116|
;;;524    	{
;;;525    		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
000050  1d2d              ADDS     r5,r5,#4
;;;526    
;;;527    		/* Overflow? */
;;;528    		configASSERT( xRequiredSpace > xDataLengthBytes );
000052  42b5              CMP      r5,r6
000054  d901              BLS      |L21.90|
000056  2001              MOVS     r0,#1
000058  e000              B        |L21.92|
                  |L21.90|
00005a  2000              MOVS     r0,#0
                  |L21.92|
00005c  b950              CBNZ     r0,|L21.116|
00005e  bf00              NOP      
000060  2050              MOVS     r0,#0x50
000062  f3808811          MSR      BASEPRI,r0
000066  f3bf8f4f          DSB      
00006a  f3bf8f6f          ISB      
00006e  bf00              NOP      
000070  bf00              NOP      
                  |L21.114|
000072  e7fe              B        |L21.114|
                  |L21.116|
;;;529    	}
;;;530    	else
;;;531    	{
;;;532    		mtCOVERAGE_TEST_MARKER();
;;;533    	}
;;;534    
;;;535    	if( xTicksToWait != ( TickType_t ) 0 )
000074  9807              LDR      r0,[sp,#0x1c]
000076  b3b8              CBZ      r0,|L21.232|
;;;536    	{
;;;537    		vTaskSetTimeOutState( &xTimeOut );
000078  a802              ADD      r0,sp,#8
00007a  f7fffffe          BL       vTaskSetTimeOutState
;;;538    
;;;539    		do
00007e  bf00              NOP      
                  |L21.128|
;;;540    		{
;;;541    			/* Wait until the required number of bytes are free in the message
;;;542    			buffer. */
;;;543    			taskENTER_CRITICAL();
000080  f7fffffe          BL       vPortEnterCritical
;;;544    			{
;;;545    				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
000084  4620              MOV      r0,r4
000086  f7fffffe          BL       xStreamBufferSpacesAvailable
00008a  4680              MOV      r8,r0
;;;546    
;;;547    				if( xSpace < xRequiredSpace )
00008c  45a8              CMP      r8,r5
00008e  d217              BCS      |L21.192|
;;;548    				{
;;;549    					/* Clear notification state as going to wait for space. */
;;;550    					( void ) xTaskNotifyStateClear( NULL );
000090  2000              MOVS     r0,#0
000092  f7fffffe          BL       xTaskNotifyStateClear
;;;551    
;;;552    					/* Should only be one writer. */
;;;553    					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
000096  6960              LDR      r0,[r4,#0x14]
000098  b908              CBNZ     r0,|L21.158|
00009a  2001              MOVS     r0,#1
00009c  e000              B        |L21.160|
                  |L21.158|
00009e  2000              MOVS     r0,#0
                  |L21.160|
0000a0  b950              CBNZ     r0,|L21.184|
0000a2  bf00              NOP      
0000a4  2050              MOVS     r0,#0x50
0000a6  f3808811          MSR      BASEPRI,r0
0000aa  f3bf8f4f          DSB      
0000ae  f3bf8f6f          ISB      
0000b2  bf00              NOP      
0000b4  bf00              NOP      
                  |L21.182|
0000b6  e7fe              B        |L21.182|
                  |L21.184|
;;;554    					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
0000b8  f7fffffe          BL       xTaskGetCurrentTaskHandle
0000bc  6160              STR      r0,[r4,#0x14]
0000be  e002              B        |L21.198|
                  |L21.192|
;;;555    				}
;;;556    				else
;;;557    				{
;;;558    					taskEXIT_CRITICAL();
0000c0  f7fffffe          BL       vPortExitCritical
;;;559    					break;
0000c4  e00f              B        |L21.230|
                  |L21.198|
;;;560    				}
;;;561    			}
;;;562    			taskEXIT_CRITICAL();
0000c6  f7fffffe          BL       vPortExitCritical
;;;563    
;;;564    			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
;;;565    			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
0000ca  2200              MOVS     r2,#0
0000cc  4611              MOV      r1,r2
0000ce  4610              MOV      r0,r2
0000d0  9b07              LDR      r3,[sp,#0x1c]
0000d2  f7fffffe          BL       xTaskNotifyWait
;;;566    			pxStreamBuffer->xTaskWaitingToSend = NULL;
0000d6  2000              MOVS     r0,#0
0000d8  6160              STR      r0,[r4,#0x14]
;;;567    
;;;568    		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
0000da  a907              ADD      r1,sp,#0x1c
0000dc  a802              ADD      r0,sp,#8
0000de  f7fffffe          BL       xTaskCheckForTimeOut
0000e2  2800              CMP      r0,#0
0000e4  d0cc              BEQ      |L21.128|
                  |L21.230|
0000e6  bf00              NOP                            ;559
                  |L21.232|
;;;569    	}
;;;570    	else
;;;571    	{
;;;572    		mtCOVERAGE_TEST_MARKER();
;;;573    	}
;;;574    
;;;575    	if( xSpace == ( size_t ) 0 )
0000e8  f1b80f00          CMP      r8,#0
0000ec  d103              BNE      |L21.246|
;;;576    	{
;;;577    		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
0000ee  4620              MOV      r0,r4
0000f0  f7fffffe          BL       xStreamBufferSpacesAvailable
0000f4  4680              MOV      r8,r0
                  |L21.246|
;;;578    	}
;;;579    	else
;;;580    	{
;;;581    		mtCOVERAGE_TEST_MARKER();
;;;582    	}
;;;583    
;;;584    	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
0000f6  4643              MOV      r3,r8
0000f8  4632              MOV      r2,r6
0000fa  4651              MOV      r1,r10
0000fc  4620              MOV      r0,r4
0000fe  9500              STR      r5,[sp,#0]
000100  f7fffffe          BL       prvWriteMessageToBuffer
000104  4607              MOV      r7,r0
;;;585    
;;;586    	if( xReturn > ( size_t ) 0 )
000106  b19f              CBZ      r7,|L21.304|
;;;587    	{
;;;588    		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );
;;;589    
;;;590    		/* Was a task waiting for the data? */
;;;591    		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
000108  4620              MOV      r0,r4
00010a  f7fffffe          BL       prvBytesInBuffer
00010e  68e1              LDR      r1,[r4,#0xc]
000110  4288              CMP      r0,r1
000112  d30d              BCC      |L21.304|
;;;592    		{
;;;593    			sbSEND_COMPLETED( pxStreamBuffer );
000114  f7fffffe          BL       vTaskSuspendAll
000118  6920              LDR      r0,[r4,#0x10]
00011a  b138              CBZ      r0,|L21.300|
00011c  6920              LDR      r0,[r4,#0x10]
00011e  2300              MOVS     r3,#0
000120  461a              MOV      r2,r3
000122  4619              MOV      r1,r3
000124  f7fffffe          BL       xTaskGenericNotify
000128  2000              MOVS     r0,#0
00012a  6120              STR      r0,[r4,#0x10]
                  |L21.300|
00012c  f7fffffe          BL       xTaskResumeAll
                  |L21.304|
;;;594    		}
;;;595    		else
;;;596    		{
;;;597    			mtCOVERAGE_TEST_MARKER();
;;;598    		}
;;;599    	}
;;;600    	else
;;;601    	{
;;;602    		mtCOVERAGE_TEST_MARKER();
;;;603    		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
;;;604    	}
;;;605    
;;;606    	return xReturn;
000130  4638              MOV      r0,r7
;;;607    }
000132  b008              ADD      sp,sp,#0x20
000134  e8bd87f0          POP      {r4-r10,pc}
;;;608    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xStreamBufferSendCompletedFromISR||, CODE, READONLY, ALIGN=1

                  xStreamBufferSendCompletedFromISR PROC
;;;1027   
;;;1028   BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1029   {
000004  4606              MOV      r6,r0
000006  4688              MOV      r8,r1
;;;1030   StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
000008  4635              MOV      r5,r6
;;;1031   BaseType_t xReturn;
;;;1032   UBaseType_t uxSavedInterruptStatus;
;;;1033   
;;;1034   	configASSERT( pxStreamBuffer );
00000a  b955              CBNZ     r5,|L22.34|
00000c  bf00              NOP      
00000e  2050              MOVS     r0,#0x50
000010  f3808811          MSR      BASEPRI,r0
000014  f3bf8f4f          DSB      
000018  f3bf8f6f          ISB      
00001c  bf00              NOP      
00001e  bf00              NOP      
                  |L22.32|
000020  e7fe              B        |L22.32|
                  |L22.34|
;;;1035   
;;;1036   	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
000022  bf00              NOP      
000024  2150              MOVS     r1,#0x50
000026  f3ef8011          MRS      r0,BASEPRI
00002a  f3818811          MSR      BASEPRI,r1
00002e  f3bf8f4f          DSB      
000032  f3bf8f6f          ISB      
000036  bf00              NOP      
000038  4604              MOV      r4,r0
;;;1037   	{
;;;1038   		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
00003a  6928              LDR      r0,[r5,#0x10]
00003c  b158              CBZ      r0,|L22.86|
;;;1039   		{
;;;1040   			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
00003e  f8cd8000          STR      r8,[sp,#0]
000042  6928              LDR      r0,[r5,#0x10]
000044  2300              MOVS     r3,#0
000046  461a              MOV      r2,r3
000048  4619              MOV      r1,r3
00004a  f7fffffe          BL       xTaskGenericNotifyFromISR
;;;1041   										 ( uint32_t ) 0,
;;;1042   										 eNoAction,
;;;1043   										 pxHigherPriorityTaskWoken );
;;;1044   			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
00004e  2000              MOVS     r0,#0
000050  6128              STR      r0,[r5,#0x10]
;;;1045   			xReturn = pdTRUE;
000052  2701              MOVS     r7,#1
000054  e000              B        |L22.88|
                  |L22.86|
;;;1046   		}
;;;1047   		else
;;;1048   		{
;;;1049   			xReturn = pdFALSE;
000056  2700              MOVS     r7,#0
                  |L22.88|
;;;1050   		}
;;;1051   	}
;;;1052   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000058  bf00              NOP      
00005a  f3848811          MSR      BASEPRI,r4
00005e  bf00              NOP      
;;;1053   
;;;1054   	return xReturn;
000060  4638              MOV      r0,r7
;;;1055   }
000062  e8bd83f8          POP      {r3-r9,pc}
;;;1056   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xStreamBufferSendFromISR||, CODE, READONLY, ALIGN=1

                  xStreamBufferSendFromISR PROC
;;;609    
;;;610    size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;611    								 const void *pvTxData,
;;;612    								 size_t xDataLengthBytes,
;;;613    								 BaseType_t * const pxHigherPriorityTaskWoken )
;;;614    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
00000a  469a              MOV      r10,r3
;;;615    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
00000c  463c              MOV      r4,r7
;;;616    size_t xReturn, xSpace;
;;;617    size_t xRequiredSpace = xDataLengthBytes;
00000e  46cb              MOV      r11,r9
;;;618    
;;;619    	configASSERT( pvTxData );
000010  f1b80f00          CMP      r8,#0
000014  d10a              BNE      |L23.44|
000016  bf00              NOP      
000018  2050              MOVS     r0,#0x50
00001a  f3808811          MSR      BASEPRI,r0
00001e  f3bf8f4f          DSB      
000022  f3bf8f6f          ISB      
000026  bf00              NOP      
000028  bf00              NOP      
                  |L23.42|
00002a  e7fe              B        |L23.42|
                  |L23.44|
;;;620    	configASSERT( pxStreamBuffer );
00002c  b954              CBNZ     r4,|L23.68|
00002e  bf00              NOP      
000030  2050              MOVS     r0,#0x50
000032  f3808811          MSR      BASEPRI,r0
000036  f3bf8f4f          DSB      
00003a  f3bf8f6f          ISB      
00003e  bf00              NOP      
000040  bf00              NOP      
                  |L23.66|
000042  e7fe              B        |L23.66|
                  |L23.68|
;;;621    
;;;622    	/* This send function is used to write to both message buffers and stream
;;;623    	buffers.  If this is a message buffer then the space needed must be
;;;624    	increased by the amount of bytes needed to store the length of the
;;;625    	message. */
;;;626    	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
000044  7f20              LDRB     r0,[r4,#0x1c]
000046  f0000001          AND      r0,r0,#1
00004a  b108              CBZ      r0,|L23.80|
;;;627    	{
;;;628    		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
00004c  f10b0b04          ADD      r11,r11,#4
                  |L23.80|
;;;629    	}
;;;630    	else
;;;631    	{
;;;632    		mtCOVERAGE_TEST_MARKER();
;;;633    	}
;;;634    
;;;635    	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       xStreamBufferSpacesAvailable
000056  9001              STR      r0,[sp,#4]
;;;636    	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
000058  f8cdb000          STR      r11,[sp,#0]
00005c  464a              MOV      r2,r9
00005e  4641              MOV      r1,r8
000060  4620              MOV      r0,r4
000062  9b01              LDR      r3,[sp,#4]
000064  f7fffffe          BL       prvWriteMessageToBuffer
000068  4605              MOV      r5,r0
;;;637    
;;;638    	if( xReturn > ( size_t ) 0 )
00006a  b315              CBZ      r5,|L23.178|
;;;639    	{
;;;640    		/* Was a task waiting for the data? */
;;;641    		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
00006c  4620              MOV      r0,r4
00006e  f7fffffe          BL       prvBytesInBuffer
000072  68e1              LDR      r1,[r4,#0xc]
000074  4288              CMP      r0,r1
000076  d31c              BCC      |L23.178|
;;;642    		{
;;;643    			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
000078  bf00              NOP      
00007a  2150              MOVS     r1,#0x50
00007c  f3ef8011          MRS      r0,BASEPRI
000080  f3818811          MSR      BASEPRI,r1
000084  f3bf8f4f          DSB      
000088  f3bf8f6f          ISB      
00008c  bf00              NOP      
00008e  4606              MOV      r6,r0
000090  6920              LDR      r0,[r4,#0x10]
000092  b148              CBZ      r0,|L23.168|
000094  f8cda000          STR      r10,[sp,#0]
000098  6920              LDR      r0,[r4,#0x10]
00009a  2300              MOVS     r3,#0
00009c  461a              MOV      r2,r3
00009e  4619              MOV      r1,r3
0000a0  f7fffffe          BL       xTaskGenericNotifyFromISR
0000a4  2000              MOVS     r0,#0
0000a6  6120              STR      r0,[r4,#0x10]
                  |L23.168|
0000a8  bf00              NOP      
0000aa  f3868811          MSR      BASEPRI,r6
0000ae  bf00              NOP      
0000b0  bf00              NOP      
                  |L23.178|
;;;644    		}
;;;645    		else
;;;646    		{
;;;647    			mtCOVERAGE_TEST_MARKER();
;;;648    		}
;;;649    	}
;;;650    	else
;;;651    	{
;;;652    		mtCOVERAGE_TEST_MARKER();
;;;653    	}
;;;654    
;;;655    	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );
;;;656    
;;;657    	return xReturn;
0000b2  4628              MOV      r0,r5
;;;658    }
0000b4  e8bd9ffc          POP      {r2-r12,pc}
;;;659    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xStreamBufferSetTriggerLevel||, CODE, READONLY, ALIGN=1

                  xStreamBufferSetTriggerLevel PROC
;;;440    
;;;441    BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
000000  b530              PUSH     {r4,r5,lr}
;;;442    {
000002  4602              MOV      r2,r0
;;;443    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
000004  4613              MOV      r3,r2
;;;444    BaseType_t xReturn;
;;;445    
;;;446    	configASSERT( pxStreamBuffer );
000006  b953              CBNZ     r3,|L24.30|
000008  bf00              NOP      
00000a  2450              MOVS     r4,#0x50
00000c  f3848811          MSR      BASEPRI,r4
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L24.28|
00001c  e7fe              B        |L24.28|
                  |L24.30|
;;;447    
;;;448    	/* It is not valid for the trigger level to be 0. */
;;;449    	if( xTriggerLevel == ( size_t ) 0 )
00001e  b901              CBNZ     r1,|L24.34|
;;;450    	{
;;;451    		xTriggerLevel = ( size_t ) 1;
000020  2101              MOVS     r1,#1
                  |L24.34|
;;;452    	}
;;;453    
;;;454    	/* The trigger level is the number of bytes that must be in the stream
;;;455    	buffer before a task that is waiting for data is unblocked. */
;;;456    	if( xTriggerLevel <= pxStreamBuffer->xLength )
000022  689c              LDR      r4,[r3,#8]
000024  428c              CMP      r4,r1
000026  d302              BCC      |L24.46|
;;;457    	{
;;;458    		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
000028  60d9              STR      r1,[r3,#0xc]
;;;459    		xReturn = pdPASS;
00002a  2001              MOVS     r0,#1
00002c  e000              B        |L24.48|
                  |L24.46|
;;;460    	}
;;;461    	else
;;;462    	{
;;;463    		xReturn = pdFALSE;
00002e  2000              MOVS     r0,#0
                  |L24.48|
;;;464    	}
;;;465    
;;;466    	return xReturn;
;;;467    }
000030  bd30              POP      {r4,r5,pc}
;;;468    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xStreamBufferSpacesAvailable||, CODE, READONLY, ALIGN=1

                  xStreamBufferSpacesAvailable PROC
;;;469    
;;;470    size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
000000  b510              PUSH     {r4,lr}
;;;471    {
000002  4602              MOV      r2,r0
;;;472    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
000004  4611              MOV      r1,r2
;;;473    size_t xSpace;
;;;474    
;;;475    	configASSERT( pxStreamBuffer );
000006  b951              CBNZ     r1,|L25.30|
000008  bf00              NOP      
00000a  2350              MOVS     r3,#0x50
00000c  f3838811          MSR      BASEPRI,r3
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L25.28|
00001c  e7fe              B        |L25.28|
                  |L25.30|
;;;476    
;;;477    	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
00001e  680c              LDR      r4,[r1,#0]
000020  688b              LDR      r3,[r1,#8]
000022  1918              ADDS     r0,r3,r4
;;;478    	xSpace -= pxStreamBuffer->xHead;
000024  684b              LDR      r3,[r1,#4]
000026  1ac0              SUBS     r0,r0,r3
;;;479    	xSpace -= ( size_t ) 1;
000028  1e40              SUBS     r0,r0,#1
;;;480    
;;;481    	if( xSpace >= pxStreamBuffer->xLength )
00002a  688b              LDR      r3,[r1,#8]
00002c  4283              CMP      r3,r0
00002e  d801              BHI      |L25.52|
;;;482    	{
;;;483    		xSpace -= pxStreamBuffer->xLength;
000030  688b              LDR      r3,[r1,#8]
000032  1ac0              SUBS     r0,r0,r3
                  |L25.52|
;;;484    	}
;;;485    	else
;;;486    	{
;;;487    		mtCOVERAGE_TEST_MARKER();
;;;488    	}
;;;489    
;;;490    	return xSpace;
;;;491    }
000034  bd10              POP      {r4,pc}
;;;492    /*-----------------------------------------------------------*/
                          ENDP

