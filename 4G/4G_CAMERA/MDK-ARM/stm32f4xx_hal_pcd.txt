; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o4gcamera\stm32f4xx_hal_pcd.o --asm_dir=.\ --list_dir=.\ --depend=4gcamera\stm32f4xx_hal_pcd.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../USB_DEVICE/App -I../USB_DEVICE/Target -I../Core/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Middlewares/ST/STM32_USB_Device_Library/Core/Inc -I../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 -I../Middlewares/Third_Party/FreeRTOS/Source/portable/RVDS/ARM_CM4F -I../HARDWARE/OV2640 -I../HARDWARE/WS2812B -I../HARDWARE/RING_BUFFER -I../HARDWARE/FLASH -I.\RTE\_4GCAMERA -IC:\Users\czm\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\czm\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=536 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F407xx --omf_browse=4gcamera\stm32f4xx_hal_pcd.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_pcd.c]
                          THUMB

                          AREA ||i.HAL_PCD_ActivateRemoteWakeup||, CODE, READONLY, ALIGN=1

                  HAL_PCD_ActivateRemoteWakeup PROC
;;;2082     */
;;;2083   HAL_StatusTypeDef HAL_PCD_ActivateRemoteWakeup(PCD_HandleTypeDef *hpcd)
000000  b510              PUSH     {r4,lr}
;;;2084   {
000002  4604              MOV      r4,r0
;;;2085     return (USB_ActivateRemoteWakeup(hpcd->Instance));
000004  6820              LDR      r0,[r4,#0]
000006  f7fffffe          BL       USB_ActivateRemoteWakeup
;;;2086   }
00000a  bd10              POP      {r4,pc}
;;;2087   
                          ENDP


                          AREA ||i.HAL_PCD_ConnectCallback||, CODE, READONLY, ALIGN=1

                  HAL_PCD_ConnectCallback PROC
;;;1680     */
;;;1681   __weak void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
000000  4770              BX       lr
;;;1682   {
;;;1683     /* Prevent unused argument(s) compilation warning */
;;;1684     UNUSED(hpcd);
;;;1685   
;;;1686     /* NOTE : This function should not be modified, when the callback is needed,
;;;1687               the HAL_PCD_ConnectCallback could be implemented in the user file
;;;1688      */
;;;1689   }
;;;1690   
                          ENDP


                          AREA ||i.HAL_PCD_DataInStageCallback||, CODE, READONLY, ALIGN=1

                  HAL_PCD_DataInStageCallback PROC
;;;1556     */
;;;1557   __weak void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
000000  4770              BX       lr
;;;1558   {
;;;1559     /* Prevent unused argument(s) compilation warning */
;;;1560     UNUSED(hpcd);
;;;1561     UNUSED(epnum);
;;;1562   
;;;1563     /* NOTE : This function should not be modified, when the callback is needed,
;;;1564               the HAL_PCD_DataInStageCallback could be implemented in the user file
;;;1565      */
;;;1566   }
;;;1567   /**
                          ENDP


                          AREA ||i.HAL_PCD_DataOutStageCallback||, CODE, READONLY, ALIGN=1

                  HAL_PCD_DataOutStageCallback PROC
;;;1539     */
;;;1540   __weak void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
000000  4770              BX       lr
;;;1541   {
;;;1542     /* Prevent unused argument(s) compilation warning */
;;;1543     UNUSED(hpcd);
;;;1544     UNUSED(epnum);
;;;1545   
;;;1546     /* NOTE : This function should not be modified, when the callback is needed,
;;;1547               the HAL_PCD_DataOutStageCallback could be implemented in the user file
;;;1548      */
;;;1549   }
;;;1550   
                          ENDP


                          AREA ||i.HAL_PCD_DeActivateRemoteWakeup||, CODE, READONLY, ALIGN=1

                  HAL_PCD_DeActivateRemoteWakeup PROC
;;;2092     */
;;;2093   HAL_StatusTypeDef HAL_PCD_DeActivateRemoteWakeup(PCD_HandleTypeDef *hpcd)
000000  b510              PUSH     {r4,lr}
;;;2094   {
000002  4604              MOV      r4,r0
;;;2095     return (USB_DeActivateRemoteWakeup(hpcd->Instance));
000004  6820              LDR      r0,[r4,#0]
000006  f7fffffe          BL       USB_DeActivateRemoteWakeup
;;;2096   }
00000a  bd10              POP      {r4,pc}
;;;2097   
                          ENDP


                          AREA ||i.HAL_PCD_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_PCD_DeInit PROC
;;;243      */
;;;244    HAL_StatusTypeDef HAL_PCD_DeInit(PCD_HandleTypeDef *hpcd)
000000  b510              PUSH     {r4,lr}
;;;245    {
000002  4604              MOV      r4,r0
;;;246      /* Check the PCD handle allocation */
;;;247      if (hpcd == NULL)
000004  b90c              CBNZ     r4,|L6.10|
;;;248      {
;;;249        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L6.8|
;;;250      }
;;;251    
;;;252      hpcd->State = HAL_PCD_STATE_BUSY;
;;;253    
;;;254      /* Stop Device */
;;;255      if (USB_StopDevice(hpcd->Instance) != HAL_OK)
;;;256      {
;;;257        return HAL_ERROR;
;;;258      }
;;;259    
;;;260    #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
;;;261      if (hpcd->MspDeInitCallback == NULL)
;;;262      {
;;;263        hpcd->MspDeInitCallback = HAL_PCD_MspDeInit; /* Legacy weak MspDeInit  */
;;;264      }
;;;265    
;;;266      /* DeInit the low level hardware */
;;;267      hpcd->MspDeInitCallback(hpcd);
;;;268    #else
;;;269      /* DeInit the low level hardware: CLOCK, NVIC.*/
;;;270      HAL_PCD_MspDeInit(hpcd);
;;;271    #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
;;;272    
;;;273      hpcd->State = HAL_PCD_STATE_RESET;
;;;274    
;;;275      return HAL_OK;
;;;276    }
000008  bd10              POP      {r4,pc}
                  |L6.10|
00000a  2003              MOVS     r0,#3                 ;252
00000c  f88404bd          STRB     r0,[r4,#0x4bd]        ;252
000010  6820              LDR      r0,[r4,#0]            ;255
000012  f7fffffe          BL       USB_StopDevice
000016  b108              CBZ      r0,|L6.28|
000018  2001              MOVS     r0,#1                 ;257
00001a  e7f5              B        |L6.8|
                  |L6.28|
00001c  4620              MOV      r0,r4                 ;270
00001e  f7fffffe          BL       HAL_PCD_MspDeInit
000022  2000              MOVS     r0,#0                 ;273
000024  f88404bd          STRB     r0,[r4,#0x4bd]        ;273
000028  bf00              NOP                            ;275
00002a  e7ed              B        |L6.8|
;;;277    
                          ENDP


                          AREA ||i.HAL_PCD_DevConnect||, CODE, READONLY, ALIGN=1

                  HAL_PCD_DevConnect PROC
;;;1729     */
;;;1730   HAL_StatusTypeDef HAL_PCD_DevConnect(PCD_HandleTypeDef *hpcd)
000000  b570              PUSH     {r4-r6,lr}
;;;1731   {
000002  4604              MOV      r4,r0
;;;1732     USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
000004  6825              LDR      r5,[r4,#0]
;;;1733   
;;;1734     __HAL_LOCK(hpcd);
000006  bf00              NOP      
000008  f89404bc          LDRB     r0,[r4,#0x4bc]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L7.20|
000010  2002              MOVS     r0,#2
                  |L7.18|
;;;1735   
;;;1736     if ((hpcd->Init.battery_charging_enable == 1U) &&
;;;1737         (hpcd->Init.phy_itface != USB_OTG_ULPI_PHY))
;;;1738     {
;;;1739       /* Enable USB Transceiver */
;;;1740       USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
;;;1741     }
;;;1742     (void)USB_DevConnect(hpcd->Instance);
;;;1743     __HAL_UNLOCK(hpcd);
;;;1744   
;;;1745     return HAL_OK;
;;;1746   }
000012  bd70              POP      {r4-r6,pc}
                  |L7.20|
000014  2001              MOVS     r0,#1                 ;1734
000016  f88404bc          STRB     r0,[r4,#0x4bc]        ;1734
00001a  bf00              NOP                            ;1734
00001c  6aa0              LDR      r0,[r4,#0x28]         ;1736
00001e  2801              CMP      r0,#1                 ;1736
000020  d106              BNE      |L7.48|
000022  69a0              LDR      r0,[r4,#0x18]         ;1737
000024  2801              CMP      r0,#1                 ;1737
000026  d003              BEQ      |L7.48|
000028  6ba8              LDR      r0,[r5,#0x38]         ;1740
00002a  f4403080          ORR      r0,r0,#0x10000        ;1740
00002e  63a8              STR      r0,[r5,#0x38]         ;1740
                  |L7.48|
000030  6820              LDR      r0,[r4,#0]            ;1742
000032  f7fffffe          BL       USB_DevConnect
000036  bf00              NOP                            ;1743
000038  2000              MOVS     r0,#0                 ;1743
00003a  f88404bc          STRB     r0,[r4,#0x4bc]        ;1743
00003e  bf00              NOP                            ;1743
000040  bf00              NOP                            ;1745
000042  e7e6              B        |L7.18|
;;;1747   
                          ENDP


                          AREA ||i.HAL_PCD_DevDisconnect||, CODE, READONLY, ALIGN=1

                  HAL_PCD_DevDisconnect PROC
;;;1752     */
;;;1753   HAL_StatusTypeDef HAL_PCD_DevDisconnect(PCD_HandleTypeDef *hpcd)
000000  b570              PUSH     {r4-r6,lr}
;;;1754   {
000002  4604              MOV      r4,r0
;;;1755     USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
000004  6825              LDR      r5,[r4,#0]
;;;1756   
;;;1757     __HAL_LOCK(hpcd);
000006  bf00              NOP      
000008  f89404bc          LDRB     r0,[r4,#0x4bc]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L8.20|
000010  2002              MOVS     r0,#2
                  |L8.18|
;;;1758     (void)USB_DevDisconnect(hpcd->Instance);
;;;1759   
;;;1760     if ((hpcd->Init.battery_charging_enable == 1U) &&
;;;1761         (hpcd->Init.phy_itface != USB_OTG_ULPI_PHY))
;;;1762     {
;;;1763       /* Disable USB Transceiver */
;;;1764       USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
;;;1765     }
;;;1766   
;;;1767     __HAL_UNLOCK(hpcd);
;;;1768   
;;;1769     return HAL_OK;
;;;1770   }
000012  bd70              POP      {r4-r6,pc}
                  |L8.20|
000014  2001              MOVS     r0,#1                 ;1757
000016  f88404bc          STRB     r0,[r4,#0x4bc]        ;1757
00001a  bf00              NOP                            ;1757
00001c  6820              LDR      r0,[r4,#0]            ;1758
00001e  f7fffffe          BL       USB_DevDisconnect
000022  6aa0              LDR      r0,[r4,#0x28]         ;1760
000024  2801              CMP      r0,#1                 ;1760
000026  d106              BNE      |L8.54|
000028  69a0              LDR      r0,[r4,#0x18]         ;1761
00002a  2801              CMP      r0,#1                 ;1761
00002c  d003              BEQ      |L8.54|
00002e  6ba8              LDR      r0,[r5,#0x38]         ;1764
000030  f4203080          BIC      r0,r0,#0x10000        ;1764
000034  63a8              STR      r0,[r5,#0x38]         ;1764
                  |L8.54|
000036  bf00              NOP                            ;1767
000038  2000              MOVS     r0,#0                 ;1767
00003a  f88404bc          STRB     r0,[r4,#0x4bc]        ;1767
00003e  bf00              NOP                            ;1767
000040  bf00              NOP                            ;1769
000042  e7e6              B        |L8.18|
;;;1771   
                          ENDP


                          AREA ||i.HAL_PCD_DisconnectCallback||, CODE, READONLY, ALIGN=1

                  HAL_PCD_DisconnectCallback PROC
;;;1695     */
;;;1696   __weak void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
000000  4770              BX       lr
;;;1697   {
;;;1698     /* Prevent unused argument(s) compilation warning */
;;;1699     UNUSED(hpcd);
;;;1700   
;;;1701     /* NOTE : This function should not be modified, when the callback is needed,
;;;1702               the HAL_PCD_DisconnectCallback could be implemented in the user file
;;;1703      */
;;;1704   }
;;;1705   
                          ENDP


                          AREA ||i.HAL_PCD_EP_Abort||, CODE, READONLY, ALIGN=1

                  HAL_PCD_EP_Abort PROC
;;;2033      */
;;;2034   HAL_StatusTypeDef HAL_PCD_EP_Abort(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2035   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;2036     HAL_StatusTypeDef ret;
;;;2037     PCD_EPTypeDef *ep;
;;;2038   
;;;2039     if ((0x80U & ep_addr) == 0x80U)
000008  f0050080          AND      r0,r5,#0x80
00000c  2880              CMP      r0,#0x80
00000e  d108              BNE      |L10.34|
;;;2040     {
;;;2041       ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
000010  f005000f          AND      r0,r5,#0xf
000014  eb0001c0          ADD      r1,r0,r0,LSL #3
000018  f104003c          ADD      r0,r4,#0x3c
00001c  eb000681          ADD      r6,r0,r1,LSL #2
000020  e007              B        |L10.50|
                  |L10.34|
;;;2042     }
;;;2043     else
;;;2044     {
;;;2045       ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
000022  f005000f          AND      r0,r5,#0xf
000026  eb0001c0          ADD      r1,r0,r0,LSL #3
00002a  f504701f          ADD      r0,r4,#0x27c
00002e  eb000681          ADD      r6,r0,r1,LSL #2
                  |L10.50|
;;;2046     }
;;;2047   
;;;2048     /* Stop Xfer */
;;;2049     ret = USB_EPStopXfer(hpcd->Instance, ep);
000032  4631              MOV      r1,r6
000034  6820              LDR      r0,[r4,#0]
000036  f7fffffe          BL       USB_EPStopXfer
00003a  4607              MOV      r7,r0
;;;2050   
;;;2051     return ret;
00003c  4638              MOV      r0,r7
;;;2052   }
00003e  e8bd81f0          POP      {r4-r8,pc}
;;;2053   
                          ENDP


                          AREA ||i.HAL_PCD_EP_Close||, CODE, READONLY, ALIGN=1

                  HAL_PCD_EP_Close PROC
;;;1839     */
;;;1840   HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
000000  b570              PUSH     {r4-r6,lr}
;;;1841   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;1842     PCD_EPTypeDef *ep;
;;;1843   
;;;1844     if ((ep_addr & 0x80U) == 0x80U)
000006  f0060080          AND      r0,r6,#0x80
00000a  2880              CMP      r0,#0x80
00000c  d10a              BNE      |L11.36|
;;;1845     {
;;;1846       ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
00000e  f006000f          AND      r0,r6,#0xf
000012  eb0001c0          ADD      r1,r0,r0,LSL #3
000016  f104003c          ADD      r0,r4,#0x3c
00001a  eb000581          ADD      r5,r0,r1,LSL #2
;;;1847       ep->is_in = 1U;
00001e  2001              MOVS     r0,#1
000020  7068              STRB     r0,[r5,#1]
000022  e009              B        |L11.56|
                  |L11.36|
;;;1848     }
;;;1849     else
;;;1850     {
;;;1851       ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
000024  f006000f          AND      r0,r6,#0xf
000028  eb0001c0          ADD      r1,r0,r0,LSL #3
00002c  f504701f          ADD      r0,r4,#0x27c
000030  eb000581          ADD      r5,r0,r1,LSL #2
;;;1852       ep->is_in = 0U;
000034  2000              MOVS     r0,#0
000036  7068              STRB     r0,[r5,#1]
                  |L11.56|
;;;1853     }
;;;1854     ep->num   = ep_addr & EP_ADDR_MSK;
000038  f006000f          AND      r0,r6,#0xf
00003c  7028              STRB     r0,[r5,#0]
;;;1855   
;;;1856     __HAL_LOCK(hpcd);
00003e  bf00              NOP      
000040  f89404bc          LDRB     r0,[r4,#0x4bc]
000044  2801              CMP      r0,#1
000046  d101              BNE      |L11.76|
000048  2002              MOVS     r0,#2
                  |L11.74|
;;;1857     (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
;;;1858     __HAL_UNLOCK(hpcd);
;;;1859     return HAL_OK;
;;;1860   }
00004a  bd70              POP      {r4-r6,pc}
                  |L11.76|
00004c  2001              MOVS     r0,#1                 ;1856
00004e  f88404bc          STRB     r0,[r4,#0x4bc]        ;1856
000052  bf00              NOP                            ;1856
000054  4629              MOV      r1,r5                 ;1857
000056  6820              LDR      r0,[r4,#0]            ;1857
000058  f7fffffe          BL       USB_DeactivateEndpoint
00005c  bf00              NOP                            ;1858
00005e  2000              MOVS     r0,#0                 ;1858
000060  f88404bc          STRB     r0,[r4,#0x4bc]        ;1858
000064  bf00              NOP                            ;1858
000066  bf00              NOP                            ;1859
000068  e7ef              B        |L11.74|
;;;1861   
                          ENDP


                          AREA ||i.HAL_PCD_EP_ClrStall||, CODE, READONLY, ALIGN=1

                  HAL_PCD_EP_ClrStall PROC
;;;1997     */
;;;1998   HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
000000  b570              PUSH     {r4-r6,lr}
;;;1999   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;2000     PCD_EPTypeDef *ep;
;;;2001   
;;;2002     if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
000006  f006000f          AND      r0,r6,#0xf
00000a  6861              LDR      r1,[r4,#4]
00000c  4288              CMP      r0,r1
00000e  d901              BLS      |L12.20|
;;;2003     {
;;;2004       return HAL_ERROR;
000010  2001              MOVS     r0,#1
                  |L12.18|
;;;2005     }
;;;2006   
;;;2007     if ((0x80U & ep_addr) == 0x80U)
;;;2008     {
;;;2009       ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
;;;2010       ep->is_in = 1U;
;;;2011     }
;;;2012     else
;;;2013     {
;;;2014       ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
;;;2015       ep->is_in = 0U;
;;;2016     }
;;;2017   
;;;2018     ep->is_stall = 0U;
;;;2019     ep->num = ep_addr & EP_ADDR_MSK;
;;;2020   
;;;2021     __HAL_LOCK(hpcd);
;;;2022     (void)USB_EPClearStall(hpcd->Instance, ep);
;;;2023     __HAL_UNLOCK(hpcd);
;;;2024   
;;;2025     return HAL_OK;
;;;2026   }
000012  bd70              POP      {r4-r6,pc}
                  |L12.20|
000014  f0060080          AND      r0,r6,#0x80           ;2007
000018  2880              CMP      r0,#0x80              ;2007
00001a  d10a              BNE      |L12.50|
00001c  f006000f          AND      r0,r6,#0xf            ;2009
000020  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2009
000024  f104003c          ADD      r0,r4,#0x3c           ;2009
000028  eb000581          ADD      r5,r0,r1,LSL #2       ;2009
00002c  2001              MOVS     r0,#1                 ;2010
00002e  7068              STRB     r0,[r5,#1]            ;2010
000030  e009              B        |L12.70|
                  |L12.50|
000032  f006000f          AND      r0,r6,#0xf            ;2014
000036  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2014
00003a  f504701f          ADD      r0,r4,#0x27c          ;2014
00003e  eb000581          ADD      r5,r0,r1,LSL #2       ;2014
000042  2000              MOVS     r0,#0                 ;2015
000044  7068              STRB     r0,[r5,#1]            ;2015
                  |L12.70|
000046  2000              MOVS     r0,#0                 ;2018
000048  70a8              STRB     r0,[r5,#2]            ;2018
00004a  f006000f          AND      r0,r6,#0xf            ;2019
00004e  7028              STRB     r0,[r5,#0]            ;2019
000050  bf00              NOP                            ;2021
000052  f89404bc          LDRB     r0,[r4,#0x4bc]        ;2021
000056  2801              CMP      r0,#1                 ;2021
000058  d101              BNE      |L12.94|
00005a  2002              MOVS     r0,#2                 ;2021
00005c  e7d9              B        |L12.18|
                  |L12.94|
00005e  2001              MOVS     r0,#1                 ;2021
000060  f88404bc          STRB     r0,[r4,#0x4bc]        ;2021
000064  bf00              NOP                            ;2021
000066  4629              MOV      r1,r5                 ;2022
000068  6820              LDR      r0,[r4,#0]            ;2022
00006a  f7fffffe          BL       USB_EPClearStall
00006e  bf00              NOP                            ;2023
000070  2000              MOVS     r0,#0                 ;2023
000072  f88404bc          STRB     r0,[r4,#0x4bc]        ;2023
000076  bf00              NOP                            ;2023
000078  bf00              NOP                            ;2025
00007a  e7ca              B        |L12.18|
;;;2027   
                          ENDP


                          AREA ||i.HAL_PCD_EP_Flush||, CODE, READONLY, ALIGN=1

                  HAL_PCD_EP_Flush PROC
;;;2059     */
;;;2060   HAL_StatusTypeDef HAL_PCD_EP_Flush(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
000000  b570              PUSH     {r4-r6,lr}
;;;2061   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2062     __HAL_LOCK(hpcd);
000006  bf00              NOP      
000008  f89404bc          LDRB     r0,[r4,#0x4bc]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L13.20|
000010  2002              MOVS     r0,#2
                  |L13.18|
;;;2063   
;;;2064     if ((ep_addr & 0x80U) == 0x80U)
;;;2065     {
;;;2066       (void)USB_FlushTxFifo(hpcd->Instance, (uint32_t)ep_addr & EP_ADDR_MSK);
;;;2067     }
;;;2068     else
;;;2069     {
;;;2070       (void)USB_FlushRxFifo(hpcd->Instance);
;;;2071     }
;;;2072   
;;;2073     __HAL_UNLOCK(hpcd);
;;;2074   
;;;2075     return HAL_OK;
;;;2076   }
000012  bd70              POP      {r4-r6,pc}
                  |L13.20|
000014  2001              MOVS     r0,#1                 ;2062
000016  f88404bc          STRB     r0,[r4,#0x4bc]        ;2062
00001a  bf00              NOP                            ;2062
00001c  f0050080          AND      r0,r5,#0x80           ;2064
000020  2880              CMP      r0,#0x80              ;2064
000022  d105              BNE      |L13.48|
000024  f005010f          AND      r1,r5,#0xf            ;2066
000028  6820              LDR      r0,[r4,#0]            ;2066
00002a  f7fffffe          BL       USB_FlushTxFifo
00002e  e002              B        |L13.54|
                  |L13.48|
000030  6820              LDR      r0,[r4,#0]            ;2070
000032  f7fffffe          BL       USB_FlushRxFifo
                  |L13.54|
000036  bf00              NOP                            ;2073
000038  2000              MOVS     r0,#0                 ;2073
00003a  f88404bc          STRB     r0,[r4,#0x4bc]        ;2073
00003e  bf00              NOP                            ;2073
000040  bf00              NOP                            ;2075
000042  e7e6              B        |L13.18|
;;;2077   
                          ENDP


                          AREA ||i.HAL_PCD_EP_GetRxCount||, CODE, READONLY, ALIGN=1

                  HAL_PCD_EP_GetRxCount PROC
;;;1906     */
;;;1907   uint32_t HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
000000  4602              MOV      r2,r0
;;;1908   {
;;;1909     return hpcd->OUT_ep[ep_addr & EP_ADDR_MSK].xfer_count;
000002  f001000f          AND      r0,r1,#0xf
000006  eb0003c0          ADD      r3,r0,r0,LSL #3
00000a  f502701f          ADD      r0,r2,#0x27c
00000e  eb000083          ADD      r0,r0,r3,LSL #2
000012  6a00              LDR      r0,[r0,#0x20]
;;;1910   }
000014  4770              BX       lr
;;;1911   /**
                          ENDP


                          AREA ||i.HAL_PCD_EP_Open||, CODE, READONLY, ALIGN=1

                  HAL_PCD_EP_Open PROC
;;;1794     */
;;;1795   HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1796                                     uint16_t ep_mps, uint8_t ep_type)
;;;1797   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
00000a  461f              MOV      r7,r3
;;;1798     HAL_StatusTypeDef  ret = HAL_OK;
00000c  f04f0900          MOV      r9,#0
;;;1799     PCD_EPTypeDef *ep;
;;;1800   
;;;1801     if ((ep_addr & 0x80U) == 0x80U)
000010  f0060080          AND      r0,r6,#0x80
000014  2880              CMP      r0,#0x80
000016  d10a              BNE      |L15.46|
;;;1802     {
;;;1803       ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
000018  f006000f          AND      r0,r6,#0xf
00001c  eb0001c0          ADD      r1,r0,r0,LSL #3
000020  f105003c          ADD      r0,r5,#0x3c
000024  eb000481          ADD      r4,r0,r1,LSL #2
;;;1804       ep->is_in = 1U;
000028  2001              MOVS     r0,#1
00002a  7060              STRB     r0,[r4,#1]
00002c  e009              B        |L15.66|
                  |L15.46|
;;;1805     }
;;;1806     else
;;;1807     {
;;;1808       ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
00002e  f006000f          AND      r0,r6,#0xf
000032  eb0001c0          ADD      r1,r0,r0,LSL #3
000036  f505701f          ADD      r0,r5,#0x27c
00003a  eb000481          ADD      r4,r0,r1,LSL #2
;;;1809       ep->is_in = 0U;
00003e  2000              MOVS     r0,#0
000040  7060              STRB     r0,[r4,#1]
                  |L15.66|
;;;1810     }
;;;1811   
;;;1812     ep->num = ep_addr & EP_ADDR_MSK;
000042  f006000f          AND      r0,r6,#0xf
000046  7020              STRB     r0,[r4,#0]
;;;1813     ep->maxpacket = ep_mps;
000048  f8c4800c          STR      r8,[r4,#0xc]
;;;1814     ep->type = ep_type;
00004c  7127              STRB     r7,[r4,#4]
;;;1815   
;;;1816     if (ep->is_in != 0U)
00004e  7860              LDRB     r0,[r4,#1]
000050  b108              CBZ      r0,|L15.86|
;;;1817     {
;;;1818       /* Assign a Tx FIFO */
;;;1819       ep->tx_fifo_num = ep->num;
000052  7820              LDRB     r0,[r4,#0]
000054  8120              STRH     r0,[r4,#8]
                  |L15.86|
;;;1820     }
;;;1821     /* Set initial data PID. */
;;;1822     if (ep_type == EP_TYPE_BULK)
000056  2f02              CMP      r7,#2
000058  d101              BNE      |L15.94|
;;;1823     {
;;;1824       ep->data_pid_start = 0U;
00005a  2000              MOVS     r0,#0
00005c  7160              STRB     r0,[r4,#5]
                  |L15.94|
;;;1825     }
;;;1826   
;;;1827     __HAL_LOCK(hpcd);
00005e  bf00              NOP      
000060  f89504bc          LDRB     r0,[r5,#0x4bc]
000064  2801              CMP      r0,#1
000066  d102              BNE      |L15.110|
000068  2002              MOVS     r0,#2
                  |L15.106|
;;;1828     (void)USB_ActivateEndpoint(hpcd->Instance, ep);
;;;1829     __HAL_UNLOCK(hpcd);
;;;1830   
;;;1831     return ret;
;;;1832   }
00006a  e8bd87f0          POP      {r4-r10,pc}
                  |L15.110|
00006e  2001              MOVS     r0,#1                 ;1827
000070  f88504bc          STRB     r0,[r5,#0x4bc]        ;1827
000074  bf00              NOP                            ;1827
000076  4621              MOV      r1,r4                 ;1828
000078  6828              LDR      r0,[r5,#0]            ;1828
00007a  f7fffffe          BL       USB_ActivateEndpoint
00007e  bf00              NOP                            ;1829
000080  2000              MOVS     r0,#0                 ;1829
000082  f88504bc          STRB     r0,[r5,#0x4bc]        ;1829
000086  bf00              NOP                            ;1829
000088  4648              MOV      r0,r9                 ;1831
00008a  e7ee              B        |L15.106|
;;;1833   
                          ENDP


                          AREA ||i.HAL_PCD_EP_Receive||, CODE, READONLY, ALIGN=1

                  HAL_PCD_EP_Receive PROC
;;;1870     */
;;;1871   HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1872   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;1873     PCD_EPTypeDef *ep;
;;;1874   
;;;1875     ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
00000c  f006000f          AND      r0,r6,#0xf
000010  eb0001c0          ADD      r1,r0,r0,LSL #3
000014  f504701f          ADD      r0,r4,#0x27c
000018  eb000581          ADD      r5,r0,r1,LSL #2
;;;1876   
;;;1877     /*setup and start the Xfer */
;;;1878     ep->xfer_buff = pBuf;
00001c  612f              STR      r7,[r5,#0x10]
;;;1879     ep->xfer_len = len;
00001e  f8c58018          STR      r8,[r5,#0x18]
;;;1880     ep->xfer_count = 0U;
000022  2000              MOVS     r0,#0
000024  6228              STR      r0,[r5,#0x20]
;;;1881     ep->is_in = 0U;
000026  7068              STRB     r0,[r5,#1]
;;;1882     ep->num = ep_addr & EP_ADDR_MSK;
000028  f006000f          AND      r0,r6,#0xf
00002c  7028              STRB     r0,[r5,#0]
;;;1883   
;;;1884     if (hpcd->Init.dma_enable == 1U)
00002e  6920              LDR      r0,[r4,#0x10]
000030  2801              CMP      r0,#1
000032  d100              BNE      |L16.54|
;;;1885     {
;;;1886       ep->dma_addr = (uint32_t)pBuf;
000034  616f              STR      r7,[r5,#0x14]
                  |L16.54|
;;;1887     }
;;;1888   
;;;1889     if ((ep_addr & EP_ADDR_MSK) == 0U)
000036  f006000f          AND      r0,r6,#0xf
00003a  b928              CBNZ     r0,|L16.72|
;;;1890     {
;;;1891       (void)USB_EP0StartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
00003c  7c22              LDRB     r2,[r4,#0x10]
00003e  4629              MOV      r1,r5
000040  6820              LDR      r0,[r4,#0]
000042  f7fffffe          BL       USB_EP0StartXfer
000046  e004              B        |L16.82|
                  |L16.72|
;;;1892     }
;;;1893     else
;;;1894     {
;;;1895       (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
000048  7c22              LDRB     r2,[r4,#0x10]
00004a  4629              MOV      r1,r5
00004c  6820              LDR      r0,[r4,#0]
00004e  f7fffffe          BL       USB_EPStartXfer
                  |L16.82|
;;;1896     }
;;;1897   
;;;1898     return HAL_OK;
000052  2000              MOVS     r0,#0
;;;1899   }
000054  e8bd81f0          POP      {r4-r8,pc}
;;;1900   
                          ENDP


                          AREA ||i.HAL_PCD_EP_SetStall||, CODE, READONLY, ALIGN=1

                  HAL_PCD_EP_SetStall PROC
;;;1954     */
;;;1955   HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
000000  b570              PUSH     {r4-r6,lr}
;;;1956   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1957     PCD_EPTypeDef *ep;
;;;1958   
;;;1959     if (((uint32_t)ep_addr & EP_ADDR_MSK) > hpcd->Init.dev_endpoints)
000006  f005000f          AND      r0,r5,#0xf
00000a  6861              LDR      r1,[r4,#4]
00000c  4288              CMP      r0,r1
00000e  d901              BLS      |L17.20|
;;;1960     {
;;;1961       return HAL_ERROR;
000010  2001              MOVS     r0,#1
                  |L17.18|
;;;1962     }
;;;1963   
;;;1964     if ((0x80U & ep_addr) == 0x80U)
;;;1965     {
;;;1966       ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
;;;1967       ep->is_in = 1U;
;;;1968     }
;;;1969     else
;;;1970     {
;;;1971       ep = &hpcd->OUT_ep[ep_addr];
;;;1972       ep->is_in = 0U;
;;;1973     }
;;;1974   
;;;1975     ep->is_stall = 1U;
;;;1976     ep->num = ep_addr & EP_ADDR_MSK;
;;;1977   
;;;1978     __HAL_LOCK(hpcd);
;;;1979   
;;;1980     (void)USB_EPSetStall(hpcd->Instance, ep);
;;;1981   
;;;1982     if ((ep_addr & EP_ADDR_MSK) == 0U)
;;;1983     {
;;;1984       (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
;;;1985     }
;;;1986   
;;;1987     __HAL_UNLOCK(hpcd);
;;;1988   
;;;1989     return HAL_OK;
;;;1990   }
000012  bd70              POP      {r4-r6,pc}
                  |L17.20|
000014  f0050080          AND      r0,r5,#0x80           ;1964
000018  2880              CMP      r0,#0x80              ;1964
00001a  d10a              BNE      |L17.50|
00001c  f005000f          AND      r0,r5,#0xf            ;1966
000020  eb0001c0          ADD      r1,r0,r0,LSL #3       ;1966
000024  f104003c          ADD      r0,r4,#0x3c           ;1966
000028  eb000681          ADD      r6,r0,r1,LSL #2       ;1966
00002c  2001              MOVS     r0,#1                 ;1967
00002e  7070              STRB     r0,[r6,#1]            ;1967
000030  e007              B        |L17.66|
                  |L17.50|
000032  eb0501c5          ADD      r1,r5,r5,LSL #3       ;1971
000036  f504701f          ADD      r0,r4,#0x27c          ;1971
00003a  eb000681          ADD      r6,r0,r1,LSL #2       ;1971
00003e  2000              MOVS     r0,#0                 ;1972
000040  7070              STRB     r0,[r6,#1]            ;1972
                  |L17.66|
000042  2001              MOVS     r0,#1                 ;1975
000044  70b0              STRB     r0,[r6,#2]            ;1975
000046  f005000f          AND      r0,r5,#0xf            ;1976
00004a  7030              STRB     r0,[r6,#0]            ;1976
00004c  bf00              NOP                            ;1978
00004e  f89404bc          LDRB     r0,[r4,#0x4bc]        ;1978
000052  2801              CMP      r0,#1                 ;1978
000054  d101              BNE      |L17.90|
000056  2002              MOVS     r0,#2                 ;1978
000058  e7db              B        |L17.18|
                  |L17.90|
00005a  2001              MOVS     r0,#1                 ;1978
00005c  f88404bc          STRB     r0,[r4,#0x4bc]        ;1978
000060  bf00              NOP                            ;1978
000062  4631              MOV      r1,r6                 ;1980
000064  6820              LDR      r0,[r4,#0]            ;1980
000066  f7fffffe          BL       USB_EPSetStall
00006a  f005000f          AND      r0,r5,#0xf            ;1982
00006e  b928              CBNZ     r0,|L17.124|
000070  7c21              LDRB     r1,[r4,#0x10]         ;1984
000072  f20442c4          ADD      r2,r4,#0x4c4          ;1984
000076  6820              LDR      r0,[r4,#0]            ;1984
000078  f7fffffe          BL       USB_EP0_OutStart
                  |L17.124|
00007c  bf00              NOP                            ;1987
00007e  2000              MOVS     r0,#0                 ;1987
000080  f88404bc          STRB     r0,[r4,#0x4bc]        ;1987
000084  bf00              NOP                            ;1987
000086  bf00              NOP                            ;1989
000088  e7c3              B        |L17.18|
;;;1991   
                          ENDP


                          AREA ||i.HAL_PCD_EP_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_PCD_EP_Transmit PROC
;;;1918     */
;;;1919   HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1920   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;1921     PCD_EPTypeDef *ep;
;;;1922   
;;;1923     ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
00000c  f006000f          AND      r0,r6,#0xf
000010  eb0001c0          ADD      r1,r0,r0,LSL #3
000014  f104003c          ADD      r0,r4,#0x3c
000018  eb000581          ADD      r5,r0,r1,LSL #2
;;;1924   
;;;1925     /*setup and start the Xfer */
;;;1926     ep->xfer_buff = pBuf;
00001c  612f              STR      r7,[r5,#0x10]
;;;1927     ep->xfer_len = len;
00001e  f8c58018          STR      r8,[r5,#0x18]
;;;1928     ep->xfer_count = 0U;
000022  2000              MOVS     r0,#0
000024  6228              STR      r0,[r5,#0x20]
;;;1929     ep->is_in = 1U;
000026  2001              MOVS     r0,#1
000028  7068              STRB     r0,[r5,#1]
;;;1930     ep->num = ep_addr & EP_ADDR_MSK;
00002a  f006000f          AND      r0,r6,#0xf
00002e  7028              STRB     r0,[r5,#0]
;;;1931   
;;;1932     if (hpcd->Init.dma_enable == 1U)
000030  6920              LDR      r0,[r4,#0x10]
000032  2801              CMP      r0,#1
000034  d100              BNE      |L18.56|
;;;1933     {
;;;1934       ep->dma_addr = (uint32_t)pBuf;
000036  616f              STR      r7,[r5,#0x14]
                  |L18.56|
;;;1935     }
;;;1936   
;;;1937     if ((ep_addr & EP_ADDR_MSK) == 0U)
000038  f006000f          AND      r0,r6,#0xf
00003c  b928              CBNZ     r0,|L18.74|
;;;1938     {
;;;1939       (void)USB_EP0StartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
00003e  7c22              LDRB     r2,[r4,#0x10]
000040  4629              MOV      r1,r5
000042  6820              LDR      r0,[r4,#0]
000044  f7fffffe          BL       USB_EP0StartXfer
000048  e004              B        |L18.84|
                  |L18.74|
;;;1940     }
;;;1941     else
;;;1942     {
;;;1943       (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
00004a  7c22              LDRB     r2,[r4,#0x10]
00004c  4629              MOV      r1,r5
00004e  6820              LDR      r0,[r4,#0]
000050  f7fffffe          BL       USB_EPStartXfer
                  |L18.84|
;;;1944     }
;;;1945   
;;;1946     return HAL_OK;
000054  2000              MOVS     r0,#0
;;;1947   }
000056  e8bd81f0          POP      {r4-r8,pc}
;;;1948   
                          ENDP


                          AREA ||i.HAL_PCD_GetState||, CODE, READONLY, ALIGN=1

                  HAL_PCD_GetState PROC
;;;2121     */
;;;2122   PCD_StateTypeDef HAL_PCD_GetState(PCD_HandleTypeDef *hpcd)
000000  4601              MOV      r1,r0
;;;2123   {
;;;2124     return hpcd->State;
000002  f89104bd          LDRB     r0,[r1,#0x4bd]
;;;2125   }
000006  4770              BX       lr
;;;2126   
                          ENDP


                          AREA ||i.HAL_PCD_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_PCD_IRQHandler PROC
;;;1053     */
;;;1054   void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;1055   {
000004  4604              MOV      r4,r0
;;;1056     USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
000006  f8d4b000          LDR      r11,[r4,#0]
;;;1057     uint32_t USBx_BASE = (uint32_t)USBx;
00000a  465e              MOV      r6,r11
;;;1058     USB_OTG_EPTypeDef *ep;
;;;1059     uint32_t i;
;;;1060     uint32_t ep_intr;
;;;1061     uint32_t epint;
;;;1062     uint32_t epnum;
;;;1063     uint32_t fifoemptymsk;
;;;1064     uint32_t RegVal;
;;;1065   
;;;1066     /* ensure that we are in device mode */
;;;1067     if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
00000c  6820              LDR      r0,[r4,#0]
00000e  f7fffffe          BL       USB_GetMode
000012  2800              CMP      r0,#0
000014  d174              BNE      |L20.256|
;;;1068     {
;;;1069       /* avoid spurious interrupt */
;;;1070       if (__HAL_PCD_IS_INVALID_INTERRUPT(hpcd))
000016  6820              LDR      r0,[r4,#0]
000018  f7fffffe          BL       USB_ReadInterrupts
00001c  b908              CBNZ     r0,|L20.34|
                  |L20.30|
;;;1071       {
;;;1072         return;
;;;1073       }
;;;1074   
;;;1075       /* store current frame number */
;;;1076       hpcd->FrameNumber = (USBx_DEVICE->DSTS & USB_OTG_DSTS_FNSOF_Msk) >> USB_OTG_DSTS_FNSOF_Pos;
;;;1077   
;;;1078       if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
;;;1079       {
;;;1080         /* incorrect mode, acknowledge the interrupt */
;;;1081         __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
;;;1082       }
;;;1083   
;;;1084       /* Handle RxQLevel Interrupt */
;;;1085       if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
;;;1086       {
;;;1087         USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
;;;1088   
;;;1089         RegVal = USBx->GRXSTSP;
;;;1090   
;;;1091         ep = &hpcd->OUT_ep[RegVal & USB_OTG_GRXSTSP_EPNUM];
;;;1092   
;;;1093         if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
;;;1094         {
;;;1095           if ((RegVal & USB_OTG_GRXSTSP_BCNT) != 0U)
;;;1096           {
;;;1097             (void)USB_ReadPacket(USBx, ep->xfer_buff,
;;;1098                                  (uint16_t)((RegVal & USB_OTG_GRXSTSP_BCNT) >> 4));
;;;1099   
;;;1100             ep->xfer_buff += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
;;;1101             ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
;;;1102           }
;;;1103         }
;;;1104         else if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) == STS_SETUP_UPDT)
;;;1105         {
;;;1106           (void)USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
;;;1107           ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
;;;1108         }
;;;1109         else
;;;1110         {
;;;1111           /* ... */
;;;1112         }
;;;1113   
;;;1114         USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
;;;1115       }
;;;1116   
;;;1117       if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
;;;1118       {
;;;1119         epnum = 0U;
;;;1120   
;;;1121         /* Read in the device interrupt bits */
;;;1122         ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
;;;1123   
;;;1124         while (ep_intr != 0U)
;;;1125         {
;;;1126           if ((ep_intr & 0x1U) != 0U)
;;;1127           {
;;;1128             epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
;;;1129   
;;;1130             if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
;;;1131             {
;;;1132               CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
;;;1133               (void)PCD_EP_OutXfrComplete_int(hpcd, epnum);
;;;1134             }
;;;1135   
;;;1136             if ((epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
;;;1137             {
;;;1138               CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
;;;1139               /* Class B setup phase done for previous decoded setup */
;;;1140               (void)PCD_EP_OutSetupPacket_int(hpcd, epnum);
;;;1141             }
;;;1142   
;;;1143             if ((epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
;;;1144             {
;;;1145               CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
;;;1146             }
;;;1147   
;;;1148             /* Clear OUT Endpoint disable interrupt */
;;;1149             if ((epint & USB_OTG_DOEPINT_EPDISD) == USB_OTG_DOEPINT_EPDISD)
;;;1150             {
;;;1151               if ((USBx->GINTSTS & USB_OTG_GINTSTS_BOUTNAKEFF) == USB_OTG_GINTSTS_BOUTNAKEFF)
;;;1152               {
;;;1153                 USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGONAK;
;;;1154               }
;;;1155   
;;;1156               ep = &hpcd->OUT_ep[epnum];
;;;1157   
;;;1158               if (ep->is_iso_incomplete == 1U)
;;;1159               {
;;;1160                 ep->is_iso_incomplete = 0U;
;;;1161   
;;;1162   #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
;;;1163                 hpcd->ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
;;;1164   #else
;;;1165                 HAL_PCD_ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
;;;1166   #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
;;;1167               }
;;;1168   
;;;1169               CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_EPDISD);
;;;1170             }
;;;1171   
;;;1172             /* Clear Status Phase Received interrupt */
;;;1173             if ((epint & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
;;;1174             {
;;;1175               CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
;;;1176             }
;;;1177   
;;;1178             /* Clear OUT NAK interrupt */
;;;1179             if ((epint & USB_OTG_DOEPINT_NAK) == USB_OTG_DOEPINT_NAK)
;;;1180             {
;;;1181               CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_NAK);
;;;1182             }
;;;1183           }
;;;1184           epnum++;
;;;1185           ep_intr >>= 1U;
;;;1186         }
;;;1187       }
;;;1188   
;;;1189       if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
;;;1190       {
;;;1191         /* Read in the device interrupt bits */
;;;1192         ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
;;;1193   
;;;1194         epnum = 0U;
;;;1195   
;;;1196         while (ep_intr != 0U)
;;;1197         {
;;;1198           if ((ep_intr & 0x1U) != 0U) /* In ITR */
;;;1199           {
;;;1200             epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
;;;1201   
;;;1202             if ((epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
;;;1203             {
;;;1204               fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
;;;1205               USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
;;;1206   
;;;1207               CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
;;;1208   
;;;1209               if (hpcd->Init.dma_enable == 1U)
;;;1210               {
;;;1211                 hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket;
;;;1212   
;;;1213                 /* this is ZLP, so prepare EP0 for next setup */
;;;1214                 if ((epnum == 0U) && (hpcd->IN_ep[epnum].xfer_len == 0U))
;;;1215                 {
;;;1216                   /* prepare to rx more setup packets */
;;;1217                   (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
;;;1218                 }
;;;1219               }
;;;1220   
;;;1221   #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
;;;1222               hpcd->DataInStageCallback(hpcd, (uint8_t)epnum);
;;;1223   #else
;;;1224               HAL_PCD_DataInStageCallback(hpcd, (uint8_t)epnum);
;;;1225   #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
;;;1226             }
;;;1227             if ((epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
;;;1228             {
;;;1229               CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
;;;1230             }
;;;1231             if ((epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
;;;1232             {
;;;1233               CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
;;;1234             }
;;;1235             if ((epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
;;;1236             {
;;;1237               CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
;;;1238             }
;;;1239             if ((epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
;;;1240             {
;;;1241               (void)USB_FlushTxFifo(USBx, epnum);
;;;1242   
;;;1243               ep = &hpcd->IN_ep[epnum];
;;;1244   
;;;1245               if (ep->is_iso_incomplete == 1U)
;;;1246               {
;;;1247                 ep->is_iso_incomplete = 0U;
;;;1248   
;;;1249   #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
;;;1250                 hpcd->ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
;;;1251   #else
;;;1252                 HAL_PCD_ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
;;;1253   #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
;;;1254               }
;;;1255   
;;;1256               CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
;;;1257             }
;;;1258             if ((epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
;;;1259             {
;;;1260               (void)PCD_WriteEmptyTxFifo(hpcd, epnum);
;;;1261             }
;;;1262           }
;;;1263           epnum++;
;;;1264           ep_intr >>= 1U;
;;;1265         }
;;;1266       }
;;;1267   
;;;1268       /* Handle Resume Interrupt */
;;;1269       if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
;;;1270       {
;;;1271         /* Clear the Remote Wake-up Signaling */
;;;1272         USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
;;;1273   
;;;1274         if (hpcd->LPM_State == LPM_L1)
;;;1275         {
;;;1276           hpcd->LPM_State = LPM_L0;
;;;1277   
;;;1278   #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
;;;1279           hpcd->LPMCallback(hpcd, PCD_LPM_L0_ACTIVE);
;;;1280   #else
;;;1281           HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
;;;1282   #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
;;;1283         }
;;;1284         else
;;;1285         {
;;;1286   #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
;;;1287           hpcd->ResumeCallback(hpcd);
;;;1288   #else
;;;1289           HAL_PCD_ResumeCallback(hpcd);
;;;1290   #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
;;;1291         }
;;;1292   
;;;1293         __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
;;;1294       }
;;;1295   
;;;1296       /* Handle Suspend Interrupt */
;;;1297       if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
;;;1298       {
;;;1299         if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
;;;1300         {
;;;1301   #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
;;;1302           hpcd->SuspendCallback(hpcd);
;;;1303   #else
;;;1304           HAL_PCD_SuspendCallback(hpcd);
;;;1305   #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
;;;1306         }
;;;1307         __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
;;;1308       }
;;;1309   #if defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
;;;1310       /* Handle LPM Interrupt */
;;;1311       if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT))
;;;1312       {
;;;1313         __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT);
;;;1314   
;;;1315         if (hpcd->LPM_State == LPM_L0)
;;;1316         {
;;;1317           hpcd->LPM_State = LPM_L1;
;;;1318           hpcd->BESL = (hpcd->Instance->GLPMCFG & USB_OTG_GLPMCFG_BESL) >> 2U;
;;;1319   
;;;1320   #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
;;;1321           hpcd->LPMCallback(hpcd, PCD_LPM_L1_ACTIVE);
;;;1322   #else
;;;1323           HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L1_ACTIVE);
;;;1324   #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
;;;1325         }
;;;1326         else
;;;1327         {
;;;1328   #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
;;;1329           hpcd->SuspendCallback(hpcd);
;;;1330   #else
;;;1331           HAL_PCD_SuspendCallback(hpcd);
;;;1332   #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
;;;1333         }
;;;1334       }
;;;1335   #endif /* defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx) */
;;;1336       /* Handle Reset Interrupt */
;;;1337       if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
;;;1338       {
;;;1339         USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
;;;1340         (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
;;;1341   
;;;1342         for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
;;;1343         {
;;;1344           USBx_INEP(i)->DIEPINT = 0xFB7FU;
;;;1345           USBx_INEP(i)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
;;;1346           USBx_OUTEP(i)->DOEPINT = 0xFB7FU;
;;;1347           USBx_OUTEP(i)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
;;;1348           USBx_OUTEP(i)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
;;;1349         }
;;;1350         USBx_DEVICE->DAINTMSK |= 0x10001U;
;;;1351   
;;;1352         if (hpcd->Init.use_dedicated_ep1 != 0U)
;;;1353         {
;;;1354           USBx_DEVICE->DOUTEP1MSK |= USB_OTG_DOEPMSK_STUPM |
;;;1355                                      USB_OTG_DOEPMSK_XFRCM |
;;;1356                                      USB_OTG_DOEPMSK_EPDM;
;;;1357   
;;;1358           USBx_DEVICE->DINEP1MSK |= USB_OTG_DIEPMSK_TOM |
;;;1359                                     USB_OTG_DIEPMSK_XFRCM |
;;;1360                                     USB_OTG_DIEPMSK_EPDM;
;;;1361         }
;;;1362         else
;;;1363         {
;;;1364           USBx_DEVICE->DOEPMSK |= USB_OTG_DOEPMSK_STUPM |
;;;1365                                   USB_OTG_DOEPMSK_XFRCM |
;;;1366                                   USB_OTG_DOEPMSK_EPDM |
;;;1367                                   USB_OTG_DOEPMSK_OTEPSPRM |
;;;1368                                   USB_OTG_DOEPMSK_NAKM;
;;;1369   
;;;1370           USBx_DEVICE->DIEPMSK |= USB_OTG_DIEPMSK_TOM |
;;;1371                                   USB_OTG_DIEPMSK_XFRCM |
;;;1372                                   USB_OTG_DIEPMSK_EPDM;
;;;1373         }
;;;1374   
;;;1375         /* Set Default Address to 0 */
;;;1376         USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
;;;1377   
;;;1378         /* setup EP0 to receive SETUP packets */
;;;1379         (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
;;;1380                                (uint8_t *)hpcd->Setup);
;;;1381   
;;;1382         __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
;;;1383       }
;;;1384   
;;;1385       /* Handle Enumeration done Interrupt */
;;;1386       if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
;;;1387       {
;;;1388         (void)USB_ActivateSetup(hpcd->Instance);
;;;1389         hpcd->Init.speed = USB_GetDevSpeed(hpcd->Instance);
;;;1390   
;;;1391         /* Set USB Turnaround time */
;;;1392         (void)USB_SetTurnaroundTime(hpcd->Instance,
;;;1393                                     HAL_RCC_GetHCLKFreq(),
;;;1394                                     (uint8_t)hpcd->Init.speed);
;;;1395   
;;;1396   #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
;;;1397         hpcd->ResetCallback(hpcd);
;;;1398   #else
;;;1399         HAL_PCD_ResetCallback(hpcd);
;;;1400   #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
;;;1401   
;;;1402         __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
;;;1403       }
;;;1404   
;;;1405       /* Handle SOF Interrupt */
;;;1406       if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
;;;1407       {
;;;1408   #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
;;;1409         hpcd->SOFCallback(hpcd);
;;;1410   #else
;;;1411         HAL_PCD_SOFCallback(hpcd);
;;;1412   #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
;;;1413   
;;;1414         __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
;;;1415       }
;;;1416   
;;;1417       /* Handle Global OUT NAK effective Interrupt */
;;;1418       if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_BOUTNAKEFF))
;;;1419       {
;;;1420         USBx->GINTMSK &= ~USB_OTG_GINTMSK_GONAKEFFM;
;;;1421   
;;;1422         for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
;;;1423         {
;;;1424           if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
;;;1425           {
;;;1426             /* Abort current transaction and disable the EP */
;;;1427             (void)HAL_PCD_EP_Abort(hpcd, (uint8_t)epnum);
;;;1428           }
;;;1429         }
;;;1430       }
;;;1431   
;;;1432       /* Handle Incomplete ISO IN Interrupt */
;;;1433       if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
;;;1434       {
;;;1435         for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
;;;1436         {
;;;1437           RegVal = USBx_INEP(epnum)->DIEPCTL;
;;;1438   
;;;1439           if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
;;;1440               ((RegVal & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA))
;;;1441           {
;;;1442             hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
;;;1443   
;;;1444             /* Abort current transaction and disable the EP */
;;;1445             (void)HAL_PCD_EP_Abort(hpcd, (uint8_t)(epnum | 0x80U));
;;;1446           }
;;;1447         }
;;;1448   
;;;1449         __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
;;;1450       }
;;;1451   
;;;1452       /* Handle Incomplete ISO OUT Interrupt */
;;;1453       if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
;;;1454       {
;;;1455         for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
;;;1456         {
;;;1457           RegVal = USBx_OUTEP(epnum)->DOEPCTL;
;;;1458   
;;;1459           if ((hpcd->OUT_ep[epnum].type == EP_TYPE_ISOC) &&
;;;1460               ((RegVal & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA) &&
;;;1461               ((RegVal & (0x1U << 16)) == (hpcd->FrameNumber & 0x1U)))
;;;1462           {
;;;1463             hpcd->OUT_ep[epnum].is_iso_incomplete = 1U;
;;;1464   
;;;1465             USBx->GINTMSK |= USB_OTG_GINTMSK_GONAKEFFM;
;;;1466   
;;;1467             if ((USBx->GINTSTS & USB_OTG_GINTSTS_BOUTNAKEFF) == 0U)
;;;1468             {
;;;1469               USBx_DEVICE->DCTL |= USB_OTG_DCTL_SGONAK;
;;;1470               break;
;;;1471             }
;;;1472           }
;;;1473         }
;;;1474   
;;;1475         __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
;;;1476       }
;;;1477   
;;;1478       /* Handle Connection event Interrupt */
;;;1479       if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
;;;1480       {
;;;1481   #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
;;;1482         hpcd->ConnectCallback(hpcd);
;;;1483   #else
;;;1484         HAL_PCD_ConnectCallback(hpcd);
;;;1485   #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
;;;1486   
;;;1487         __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
;;;1488       }
;;;1489   
;;;1490       /* Handle Disconnection event Interrupt */
;;;1491       if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
;;;1492       {
;;;1493         RegVal = hpcd->Instance->GOTGINT;
;;;1494   
;;;1495         if ((RegVal & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
;;;1496         {
;;;1497   #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
;;;1498           hpcd->DisconnectCallback(hpcd);
;;;1499   #else
;;;1500           HAL_PCD_DisconnectCallback(hpcd);
;;;1501   #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
;;;1502         }
;;;1503         hpcd->Instance->GOTGINT |= RegVal;
;;;1504       }
;;;1505     }
;;;1506   }
00001e  e8bd8ffe          POP      {r1-r11,pc}
                  |L20.34|
000022  f6400008          MOV      r0,#0x808             ;1076
000026  5980              LDR      r0,[r0,r6]            ;1076
000028  f3c0200d          UBFX     r0,r0,#8,#14          ;1076
00002c  f8c404fc          STR      r0,[r4,#0x4fc]        ;1076
000030  6820              LDR      r0,[r4,#0]            ;1078
000032  f7fffffe          BL       USB_ReadInterrupts
000036  f0000002          AND      r0,r0,#2              ;1078
00003a  2802              CMP      r0,#2                 ;1078
00003c  d105              BNE      |L20.74|
00003e  6820              LDR      r0,[r4,#0]            ;1081
000040  6940              LDR      r0,[r0,#0x14]         ;1081
000042  f0000002          AND      r0,r0,#2              ;1081
000046  6821              LDR      r1,[r4,#0]            ;1081
000048  6148              STR      r0,[r1,#0x14]         ;1081
                  |L20.74|
00004a  6820              LDR      r0,[r4,#0]            ;1085
00004c  f7fffffe          BL       USB_ReadInterrupts
000050  f0000010          AND      r0,r0,#0x10           ;1085
000054  2810              CMP      r0,#0x10              ;1085
000056  d145              BNE      |L20.228|
000058  6820              LDR      r0,[r4,#0]            ;1087
00005a  6980              LDR      r0,[r0,#0x18]         ;1087
00005c  f0200010          BIC      r0,r0,#0x10           ;1087
000060  6821              LDR      r1,[r4,#0]            ;1087
000062  6188              STR      r0,[r1,#0x18]         ;1087
000064  f8db9020          LDR      r9,[r11,#0x20]        ;1089
000068  f009000f          AND      r0,r9,#0xf            ;1091
00006c  eb0001c0          ADD      r1,r0,r0,LSL #3       ;1091
000070  f504701f          ADD      r0,r4,#0x27c          ;1091
000074  eb000a81          ADD      r10,r0,r1,LSL #2      ;1091
000078  f3c94043          UBFX     r0,r9,#17,#4          ;1093
00007c  2802              CMP      r0,#2                 ;1093
00007e  d11a              BNE      |L20.182|
000080  f64770f0          MOV      r0,#0x7ff0            ;1095
000084  ea090000          AND      r0,r9,r0              ;1095
000088  b330              CBZ      r0,|L20.216|
00008a  f3c9120a          UBFX     r2,r9,#4,#11          ;1097
00008e  4658              MOV      r0,r11                ;1097
000090  f8da1010          LDR      r1,[r10,#0x10]        ;1097
000094  f7fffffe          BL       USB_ReadPacket
000098  f3c9110a          UBFX     r1,r9,#4,#11          ;1100
00009c  f8da0010          LDR      r0,[r10,#0x10]        ;1100
0000a0  4408              ADD      r0,r0,r1              ;1100
0000a2  f8ca0010          STR      r0,[r10,#0x10]        ;1100
0000a6  f3c9110a          UBFX     r1,r9,#4,#11          ;1101
0000aa  f8da0020          LDR      r0,[r10,#0x20]        ;1101
0000ae  4408              ADD      r0,r0,r1              ;1101
0000b0  f8ca0020          STR      r0,[r10,#0x20]        ;1101
0000b4  e010              B        |L20.216|
                  |L20.182|
0000b6  f3c94043          UBFX     r0,r9,#17,#4          ;1104
0000ba  2806              CMP      r0,#6                 ;1104
0000bc  d10c              BNE      |L20.216|
0000be  2208              MOVS     r2,#8                 ;1106
0000c0  f20441c4          ADD      r1,r4,#0x4c4          ;1106
0000c4  4658              MOV      r0,r11                ;1106
0000c6  f7fffffe          BL       USB_ReadPacket
0000ca  f3c9110a          UBFX     r1,r9,#4,#11          ;1107
0000ce  f8da0020          LDR      r0,[r10,#0x20]        ;1107
0000d2  4408              ADD      r0,r0,r1              ;1107
0000d4  f8ca0020          STR      r0,[r10,#0x20]        ;1107
                  |L20.216|
0000d8  6820              LDR      r0,[r4,#0]            ;1114
0000da  6980              LDR      r0,[r0,#0x18]         ;1114
0000dc  f0400010          ORR      r0,r0,#0x10           ;1114
0000e0  6821              LDR      r1,[r4,#0]            ;1114
0000e2  6188              STR      r0,[r1,#0x18]         ;1114
                  |L20.228|
0000e4  6820              LDR      r0,[r4,#0]            ;1117
0000e6  f7fffffe          BL       USB_ReadInterrupts
0000ea  f4002000          AND      r0,r0,#0x80000        ;1117
0000ee  f5b02f00          CMP      r0,#0x80000           ;1117
0000f2  d17b              BNE      |L20.492|
0000f4  2500              MOVS     r5,#0                 ;1119
0000f6  6820              LDR      r0,[r4,#0]            ;1122
0000f8  f7fffffe          BL       USB_ReadDevAllOutEpInterrupt
0000fc  9002              STR      r0,[sp,#8]            ;1122
0000fe  e072              B        |L20.486|
                  |L20.256|
000100  e2e1              B        |L20.1734|
                  |L20.258|
000102  9802              LDR      r0,[sp,#8]            ;1126
000104  f0000001          AND      r0,r0,#1              ;1126
000108  2800              CMP      r0,#0                 ;1126
00010a  d068              BEQ      |L20.478|
00010c  b2e9              UXTB     r1,r5                 ;1128
00010e  6820              LDR      r0,[r4,#0]            ;1128
000110  f7fffffe          BL       USB_ReadDevOutEPInterrupt
000114  4680              MOV      r8,r0                 ;1128
000116  f0080001          AND      r0,r8,#1              ;1130
00011a  b148              CBZ      r0,|L20.304|
00011c  2101              MOVS     r1,#1                 ;1132
00011e  f5066030          ADD      r0,r6,#0xb00          ;1132
000122  eb001045          ADD      r0,r0,r5,LSL #5       ;1132
000126  6081              STR      r1,[r0,#8]            ;1132
000128  4629              MOV      r1,r5                 ;1133
00012a  4620              MOV      r0,r4                 ;1133
00012c  f7fffffe          BL       PCD_EP_OutXfrComplete_int
                  |L20.304|
000130  f0080008          AND      r0,r8,#8              ;1136
000134  2808              CMP      r0,#8                 ;1136
000136  d109              BNE      |L20.332|
000138  2108              MOVS     r1,#8                 ;1138
00013a  f5066030          ADD      r0,r6,#0xb00          ;1138
00013e  eb001045          ADD      r0,r0,r5,LSL #5       ;1138
000142  6081              STR      r1,[r0,#8]            ;1138
000144  4629              MOV      r1,r5                 ;1140
000146  4620              MOV      r0,r4                 ;1140
000148  f7fffffe          BL       PCD_EP_OutSetupPacket_int
                  |L20.332|
00014c  f0080010          AND      r0,r8,#0x10           ;1143
000150  2810              CMP      r0,#0x10              ;1143
000152  d105              BNE      |L20.352|
000154  2110              MOVS     r1,#0x10              ;1145
000156  f5066030          ADD      r0,r6,#0xb00          ;1145
00015a  eb001045          ADD      r0,r0,r5,LSL #5       ;1145
00015e  6081              STR      r1,[r0,#8]            ;1145
                  |L20.352|
000160  f0080002          AND      r0,r8,#2              ;1149
000164  2802              CMP      r0,#2                 ;1149
000166  d124              BNE      |L20.434|
000168  f8db0014          LDR      r0,[r11,#0x14]        ;1151
00016c  f0000080          AND      r0,r0,#0x80           ;1151
000170  2880              CMP      r0,#0x80              ;1151
000172  d107              BNE      |L20.388|
000174  f6400004          MOV      r0,#0x804             ;1153
000178  5980              LDR      r0,[r0,r6]            ;1153
00017a  f4406180          ORR      r1,r0,#0x400          ;1153
00017e  f6400004          MOV      r0,#0x804             ;1153
000182  5181              STR      r1,[r0,r6]            ;1153
                  |L20.388|
000184  eb0501c5          ADD      r1,r5,r5,LSL #3       ;1156
000188  f504701f          ADD      r0,r4,#0x27c          ;1156
00018c  eb000a81          ADD      r10,r0,r1,LSL #2      ;1156
000190  f89a0003          LDRB     r0,[r10,#3]           ;1158
000194  2801              CMP      r0,#1                 ;1158
000196  d106              BNE      |L20.422|
000198  2000              MOVS     r0,#0                 ;1160
00019a  f88a0003          STRB     r0,[r10,#3]           ;1160
00019e  b2e9              UXTB     r1,r5                 ;1165
0001a0  4620              MOV      r0,r4                 ;1165
0001a2  f7fffffe          BL       HAL_PCD_ISOOUTIncompleteCallback
                  |L20.422|
0001a6  2102              MOVS     r1,#2                 ;1169
0001a8  f5066030          ADD      r0,r6,#0xb00          ;1169
0001ac  eb001045          ADD      r0,r0,r5,LSL #5       ;1169
0001b0  6081              STR      r1,[r0,#8]            ;1169
                  |L20.434|
0001b2  f0080020          AND      r0,r8,#0x20           ;1173
0001b6  2820              CMP      r0,#0x20              ;1173
0001b8  d105              BNE      |L20.454|
0001ba  2120              MOVS     r1,#0x20              ;1175
0001bc  f5066030          ADD      r0,r6,#0xb00          ;1175
0001c0  eb001045          ADD      r0,r0,r5,LSL #5       ;1175
0001c4  6081              STR      r1,[r0,#8]            ;1175
                  |L20.454|
0001c6  f4085000          AND      r0,r8,#0x2000         ;1179
0001ca  f5b05f00          CMP      r0,#0x2000            ;1179
0001ce  d106              BNE      |L20.478|
0001d0  f44f5100          MOV      r1,#0x2000            ;1181
0001d4  f5066030          ADD      r0,r6,#0xb00          ;1181
0001d8  eb001045          ADD      r0,r0,r5,LSL #5       ;1181
0001dc  6081              STR      r1,[r0,#8]            ;1181
                  |L20.478|
0001de  1c6d              ADDS     r5,r5,#1              ;1184
0001e0  9802              LDR      r0,[sp,#8]            ;1185
0001e2  0840              LSRS     r0,r0,#1              ;1185
0001e4  9002              STR      r0,[sp,#8]            ;1185
                  |L20.486|
0001e6  9802              LDR      r0,[sp,#8]            ;1124
0001e8  2800              CMP      r0,#0                 ;1124
0001ea  d18a              BNE      |L20.258|
                  |L20.492|
0001ec  6820              LDR      r0,[r4,#0]            ;1189
0001ee  f7fffffe          BL       USB_ReadInterrupts
0001f2  f4002080          AND      r0,r0,#0x40000        ;1189
0001f6  f5b02f80          CMP      r0,#0x40000           ;1189
0001fa  d17d              BNE      |L20.760|
0001fc  6820              LDR      r0,[r4,#0]            ;1192
0001fe  f7fffffe          BL       USB_ReadDevAllInEpInterrupt
000202  9002              STR      r0,[sp,#8]            ;1192
000204  2500              MOVS     r5,#0                 ;1194
000206  e09a              B        |L20.830|
                  |L20.520|
000208  9802              LDR      r0,[sp,#8]            ;1198
00020a  f0000001          AND      r0,r0,#1              ;1198
00020e  2800              CMP      r0,#0                 ;1198
000210  d073              BEQ      |L20.762|
000212  b2e9              UXTB     r1,r5                 ;1200
000214  6820              LDR      r0,[r4,#0]            ;1200
000216  f7fffffe          BL       USB_ReadDevInEPInterrupt
00021a  4680              MOV      r8,r0                 ;1200
00021c  f0080001          AND      r0,r8,#1              ;1202
000220  b3f0              CBZ      r0,|L20.672|
000222  f005010f          AND      r1,r5,#0xf            ;1204
000226  2001              MOVS     r0,#1                 ;1204
000228  4088              LSLS     r0,r0,r1              ;1204
00022a  9001              STR      r0,[sp,#4]            ;1204
00022c  f6400034          MOV      r0,#0x834             ;1205
000230  5981              LDR      r1,[r0,r6]            ;1205
000232  9801              LDR      r0,[sp,#4]            ;1205
000234  ea210000          BIC      r0,r1,r0              ;1205
000238  f6400134          MOV      r1,#0x834             ;1205
00023c  5188              STR      r0,[r1,r6]            ;1205
00023e  2101              MOVS     r1,#1                 ;1207
000240  f5066010          ADD      r0,r6,#0x900          ;1207
000244  eb001045          ADD      r0,r0,r5,LSL #5       ;1207
000248  6081              STR      r1,[r0,#8]            ;1207
00024a  6920              LDR      r0,[r4,#0x10]         ;1209
00024c  2801              CMP      r0,#1                 ;1209
00024e  d124              BNE      |L20.666|
000250  eb0501c5          ADD      r1,r5,r5,LSL #3       ;1211
000254  f104003c          ADD      r0,r4,#0x3c           ;1211
000258  eb000081          ADD      r0,r0,r1,LSL #2       ;1211
00025c  eb0502c5          ADD      r2,r5,r5,LSL #3       ;1211
000260  6901              LDR      r1,[r0,#0x10]         ;1211
000262  f104003c          ADD      r0,r4,#0x3c           ;1211
000266  eb000082          ADD      r0,r0,r2,LSL #2       ;1211
00026a  68c0              LDR      r0,[r0,#0xc]          ;1211
00026c  4401              ADD      r1,r1,r0              ;1211
00026e  eb0502c5          ADD      r2,r5,r5,LSL #3       ;1211
000272  f104003c          ADD      r0,r4,#0x3c           ;1211
000276  eb000082          ADD      r0,r0,r2,LSL #2       ;1211
00027a  6101              STR      r1,[r0,#0x10]         ;1211
00027c  b96d              CBNZ     r5,|L20.666|
00027e  eb0501c5          ADD      r1,r5,r5,LSL #3       ;1214
000282  f104003c          ADD      r0,r4,#0x3c           ;1214
000286  eb000081          ADD      r0,r0,r1,LSL #2       ;1214
00028a  6980              LDR      r0,[r0,#0x18]         ;1214
00028c  b928              CBNZ     r0,|L20.666|
00028e  f20442c4          ADD      r2,r4,#0x4c4          ;1217
000292  2101              MOVS     r1,#1                 ;1217
000294  6820              LDR      r0,[r4,#0]            ;1217
000296  f7fffffe          BL       USB_EP0_OutStart
                  |L20.666|
00029a  b2e9              UXTB     r1,r5                 ;1224
00029c  4620              MOV      r0,r4                 ;1224
00029e  e000              B        |L20.674|
                  |L20.672|
0002a0  e001              B        |L20.678|
                  |L20.674|
0002a2  f7fffffe          BL       HAL_PCD_DataInStageCallback
                  |L20.678|
0002a6  f0080008          AND      r0,r8,#8              ;1227
0002aa  2808              CMP      r0,#8                 ;1227
0002ac  d105              BNE      |L20.698|
0002ae  2108              MOVS     r1,#8                 ;1229
0002b0  f5066010          ADD      r0,r6,#0x900          ;1229
0002b4  eb001045          ADD      r0,r0,r5,LSL #5       ;1229
0002b8  6081              STR      r1,[r0,#8]            ;1229
                  |L20.698|
0002ba  f0080010          AND      r0,r8,#0x10           ;1231
0002be  2810              CMP      r0,#0x10              ;1231
0002c0  d105              BNE      |L20.718|
0002c2  2110              MOVS     r1,#0x10              ;1233
0002c4  f5066010          ADD      r0,r6,#0x900          ;1233
0002c8  eb001045          ADD      r0,r0,r5,LSL #5       ;1233
0002cc  6081              STR      r1,[r0,#8]            ;1233
                  |L20.718|
0002ce  f0080040          AND      r0,r8,#0x40           ;1235
0002d2  2840              CMP      r0,#0x40              ;1235
0002d4  d105              BNE      |L20.738|
0002d6  2140              MOVS     r1,#0x40              ;1237
0002d8  f5066010          ADD      r0,r6,#0x900          ;1237
0002dc  eb001045          ADD      r0,r0,r5,LSL #5       ;1237
0002e0  6081              STR      r1,[r0,#8]            ;1237
                  |L20.738|
0002e2  f0080002          AND      r0,r8,#2              ;1239
0002e6  2802              CMP      r0,#2                 ;1239
0002e8  d11d              BNE      |L20.806|
0002ea  4629              MOV      r1,r5                 ;1241
0002ec  4658              MOV      r0,r11                ;1241
0002ee  f7fffffe          BL       USB_FlushTxFifo
0002f2  eb0501c5          ADD      r1,r5,r5,LSL #3       ;1243
0002f6  e001              B        |L20.764|
                  |L20.760|
0002f8  e025              B        |L20.838|
                  |L20.762|
0002fa  e01c              B        |L20.822|
                  |L20.764|
0002fc  f104003c          ADD      r0,r4,#0x3c           ;1243
000300  eb000a81          ADD      r10,r0,r1,LSL #2      ;1243
000304  f89a0003          LDRB     r0,[r10,#3]           ;1245
000308  2801              CMP      r0,#1                 ;1245
00030a  d106              BNE      |L20.794|
00030c  2000              MOVS     r0,#0                 ;1247
00030e  f88a0003          STRB     r0,[r10,#3]           ;1247
000312  b2e9              UXTB     r1,r5                 ;1252
000314  4620              MOV      r0,r4                 ;1252
000316  f7fffffe          BL       HAL_PCD_ISOINIncompleteCallback
                  |L20.794|
00031a  2102              MOVS     r1,#2                 ;1256
00031c  f5066010          ADD      r0,r6,#0x900          ;1256
000320  eb001045          ADD      r0,r0,r5,LSL #5       ;1256
000324  6081              STR      r1,[r0,#8]            ;1256
                  |L20.806|
000326  f0080080          AND      r0,r8,#0x80           ;1258
00032a  2880              CMP      r0,#0x80              ;1258
00032c  d103              BNE      |L20.822|
00032e  4629              MOV      r1,r5                 ;1260
000330  4620              MOV      r0,r4                 ;1260
000332  f7fffffe          BL       PCD_WriteEmptyTxFifo
                  |L20.822|
000336  1c6d              ADDS     r5,r5,#1              ;1263
000338  9802              LDR      r0,[sp,#8]            ;1264
00033a  0840              LSRS     r0,r0,#1              ;1264
00033c  9002              STR      r0,[sp,#8]            ;1264
                  |L20.830|
00033e  9802              LDR      r0,[sp,#8]            ;1196
000340  2800              CMP      r0,#0                 ;1196
000342  f47faf61          BNE      |L20.520|
                  |L20.838|
000346  6820              LDR      r0,[r4,#0]            ;1269
000348  f7fffffe          BL       USB_ReadInterrupts
00034c  f0004000          AND      r0,r0,#0x80000000     ;1269
000350  f1b04f00          CMP      r0,#0x80000000        ;1269
000354  d11c              BNE      |L20.912|
000356  f6400004          MOV      r0,#0x804             ;1272
00035a  5980              LDR      r0,[r0,r6]            ;1272
00035c  f0200101          BIC      r1,r0,#1              ;1272
000360  f6400004          MOV      r0,#0x804             ;1272
000364  5181              STR      r1,[r0,r6]            ;1272
000366  f89404f4          LDRB     r0,[r4,#0x4f4]        ;1274
00036a  2801              CMP      r0,#1                 ;1274
00036c  d107              BNE      |L20.894|
00036e  2000              MOVS     r0,#0                 ;1276
000370  f88404f4          STRB     r0,[r4,#0x4f4]        ;1276
000374  2100              MOVS     r1,#0                 ;1281
000376  4620              MOV      r0,r4                 ;1281
000378  f7fffffe          BL       HAL_PCDEx_LPM_Callback
00037c  e002              B        |L20.900|
                  |L20.894|
00037e  4620              MOV      r0,r4                 ;1289
000380  f7fffffe          BL       HAL_PCD_ResumeCallback
                  |L20.900|
000384  6820              LDR      r0,[r4,#0]            ;1293
000386  6940              LDR      r0,[r0,#0x14]         ;1293
000388  f0004000          AND      r0,r0,#0x80000000     ;1293
00038c  6821              LDR      r1,[r4,#0]            ;1293
00038e  6148              STR      r0,[r1,#0x14]         ;1293
                  |L20.912|
000390  6820              LDR      r0,[r4,#0]            ;1297
000392  f7fffffe          BL       USB_ReadInterrupts
000396  f4006000          AND      r0,r0,#0x800          ;1297
00039a  f5b06f00          CMP      r0,#0x800             ;1297
00039e  d10e              BNE      |L20.958|
0003a0  f6400008          MOV      r0,#0x808             ;1299
0003a4  5980              LDR      r0,[r0,r6]            ;1299
0003a6  f0000001          AND      r0,r0,#1              ;1299
0003aa  b110              CBZ      r0,|L20.946|
0003ac  4620              MOV      r0,r4                 ;1304
0003ae  f7fffffe          BL       HAL_PCD_SuspendCallback
                  |L20.946|
0003b2  6820              LDR      r0,[r4,#0]            ;1307
0003b4  6940              LDR      r0,[r0,#0x14]         ;1307
0003b6  f4006000          AND      r0,r0,#0x800          ;1307
0003ba  6821              LDR      r1,[r4,#0]            ;1307
0003bc  6148              STR      r0,[r1,#0x14]         ;1307
                  |L20.958|
0003be  6820              LDR      r0,[r4,#0]            ;1337
0003c0  f7fffffe          BL       USB_ReadInterrupts
0003c4  f4005080          AND      r0,r0,#0x1000         ;1337
0003c8  f5b05f80          CMP      r0,#0x1000            ;1337
0003cc  d17e              BNE      |L20.1228|
0003ce  f6400004          MOV      r0,#0x804             ;1339
0003d2  5980              LDR      r0,[r0,r6]            ;1339
0003d4  f0200101          BIC      r1,r0,#1              ;1339
0003d8  f6400004          MOV      r0,#0x804             ;1339
0003dc  5181              STR      r1,[r0,r6]            ;1339
0003de  2110              MOVS     r1,#0x10              ;1340
0003e0  6820              LDR      r0,[r4,#0]            ;1340
0003e2  f7fffffe          BL       USB_FlushTxFifo
0003e6  2700              MOVS     r7,#0                 ;1342
0003e8  e032              B        |L20.1104|
                  |L20.1002|
0003ea  f64f317f          MOV      r1,#0xfb7f            ;1344
0003ee  f5066010          ADD      r0,r6,#0x900          ;1344
0003f2  eb001047          ADD      r0,r0,r7,LSL #5       ;1344
0003f6  6081              STR      r1,[r0,#8]            ;1344
0003f8  f5066010          ADD      r0,r6,#0x900          ;1345
0003fc  eb001047          ADD      r0,r0,r7,LSL #5       ;1345
000400  6800              LDR      r0,[r0,#0]            ;1345
000402  f4201100          BIC      r1,r0,#0x200000       ;1345
000406  f5066010          ADD      r0,r6,#0x900          ;1345
00040a  eb001047          ADD      r0,r0,r7,LSL #5       ;1345
00040e  6001              STR      r1,[r0,#0]            ;1345
000410  f64f317f          MOV      r1,#0xfb7f            ;1346
000414  f5066030          ADD      r0,r6,#0xb00          ;1346
000418  eb001047          ADD      r0,r0,r7,LSL #5       ;1346
00041c  6081              STR      r1,[r0,#8]            ;1346
00041e  f5066030          ADD      r0,r6,#0xb00          ;1347
000422  eb001047          ADD      r0,r0,r7,LSL #5       ;1347
000426  6800              LDR      r0,[r0,#0]            ;1347
000428  f4201100          BIC      r1,r0,#0x200000       ;1347
00042c  f5066030          ADD      r0,r6,#0xb00          ;1347
000430  eb001047          ADD      r0,r0,r7,LSL #5       ;1347
000434  6001              STR      r1,[r0,#0]            ;1347
000436  f5066030          ADD      r0,r6,#0xb00          ;1348
00043a  eb001047          ADD      r0,r0,r7,LSL #5       ;1348
00043e  6800              LDR      r0,[r0,#0]            ;1348
000440  f0406100          ORR      r1,r0,#0x8000000      ;1348
000444  f5066030          ADD      r0,r6,#0xb00          ;1348
000448  eb001047          ADD      r0,r0,r7,LSL #5       ;1348
00044c  6001              STR      r1,[r0,#0]            ;1348
00044e  1c7f              ADDS     r7,r7,#1              ;1342
                  |L20.1104|
000450  6860              LDR      r0,[r4,#4]            ;1342
000452  42b8              CMP      r0,r7                 ;1342
000454  d8c9              BHI      |L20.1002|
000456  f640001c          MOV      r0,#0x81c             ;1350
00045a  5980              LDR      r0,[r0,r6]            ;1350
00045c  f0401101          ORR      r1,r0,#0x10001        ;1350
000460  f640001c          MOV      r0,#0x81c             ;1350
000464  5181              STR      r1,[r0,r6]            ;1350
000466  6b20              LDR      r0,[r4,#0x30]         ;1352
000468  b170              CBZ      r0,|L20.1160|
00046a  f8d60884          LDR      r0,[r6,#0x884]        ;1354
00046e  f040010b          ORR      r1,r0,#0xb            ;1354
000472  f8c61884          STR      r1,[r6,#0x884]        ;1354
000476  f6400044          MOV      r0,#0x844             ;1358
00047a  5980              LDR      r0,[r0,r6]            ;1358
00047c  f040010b          ORR      r1,r0,#0xb            ;1358
000480  f6400044          MOV      r0,#0x844             ;1358
000484  5181              STR      r1,[r0,r6]            ;1358
000486  e00f              B        |L20.1192|
                  |L20.1160|
000488  f6400014          MOV      r0,#0x814             ;1364
00048c  5980              LDR      r0,[r0,r6]            ;1364
00048e  f242012b          MOV      r1,#0x202b            ;1364
000492  4308              ORRS     r0,r0,r1              ;1364
000494  f6400114          MOV      r1,#0x814             ;1364
000498  5188              STR      r0,[r1,r6]            ;1364
00049a  1f08              SUBS     r0,r1,#4              ;1370
00049c  5980              LDR      r0,[r0,r6]            ;1370
00049e  f040010b          ORR      r1,r0,#0xb            ;1370
0004a2  f44f6001          MOV      r0,#0x810             ;1370
0004a6  5181              STR      r1,[r0,r6]            ;1370
                  |L20.1192|
0004a8  f8d60800          LDR      r0,[r6,#0x800]        ;1376
0004ac  f42060fe          BIC      r0,r0,#0x7f0          ;1376
0004b0  f8c60800          STR      r0,[r6,#0x800]        ;1376
0004b4  7c21              LDRB     r1,[r4,#0x10]         ;1379
0004b6  f20442c4          ADD      r2,r4,#0x4c4          ;1379
0004ba  6820              LDR      r0,[r4,#0]            ;1379
0004bc  f7fffffe          BL       USB_EP0_OutStart
0004c0  6820              LDR      r0,[r4,#0]            ;1382
0004c2  6940              LDR      r0,[r0,#0x14]         ;1382
0004c4  f4005080          AND      r0,r0,#0x1000         ;1382
0004c8  6821              LDR      r1,[r4,#0]            ;1382
0004ca  e000              B        |L20.1230|
                  |L20.1228|
0004cc  e000              B        |L20.1232|
                  |L20.1230|
0004ce  6148              STR      r0,[r1,#0x14]         ;1382
                  |L20.1232|
0004d0  6820              LDR      r0,[r4,#0]            ;1386
0004d2  f7fffffe          BL       USB_ReadInterrupts
0004d6  f4005000          AND      r0,r0,#0x2000         ;1386
0004da  f5b05f00          CMP      r0,#0x2000            ;1386
0004de  d117              BNE      |L20.1296|
0004e0  6820              LDR      r0,[r4,#0]            ;1388
0004e2  f7fffffe          BL       USB_ActivateSetup
0004e6  6820              LDR      r0,[r4,#0]            ;1389
0004e8  f7fffffe          BL       USB_GetDevSpeed
0004ec  60e0              STR      r0,[r4,#0xc]          ;1389
0004ee  f7fffffe          BL       HAL_RCC_GetHCLKFreq
0004f2  9000              STR      r0,[sp,#0]            ;1392
0004f4  7b22              LDRB     r2,[r4,#0xc]          ;1392
0004f6  6820              LDR      r0,[r4,#0]            ;1392
0004f8  9900              LDR      r1,[sp,#0]            ;1392
0004fa  f7fffffe          BL       USB_SetTurnaroundTime
0004fe  4620              MOV      r0,r4                 ;1399
000500  f7fffffe          BL       HAL_PCD_ResetCallback
000504  6820              LDR      r0,[r4,#0]            ;1402
000506  6940              LDR      r0,[r0,#0x14]         ;1402
000508  f4005000          AND      r0,r0,#0x2000         ;1402
00050c  6821              LDR      r1,[r4,#0]            ;1402
00050e  6148              STR      r0,[r1,#0x14]         ;1402
                  |L20.1296|
000510  6820              LDR      r0,[r4,#0]            ;1406
000512  f7fffffe          BL       USB_ReadInterrupts
000516  f0000008          AND      r0,r0,#8              ;1406
00051a  2808              CMP      r0,#8                 ;1406
00051c  d108              BNE      |L20.1328|
00051e  4620              MOV      r0,r4                 ;1411
000520  f7fffffe          BL       HAL_PCD_SOFCallback
000524  6820              LDR      r0,[r4,#0]            ;1414
000526  6940              LDR      r0,[r0,#0x14]         ;1414
000528  f0000008          AND      r0,r0,#8              ;1414
00052c  6821              LDR      r1,[r4,#0]            ;1414
00052e  6148              STR      r0,[r1,#0x14]         ;1414
                  |L20.1328|
000530  6820              LDR      r0,[r4,#0]            ;1418
000532  f7fffffe          BL       USB_ReadInterrupts
000536  f0000080          AND      r0,r0,#0x80           ;1418
00053a  2880              CMP      r0,#0x80              ;1418
00053c  d118              BNE      |L20.1392|
00053e  f8db0018          LDR      r0,[r11,#0x18]        ;1420
000542  f0200080          BIC      r0,r0,#0x80           ;1420
000546  f8cb0018          STR      r0,[r11,#0x18]        ;1420
00054a  2501              MOVS     r5,#1                 ;1422
00054c  e00d              B        |L20.1386|
                  |L20.1358|
00054e  eb0501c5          ADD      r1,r5,r5,LSL #3       ;1424
000552  f504701f          ADD      r0,r4,#0x27c          ;1424
000556  eb000081          ADD      r0,r0,r1,LSL #2       ;1424
00055a  78c0              LDRB     r0,[r0,#3]            ;1424
00055c  2801              CMP      r0,#1                 ;1424
00055e  d103              BNE      |L20.1384|
000560  b2e9              UXTB     r1,r5                 ;1427
000562  4620              MOV      r0,r4                 ;1427
000564  f7fffffe          BL       HAL_PCD_EP_Abort
                  |L20.1384|
000568  1c6d              ADDS     r5,r5,#1              ;1422
                  |L20.1386|
00056a  6860              LDR      r0,[r4,#4]            ;1422
00056c  42a8              CMP      r0,r5                 ;1422
00056e  d8ee              BHI      |L20.1358|
                  |L20.1392|
000570  6820              LDR      r0,[r4,#0]            ;1433
000572  f7fffffe          BL       USB_ReadInterrupts
000576  f4001080          AND      r0,r0,#0x100000       ;1433
00057a  f5b01f80          CMP      r0,#0x100000          ;1433
00057e  d12d              BNE      |L20.1500|
000580  2501              MOVS     r5,#1                 ;1435
000582  e022              B        |L20.1482|
                  |L20.1412|
000584  f5066010          ADD      r0,r6,#0x900          ;1437
000588  eb001045          ADD      r0,r0,r5,LSL #5       ;1437
00058c  f8d09000          LDR      r9,[r0,#0]            ;1437
000590  eb0501c5          ADD      r1,r5,r5,LSL #3       ;1439
000594  f104003c          ADD      r0,r4,#0x3c           ;1439
000598  eb000081          ADD      r0,r0,r1,LSL #2       ;1439
00059c  7900              LDRB     r0,[r0,#4]            ;1439
00059e  2801              CMP      r0,#1                 ;1439
0005a0  d112              BNE      |L20.1480|
0005a2  f0094000          AND      r0,r9,#0x80000000     ;1440
0005a6  f1b04f00          CMP      r0,#0x80000000        ;1440
0005aa  d10d              BNE      |L20.1480|
0005ac  2101              MOVS     r1,#1                 ;1442
0005ae  eb0502c5          ADD      r2,r5,r5,LSL #3       ;1442
0005b2  f104003c          ADD      r0,r4,#0x3c           ;1442
0005b6  eb000082          ADD      r0,r0,r2,LSL #2       ;1442
0005ba  70c1              STRB     r1,[r0,#3]            ;1442
0005bc  b2e8              UXTB     r0,r5                 ;1445
0005be  f0400180          ORR      r1,r0,#0x80           ;1445
0005c2  4620              MOV      r0,r4                 ;1445
0005c4  f7fffffe          BL       HAL_PCD_EP_Abort
                  |L20.1480|
0005c8  1c6d              ADDS     r5,r5,#1              ;1435
                  |L20.1482|
0005ca  6860              LDR      r0,[r4,#4]            ;1435
0005cc  42a8              CMP      r0,r5                 ;1435
0005ce  d8d9              BHI      |L20.1412|
0005d0  6820              LDR      r0,[r4,#0]            ;1449
0005d2  6940              LDR      r0,[r0,#0x14]         ;1449
0005d4  f4001080          AND      r0,r0,#0x100000       ;1449
0005d8  6821              LDR      r1,[r4,#0]            ;1449
0005da  6148              STR      r0,[r1,#0x14]         ;1449
                  |L20.1500|
0005dc  6820              LDR      r0,[r4,#0]            ;1453
0005de  f7fffffe          BL       USB_ReadInterrupts
0005e2  f4001000          AND      r0,r0,#0x200000       ;1453
0005e6  f5b01f00          CMP      r0,#0x200000          ;1453
0005ea  d144              BNE      |L20.1654|
0005ec  2501              MOVS     r5,#1                 ;1455
0005ee  e038              B        |L20.1634|
                  |L20.1520|
0005f0  f5066030          ADD      r0,r6,#0xb00          ;1457
0005f4  eb001045          ADD      r0,r0,r5,LSL #5       ;1457
0005f8  f8d09000          LDR      r9,[r0,#0]            ;1457
0005fc  eb0501c5          ADD      r1,r5,r5,LSL #3       ;1459
000600  f504701f          ADD      r0,r4,#0x27c          ;1459
000604  eb000081          ADD      r0,r0,r1,LSL #2       ;1459
000608  7900              LDRB     r0,[r0,#4]            ;1459
00060a  2801              CMP      r0,#1                 ;1459
00060c  d128              BNE      |L20.1632|
00060e  f0094000          AND      r0,r9,#0x80000000     ;1460
000612  f1b04f00          CMP      r0,#0x80000000        ;1460
000616  d123              BNE      |L20.1632|
000618  f4093080          AND      r0,r9,#0x10000        ;1461
00061c  f89414fc          LDRB     r1,[r4,#0x4fc]        ;1461
000620  f0010101          AND      r1,r1,#1              ;1461
000624  4288              CMP      r0,r1                 ;1461
000626  d11b              BNE      |L20.1632|
000628  2101              MOVS     r1,#1                 ;1463
00062a  eb0502c5          ADD      r2,r5,r5,LSL #3       ;1463
00062e  f504701f          ADD      r0,r4,#0x27c          ;1463
000632  eb000082          ADD      r0,r0,r2,LSL #2       ;1463
000636  70c1              STRB     r1,[r0,#3]            ;1463
000638  f8db0018          LDR      r0,[r11,#0x18]        ;1465
00063c  f0400080          ORR      r0,r0,#0x80           ;1465
000640  f8cb0018          STR      r0,[r11,#0x18]        ;1465
000644  f8db0014          LDR      r0,[r11,#0x14]        ;1467
000648  f0000080          AND      r0,r0,#0x80           ;1467
00064c  b940              CBNZ     r0,|L20.1632|
00064e  f6400004          MOV      r0,#0x804             ;1469
000652  5980              LDR      r0,[r0,r6]            ;1469
000654  f4407100          ORR      r1,r0,#0x200          ;1469
000658  f6400004          MOV      r0,#0x804             ;1469
00065c  5181              STR      r1,[r0,r6]            ;1469
00065e  e003              B        |L20.1640|
                  |L20.1632|
000660  1c6d              ADDS     r5,r5,#1              ;1455
                  |L20.1634|
000662  6860              LDR      r0,[r4,#4]            ;1455
000664  42a8              CMP      r0,r5                 ;1455
000666  d8c3              BHI      |L20.1520|
                  |L20.1640|
000668  bf00              NOP                            ;1470
00066a  6820              LDR      r0,[r4,#0]            ;1475
00066c  6940              LDR      r0,[r0,#0x14]         ;1475
00066e  f4001000          AND      r0,r0,#0x200000       ;1475
000672  6821              LDR      r1,[r4,#0]            ;1475
000674  6148              STR      r0,[r1,#0x14]         ;1475
                  |L20.1654|
000676  6820              LDR      r0,[r4,#0]            ;1479
000678  f7fffffe          BL       USB_ReadInterrupts
00067c  f0004080          AND      r0,r0,#0x40000000     ;1479
000680  f1b04f80          CMP      r0,#0x40000000        ;1479
000684  d108              BNE      |L20.1688|
000686  4620              MOV      r0,r4                 ;1484
000688  f7fffffe          BL       HAL_PCD_ConnectCallback
00068c  6820              LDR      r0,[r4,#0]            ;1487
00068e  6940              LDR      r0,[r0,#0x14]         ;1487
000690  f0004080          AND      r0,r0,#0x40000000     ;1487
000694  6821              LDR      r1,[r4,#0]            ;1487
000696  6148              STR      r0,[r1,#0x14]         ;1487
                  |L20.1688|
000698  6820              LDR      r0,[r4,#0]            ;1491
00069a  f7fffffe          BL       USB_ReadInterrupts
00069e  f0000004          AND      r0,r0,#4              ;1491
0006a2  2804              CMP      r0,#4                 ;1491
0006a4  d10f              BNE      |L20.1734|
0006a6  6820              LDR      r0,[r4,#0]            ;1493
0006a8  f8d09004          LDR      r9,[r0,#4]            ;1493
0006ac  f0090004          AND      r0,r9,#4              ;1495
0006b0  2804              CMP      r0,#4                 ;1495
0006b2  d102              BNE      |L20.1722|
0006b4  4620              MOV      r0,r4                 ;1500
0006b6  f7fffffe          BL       HAL_PCD_DisconnectCallback
                  |L20.1722|
0006ba  6820              LDR      r0,[r4,#0]            ;1503
0006bc  6840              LDR      r0,[r0,#4]            ;1503
0006be  ea400009          ORR      r0,r0,r9              ;1503
0006c2  6821              LDR      r1,[r4,#0]            ;1503
0006c4  6048              STR      r0,[r1,#4]            ;1503
                  |L20.1734|
0006c6  bf00              NOP      
0006c8  e4a9              B        |L20.30|
;;;1507   
                          ENDP


                          AREA ||i.HAL_PCD_ISOINIncompleteCallback||, CODE, READONLY, ALIGN=1

                  HAL_PCD_ISOINIncompleteCallback PROC
;;;1664     */
;;;1665   __weak void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
000000  4770              BX       lr
;;;1666   {
;;;1667     /* Prevent unused argument(s) compilation warning */
;;;1668     UNUSED(hpcd);
;;;1669     UNUSED(epnum);
;;;1670   
;;;1671     /* NOTE : This function should not be modified, when the callback is needed,
;;;1672               the HAL_PCD_ISOINIncompleteCallback could be implemented in the user file
;;;1673      */
;;;1674   }
;;;1675   
                          ENDP


                          AREA ||i.HAL_PCD_ISOOUTIncompleteCallback||, CODE, READONLY, ALIGN=1

                  HAL_PCD_ISOOUTIncompleteCallback PROC
;;;1647     */
;;;1648   __weak void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
000000  4770              BX       lr
;;;1649   {
;;;1650     /* Prevent unused argument(s) compilation warning */
;;;1651     UNUSED(hpcd);
;;;1652     UNUSED(epnum);
;;;1653   
;;;1654     /* NOTE : This function should not be modified, when the callback is needed,
;;;1655               the HAL_PCD_ISOOUTIncompleteCallback could be implemented in the user file
;;;1656      */
;;;1657   }
;;;1658   
                          ENDP


                          AREA ||i.HAL_PCD_Init||, CODE, READONLY, ALIGN=1

                  HAL_PCD_Init PROC
;;;122      */
;;;123    HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
000000  b570              PUSH     {r4-r6,lr}
;;;124    {
000002  b08a              SUB      sp,sp,#0x28
000004  4604              MOV      r4,r0
;;;125      USB_OTG_GlobalTypeDef *USBx;
;;;126      uint8_t i;
;;;127    
;;;128      /* Check the PCD handle allocation */
;;;129      if (hpcd == NULL)
000006  b914              CBNZ     r4,|L23.14|
;;;130      {
;;;131        return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L23.10|
;;;132      }
;;;133    
;;;134      /* Check the parameters */
;;;135      assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));
;;;136    
;;;137      USBx = hpcd->Instance;
;;;138    
;;;139      if (hpcd->State == HAL_PCD_STATE_RESET)
;;;140      {
;;;141        /* Allocate lock resource and initialize it */
;;;142        hpcd->Lock = HAL_UNLOCKED;
;;;143    
;;;144    #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
;;;145        hpcd->SOFCallback = HAL_PCD_SOFCallback;
;;;146        hpcd->SetupStageCallback = HAL_PCD_SetupStageCallback;
;;;147        hpcd->ResetCallback = HAL_PCD_ResetCallback;
;;;148        hpcd->SuspendCallback = HAL_PCD_SuspendCallback;
;;;149        hpcd->ResumeCallback = HAL_PCD_ResumeCallback;
;;;150        hpcd->ConnectCallback = HAL_PCD_ConnectCallback;
;;;151        hpcd->DisconnectCallback = HAL_PCD_DisconnectCallback;
;;;152        hpcd->DataOutStageCallback = HAL_PCD_DataOutStageCallback;
;;;153        hpcd->DataInStageCallback = HAL_PCD_DataInStageCallback;
;;;154        hpcd->ISOOUTIncompleteCallback = HAL_PCD_ISOOUTIncompleteCallback;
;;;155        hpcd->ISOINIncompleteCallback = HAL_PCD_ISOINIncompleteCallback;
;;;156        hpcd->LPMCallback = HAL_PCDEx_LPM_Callback;
;;;157        hpcd->BCDCallback = HAL_PCDEx_BCD_Callback;
;;;158    
;;;159        if (hpcd->MspInitCallback == NULL)
;;;160        {
;;;161          hpcd->MspInitCallback = HAL_PCD_MspInit;
;;;162        }
;;;163    
;;;164        /* Init the low level hardware */
;;;165        hpcd->MspInitCallback(hpcd);
;;;166    #else
;;;167        /* Init the low level hardware : GPIO, CLOCK, NVIC... */
;;;168        HAL_PCD_MspInit(hpcd);
;;;169    #endif /* (USE_HAL_PCD_REGISTER_CALLBACKS) */
;;;170      }
;;;171    
;;;172      hpcd->State = HAL_PCD_STATE_BUSY;
;;;173    
;;;174      /* Disable DMA mode for FS instance */
;;;175      if ((USBx->CID & (0x1U << 8)) == 0U)
;;;176      {
;;;177        hpcd->Init.dma_enable = 0U;
;;;178      }
;;;179    
;;;180      /* Disable the Interrupts */
;;;181      __HAL_PCD_DISABLE(hpcd);
;;;182    
;;;183      /*Init the Core (common init.) */
;;;184      if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)
;;;185      {
;;;186        hpcd->State = HAL_PCD_STATE_ERROR;
;;;187        return HAL_ERROR;
;;;188      }
;;;189    
;;;190      /* Force Device Mode*/
;;;191      (void)USB_SetCurrentMode(hpcd->Instance, USB_DEVICE_MODE);
;;;192    
;;;193      /* Init endpoints structures */
;;;194      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
;;;195      {
;;;196        /* Init ep structure */
;;;197        hpcd->IN_ep[i].is_in = 1U;
;;;198        hpcd->IN_ep[i].num = i;
;;;199        hpcd->IN_ep[i].tx_fifo_num = i;
;;;200        /* Control until ep is activated */
;;;201        hpcd->IN_ep[i].type = EP_TYPE_CTRL;
;;;202        hpcd->IN_ep[i].maxpacket = 0U;
;;;203        hpcd->IN_ep[i].xfer_buff = 0U;
;;;204        hpcd->IN_ep[i].xfer_len = 0U;
;;;205      }
;;;206    
;;;207      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
;;;208      {
;;;209        hpcd->OUT_ep[i].is_in = 0U;
;;;210        hpcd->OUT_ep[i].num = i;
;;;211        /* Control until ep is activated */
;;;212        hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
;;;213        hpcd->OUT_ep[i].maxpacket = 0U;
;;;214        hpcd->OUT_ep[i].xfer_buff = 0U;
;;;215        hpcd->OUT_ep[i].xfer_len = 0U;
;;;216      }
;;;217    
;;;218      /* Init Device */
;;;219      if (USB_DevInit(hpcd->Instance, hpcd->Init) != HAL_OK)
;;;220      {
;;;221        hpcd->State = HAL_PCD_STATE_ERROR;
;;;222        return HAL_ERROR;
;;;223      }
;;;224    
;;;225      hpcd->USB_Address = 0U;
;;;226      hpcd->State = HAL_PCD_STATE_READY;
;;;227    #if defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
;;;228      /* Activate LPM */
;;;229      if (hpcd->Init.lpm_enable == 1U)
;;;230      {
;;;231        (void)HAL_PCDEx_ActivateLPM(hpcd);
;;;232      }
;;;233    #endif /* defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx) */
;;;234      (void)USB_DevDisconnect(hpcd->Instance);
;;;235    
;;;236      return HAL_OK;
;;;237    }
00000a  b00a              ADD      sp,sp,#0x28
00000c  bd70              POP      {r4-r6,pc}
                  |L23.14|
00000e  6826              LDR      r6,[r4,#0]            ;137
000010  f89404bd          LDRB     r0,[r4,#0x4bd]        ;139
000014  b928              CBNZ     r0,|L23.34|
000016  2000              MOVS     r0,#0                 ;142
000018  f88404bc          STRB     r0,[r4,#0x4bc]        ;142
00001c  4620              MOV      r0,r4                 ;168
00001e  f7fffffe          BL       HAL_PCD_MspInit
                  |L23.34|
000022  2003              MOVS     r0,#3                 ;172
000024  f88404bd          STRB     r0,[r4,#0x4bd]        ;172
000028  6bf0              LDR      r0,[r6,#0x3c]         ;175
00002a  f4007080          AND      r0,r0,#0x100          ;175
00002e  b908              CBNZ     r0,|L23.52|
000030  2100              MOVS     r1,#0                 ;177
000032  6121              STR      r1,[r4,#0x10]         ;177
                  |L23.52|
000034  6820              LDR      r0,[r4,#0]            ;181
000036  f7fffffe          BL       USB_DisableGlobalInt
00003a  2228              MOVS     r2,#0x28              ;184
00003c  f1040110          ADD      r1,r4,#0x10           ;184
000040  4668              MOV      r0,sp                 ;184
000042  f7fffffe          BL       __aeabi_memcpy4
000046  e894000f          LDM      r4,{r0-r3}            ;184
00004a  f7fffffe          BL       USB_CoreInit
00004e  b120              CBZ      r0,|L23.90|
000050  2002              MOVS     r0,#2                 ;186
000052  f88404bd          STRB     r0,[r4,#0x4bd]        ;186
000056  2001              MOVS     r0,#1                 ;187
000058  e7d7              B        |L23.10|
                  |L23.90|
00005a  2100              MOVS     r1,#0                 ;191
00005c  6820              LDR      r0,[r4,#0]            ;191
00005e  f7fffffe          BL       USB_SetCurrentMode
000062  2500              MOVS     r5,#0                 ;194
000064  e031              B        |L23.202|
                  |L23.102|
000066  2101              MOVS     r1,#1                 ;197
000068  eb0502c5          ADD      r2,r5,r5,LSL #3       ;197
00006c  f104003c          ADD      r0,r4,#0x3c           ;197
000070  eb000082          ADD      r0,r0,r2,LSL #2       ;197
000074  7041              STRB     r1,[r0,#1]            ;197
000076  eb0501c5          ADD      r1,r5,r5,LSL #3       ;198
00007a  f104003c          ADD      r0,r4,#0x3c           ;198
00007e  f8005021          STRB     r5,[r0,r1,LSL #2]     ;198
000082  eb0501c5          ADD      r1,r5,r5,LSL #3       ;199
000086  eb000081          ADD      r0,r0,r1,LSL #2       ;199
00008a  8105              STRH     r5,[r0,#8]            ;199
00008c  2100              MOVS     r1,#0                 ;201
00008e  eb0502c5          ADD      r2,r5,r5,LSL #3       ;201
000092  f104003c          ADD      r0,r4,#0x3c           ;201
000096  eb000082          ADD      r0,r0,r2,LSL #2       ;201
00009a  7101              STRB     r1,[r0,#4]            ;201
00009c  eb0502c5          ADD      r2,r5,r5,LSL #3       ;202
0000a0  f104003c          ADD      r0,r4,#0x3c           ;202
0000a4  eb000082          ADD      r0,r0,r2,LSL #2       ;202
0000a8  60c1              STR      r1,[r0,#0xc]          ;202
0000aa  eb0502c5          ADD      r2,r5,r5,LSL #3       ;203
0000ae  f104003c          ADD      r0,r4,#0x3c           ;203
0000b2  eb000082          ADD      r0,r0,r2,LSL #2       ;203
0000b6  6101              STR      r1,[r0,#0x10]         ;203
0000b8  eb0502c5          ADD      r2,r5,r5,LSL #3       ;204
0000bc  f104003c          ADD      r0,r4,#0x3c           ;204
0000c0  eb000082          ADD      r0,r0,r2,LSL #2       ;204
0000c4  6181              STR      r1,[r0,#0x18]         ;204
0000c6  1c68              ADDS     r0,r5,#1              ;194
0000c8  b2c5              UXTB     r5,r0                 ;194
                  |L23.202|
0000ca  6860              LDR      r0,[r4,#4]            ;194
0000cc  42a8              CMP      r0,r5                 ;194
0000ce  d8ca              BHI      |L23.102|
0000d0  2500              MOVS     r5,#0                 ;207
0000d2  e02a              B        |L23.298|
                  |L23.212|
0000d4  2100              MOVS     r1,#0                 ;209
0000d6  eb0502c5          ADD      r2,r5,r5,LSL #3       ;209
0000da  f504701f          ADD      r0,r4,#0x27c          ;209
0000de  eb000082          ADD      r0,r0,r2,LSL #2       ;209
0000e2  7041              STRB     r1,[r0,#1]            ;209
0000e4  eb0501c5          ADD      r1,r5,r5,LSL #3       ;210
0000e8  f504701f          ADD      r0,r4,#0x27c          ;210
0000ec  f8005021          STRB     r5,[r0,r1,LSL #2]     ;210
0000f0  2100              MOVS     r1,#0                 ;212
0000f2  eb0502c5          ADD      r2,r5,r5,LSL #3       ;212
0000f6  eb000082          ADD      r0,r0,r2,LSL #2       ;212
0000fa  7101              STRB     r1,[r0,#4]            ;212
0000fc  eb0502c5          ADD      r2,r5,r5,LSL #3       ;213
000100  f504701f          ADD      r0,r4,#0x27c          ;213
000104  eb000082          ADD      r0,r0,r2,LSL #2       ;213
000108  60c1              STR      r1,[r0,#0xc]          ;213
00010a  eb0502c5          ADD      r2,r5,r5,LSL #3       ;214
00010e  f504701f          ADD      r0,r4,#0x27c          ;214
000112  eb000082          ADD      r0,r0,r2,LSL #2       ;214
000116  6101              STR      r1,[r0,#0x10]         ;214
000118  eb0502c5          ADD      r2,r5,r5,LSL #3       ;215
00011c  f504701f          ADD      r0,r4,#0x27c          ;215
000120  eb000082          ADD      r0,r0,r2,LSL #2       ;215
000124  6181              STR      r1,[r0,#0x18]         ;215
000126  1c68              ADDS     r0,r5,#1              ;207
000128  b2c5              UXTB     r5,r0                 ;207
                  |L23.298|
00012a  6860              LDR      r0,[r4,#4]            ;207
00012c  42a8              CMP      r0,r5                 ;207
00012e  d8d1              BHI      |L23.212|
000130  2228              MOVS     r2,#0x28              ;219
000132  f1040110          ADD      r1,r4,#0x10           ;219
000136  4668              MOV      r0,sp                 ;219
000138  f7fffffe          BL       __aeabi_memcpy4
00013c  e894000f          LDM      r4,{r0-r3}            ;219
000140  f7fffffe          BL       USB_DevInit
000144  b120              CBZ      r0,|L23.336|
000146  2002              MOVS     r0,#2                 ;221
000148  f88404bd          STRB     r0,[r4,#0x4bd]        ;221
00014c  2001              MOVS     r0,#1                 ;222
00014e  e75c              B        |L23.10|
                  |L23.336|
000150  2000              MOVS     r0,#0                 ;225
000152  f8840038          STRB     r0,[r4,#0x38]         ;225
000156  2001              MOVS     r0,#1                 ;226
000158  f88404bd          STRB     r0,[r4,#0x4bd]        ;226
00015c  6820              LDR      r0,[r4,#0]            ;234
00015e  f7fffffe          BL       USB_DevDisconnect
000162  2000              MOVS     r0,#0                 ;236
000164  e751              B        |L23.10|
;;;238    
                          ENDP


                          AREA ||i.HAL_PCD_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_PCD_MspDeInit PROC
;;;297      */
;;;298    __weak void HAL_PCD_MspDeInit(PCD_HandleTypeDef *hpcd)
000000  4770              BX       lr
;;;299    {
;;;300      /* Prevent unused argument(s) compilation warning */
;;;301      UNUSED(hpcd);
;;;302    
;;;303      /* NOTE : This function should not be modified, when the callback is needed,
;;;304                the HAL_PCD_MspDeInit could be implemented in the user file
;;;305       */
;;;306    }
;;;307    
                          ENDP


                          AREA ||i.HAL_PCD_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_PCD_MspInit PROC
;;;282      */
;;;283    __weak void HAL_PCD_MspInit(PCD_HandleTypeDef *hpcd)
000000  4770              BX       lr
;;;284    {
;;;285      /* Prevent unused argument(s) compilation warning */
;;;286      UNUSED(hpcd);
;;;287    
;;;288      /* NOTE : This function should not be modified, when the callback is needed,
;;;289                the HAL_PCD_MspInit could be implemented in the user file
;;;290       */
;;;291    }
;;;292    
                          ENDP


                          AREA ||i.HAL_PCD_ResetCallback||, CODE, READONLY, ALIGN=1

                  HAL_PCD_ResetCallback PROC
;;;1601     */
;;;1602   __weak void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
000000  4770              BX       lr
;;;1603   {
;;;1604     /* Prevent unused argument(s) compilation warning */
;;;1605     UNUSED(hpcd);
;;;1606   
;;;1607     /* NOTE : This function should not be modified, when the callback is needed,
;;;1608               the HAL_PCD_ResetCallback could be implemented in the user file
;;;1609      */
;;;1610   }
;;;1611   
                          ENDP


                          AREA ||i.HAL_PCD_ResumeCallback||, CODE, READONLY, ALIGN=1

                  HAL_PCD_ResumeCallback PROC
;;;1631     */
;;;1632   __weak void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
000000  4770              BX       lr
;;;1633   {
;;;1634     /* Prevent unused argument(s) compilation warning */
;;;1635     UNUSED(hpcd);
;;;1636   
;;;1637     /* NOTE : This function should not be modified, when the callback is needed,
;;;1638               the HAL_PCD_ResumeCallback could be implemented in the user file
;;;1639      */
;;;1640   }
;;;1641   
                          ENDP


                          AREA ||i.HAL_PCD_SOFCallback||, CODE, READONLY, ALIGN=1

                  HAL_PCD_SOFCallback PROC
;;;1586     */
;;;1587   __weak void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
000000  4770              BX       lr
;;;1588   {
;;;1589     /* Prevent unused argument(s) compilation warning */
;;;1590     UNUSED(hpcd);
;;;1591   
;;;1592     /* NOTE : This function should not be modified, when the callback is needed,
;;;1593               the HAL_PCD_SOFCallback could be implemented in the user file
;;;1594      */
;;;1595   }
;;;1596   
                          ENDP


                          AREA ||i.HAL_PCD_SetAddress||, CODE, READONLY, ALIGN=1

                  HAL_PCD_SetAddress PROC
;;;1777     */
;;;1778   HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
000000  b570              PUSH     {r4-r6,lr}
;;;1779   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1780     __HAL_LOCK(hpcd);
000006  bf00              NOP      
000008  f89404bc          LDRB     r0,[r4,#0x4bc]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L29.20|
000010  2002              MOVS     r0,#2
                  |L29.18|
;;;1781     hpcd->USB_Address = address;
;;;1782     (void)USB_SetDevAddress(hpcd->Instance, address);
;;;1783     __HAL_UNLOCK(hpcd);
;;;1784   
;;;1785     return HAL_OK;
;;;1786   }
000012  bd70              POP      {r4-r6,pc}
                  |L29.20|
000014  2001              MOVS     r0,#1                 ;1780
000016  f88404bc          STRB     r0,[r4,#0x4bc]        ;1780
00001a  bf00              NOP                            ;1780
00001c  f8845038          STRB     r5,[r4,#0x38]         ;1781
000020  4629              MOV      r1,r5                 ;1782
000022  6820              LDR      r0,[r4,#0]            ;1782
000024  f7fffffe          BL       USB_SetDevAddress
000028  bf00              NOP                            ;1783
00002a  2000              MOVS     r0,#0                 ;1783
00002c  f88404bc          STRB     r0,[r4,#0x4bc]        ;1783
000030  bf00              NOP                            ;1783
000032  bf00              NOP                            ;1785
000034  e7ed              B        |L29.18|
;;;1787   /**
                          ENDP


                          AREA ||i.HAL_PCD_SetTestMode||, CODE, READONLY, ALIGN=1

                  HAL_PCD_SetTestMode PROC
;;;2132     */
;;;2133   HAL_StatusTypeDef HAL_PCD_SetTestMode(PCD_HandleTypeDef *hpcd, uint8_t testmode)
000000  b530              PUSH     {r4,r5,lr}
;;;2134   {
000002  4602              MOV      r2,r0
;;;2135     USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
000004  6814              LDR      r4,[r2,#0]
;;;2136     uint32_t USBx_BASE = (uint32_t)USBx;
000006  4623              MOV      r3,r4
;;;2137   
;;;2138     switch (testmode)
000008  2906              CMP      r1,#6
00000a  d211              BCS      |L30.48|
00000c  e8dff001          TBB      [pc,r1]
000010  10030405          DCB      0x10,0x03,0x04,0x05
000014  0607              DCB      0x06,0x07
;;;2139     {
;;;2140       case TEST_J:
;;;2141       case TEST_K:
000016  bf00              NOP      
;;;2142       case TEST_SE0_NAK:
000018  bf00              NOP      
;;;2143       case TEST_PACKET:
00001a  bf00              NOP      
;;;2144       case TEST_FORCE_EN:
00001c  bf00              NOP      
;;;2145         USBx_DEVICE->DCTL |= (uint32_t)testmode << 4;
00001e  f6400004          MOV      r0,#0x804
000022  58c0              LDR      r0,[r0,r3]
000024  ea401501          ORR      r5,r0,r1,LSL #4
000028  f6400004          MOV      r0,#0x804
00002c  50c5              STR      r5,[r0,r3]
;;;2146         break;
00002e  e000              B        |L30.50|
                  |L30.48|
;;;2147   
;;;2148       default:
;;;2149         break;
000030  bf00              NOP      
                  |L30.50|
000032  bf00              NOP                            ;2146
;;;2150     }
;;;2151   
;;;2152     return HAL_OK;
000034  2000              MOVS     r0,#0
;;;2153   }
000036  bd30              POP      {r4,r5,pc}
;;;2154   /**
                          ENDP


                          AREA ||i.HAL_PCD_SetupStageCallback||, CODE, READONLY, ALIGN=1

                  HAL_PCD_SetupStageCallback PROC
;;;1571     */
;;;1572   __weak void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
000000  4770              BX       lr
;;;1573   {
;;;1574     /* Prevent unused argument(s) compilation warning */
;;;1575     UNUSED(hpcd);
;;;1576   
;;;1577     /* NOTE : This function should not be modified, when the callback is needed,
;;;1578               the HAL_PCD_SetupStageCallback could be implemented in the user file
;;;1579      */
;;;1580   }
;;;1581   
                          ENDP


                          AREA ||i.HAL_PCD_Start||, CODE, READONLY, ALIGN=1

                  HAL_PCD_Start PROC
;;;1000     */
;;;1001   HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
000000  b570              PUSH     {r4-r6,lr}
;;;1002   {
000002  4604              MOV      r4,r0
;;;1003     USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
000004  6825              LDR      r5,[r4,#0]
;;;1004   
;;;1005     __HAL_LOCK(hpcd);
000006  bf00              NOP      
000008  f89404bc          LDRB     r0,[r4,#0x4bc]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L32.20|
000010  2002              MOVS     r0,#2
                  |L32.18|
;;;1006   
;;;1007     if ((hpcd->Init.battery_charging_enable == 1U) &&
;;;1008         (hpcd->Init.phy_itface != USB_OTG_ULPI_PHY))
;;;1009     {
;;;1010       /* Enable USB Transceiver */
;;;1011       USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
;;;1012     }
;;;1013   
;;;1014     __HAL_PCD_ENABLE(hpcd);
;;;1015     (void)USB_DevConnect(hpcd->Instance);
;;;1016     __HAL_UNLOCK(hpcd);
;;;1017   
;;;1018     return HAL_OK;
;;;1019   }
000012  bd70              POP      {r4-r6,pc}
                  |L32.20|
000014  2001              MOVS     r0,#1                 ;1005
000016  f88404bc          STRB     r0,[r4,#0x4bc]        ;1005
00001a  bf00              NOP                            ;1005
00001c  6aa0              LDR      r0,[r4,#0x28]         ;1007
00001e  2801              CMP      r0,#1                 ;1007
000020  d106              BNE      |L32.48|
000022  69a0              LDR      r0,[r4,#0x18]         ;1008
000024  2801              CMP      r0,#1                 ;1008
000026  d003              BEQ      |L32.48|
000028  6ba8              LDR      r0,[r5,#0x38]         ;1011
00002a  f4403080          ORR      r0,r0,#0x10000        ;1011
00002e  63a8              STR      r0,[r5,#0x38]         ;1011
                  |L32.48|
000030  6820              LDR      r0,[r4,#0]            ;1014
000032  f7fffffe          BL       USB_EnableGlobalInt
000036  6820              LDR      r0,[r4,#0]            ;1015
000038  f7fffffe          BL       USB_DevConnect
00003c  bf00              NOP                            ;1016
00003e  2000              MOVS     r0,#0                 ;1016
000040  f88404bc          STRB     r0,[r4,#0x4bc]        ;1016
000044  bf00              NOP                            ;1016
000046  bf00              NOP                            ;1018
000048  e7e3              B        |L32.18|
;;;1020   
                          ENDP


                          AREA ||i.HAL_PCD_Stop||, CODE, READONLY, ALIGN=1

                  HAL_PCD_Stop PROC
;;;1025     */
;;;1026   HAL_StatusTypeDef HAL_PCD_Stop(PCD_HandleTypeDef *hpcd)
000000  b570              PUSH     {r4-r6,lr}
;;;1027   {
000002  4604              MOV      r4,r0
;;;1028     USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
000004  6825              LDR      r5,[r4,#0]
;;;1029   
;;;1030     __HAL_LOCK(hpcd);
000006  bf00              NOP      
000008  f89404bc          LDRB     r0,[r4,#0x4bc]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L33.20|
000010  2002              MOVS     r0,#2
                  |L33.18|
;;;1031     __HAL_PCD_DISABLE(hpcd);
;;;1032     (void)USB_DevDisconnect(hpcd->Instance);
;;;1033   
;;;1034     (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
;;;1035   
;;;1036     if ((hpcd->Init.battery_charging_enable == 1U) &&
;;;1037         (hpcd->Init.phy_itface != USB_OTG_ULPI_PHY))
;;;1038     {
;;;1039       /* Disable USB Transceiver */
;;;1040       USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
;;;1041     }
;;;1042   
;;;1043     __HAL_UNLOCK(hpcd);
;;;1044   
;;;1045     return HAL_OK;
;;;1046   }
000012  bd70              POP      {r4-r6,pc}
                  |L33.20|
000014  2001              MOVS     r0,#1                 ;1030
000016  f88404bc          STRB     r0,[r4,#0x4bc]        ;1030
00001a  bf00              NOP                            ;1030
00001c  6820              LDR      r0,[r4,#0]            ;1031
00001e  f7fffffe          BL       USB_DisableGlobalInt
000022  6820              LDR      r0,[r4,#0]            ;1032
000024  f7fffffe          BL       USB_DevDisconnect
000028  2110              MOVS     r1,#0x10              ;1034
00002a  6820              LDR      r0,[r4,#0]            ;1034
00002c  f7fffffe          BL       USB_FlushTxFifo
000030  6aa0              LDR      r0,[r4,#0x28]         ;1036
000032  2801              CMP      r0,#1                 ;1036
000034  d106              BNE      |L33.68|
000036  69a0              LDR      r0,[r4,#0x18]         ;1037
000038  2801              CMP      r0,#1                 ;1037
00003a  d003              BEQ      |L33.68|
00003c  6ba8              LDR      r0,[r5,#0x38]         ;1040
00003e  f4203080          BIC      r0,r0,#0x10000        ;1040
000042  63a8              STR      r0,[r5,#0x38]         ;1040
                  |L33.68|
000044  bf00              NOP                            ;1043
000046  2000              MOVS     r0,#0                 ;1043
000048  f88404bc          STRB     r0,[r4,#0x4bc]        ;1043
00004c  bf00              NOP                            ;1043
00004e  bf00              NOP                            ;1045
000050  e7df              B        |L33.18|
;;;1047   
                          ENDP


                          AREA ||i.HAL_PCD_SuspendCallback||, CODE, READONLY, ALIGN=1

                  HAL_PCD_SuspendCallback PROC
;;;1616     */
;;;1617   __weak void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
000000  4770              BX       lr
;;;1618   {
;;;1619     /* Prevent unused argument(s) compilation warning */
;;;1620     UNUSED(hpcd);
;;;1621   
;;;1622     /* NOTE : This function should not be modified, when the callback is needed,
;;;1623               the HAL_PCD_SuspendCallback could be implemented in the user file
;;;1624      */
;;;1625   }
;;;1626   
                          ENDP


                          AREA ||i.HAL_PCD_WKUP_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_PCD_WKUP_IRQHandler PROC
;;;1513     */
;;;1514   void HAL_PCD_WKUP_IRQHandler(PCD_HandleTypeDef *hpcd)
000000  6801              LDR      r1,[r0,#0]
;;;1515   {
;;;1516     USB_OTG_GlobalTypeDef *USBx;
;;;1517   
;;;1518     USBx = hpcd->Instance;
;;;1519   
;;;1520     if ((USBx->CID & (0x1U << 8)) == 0U)
000002  6bca              LDR      r2,[r1,#0x3c]
000004  f4027280          AND      r2,r2,#0x100
000008  b922              CBNZ     r2,|L35.20|
;;;1521     {
;;;1522       /* Clear EXTI pending Bit */
;;;1523       __HAL_USB_OTG_FS_WAKEUP_EXTI_CLEAR_FLAG();
00000a  f44f2280          MOV      r2,#0x40000
00000e  4b04              LDR      r3,|L35.32|
000010  601a              STR      r2,[r3,#0]
000012  e003              B        |L35.28|
                  |L35.20|
;;;1524     }
;;;1525     else
;;;1526     {
;;;1527       /* Clear EXTI pending Bit */
;;;1528       __HAL_USB_OTG_HS_WAKEUP_EXTI_CLEAR_FLAG();
000014  f44f1280          MOV      r2,#0x100000
000018  4b01              LDR      r3,|L35.32|
00001a  601a              STR      r2,[r3,#0]
                  |L35.28|
;;;1529     }
;;;1530   }
00001c  4770              BX       lr
;;;1531   #endif /* defined (USB_OTG_FS) || defined (USB_OTG_HS) */
                          ENDP

00001e  0000              DCW      0x0000
                  |L35.32|
                          DCD      0x40013c14

                          AREA ||i.PCD_EP_OutSetupPacket_int||, CODE, READONLY, ALIGN=2

                  PCD_EP_OutSetupPacket_int PROC
;;;2344     */
;;;2345   static HAL_StatusTypeDef PCD_EP_OutSetupPacket_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;2346   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;2347     USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
000008  6826              LDR      r6,[r4,#0]
;;;2348     uint32_t USBx_BASE = (uint32_t)USBx;
00000a  4637              MOV      r7,r6
;;;2349     uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
00000c  f8d68040          LDR      r8,[r6,#0x40]
;;;2350     uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
000010  f5076030          ADD      r0,r7,#0xb00
000014  eb001045          ADD      r0,r0,r5,LSL #5
000018  f8d09008          LDR      r9,[r0,#8]
;;;2351   
;;;2352     if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
00001c  4810              LDR      r0,|L36.96|
00001e  4580              CMP      r8,r0
000020  d90b              BLS      |L36.58|
;;;2353         ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
000022  f4094000          AND      r0,r9,#0x8000
000026  f5b04f00          CMP      r0,#0x8000
00002a  d106              BNE      |L36.58|
;;;2354     {
;;;2355       CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
00002c  f44f4100          MOV      r1,#0x8000
000030  f5076030          ADD      r0,r7,#0xb00
000034  eb001045          ADD      r0,r0,r5,LSL #5
000038  6081              STR      r1,[r0,#8]
                  |L36.58|
;;;2356     }
;;;2357   
;;;2358     /* Inform the upper layer that a setup packet is available */
;;;2359   #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
;;;2360     hpcd->SetupStageCallback(hpcd);
;;;2361   #else
;;;2362     HAL_PCD_SetupStageCallback(hpcd);
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       HAL_PCD_SetupStageCallback
;;;2363   #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
;;;2364   
;;;2365     if ((gSNPSiD > USB_OTG_CORE_ID_300A) && (hpcd->Init.dma_enable == 1U))
000040  4807              LDR      r0,|L36.96|
000042  4580              CMP      r8,r0
000044  d908              BLS      |L36.88|
000046  6920              LDR      r0,[r4,#0x10]
000048  2801              CMP      r0,#1
00004a  d105              BNE      |L36.88|
;;;2366     {
;;;2367       (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
00004c  f20442c4          ADD      r2,r4,#0x4c4
000050  2101              MOVS     r1,#1
000052  6820              LDR      r0,[r4,#0]
000054  f7fffffe          BL       USB_EP0_OutStart
                  |L36.88|
;;;2368     }
;;;2369   
;;;2370     return HAL_OK;
000058  2000              MOVS     r0,#0
;;;2371   }
00005a  e8bd87f0          POP      {r4-r10,pc}
;;;2372   #endif /* defined (USB_OTG_FS) || defined (USB_OTG_HS) */
                          ENDP

00005e  0000              DCW      0x0000
                  |L36.96|
                          DCD      0x4f54300a

                          AREA ||i.PCD_EP_OutXfrComplete_int||, CODE, READONLY, ALIGN=2

                  PCD_EP_OutXfrComplete_int PROC
;;;2232     */
;;;2233   static HAL_StatusTypeDef PCD_EP_OutXfrComplete_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;2234   {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;2235     USB_OTG_EPTypeDef *ep;
;;;2236     USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
000008  f8d59000          LDR      r9,[r5,#0]
;;;2237     uint32_t USBx_BASE = (uint32_t)USBx;
00000c  464e              MOV      r6,r9
;;;2238     uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
00000e  f8d9a040          LDR      r10,[r9,#0x40]
;;;2239     uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
000012  f5066030          ADD      r0,r6,#0xb00
000016  eb001044          ADD      r0,r0,r4,LSL #5
00001a  f8d08008          LDR      r8,[r0,#8]
;;;2240   
;;;2241     if (hpcd->Init.dma_enable == 1U)
00001e  6928              LDR      r0,[r5,#0x10]
000020  2801              CMP      r0,#1
000022  d155              BNE      |L37.208|
;;;2242     {
;;;2243       if ((DoepintReg & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP) /* Class C */
000024  f0080008          AND      r0,r8,#8
000028  2808              CMP      r0,#8
00002a  d10f              BNE      |L37.76|
;;;2244       {
;;;2245         /* StupPktRcvd = 1 this is a setup packet */
;;;2246         if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
00002c  4843              LDR      r0,|L37.316|
00002e  4582              CMP      r10,r0
000030  d90b              BLS      |L37.74|
;;;2247             ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
000032  f4084000          AND      r0,r8,#0x8000
000036  f5b04f00          CMP      r0,#0x8000
00003a  d17b              BNE      |L37.308|
;;;2248         {
;;;2249           CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
00003c  f44f4100          MOV      r1,#0x8000
000040  f5066030          ADD      r0,r6,#0xb00
000044  eb001044          ADD      r0,r0,r4,LSL #5
000048  6081              STR      r1,[r0,#8]
                  |L37.74|
00004a  e073              B        |L37.308|
                  |L37.76|
;;;2250         }
;;;2251       }
;;;2252       else if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR) /* Class E */
00004c  f0080020          AND      r0,r8,#0x20
000050  2820              CMP      r0,#0x20
000052  d106              BNE      |L37.98|
;;;2253       {
;;;2254         CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
000054  2120              MOVS     r1,#0x20
000056  f5066030          ADD      r0,r6,#0xb00
00005a  eb001044          ADD      r0,r0,r4,LSL #5
00005e  6081              STR      r1,[r0,#8]
000060  e068              B        |L37.308|
                  |L37.98|
;;;2255       }
;;;2256       else if ((DoepintReg & (USB_OTG_DOEPINT_STUP | USB_OTG_DOEPINT_OTEPSPR)) == 0U)
000062  f0080028          AND      r0,r8,#0x28
000066  2800              CMP      r0,#0
000068  d164              BNE      |L37.308|
;;;2257       {
;;;2258         /* StupPktRcvd = 1 this is a setup packet */
;;;2259         if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
00006a  4834              LDR      r0,|L37.316|
00006c  4582              CMP      r10,r0
00006e  d90c              BLS      |L37.138|
;;;2260             ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
000070  f4084000          AND      r0,r8,#0x8000
000074  f5b04f00          CMP      r0,#0x8000
000078  d107              BNE      |L37.138|
;;;2261         {
;;;2262           CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
00007a  f44f4100          MOV      r1,#0x8000
00007e  f5066030          ADD      r0,r6,#0xb00
000082  eb001044          ADD      r0,r0,r4,LSL #5
000086  6081              STR      r1,[r0,#8]
000088  e054              B        |L37.308|
                  |L37.138|
;;;2263         }
;;;2264         else
;;;2265         {
;;;2266           ep = &hpcd->OUT_ep[epnum];
00008a  eb0401c4          ADD      r1,r4,r4,LSL #3
00008e  f505701f          ADD      r0,r5,#0x27c
000092  eb000781          ADD      r7,r0,r1,LSL #2
;;;2267   
;;;2268           /* out data packet received over EP */
;;;2269           ep->xfer_count = ep->xfer_size - (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ);
000096  f5066030          ADD      r0,r6,#0xb00
00009a  eb001044          ADD      r0,r0,r4,LSL #5
00009e  69f9              LDR      r1,[r7,#0x1c]
0000a0  6900              LDR      r0,[r0,#0x10]
0000a2  f3c00012          UBFX     r0,r0,#0,#19
0000a6  1a08              SUBS     r0,r1,r0
0000a8  6238              STR      r0,[r7,#0x20]
;;;2270   
;;;2271           if (epnum == 0U)
0000aa  b964              CBNZ     r4,|L37.198|
;;;2272           {
;;;2273             if (ep->xfer_len == 0U)
0000ac  69b8              LDR      r0,[r7,#0x18]
0000ae  b930              CBNZ     r0,|L37.190|
;;;2274             {
;;;2275               /* this is ZLP, so prepare EP0 for next setup */
;;;2276               (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
0000b0  f20542c4          ADD      r2,r5,#0x4c4
0000b4  2101              MOVS     r1,#1
0000b6  6828              LDR      r0,[r5,#0]
0000b8  f7fffffe          BL       USB_EP0_OutStart
0000bc  e003              B        |L37.198|
                  |L37.190|
;;;2277             }
;;;2278             else
;;;2279             {
;;;2280               ep->xfer_buff += ep->xfer_count;
0000be  6a39              LDR      r1,[r7,#0x20]
0000c0  6938              LDR      r0,[r7,#0x10]
0000c2  4408              ADD      r0,r0,r1
0000c4  6138              STR      r0,[r7,#0x10]
                  |L37.198|
;;;2281             }
;;;2282           }
;;;2283   
;;;2284   #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
;;;2285           hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
;;;2286   #else
;;;2287           HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
0000c6  b2e1              UXTB     r1,r4
0000c8  4628              MOV      r0,r5
0000ca  f7fffffe          BL       HAL_PCD_DataOutStageCallback
0000ce  e031              B        |L37.308|
                  |L37.208|
;;;2288   #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
;;;2289         }
;;;2290       }
;;;2291       else
;;;2292       {
;;;2293         /* ... */
;;;2294       }
;;;2295     }
;;;2296     else
;;;2297     {
;;;2298       if (gSNPSiD == USB_OTG_CORE_ID_310A)
0000d0  481b              LDR      r0,|L37.320|
0000d2  4582              CMP      r10,r0
0000d4  d11b              BNE      |L37.270|
;;;2299       {
;;;2300         /* StupPktRcvd = 1 this is a setup packet */
;;;2301         if ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX)
0000d6  f4084000          AND      r0,r8,#0x8000
0000da  f5b04f00          CMP      r0,#0x8000
0000de  d107              BNE      |L37.240|
;;;2302         {
;;;2303           CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
0000e0  f44f4100          MOV      r1,#0x8000
0000e4  f5066030          ADD      r0,r6,#0xb00
0000e8  eb001044          ADD      r0,r0,r4,LSL #5
0000ec  6081              STR      r1,[r0,#8]
0000ee  e021              B        |L37.308|
                  |L37.240|
;;;2304         }
;;;2305         else
;;;2306         {
;;;2307           if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
0000f0  f0080020          AND      r0,r8,#0x20
0000f4  2820              CMP      r0,#0x20
0000f6  d105              BNE      |L37.260|
;;;2308           {
;;;2309             CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
0000f8  2120              MOVS     r1,#0x20
0000fa  f5066030          ADD      r0,r6,#0xb00
0000fe  eb001044          ADD      r0,r0,r4,LSL #5
000102  6081              STR      r1,[r0,#8]
                  |L37.260|
;;;2310           }
;;;2311   
;;;2312   #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
;;;2313           hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
;;;2314   #else
;;;2315           HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
000104  b2e1              UXTB     r1,r4
000106  4628              MOV      r0,r5
000108  f7fffffe          BL       HAL_PCD_DataOutStageCallback
00010c  e012              B        |L37.308|
                  |L37.270|
;;;2316   #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
;;;2317         }
;;;2318       }
;;;2319       else
;;;2320       {
;;;2321         if ((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))
00010e  b96c              CBNZ     r4,|L37.300|
000110  eb0401c4          ADD      r1,r4,r4,LSL #3
000114  f505701f          ADD      r0,r5,#0x27c
000118  eb000081          ADD      r0,r0,r1,LSL #2
00011c  6980              LDR      r0,[r0,#0x18]
00011e  b928              CBNZ     r0,|L37.300|
;;;2322         {
;;;2323           /* this is ZLP, so prepare EP0 for next setup */
;;;2324           (void)USB_EP0_OutStart(hpcd->Instance, 0U, (uint8_t *)hpcd->Setup);
000120  f20542c4          ADD      r2,r5,#0x4c4
000124  2100              MOVS     r1,#0
000126  6828              LDR      r0,[r5,#0]
000128  f7fffffe          BL       USB_EP0_OutStart
                  |L37.300|
;;;2325         }
;;;2326   
;;;2327   #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
;;;2328         hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
;;;2329   #else
;;;2330         HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
00012c  b2e1              UXTB     r1,r4
00012e  4628              MOV      r0,r5
000130  f7fffffe          BL       HAL_PCD_DataOutStageCallback
                  |L37.308|
;;;2331   #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
;;;2332       }
;;;2333     }
;;;2334   
;;;2335     return HAL_OK;
000134  2000              MOVS     r0,#0
;;;2336   }
000136  e8bd87f0          POP      {r4-r10,pc}
;;;2337   
                          ENDP

00013a  0000              DCW      0x0000
                  |L37.316|
                          DCD      0x4f54300a
                  |L37.320|
                          DCD      0x4f54310a

                          AREA ||i.PCD_WriteEmptyTxFifo||, CODE, READONLY, ALIGN=1

                  PCD_WriteEmptyTxFifo PROC
;;;2172     */
;;;2173   static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;2174   {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
;;;2175     USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
000008  f8d79000          LDR      r9,[r7,#0]
;;;2176     uint32_t USBx_BASE = (uint32_t)USBx;
00000c  46c8              MOV      r8,r9
;;;2177     USB_OTG_EPTypeDef *ep;
;;;2178     uint32_t len;
;;;2179     uint32_t len32b;
;;;2180     uint32_t fifoemptymsk;
;;;2181   
;;;2182     ep = &hpcd->IN_ep[epnum];
00000e  eb0601c6          ADD      r1,r6,r6,LSL #3
000012  f107003c          ADD      r0,r7,#0x3c
000016  eb000481          ADD      r4,r0,r1,LSL #2
;;;2183   
;;;2184     if (ep->xfer_count > ep->xfer_len)
00001a  69a1              LDR      r1,[r4,#0x18]
00001c  6a20              LDR      r0,[r4,#0x20]
00001e  4288              CMP      r0,r1
000020  d902              BLS      |L38.40|
;;;2185     {
;;;2186       return HAL_ERROR;
000022  2001              MOVS     r0,#1
                  |L38.36|
;;;2187     }
;;;2188   
;;;2189     len = ep->xfer_len - ep->xfer_count;
;;;2190   
;;;2191     if (len > ep->maxpacket)
;;;2192     {
;;;2193       len = ep->maxpacket;
;;;2194     }
;;;2195   
;;;2196     len32b = (len + 3U) / 4U;
;;;2197   
;;;2198     while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
;;;2199            (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
;;;2200     {
;;;2201       /* Write the FIFO */
;;;2202       len = ep->xfer_len - ep->xfer_count;
;;;2203   
;;;2204       if (len > ep->maxpacket)
;;;2205       {
;;;2206         len = ep->maxpacket;
;;;2207       }
;;;2208       len32b = (len + 3U) / 4U;
;;;2209   
;;;2210       (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len,
;;;2211                             (uint8_t)hpcd->Init.dma_enable);
;;;2212   
;;;2213       ep->xfer_buff  += len;
;;;2214       ep->xfer_count += len;
;;;2215     }
;;;2216   
;;;2217     if (ep->xfer_len <= ep->xfer_count)
;;;2218     {
;;;2219       fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
;;;2220       USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
;;;2221     }
;;;2222   
;;;2223     return HAL_OK;
;;;2224   }
000024  e8bd8ff8          POP      {r3-r11,pc}
                  |L38.40|
000028  6a21              LDR      r1,[r4,#0x20]         ;2189
00002a  69a0              LDR      r0,[r4,#0x18]         ;2189
00002c  1a45              SUBS     r5,r0,r1              ;2189
00002e  68e0              LDR      r0,[r4,#0xc]          ;2191
000030  42a8              CMP      r0,r5                 ;2191
000032  d200              BCS      |L38.54|
000034  68e5              LDR      r5,[r4,#0xc]          ;2193
                  |L38.54|
000036  1ce8              ADDS     r0,r5,#3              ;2196
000038  ea4f0a90          LSR      r10,r0,#2             ;2196
00003c  e017              B        |L38.110|
                  |L38.62|
00003e  6a21              LDR      r1,[r4,#0x20]         ;2202
000040  69a0              LDR      r0,[r4,#0x18]         ;2202
000042  1a45              SUBS     r5,r0,r1              ;2202
000044  68e0              LDR      r0,[r4,#0xc]          ;2204
000046  42a8              CMP      r0,r5                 ;2204
000048  d200              BCS      |L38.76|
00004a  68e5              LDR      r5,[r4,#0xc]          ;2206
                  |L38.76|
00004c  1ce8              ADDS     r0,r5,#3              ;2208
00004e  ea4f0a90          LSR      r10,r0,#2             ;2208
000052  7c38              LDRB     r0,[r7,#0x10]         ;2210
000054  b2ab              UXTH     r3,r5                 ;2210
000056  b2f2              UXTB     r2,r6                 ;2210
000058  9000              STR      r0,[sp,#0]            ;2210
00005a  4648              MOV      r0,r9                 ;2210
00005c  6921              LDR      r1,[r4,#0x10]         ;2210
00005e  f7fffffe          BL       USB_WritePacket
000062  6920              LDR      r0,[r4,#0x10]         ;2213
000064  4428              ADD      r0,r0,r5              ;2213
000066  6120              STR      r0,[r4,#0x10]         ;2213
000068  6a20              LDR      r0,[r4,#0x20]         ;2214
00006a  4428              ADD      r0,r0,r5              ;2214
00006c  6220              STR      r0,[r4,#0x20]         ;2214
                  |L38.110|
00006e  f5086010          ADD      r0,r8,#0x900          ;2198
000072  eb001046          ADD      r0,r0,r6,LSL #5       ;2198
000076  6980              LDR      r0,[r0,#0x18]         ;2198
000078  b280              UXTH     r0,r0                 ;2198
00007a  4550              CMP      r0,r10                ;2198
00007c  d306              BCC      |L38.140|
00007e  69a1              LDR      r1,[r4,#0x18]         ;2199
000080  6a20              LDR      r0,[r4,#0x20]         ;2199
000082  4288              CMP      r0,r1                 ;2199
000084  d202              BCS      |L38.140|
000086  69a0              LDR      r0,[r4,#0x18]         ;2199
000088  2800              CMP      r0,#0                 ;2199
00008a  d1d8              BNE      |L38.62|
                  |L38.140|
00008c  6a21              LDR      r1,[r4,#0x20]         ;2217
00008e  69a0              LDR      r0,[r4,#0x18]         ;2217
000090  4288              CMP      r0,r1                 ;2217
000092  d80e              BHI      |L38.178|
000094  f006010f          AND      r1,r6,#0xf            ;2219
000098  2001              MOVS     r0,#1                 ;2219
00009a  fa00fb01          LSL      r11,r0,r1             ;2219
00009e  f6400034          MOV      r0,#0x834             ;2220
0000a2  f8500008          LDR      r0,[r0,r8]            ;2220
0000a6  ea20000b          BIC      r0,r0,r11             ;2220
0000aa  f6400134          MOV      r1,#0x834             ;2220
0000ae  f8410008          STR      r0,[r1,r8]            ;2220
                  |L38.178|
0000b2  2000              MOVS     r0,#0                 ;2223
0000b4  e7b6              B        |L38.36|
;;;2225   
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_pcd.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_pcd_c_3a5cb0d3____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___19_stm32f4xx_hal_pcd_c_3a5cb0d3____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_pcd_c_3a5cb0d3____REVSH|
#line 478
|__asm___19_stm32f4xx_hal_pcd_c_3a5cb0d3____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_pcd_c_3a5cb0d3____RRX|
#line 665
|__asm___19_stm32f4xx_hal_pcd_c_3a5cb0d3____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
