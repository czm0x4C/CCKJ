; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o4gcamera\stm32f4xx_hal_gpio.o --asm_dir=.\ --list_dir=.\ --depend=4gcamera\stm32f4xx_hal_gpio.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../USB_DEVICE/App -I../USB_DEVICE/Target -I../Core/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Middlewares/ST/STM32_USB_Device_Library/Core/Inc -I../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 -I../Middlewares/Third_Party/FreeRTOS/Source/portable/RVDS/ARM_CM4F -I../HARDWARE/OV2640 -I../HARDWARE/WS2812B -I../HARDWARE/RING_BUFFER -I../HARDWARE/FLASH -I.\RTE\_4GCAMERA -IC:\Users\czm\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\czm\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=536 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F407xx --omf_browse=4gcamera\stm32f4xx_hal_gpio.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_gpio.c]
                          THUMB

                          AREA ||i.HAL_GPIO_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_DeInit PROC
;;;293      */
;;;294    void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
000000  b5f0              PUSH     {r4-r7,lr}
;;;295    {
000002  460c              MOV      r4,r1
;;;296      uint32_t position;
;;;297      uint32_t ioposition = 0x00U;
000004  2500              MOVS     r5,#0
;;;298      uint32_t iocurrent = 0x00U;
000006  2200              MOVS     r2,#0
;;;299      uint32_t tmp = 0x00U;
000008  2300              MOVS     r3,#0
;;;300    
;;;301      /* Check the parameters */
;;;302      assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
;;;303      
;;;304      /* Configure the port pins */
;;;305      for(position = 0U; position < GPIO_NUMBER; position++)
00000a  2100              MOVS     r1,#0
00000c  e094              B        |L1.312|
                  |L1.14|
;;;306      {
;;;307        /* Get the IO position */
;;;308        ioposition = 0x01U << position;
00000e  2601              MOVS     r6,#1
000010  fa06f501          LSL      r5,r6,r1
;;;309        /* Get the current IO position */
;;;310        iocurrent = (GPIO_Pin) & ioposition;
000014  ea040205          AND      r2,r4,r5
;;;311    
;;;312        if(iocurrent == ioposition)
000018  42aa              CMP      r2,r5
00001a  d17d              BNE      |L1.280|
;;;313        {
;;;314          /*------------------------- EXTI Mode Configuration --------------------*/
;;;315          tmp = SYSCFG->EXTICR[position >> 2U];
00001c  4e48              LDR      r6,|L1.320|
00001e  088f              LSRS     r7,r1,#2
000020  f8563027          LDR      r3,[r6,r7,LSL #2]
;;;316          tmp &= (0x0FU << (4U * (position & 0x03U)));
000024  078e              LSLS     r6,r1,#30
000026  0f37              LSRS     r7,r6,#28
000028  260f              MOVS     r6,#0xf
00002a  40be              LSLS     r6,r6,r7
00002c  4033              ANDS     r3,r3,r6
;;;317          if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U))))
00002e  4e45              LDR      r6,|L1.324|
000030  42b0              CMP      r0,r6
000032  d101              BNE      |L1.56|
000034  2600              MOVS     r6,#0
000036  e023              B        |L1.128|
                  |L1.56|
000038  4e43              LDR      r6,|L1.328|
00003a  42b0              CMP      r0,r6
00003c  d101              BNE      |L1.66|
00003e  2601              MOVS     r6,#1
000040  e01e              B        |L1.128|
                  |L1.66|
000042  4e42              LDR      r6,|L1.332|
000044  42b0              CMP      r0,r6
000046  d101              BNE      |L1.76|
000048  2602              MOVS     r6,#2
00004a  e019              B        |L1.128|
                  |L1.76|
00004c  4e40              LDR      r6,|L1.336|
00004e  42b0              CMP      r0,r6
000050  d101              BNE      |L1.86|
000052  2603              MOVS     r6,#3
000054  e014              B        |L1.128|
                  |L1.86|
000056  4e3f              LDR      r6,|L1.340|
000058  42b0              CMP      r0,r6
00005a  d101              BNE      |L1.96|
00005c  2604              MOVS     r6,#4
00005e  e00f              B        |L1.128|
                  |L1.96|
000060  4e3d              LDR      r6,|L1.344|
000062  42b0              CMP      r0,r6
000064  d101              BNE      |L1.106|
000066  2605              MOVS     r6,#5
000068  e00a              B        |L1.128|
                  |L1.106|
00006a  4e3c              LDR      r6,|L1.348|
00006c  42b0              CMP      r0,r6
00006e  d101              BNE      |L1.116|
000070  2606              MOVS     r6,#6
000072  e005              B        |L1.128|
                  |L1.116|
000074  4e3a              LDR      r6,|L1.352|
000076  42b0              CMP      r0,r6
000078  d101              BNE      |L1.126|
00007a  2607              MOVS     r6,#7
00007c  e000              B        |L1.128|
                  |L1.126|
00007e  2608              MOVS     r6,#8
                  |L1.128|
000080  078f              LSLS     r7,r1,#30
000082  0f3f              LSRS     r7,r7,#28
000084  40be              LSLS     r6,r6,r7
000086  429e              CMP      r6,r3
000088  d124              BNE      |L1.212|
;;;318          {
;;;319            /* Clear EXTI line configuration */
;;;320            EXTI->IMR &= ~((uint32_t)iocurrent);
00008a  4e36              LDR      r6,|L1.356|
00008c  6836              LDR      r6,[r6,#0]
00008e  4396              BICS     r6,r6,r2
000090  4f34              LDR      r7,|L1.356|
000092  603e              STR      r6,[r7,#0]
;;;321            EXTI->EMR &= ~((uint32_t)iocurrent);
000094  1d3e              ADDS     r6,r7,#4
000096  6836              LDR      r6,[r6,#0]
000098  4396              BICS     r6,r6,r2
00009a  1d3f              ADDS     r7,r7,#4
00009c  603e              STR      r6,[r7,#0]
;;;322            
;;;323            /* Clear Rising Falling edge configuration */
;;;324            EXTI->FTSR &= ~((uint32_t)iocurrent);
00009e  4e31              LDR      r6,|L1.356|
0000a0  360c              ADDS     r6,r6,#0xc
0000a2  6836              LDR      r6,[r6,#0]
0000a4  4396              BICS     r6,r6,r2
0000a6  4f2f              LDR      r7,|L1.356|
0000a8  370c              ADDS     r7,r7,#0xc
0000aa  603e              STR      r6,[r7,#0]
;;;325            EXTI->RTSR &= ~((uint32_t)iocurrent);
0000ac  1f3e              SUBS     r6,r7,#4
0000ae  6836              LDR      r6,[r6,#0]
0000b0  4396              BICS     r6,r6,r2
0000b2  1f3f              SUBS     r7,r7,#4
0000b4  603e              STR      r6,[r7,#0]
;;;326    
;;;327            /* Configure the External Interrupt or event for the current IO */
;;;328            tmp = 0x0FU << (4U * (position & 0x03U));
0000b6  078e              LSLS     r6,r1,#30
0000b8  0f37              LSRS     r7,r6,#28
0000ba  260f              MOVS     r6,#0xf
0000bc  fa06f307          LSL      r3,r6,r7
;;;329            SYSCFG->EXTICR[position >> 2U] &= ~tmp;
0000c0  4e1f              LDR      r6,|L1.320|
0000c2  088f              LSRS     r7,r1,#2
0000c4  f8566027          LDR      r6,[r6,r7,LSL #2]
0000c8  439e              BICS     r6,r6,r3
0000ca  4f1d              LDR      r7,|L1.320|
0000cc  ea4f0c91          LSR      r12,r1,#2
0000d0  f847602c          STR      r6,[r7,r12,LSL #2]
                  |L1.212|
;;;330          }
;;;331    
;;;332          /*------------------------- GPIO Mode Configuration --------------------*/
;;;333          /* Configure IO Direction in Input Floating Mode */
;;;334          GPIOx->MODER &= ~(GPIO_MODER_MODER0 << (position * 2U));
0000d4  6806              LDR      r6,[r0,#0]
0000d6  ea4f0c41          LSL      r12,r1,#1
0000da  2703              MOVS     r7,#3
0000dc  fa07f70c          LSL      r7,r7,r12
0000e0  43be              BICS     r6,r6,r7
0000e2  6006              STR      r6,[r0,#0]
;;;335    
;;;336          /* Configure the default Alternate Function in current IO */
;;;337          GPIOx->AFR[position >> 3U] &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
0000e4  08cf              LSRS     r7,r1,#3
0000e6  f1000620          ADD      r6,r0,#0x20
0000ea  f8566027          LDR      r6,[r6,r7,LSL #2]
0000ee  074f              LSLS     r7,r1,#29
0000f0  ea4f6cd7          LSR      r12,r7,#27
0000f4  270f              MOVS     r7,#0xf
0000f6  fa07f70c          LSL      r7,r7,r12
0000fa  43be              BICS     r6,r6,r7
0000fc  ea4f0cd1          LSR      r12,r1,#3
000100  f1000720          ADD      r7,r0,#0x20
000104  f847602c          STR      r6,[r7,r12,LSL #2]
;;;338    
;;;339          /* Deactivate the Pull-up and Pull-down resistor for the current IO */
;;;340          GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
000108  68c6              LDR      r6,[r0,#0xc]
00010a  ea4f0c41          LSL      r12,r1,#1
00010e  2703              MOVS     r7,#3
000110  fa07f70c          LSL      r7,r7,r12
000114  43be              BICS     r6,r6,r7
000116  e000              B        |L1.282|
                  |L1.280|
000118  e00d              B        |L1.310|
                  |L1.282|
00011a  60c6              STR      r6,[r0,#0xc]
;;;341    
;;;342          /* Configure the default value IO Output Type */
;;;343          GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;
00011c  6846              LDR      r6,[r0,#4]
00011e  2701              MOVS     r7,#1
000120  408f              LSLS     r7,r7,r1
000122  43be              BICS     r6,r6,r7
000124  6046              STR      r6,[r0,#4]
;;;344    
;;;345          /* Configure the default value for IO Speed */
;;;346          GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
000126  6886              LDR      r6,[r0,#8]
000128  ea4f0c41          LSL      r12,r1,#1
00012c  2703              MOVS     r7,#3
00012e  fa07f70c          LSL      r7,r7,r12
000132  43be              BICS     r6,r6,r7
000134  6086              STR      r6,[r0,#8]
                  |L1.310|
000136  1c49              ADDS     r1,r1,#1              ;305
                  |L1.312|
000138  2910              CMP      r1,#0x10              ;305
00013a  f4ffaf68          BCC      |L1.14|
;;;347        }
;;;348      }
;;;349    }
00013e  bdf0              POP      {r4-r7,pc}
;;;350    
                          ENDP

                  |L1.320|
                          DCD      0x40013808
                  |L1.324|
                          DCD      0x40020000
                  |L1.328|
                          DCD      0x40020400
                  |L1.332|
                          DCD      0x40020800
                  |L1.336|
                          DCD      0x40020c00
                  |L1.340|
                          DCD      0x40021000
                  |L1.344|
                          DCD      0x40021400
                  |L1.348|
                          DCD      0x40021800
                  |L1.352|
                          DCD      0x40021c00
                  |L1.356|
                          DCD      0x40013c00

                          AREA ||i.HAL_GPIO_EXTI_Callback||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_EXTI_Callback PROC
;;;506      */
;;;507    __weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
000000  4770              BX       lr
;;;508    {
;;;509      /* Prevent unused argument(s) compilation warning */
;;;510      UNUSED(GPIO_Pin);
;;;511      /* NOTE: This function Should not be modified, when the callback is needed,
;;;512               the HAL_GPIO_EXTI_Callback could be implemented in the user file
;;;513       */
;;;514    }
;;;515    
                          ENDP


                          AREA ||i.HAL_GPIO_EXTI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_EXTI_IRQHandler PROC
;;;491      */
;;;492    void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
000000  b510              PUSH     {r4,lr}
;;;493    {
000002  4604              MOV      r4,r0
;;;494      /* EXTI line interrupt detected */
;;;495      if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
000004  4804              LDR      r0,|L3.24|
000006  6800              LDR      r0,[r0,#0]
000008  4020              ANDS     r0,r0,r4
00000a  b120              CBZ      r0,|L3.22|
;;;496      {
;;;497        __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
00000c  4802              LDR      r0,|L3.24|
00000e  6004              STR      r4,[r0,#0]
;;;498        HAL_GPIO_EXTI_Callback(GPIO_Pin);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       HAL_GPIO_EXTI_Callback
                  |L3.22|
;;;499      }
;;;500    }
000016  bd10              POP      {r4,pc}
;;;501    
                          ENDP

                  |L3.24|
                          DCD      0x40013c14

                          AREA ||i.HAL_GPIO_Init||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_Init PROC
;;;163      */
;;;164    void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
000000  b5f8              PUSH     {r3-r7,lr}
;;;165    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;166      uint32_t position;
;;;167      uint32_t ioposition = 0x00U;
000006  2500              MOVS     r5,#0
;;;168      uint32_t iocurrent = 0x00U;
000008  2400              MOVS     r4,#0
;;;169      uint32_t temp = 0x00U;
00000a  2000              MOVS     r0,#0
;;;170    
;;;171      /* Check the parameters */
;;;172      assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
;;;173      assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
;;;174      assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
;;;175    
;;;176      /* Configure the port pins */
;;;177      for(position = 0U; position < GPIO_NUMBER; position++)
00000c  2100              MOVS     r1,#0
00000e  e0d6              B        |L4.446|
                  |L4.16|
;;;178      {
;;;179        /* Get the IO position */
;;;180        ioposition = 0x01U << position;
000010  2601              MOVS     r6,#1
000012  fa06f501          LSL      r5,r6,r1
;;;181        /* Get the current IO position */
;;;182        iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
000016  681e              LDR      r6,[r3,#0]
000018  ea060405          AND      r4,r6,r5
;;;183    
;;;184        if(iocurrent == ioposition)
00001c  42ac              CMP      r4,r5
00001e  d174              BNE      |L4.266|
;;;185        {
;;;186          /*--------------------- GPIO Mode Configuration ------------------------*/
;;;187          /* In case of Output or Alternate function mode selection */
;;;188          if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \
000020  791e              LDRB     r6,[r3,#4]
000022  f0060603          AND      r6,r6,#3
000026  2e01              CMP      r6,#1
000028  d004              BEQ      |L4.52|
;;;189              (GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
00002a  791e              LDRB     r6,[r3,#4]
00002c  f0060603          AND      r6,r6,#3
000030  2e02              CMP      r6,#2
000032  d113              BNE      |L4.92|
                  |L4.52|
;;;190          {
;;;191            /* Check the Speed parameter */
;;;192            assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
;;;193            /* Configure the IO Speed */
;;;194            temp = GPIOx->OSPEEDR; 
000034  6890              LDR      r0,[r2,#8]
;;;195            temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
000036  004f              LSLS     r7,r1,#1
000038  2603              MOVS     r6,#3
00003a  40be              LSLS     r6,r6,r7
00003c  43b0              BICS     r0,r0,r6
;;;196            temp |= (GPIO_Init->Speed << (position * 2U));
00003e  004f              LSLS     r7,r1,#1
000040  68de              LDR      r6,[r3,#0xc]
000042  40be              LSLS     r6,r6,r7
000044  4330              ORRS     r0,r0,r6
;;;197            GPIOx->OSPEEDR = temp;
000046  6090              STR      r0,[r2,#8]
;;;198    
;;;199            /* Configure the IO Output Type */
;;;200            temp = GPIOx->OTYPER;
000048  6850              LDR      r0,[r2,#4]
;;;201            temp &= ~(GPIO_OTYPER_OT_0 << position) ;
00004a  2601              MOVS     r6,#1
00004c  408e              LSLS     r6,r6,r1
00004e  43b0              BICS     r0,r0,r6
;;;202            temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
000050  791e              LDRB     r6,[r3,#4]
000052  f3c61600          UBFX     r6,r6,#4,#1
000056  408e              LSLS     r6,r6,r1
000058  4330              ORRS     r0,r0,r6
;;;203            GPIOx->OTYPER = temp;
00005a  6050              STR      r0,[r2,#4]
                  |L4.92|
;;;204           }
;;;205    
;;;206          if((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
00005c  791e              LDRB     r6,[r3,#4]
00005e  f0060603          AND      r6,r6,#3
000062  2e03              CMP      r6,#3
000064  d009              BEQ      |L4.122|
;;;207          {
;;;208            /* Check the parameters */
;;;209            assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
;;;210            
;;;211            /* Activate the Pull-up or Pull down resistor for the current IO */
;;;212            temp = GPIOx->PUPDR;
000066  68d0              LDR      r0,[r2,#0xc]
;;;213            temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
000068  004f              LSLS     r7,r1,#1
00006a  2603              MOVS     r6,#3
00006c  40be              LSLS     r6,r6,r7
00006e  43b0              BICS     r0,r0,r6
;;;214            temp |= ((GPIO_Init->Pull) << (position * 2U));
000070  004f              LSLS     r7,r1,#1
000072  689e              LDR      r6,[r3,#8]
000074  40be              LSLS     r6,r6,r7
000076  4330              ORRS     r0,r0,r6
;;;215            GPIOx->PUPDR = temp;
000078  60d0              STR      r0,[r2,#0xc]
                  |L4.122|
;;;216          }
;;;217    
;;;218          /* In case of Alternate function mode selection */
;;;219          if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
00007a  791e              LDRB     r6,[r3,#4]
00007c  f0060603          AND      r6,r6,#3
000080  2e02              CMP      r6,#2
000082  d113              BNE      |L4.172|
;;;220          {
;;;221            /* Check the Alternate function parameter */
;;;222            assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
;;;223            /* Configure Alternate function mapped with the current IO */
;;;224            temp = GPIOx->AFR[position >> 3U];
000084  08cf              LSRS     r7,r1,#3
000086  f1020620          ADD      r6,r2,#0x20
00008a  f8560027          LDR      r0,[r6,r7,LSL #2]
;;;225            temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
00008e  074e              LSLS     r6,r1,#29
000090  0ef7              LSRS     r7,r6,#27
000092  260f              MOVS     r6,#0xf
000094  40be              LSLS     r6,r6,r7
000096  43b0              BICS     r0,r0,r6
;;;226            temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
000098  074f              LSLS     r7,r1,#29
00009a  0eff              LSRS     r7,r7,#27
00009c  691e              LDR      r6,[r3,#0x10]
00009e  40be              LSLS     r6,r6,r7
0000a0  4330              ORRS     r0,r0,r6
;;;227            GPIOx->AFR[position >> 3U] = temp;
0000a2  08cf              LSRS     r7,r1,#3
0000a4  f1020620          ADD      r6,r2,#0x20
0000a8  f8460027          STR      r0,[r6,r7,LSL #2]
                  |L4.172|
;;;228          }
;;;229    
;;;230          /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
;;;231          temp = GPIOx->MODER;
0000ac  6810              LDR      r0,[r2,#0]
;;;232          temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
0000ae  004f              LSLS     r7,r1,#1
0000b0  2603              MOVS     r6,#3
0000b2  40be              LSLS     r6,r6,r7
0000b4  43b0              BICS     r0,r0,r6
;;;233          temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
0000b6  791e              LDRB     r6,[r3,#4]
0000b8  f0060603          AND      r6,r6,#3
0000bc  004f              LSLS     r7,r1,#1
0000be  40be              LSLS     r6,r6,r7
0000c0  4330              ORRS     r0,r0,r6
;;;234          GPIOx->MODER = temp;
0000c2  6010              STR      r0,[r2,#0]
;;;235    
;;;236          /*--------------------- EXTI Mode Configuration ------------------------*/
;;;237          /* Configure the External Interrupt or event for the current IO */
;;;238          if((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
0000c4  685e              LDR      r6,[r3,#4]
0000c6  f4063640          AND      r6,r6,#0x30000
0000ca  2e00              CMP      r6,#0
0000cc  d076              BEQ      |L4.444|
;;;239          {
;;;240            /* Enable SYSCFG Clock */
;;;241            __HAL_RCC_SYSCFG_CLK_ENABLE();
0000ce  bf00              NOP      
0000d0  2600              MOVS     r6,#0
0000d2  9600              STR      r6,[sp,#0]
0000d4  4e3c              LDR      r6,|L4.456|
0000d6  6836              LDR      r6,[r6,#0]
0000d8  f4464680          ORR      r6,r6,#0x4000
0000dc  4f3a              LDR      r7,|L4.456|
0000de  603e              STR      r6,[r7,#0]
0000e0  463e              MOV      r6,r7
0000e2  6836              LDR      r6,[r6,#0]
0000e4  f4064680          AND      r6,r6,#0x4000
0000e8  9600              STR      r6,[sp,#0]
0000ea  bf00              NOP      
0000ec  bf00              NOP      
;;;242    
;;;243            temp = SYSCFG->EXTICR[position >> 2U];
0000ee  4e37              LDR      r6,|L4.460|
0000f0  088f              LSRS     r7,r1,#2
0000f2  f8560027          LDR      r0,[r6,r7,LSL #2]
;;;244            temp &= ~(0x0FU << (4U * (position & 0x03U)));
0000f6  078e              LSLS     r6,r1,#30
0000f8  0f37              LSRS     r7,r6,#28
0000fa  260f              MOVS     r6,#0xf
0000fc  40be              LSLS     r6,r6,r7
0000fe  43b0              BICS     r0,r0,r6
;;;245            temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
000100  4e33              LDR      r6,|L4.464|
000102  42b2              CMP      r2,r6
000104  d102              BNE      |L4.268|
000106  2600              MOVS     r6,#0
000108  e024              B        |L4.340|
                  |L4.266|
00010a  e057              B        |L4.444|
                  |L4.268|
00010c  4e31              LDR      r6,|L4.468|
00010e  42b2              CMP      r2,r6
000110  d101              BNE      |L4.278|
000112  2601              MOVS     r6,#1
000114  e01e              B        |L4.340|
                  |L4.278|
000116  4e30              LDR      r6,|L4.472|
000118  42b2              CMP      r2,r6
00011a  d101              BNE      |L4.288|
00011c  2602              MOVS     r6,#2
00011e  e019              B        |L4.340|
                  |L4.288|
000120  4e2e              LDR      r6,|L4.476|
000122  42b2              CMP      r2,r6
000124  d101              BNE      |L4.298|
000126  2603              MOVS     r6,#3
000128  e014              B        |L4.340|
                  |L4.298|
00012a  4e2d              LDR      r6,|L4.480|
00012c  42b2              CMP      r2,r6
00012e  d101              BNE      |L4.308|
000130  2604              MOVS     r6,#4
000132  e00f              B        |L4.340|
                  |L4.308|
000134  4e2b              LDR      r6,|L4.484|
000136  42b2              CMP      r2,r6
000138  d101              BNE      |L4.318|
00013a  2605              MOVS     r6,#5
00013c  e00a              B        |L4.340|
                  |L4.318|
00013e  4e2a              LDR      r6,|L4.488|
000140  42b2              CMP      r2,r6
000142  d101              BNE      |L4.328|
000144  2606              MOVS     r6,#6
000146  e005              B        |L4.340|
                  |L4.328|
000148  4e28              LDR      r6,|L4.492|
00014a  42b2              CMP      r2,r6
00014c  d101              BNE      |L4.338|
00014e  2607              MOVS     r6,#7
000150  e000              B        |L4.340|
                  |L4.338|
000152  2608              MOVS     r6,#8
                  |L4.340|
000154  078f              LSLS     r7,r1,#30
000156  0f3f              LSRS     r7,r7,#28
000158  40be              LSLS     r6,r6,r7
00015a  4330              ORRS     r0,r0,r6
;;;246            SYSCFG->EXTICR[position >> 2U] = temp;
00015c  4e1b              LDR      r6,|L4.460|
00015e  088f              LSRS     r7,r1,#2
000160  f8460027          STR      r0,[r6,r7,LSL #2]
;;;247    
;;;248            /* Clear Rising Falling edge configuration */
;;;249            temp = EXTI->RTSR;
000164  4e22              LDR      r6,|L4.496|
000166  6830              LDR      r0,[r6,#0]
;;;250            temp &= ~((uint32_t)iocurrent);
000168  43a0              BICS     r0,r0,r4
;;;251            if((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
00016a  685e              LDR      r6,[r3,#4]
00016c  f4061680          AND      r6,r6,#0x100000
000170  b106              CBZ      r6,|L4.372|
;;;252            {
;;;253              temp |= iocurrent;
000172  4320              ORRS     r0,r0,r4
                  |L4.372|
;;;254            }
;;;255            EXTI->RTSR = temp;
000174  4e1e              LDR      r6,|L4.496|
000176  6030              STR      r0,[r6,#0]
;;;256    
;;;257            temp = EXTI->FTSR;
000178  1d36              ADDS     r6,r6,#4
00017a  6830              LDR      r0,[r6,#0]
;;;258            temp &= ~((uint32_t)iocurrent);
00017c  43a0              BICS     r0,r0,r4
;;;259            if((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
00017e  685e              LDR      r6,[r3,#4]
000180  f4061600          AND      r6,r6,#0x200000
000184  b106              CBZ      r6,|L4.392|
;;;260            {
;;;261              temp |= iocurrent;
000186  4320              ORRS     r0,r0,r4
                  |L4.392|
;;;262            }
;;;263            EXTI->FTSR = temp;
000188  4e19              LDR      r6,|L4.496|
00018a  1d36              ADDS     r6,r6,#4
00018c  6030              STR      r0,[r6,#0]
;;;264    
;;;265            temp = EXTI->EMR;
00018e  4e18              LDR      r6,|L4.496|
000190  1f36              SUBS     r6,r6,#4
000192  6830              LDR      r0,[r6,#0]
;;;266            temp &= ~((uint32_t)iocurrent);
000194  43a0              BICS     r0,r0,r4
;;;267            if((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
000196  685e              LDR      r6,[r3,#4]
000198  f4063600          AND      r6,r6,#0x20000
00019c  b106              CBZ      r6,|L4.416|
;;;268            {
;;;269              temp |= iocurrent;
00019e  4320              ORRS     r0,r0,r4
                  |L4.416|
;;;270            }
;;;271            EXTI->EMR = temp;
0001a0  4e13              LDR      r6,|L4.496|
0001a2  1f36              SUBS     r6,r6,#4
0001a4  6030              STR      r0,[r6,#0]
;;;272    
;;;273            /* Clear EXTI line configuration */
;;;274            temp = EXTI->IMR;
0001a6  1f36              SUBS     r6,r6,#4
0001a8  6830              LDR      r0,[r6,#0]
;;;275            temp &= ~((uint32_t)iocurrent);
0001aa  43a0              BICS     r0,r0,r4
;;;276            if((GPIO_Init->Mode & EXTI_IT) != 0x00U)
0001ac  685e              LDR      r6,[r3,#4]
0001ae  f4063680          AND      r6,r6,#0x10000
0001b2  b106              CBZ      r6,|L4.438|
;;;277            {
;;;278              temp |= iocurrent;
0001b4  4320              ORRS     r0,r0,r4
                  |L4.438|
;;;279            }
;;;280            EXTI->IMR = temp;
0001b6  4e0e              LDR      r6,|L4.496|
0001b8  3e08              SUBS     r6,r6,#8
0001ba  6030              STR      r0,[r6,#0]
                  |L4.444|
0001bc  1c49              ADDS     r1,r1,#1              ;177
                  |L4.446|
0001be  2910              CMP      r1,#0x10              ;177
0001c0  f4ffaf26          BCC      |L4.16|
;;;281          }
;;;282        }
;;;283      }
;;;284    }
0001c4  bdf8              POP      {r3-r7,pc}
;;;285    
                          ENDP

0001c6  0000              DCW      0x0000
                  |L4.456|
                          DCD      0x40023844
                  |L4.460|
                          DCD      0x40013808
                  |L4.464|
                          DCD      0x40020000
                  |L4.468|
                          DCD      0x40020400
                  |L4.472|
                          DCD      0x40020800
                  |L4.476|
                          DCD      0x40020c00
                  |L4.480|
                          DCD      0x40021000
                  |L4.484|
                          DCD      0x40021400
                  |L4.488|
                          DCD      0x40021800
                  |L4.492|
                          DCD      0x40021c00
                  |L4.496|
                          DCD      0x40013c08

                          AREA ||i.HAL_GPIO_LockPin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_LockPin PROC
;;;457      */
;;;458    HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  b508              PUSH     {r3,lr}
;;;459    {
000002  4602              MOV      r2,r0
;;;460      __IO uint32_t tmp = GPIO_LCKR_LCKK;
000004  f44f3080          MOV      r0,#0x10000
000008  9000              STR      r0,[sp,#0]
;;;461    
;;;462      /* Check the parameters */
;;;463      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;464    
;;;465      /* Apply lock key write sequence */
;;;466      tmp |= GPIO_Pin;
00000a  9800              LDR      r0,[sp,#0]
00000c  4308              ORRS     r0,r0,r1
00000e  9000              STR      r0,[sp,#0]
;;;467      /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
;;;468      GPIOx->LCKR = tmp;
000010  9800              LDR      r0,[sp,#0]
000012  61d0              STR      r0,[r2,#0x1c]
;;;469      /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
;;;470      GPIOx->LCKR = GPIO_Pin;
000014  61d1              STR      r1,[r2,#0x1c]
;;;471      /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
;;;472      GPIOx->LCKR = tmp;
000016  9800              LDR      r0,[sp,#0]
000018  61d0              STR      r0,[r2,#0x1c]
;;;473      /* Read LCKR register. This read is mandatory to complete key lock sequence */
;;;474      tmp = GPIOx->LCKR;
00001a  69d0              LDR      r0,[r2,#0x1c]
00001c  9000              STR      r0,[sp,#0]
;;;475    
;;;476      /* Read again in order to confirm lock is active */
;;;477     if((GPIOx->LCKR & GPIO_LCKR_LCKK) != RESET)
00001e  69d0              LDR      r0,[r2,#0x1c]
000020  f4003080          AND      r0,r0,#0x10000
000024  b108              CBZ      r0,|L5.42|
;;;478      {
;;;479        return HAL_OK;
000026  2000              MOVS     r0,#0
                  |L5.40|
;;;480      }
;;;481      else
;;;482      {
;;;483        return HAL_ERROR;
;;;484      }
;;;485    }
000028  bd08              POP      {r3,pc}
                  |L5.42|
00002a  2001              MOVS     r0,#1                 ;483
00002c  e7fc              B        |L5.40|
;;;486    
                          ENDP


                          AREA ||i.HAL_GPIO_ReadPin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_ReadPin PROC
;;;374      */
;;;375    GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  4602              MOV      r2,r0
;;;376    {
;;;377      GPIO_PinState bitstatus;
;;;378    
;;;379      /* Check the parameters */
;;;380      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;381    
;;;382      if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
000002  6913              LDR      r3,[r2,#0x10]
000004  400b              ANDS     r3,r3,r1
000006  b10b              CBZ      r3,|L6.12|
;;;383      {
;;;384        bitstatus = GPIO_PIN_SET;
000008  2001              MOVS     r0,#1
00000a  e000              B        |L6.14|
                  |L6.12|
;;;385      }
;;;386      else
;;;387      {
;;;388        bitstatus = GPIO_PIN_RESET;
00000c  2000              MOVS     r0,#0
                  |L6.14|
;;;389      }
;;;390      return bitstatus;
;;;391    }
00000e  4770              BX       lr
;;;392    
                          ENDP


                          AREA ||i.HAL_GPIO_TogglePin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_TogglePin PROC
;;;432      */
;;;433    void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  b510              PUSH     {r4,lr}
;;;434    {
;;;435      uint32_t odr;
;;;436    
;;;437      /* Check the parameters */
;;;438      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;439    
;;;440      /* get current Output Data Register value */
;;;441      odr = GPIOx->ODR;
000002  6942              LDR      r2,[r0,#0x14]
;;;442    
;;;443      /* Set selected pins that were at low level, and reset ones that were high */
;;;444      GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
000004  ea210302          BIC      r3,r1,r2
000008  ea020401          AND      r4,r2,r1
00000c  ea434304          ORR      r3,r3,r4,LSL #16
000010  6183              STR      r3,[r0,#0x18]
;;;445    }
000012  bd10              POP      {r4,pc}
;;;446    
                          ENDP


                          AREA ||i.HAL_GPIO_WritePin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_WritePin PROC
;;;409      */
;;;410    void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
000000  b10a              CBZ      r2,|L8.6|
;;;411    {
;;;412      /* Check the parameters */
;;;413      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;414      assert_param(IS_GPIO_PIN_ACTION(PinState));
;;;415    
;;;416      if(PinState != GPIO_PIN_RESET)
;;;417      {
;;;418        GPIOx->BSRR = GPIO_Pin;
000002  6181              STR      r1,[r0,#0x18]
000004  e001              B        |L8.10|
                  |L8.6|
;;;419      }
;;;420      else
;;;421      {
;;;422        GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
000006  040b              LSLS     r3,r1,#16
000008  6183              STR      r3,[r0,#0x18]
                  |L8.10|
;;;423      }
;;;424    }
00000a  4770              BX       lr
;;;425    
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_gpio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_gpio_c_ea787061____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___20_stm32f4xx_hal_gpio_c_ea787061____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_gpio_c_ea787061____REVSH|
#line 478
|__asm___20_stm32f4xx_hal_gpio_c_ea787061____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_gpio_c_ea787061____RRX|
#line 665
|__asm___20_stm32f4xx_hal_gpio_c_ea787061____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
