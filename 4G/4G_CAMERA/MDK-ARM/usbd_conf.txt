; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o4gcamera\usbd_conf.o --asm_dir=.\ --list_dir=.\ --depend=4gcamera\usbd_conf.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../USB_DEVICE/App -I../USB_DEVICE/Target -I../Core/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Middlewares/ST/STM32_USB_Device_Library/Core/Inc -I../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 -I../Middlewares/Third_Party/FreeRTOS/Source/portable/RVDS/ARM_CM4F -I../HARDWARE/OV2640 -I../HARDWARE/WS2812B -I../HARDWARE/RING_BUFFER -I../HARDWARE/FLASH -I.\RTE\_4GCAMERA -IC:\Users\czm\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Users\czm\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=536 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F407xx --omf_browse=4gcamera\usbd_conf.crf ../USB_DEVICE/Target/usbd_conf.c]
                          THUMB

                          AREA ||i.HAL_PCD_ConnectCallback||, CODE, READONLY, ALIGN=1

                  HAL_PCD_ConnectCallback PROC
;;;297    #else
;;;298    void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
000000  b510              PUSH     {r4,lr}
;;;299    #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
;;;300    {
000002  4604              MOV      r4,r0
;;;301      USBD_LL_DevConnected((USBD_HandleTypeDef*)hpcd->pData);
000004  f8d40508          LDR      r0,[r4,#0x508]
000008  f7fffffe          BL       USBD_LL_DevConnected
;;;302    }
00000c  bd10              POP      {r4,pc}
;;;303    
                          ENDP


                          AREA ||i.HAL_PCD_DataInStageCallback||, CODE, READONLY, ALIGN=1

                  HAL_PCD_DataInStageCallback PROC
;;;164    #else
;;;165    void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
000000  b570              PUSH     {r4-r6,lr}
;;;166    #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
;;;167    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;168      USBD_LL_DataInStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
000006  eb0503c5          ADD      r3,r5,r5,LSL #3
00000a  f104013c          ADD      r1,r4,#0x3c
00000e  eb010183          ADD      r1,r1,r3,LSL #2
000012  690a              LDR      r2,[r1,#0x10]
000014  4629              MOV      r1,r5
000016  f8d40508          LDR      r0,[r4,#0x508]
00001a  f7fffffe          BL       USBD_LL_DataInStage
;;;169    }
00001e  bd70              POP      {r4-r6,pc}
;;;170    
                          ENDP


                          AREA ||i.HAL_PCD_DataOutStageCallback||, CODE, READONLY, ALIGN=1

                  HAL_PCD_DataOutStageCallback PROC
;;;149    #else
;;;150    void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
000000  b570              PUSH     {r4-r6,lr}
;;;151    #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
;;;152    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;153      USBD_LL_DataOutStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
000006  eb0503c5          ADD      r3,r5,r5,LSL #3
00000a  f504711f          ADD      r1,r4,#0x27c
00000e  eb010183          ADD      r1,r1,r3,LSL #2
000012  690a              LDR      r2,[r1,#0x10]
000014  4629              MOV      r1,r5
000016  f8d40508          LDR      r0,[r4,#0x508]
00001a  f7fffffe          BL       USBD_LL_DataOutStage
;;;154    }
00001e  bd70              POP      {r4-r6,pc}
;;;155    
                          ENDP


                          AREA ||i.HAL_PCD_DisconnectCallback||, CODE, READONLY, ALIGN=1

                  HAL_PCD_DisconnectCallback PROC
;;;311    #else
;;;312    void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
000000  b510              PUSH     {r4,lr}
;;;313    #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
;;;314    {
000002  4604              MOV      r4,r0
;;;315      USBD_LL_DevDisconnected((USBD_HandleTypeDef*)hpcd->pData);
000004  f8d40508          LDR      r0,[r4,#0x508]
000008  f7fffffe          BL       USBD_LL_DevDisconnected
;;;316    }
00000c  bd10              POP      {r4,pc}
;;;317    
                          ENDP


                          AREA ||i.HAL_PCD_ISOINIncompleteCallback||, CODE, READONLY, ALIGN=1

                  HAL_PCD_ISOINIncompleteCallback PROC
;;;283    #else
;;;284    void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
000000  b570              PUSH     {r4-r6,lr}
;;;285    #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
;;;286    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;287      USBD_LL_IsoINIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
000006  4629              MOV      r1,r5
000008  f8d40508          LDR      r0,[r4,#0x508]
00000c  f7fffffe          BL       USBD_LL_IsoINIncomplete
;;;288    }
000010  bd70              POP      {r4-r6,pc}
;;;289    
                          ENDP


                          AREA ||i.HAL_PCD_ISOOUTIncompleteCallback||, CODE, READONLY, ALIGN=1

                  HAL_PCD_ISOOUTIncompleteCallback PROC
;;;268    #else
;;;269    void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
000000  b570              PUSH     {r4-r6,lr}
;;;270    #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
;;;271    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;272      USBD_LL_IsoOUTIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
000006  4629              MOV      r1,r5
000008  f8d40508          LDR      r0,[r4,#0x508]
00000c  f7fffffe          BL       USBD_LL_IsoOUTIncomplete
;;;273    }
000010  bd70              POP      {r4-r6,pc}
;;;274    
                          ENDP


                          AREA ||i.HAL_PCD_MspDeInit||, CODE, READONLY, ALIGN=2

                  HAL_PCD_MspDeInit PROC
;;;101    
;;;102    void HAL_PCD_MspDeInit(PCD_HandleTypeDef* pcdHandle)
000000  b510              PUSH     {r4,lr}
;;;103    {
000002  4604              MOV      r4,r0
;;;104      if(pcdHandle->Instance==USB_OTG_HS)
000004  4909              LDR      r1,|L7.44|
000006  6820              LDR      r0,[r4,#0]
000008  4288              CMP      r0,r1
00000a  d10d              BNE      |L7.40|
;;;105      {
;;;106      /* USER CODE BEGIN USB_OTG_HS_MspDeInit 0 */
;;;107    
;;;108      /* USER CODE END USB_OTG_HS_MspDeInit 0 */
;;;109        /* Peripheral clock disable */
;;;110        __HAL_RCC_USB_OTG_HS_CLK_DISABLE();
00000c  4808              LDR      r0,|L7.48|
00000e  6800              LDR      r0,[r0,#0]
000010  f0205000          BIC      r0,r0,#0x20000000
000014  4906              LDR      r1,|L7.48|
000016  6008              STR      r0,[r1,#0]
;;;111    
;;;112        /**USB_OTG_HS GPIO Configuration
;;;113        PB14     ------> USB_OTG_HS_DM
;;;114        PB15     ------> USB_OTG_HS_DP
;;;115        */
;;;116        HAL_GPIO_DeInit(GPIOB, GPIO_PIN_14|GPIO_PIN_15);
000018  f44f4140          MOV      r1,#0xc000
00001c  4805              LDR      r0,|L7.52|
00001e  f7fffffe          BL       HAL_GPIO_DeInit
;;;117    
;;;118        /* Peripheral interrupt Deinit*/
;;;119        HAL_NVIC_DisableIRQ(OTG_HS_IRQn);
000022  204d              MOVS     r0,#0x4d
000024  f7fffffe          BL       HAL_NVIC_DisableIRQ
                  |L7.40|
;;;120    
;;;121      /* USER CODE BEGIN USB_OTG_HS_MspDeInit 1 */
;;;122    
;;;123      /* USER CODE END USB_OTG_HS_MspDeInit 1 */
;;;124      }
;;;125    }
000028  bd10              POP      {r4,pc}
;;;126    
                          ENDP

00002a  0000              DCW      0x0000
                  |L7.44|
                          DCD      0x40040000
                  |L7.48|
                          DCD      0x40023830
                  |L7.52|
                          DCD      0x40020400

                          AREA ||i.HAL_PCD_MspInit||, CODE, READONLY, ALIGN=2

                  HAL_PCD_MspInit PROC
;;;68     
;;;69     void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
000000  b510              PUSH     {r4,lr}
;;;70     {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;71       GPIO_InitTypeDef GPIO_InitStruct = {0};
000006  2114              MOVS     r1,#0x14
000008  a801              ADD      r0,sp,#4
00000a  f7fffffe          BL       __aeabi_memclr4
;;;72       if(pcdHandle->Instance==USB_OTG_HS)
00000e  491e              LDR      r1,|L8.136|
000010  6820              LDR      r0,[r4,#0]
000012  4288              CMP      r0,r1
000014  d136              BNE      |L8.132|
;;;73       {
;;;74       /* USER CODE BEGIN USB_OTG_HS_MspInit 0 */
;;;75     
;;;76       /* USER CODE END USB_OTG_HS_MspInit 0 */
;;;77     
;;;78         __HAL_RCC_GPIOB_CLK_ENABLE();
000016  bf00              NOP      
000018  2000              MOVS     r0,#0
00001a  9000              STR      r0,[sp,#0]
00001c  481b              LDR      r0,|L8.140|
00001e  6800              LDR      r0,[r0,#0]
000020  f0400002          ORR      r0,r0,#2
000024  4919              LDR      r1,|L8.140|
000026  6008              STR      r0,[r1,#0]
000028  4608              MOV      r0,r1
00002a  6800              LDR      r0,[r0,#0]
00002c  f0000002          AND      r0,r0,#2
000030  9000              STR      r0,[sp,#0]
000032  bf00              NOP      
000034  bf00              NOP      
;;;79         /**USB_OTG_HS GPIO Configuration
;;;80         PB14     ------> USB_OTG_HS_DM
;;;81         PB15     ------> USB_OTG_HS_DP
;;;82         */
;;;83         GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_15;
000036  f44f4040          MOV      r0,#0xc000
00003a  9001              STR      r0,[sp,#4]
;;;84         GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
00003c  2002              MOVS     r0,#2
00003e  9002              STR      r0,[sp,#8]
;;;85         GPIO_InitStruct.Pull = GPIO_NOPULL;
000040  2000              MOVS     r0,#0
000042  9003              STR      r0,[sp,#0xc]
;;;86         GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
000044  2003              MOVS     r0,#3
000046  9004              STR      r0,[sp,#0x10]
;;;87         GPIO_InitStruct.Alternate = GPIO_AF12_OTG_HS_FS;
000048  200c              MOVS     r0,#0xc
00004a  9005              STR      r0,[sp,#0x14]
;;;88         HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
00004c  a901              ADD      r1,sp,#4
00004e  4810              LDR      r0,|L8.144|
000050  f7fffffe          BL       HAL_GPIO_Init
;;;89     
;;;90         /* Peripheral clock enable */
;;;91         __HAL_RCC_USB_OTG_HS_CLK_ENABLE();
000054  bf00              NOP      
000056  2000              MOVS     r0,#0
000058  9000              STR      r0,[sp,#0]
00005a  480c              LDR      r0,|L8.140|
00005c  6800              LDR      r0,[r0,#0]
00005e  f0405000          ORR      r0,r0,#0x20000000
000062  490a              LDR      r1,|L8.140|
000064  6008              STR      r0,[r1,#0]
000066  4608              MOV      r0,r1
000068  6800              LDR      r0,[r0,#0]
00006a  f0005000          AND      r0,r0,#0x20000000
00006e  9000              STR      r0,[sp,#0]
000070  bf00              NOP      
000072  bf00              NOP      
;;;92     
;;;93         /* Peripheral interrupt init */
;;;94         HAL_NVIC_SetPriority(OTG_HS_IRQn, 5, 0);
000074  2200              MOVS     r2,#0
000076  2105              MOVS     r1,#5
000078  204d              MOVS     r0,#0x4d
00007a  f7fffffe          BL       HAL_NVIC_SetPriority
;;;95         HAL_NVIC_EnableIRQ(OTG_HS_IRQn);
00007e  204d              MOVS     r0,#0x4d
000080  f7fffffe          BL       HAL_NVIC_EnableIRQ
                  |L8.132|
;;;96       /* USER CODE BEGIN USB_OTG_HS_MspInit 1 */
;;;97     
;;;98       /* USER CODE END USB_OTG_HS_MspInit 1 */
;;;99       }
;;;100    }
000084  b006              ADD      sp,sp,#0x18
000086  bd10              POP      {r4,pc}
;;;101    
                          ENDP

                  |L8.136|
                          DCD      0x40040000
                  |L8.140|
                          DCD      0x40023830
                  |L8.144|
                          DCD      0x40020400

                          AREA ||i.HAL_PCD_ResetCallback||, CODE, READONLY, ALIGN=1

                  HAL_PCD_ResetCallback PROC
;;;192    #else
;;;193    void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
000000  b570              PUSH     {r4-r6,lr}
;;;194    #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
;;;195    {
000002  4604              MOV      r4,r0
;;;196      USBD_SpeedTypeDef speed = USBD_SPEED_FULL;
000004  2501              MOVS     r5,#1
;;;197    
;;;198      if ( hpcd->Init.speed == PCD_SPEED_HIGH)
000006  68e0              LDR      r0,[r4,#0xc]
000008  b908              CBNZ     r0,|L9.14|
;;;199      {
;;;200        speed = USBD_SPEED_HIGH;
00000a  2500              MOVS     r5,#0
00000c  e006              B        |L9.28|
                  |L9.14|
;;;201      }
;;;202      else if ( hpcd->Init.speed == PCD_SPEED_FULL)
00000e  68e0              LDR      r0,[r4,#0xc]
000010  2802              CMP      r0,#2
000012  d101              BNE      |L9.24|
;;;203      {
;;;204        speed = USBD_SPEED_FULL;
000014  2501              MOVS     r5,#1
000016  e001              B        |L9.28|
                  |L9.24|
;;;205      }
;;;206      else
;;;207      {
;;;208        Error_Handler();
000018  f7fffffe          BL       Error_Handler
                  |L9.28|
;;;209      }
;;;210        /* Set Speed. */
;;;211      USBD_LL_SetSpeed((USBD_HandleTypeDef*)hpcd->pData, speed);
00001c  4629              MOV      r1,r5
00001e  f8d40508          LDR      r0,[r4,#0x508]
000022  f7fffffe          BL       USBD_LL_SetSpeed
;;;212    
;;;213      /* Reset Device. */
;;;214      USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
000026  f8d40508          LDR      r0,[r4,#0x508]
00002a  f7fffffe          BL       USBD_LL_Reset
;;;215    }
00002e  bd70              POP      {r4-r6,pc}
;;;216    
                          ENDP


                          AREA ||i.HAL_PCD_ResumeCallback||, CODE, READONLY, ALIGN=1

                  HAL_PCD_ResumeCallback PROC
;;;250    #else
;;;251    void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
000000  b510              PUSH     {r4,lr}
;;;252    #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
;;;253    {
000002  4604              MOV      r4,r0
;;;254      /* USER CODE BEGIN 3 */
;;;255    
;;;256      /* USER CODE END 3 */
;;;257      USBD_LL_Resume((USBD_HandleTypeDef*)hpcd->pData);
000004  f8d40508          LDR      r0,[r4,#0x508]
000008  f7fffffe          BL       USBD_LL_Resume
;;;258    }
00000c  bd10              POP      {r4,pc}
;;;259    
                          ENDP


                          AREA ||i.HAL_PCD_SOFCallback||, CODE, READONLY, ALIGN=1

                  HAL_PCD_SOFCallback PROC
;;;178    #else
;;;179    void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
000000  b510              PUSH     {r4,lr}
;;;180    #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
;;;181    {
000002  4604              MOV      r4,r0
;;;182      USBD_LL_SOF((USBD_HandleTypeDef*)hpcd->pData);
000004  f8d40508          LDR      r0,[r4,#0x508]
000008  f7fffffe          BL       USBD_LL_SOF
;;;183    }
00000c  bd10              POP      {r4,pc}
;;;184    
                          ENDP


                          AREA ||i.HAL_PCD_SetupStageCallback||, CODE, READONLY, ALIGN=1

                  HAL_PCD_SetupStageCallback PROC
;;;134    #else
;;;135    void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
000000  b510              PUSH     {r4,lr}
;;;136    #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
;;;137    {
000002  4604              MOV      r4,r0
;;;138      USBD_LL_SetupStage((USBD_HandleTypeDef*)hpcd->pData, (uint8_t *)hpcd->Setup);
000004  f20441c4          ADD      r1,r4,#0x4c4
000008  f8d40508          LDR      r0,[r4,#0x508]
00000c  f7fffffe          BL       USBD_LL_SetupStage
;;;139    }
000010  bd10              POP      {r4,pc}
;;;140    
                          ENDP


                          AREA ||i.HAL_PCD_SuspendCallback||, CODE, READONLY, ALIGN=2

                  HAL_PCD_SuspendCallback PROC
;;;225    #else
;;;226    void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
000000  b510              PUSH     {r4,lr}
;;;227    #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
;;;228    {
000002  4604              MOV      r4,r0
;;;229      /* Inform USB library that core enters in suspend Mode. */
;;;230      USBD_LL_Suspend((USBD_HandleTypeDef*)hpcd->pData);
000004  f8d40508          LDR      r0,[r4,#0x508]
000008  f7fffffe          BL       USBD_LL_Suspend
;;;231      __HAL_PCD_GATE_PHYCLOCK(hpcd);
00000c  6820              LDR      r0,[r4,#0]
00000e  f8d00e00          LDR      r0,[r0,#0xe00]
000012  f0400001          ORR      r0,r0,#1
000016  6821              LDR      r1,[r4,#0]
000018  f8c10e00          STR      r0,[r1,#0xe00]
;;;232      /* Enter in STOP mode. */
;;;233      /* USER CODE BEGIN 2 */
;;;234      if (hpcd->Init.low_power_enable)
00001c  6a20              LDR      r0,[r4,#0x20]
00001e  b128              CBZ      r0,|L13.44|
;;;235      {
;;;236        /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register. */
;;;237        SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
000020  4803              LDR      r0,|L13.48|
000022  6800              LDR      r0,[r0,#0]
000024  f0400006          ORR      r0,r0,#6
000028  4901              LDR      r1,|L13.48|
00002a  6008              STR      r0,[r1,#0]
                  |L13.44|
;;;238      }
;;;239      /* USER CODE END 2 */
;;;240    }
00002c  bd10              POP      {r4,pc}
;;;241    
                          ENDP

00002e  0000              DCW      0x0000
                  |L13.48|
                          DCD      0xe000ed10

                          AREA ||i.USBD_Get_USB_Status||, CODE, READONLY, ALIGN=1

                  USBD_Get_USB_Status PROC
;;;656      */
;;;657    USBD_StatusTypeDef USBD_Get_USB_Status(HAL_StatusTypeDef hal_status)
000000  4601              MOV      r1,r0
;;;658    {
;;;659      USBD_StatusTypeDef usb_status = USBD_OK;
000002  2000              MOVS     r0,#0
;;;660    
;;;661      switch (hal_status)
000004  b131              CBZ      r1,|L14.20|
000006  2901              CMP      r1,#1
000008  d006              BEQ      |L14.24|
00000a  2902              CMP      r1,#2
00000c  d006              BEQ      |L14.28|
00000e  2903              CMP      r1,#3
000010  d108              BNE      |L14.36|
000012  e005              B        |L14.32|
                  |L14.20|
;;;662      {
;;;663        case HAL_OK :
;;;664          usb_status = USBD_OK;
000014  2000              MOVS     r0,#0
;;;665        break;
000016  e007              B        |L14.40|
                  |L14.24|
;;;666        case HAL_ERROR :
;;;667          usb_status = USBD_FAIL;
000018  2003              MOVS     r0,#3
;;;668        break;
00001a  e005              B        |L14.40|
                  |L14.28|
;;;669        case HAL_BUSY :
;;;670          usb_status = USBD_BUSY;
00001c  2001              MOVS     r0,#1
;;;671        break;
00001e  e003              B        |L14.40|
                  |L14.32|
;;;672        case HAL_TIMEOUT :
;;;673          usb_status = USBD_FAIL;
000020  2003              MOVS     r0,#3
;;;674        break;
000022  e001              B        |L14.40|
                  |L14.36|
;;;675        default :
;;;676          usb_status = USBD_FAIL;
000024  2003              MOVS     r0,#3
;;;677        break;
000026  bf00              NOP      
                  |L14.40|
000028  bf00              NOP                            ;665
;;;678      }
;;;679      return usb_status;
;;;680    }
00002a  4770              BX       lr
                          ENDP


                          AREA ||i.USBD_LL_ClearStallEP||, CODE, READONLY, ALIGN=1

                  USBD_LL_ClearStallEP PROC
;;;503      */
;;;504    USBD_StatusTypeDef USBD_LL_ClearStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;505    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;506      HAL_StatusTypeDef hal_status = HAL_OK;
000008  2600              MOVS     r6,#0
;;;507      USBD_StatusTypeDef usb_status = USBD_OK;
00000a  2700              MOVS     r7,#0
;;;508    
;;;509      hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);
00000c  4629              MOV      r1,r5
00000e  f8d402c8          LDR      r0,[r4,#0x2c8]
000012  f7fffffe          BL       HAL_PCD_EP_ClrStall
000016  4606              MOV      r6,r0
;;;510    
;;;511      usb_status =  USBD_Get_USB_Status(hal_status);
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       USBD_Get_USB_Status
00001e  4607              MOV      r7,r0
;;;512    
;;;513      return usb_status;
000020  4638              MOV      r0,r7
;;;514    }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;515    
                          ENDP


                          AREA ||i.USBD_LL_CloseEP||, CODE, READONLY, ALIGN=1

                  USBD_LL_CloseEP PROC
;;;449      */
;;;450    USBD_StatusTypeDef USBD_LL_CloseEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;451    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;452      HAL_StatusTypeDef hal_status = HAL_OK;
000008  2600              MOVS     r6,#0
;;;453      USBD_StatusTypeDef usb_status = USBD_OK;
00000a  2700              MOVS     r7,#0
;;;454    
;;;455      hal_status = HAL_PCD_EP_Close(pdev->pData, ep_addr);
00000c  4629              MOV      r1,r5
00000e  f8d402c8          LDR      r0,[r4,#0x2c8]
000012  f7fffffe          BL       HAL_PCD_EP_Close
000016  4606              MOV      r6,r0
;;;456    
;;;457      usb_status =  USBD_Get_USB_Status(hal_status);
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       USBD_Get_USB_Status
00001e  4607              MOV      r7,r0
;;;458    
;;;459      return usb_status;
000020  4638              MOV      r0,r7
;;;460    }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;461    
                          ENDP


                          AREA ||i.USBD_LL_DeInit||, CODE, READONLY, ALIGN=1

                  USBD_LL_DeInit PROC
;;;377      */
;;;378    USBD_StatusTypeDef USBD_LL_DeInit(USBD_HandleTypeDef *pdev)
000000  b570              PUSH     {r4-r6,lr}
;;;379    {
000002  4604              MOV      r4,r0
;;;380      HAL_StatusTypeDef hal_status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;381      USBD_StatusTypeDef usb_status = USBD_OK;
000006  2600              MOVS     r6,#0
;;;382    
;;;383      hal_status = HAL_PCD_DeInit(pdev->pData);
000008  f8d402c8          LDR      r0,[r4,#0x2c8]
00000c  f7fffffe          BL       HAL_PCD_DeInit
000010  4605              MOV      r5,r0
;;;384    
;;;385      usb_status =  USBD_Get_USB_Status(hal_status);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       USBD_Get_USB_Status
000018  4606              MOV      r6,r0
;;;386    
;;;387      return usb_status;
00001a  4630              MOV      r0,r6
;;;388    }
00001c  bd70              POP      {r4-r6,pc}
;;;389    
                          ENDP


                          AREA ||i.USBD_LL_Delay||, CODE, READONLY, ALIGN=1

                  USBD_LL_Delay PROC
;;;646      */
;;;647    void USBD_LL_Delay(uint32_t Delay)
000000  b510              PUSH     {r4,lr}
;;;648    {
000002  4604              MOV      r4,r0
;;;649      HAL_Delay(Delay);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       HAL_Delay
;;;650    }
00000a  bd10              POP      {r4,pc}
;;;651    
                          ENDP


                          AREA ||i.USBD_LL_FlushEP||, CODE, READONLY, ALIGN=1

                  USBD_LL_FlushEP PROC
;;;467      */
;;;468    USBD_StatusTypeDef USBD_LL_FlushEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;469    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;470      HAL_StatusTypeDef hal_status = HAL_OK;
000008  2600              MOVS     r6,#0
;;;471      USBD_StatusTypeDef usb_status = USBD_OK;
00000a  2700              MOVS     r7,#0
;;;472    
;;;473      hal_status = HAL_PCD_EP_Flush(pdev->pData, ep_addr);
00000c  4629              MOV      r1,r5
00000e  f8d402c8          LDR      r0,[r4,#0x2c8]
000012  f7fffffe          BL       HAL_PCD_EP_Flush
000016  4606              MOV      r6,r0
;;;474    
;;;475      usb_status =  USBD_Get_USB_Status(hal_status);
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       USBD_Get_USB_Status
00001e  4607              MOV      r7,r0
;;;476    
;;;477      return usb_status;
000020  4638              MOV      r0,r7
;;;478    }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;479    
                          ENDP


                          AREA ||i.USBD_LL_GetRxDataSize||, CODE, READONLY, ALIGN=1

                  USBD_LL_GetRxDataSize PROC
;;;599      */
;;;600    uint32_t USBD_LL_GetRxDataSize(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
000000  b570              PUSH     {r4-r6,lr}
;;;601    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;602      return HAL_PCD_EP_GetRxCount((PCD_HandleTypeDef*) pdev->pData, ep_addr);
000006  4629              MOV      r1,r5
000008  f8d402c8          LDR      r0,[r4,#0x2c8]
00000c  f7fffffe          BL       HAL_PCD_EP_GetRxCount
;;;603    }
000010  bd70              POP      {r4-r6,pc}
;;;604    
                          ENDP


                          AREA ||i.USBD_LL_Init||, CODE, READONLY, ALIGN=2

                  USBD_LL_Init PROC
;;;326      */
;;;327    USBD_StatusTypeDef USBD_LL_Init(USBD_HandleTypeDef *pdev)
000000  b510              PUSH     {r4,lr}
;;;328    {
000002  4604              MOV      r4,r0
;;;329      /* Init USB Ip. */
;;;330      if (pdev->id == DEVICE_HS) {
000004  7820              LDRB     r0,[r4,#0]
000006  2801              CMP      r0,#1
000008  d12c              BNE      |L21.100|
;;;331      /* Link the driver to the stack. */
;;;332      hpcd_USB_OTG_HS.pData = pdev;
00000a  4817              LDR      r0,|L21.104|
00000c  f8c04508          STR      r4,[r0,#0x508]  ; hpcd_USB_OTG_HS
;;;333      pdev->pData = &hpcd_USB_OTG_HS;
000010  f8c402c8          STR      r0,[r4,#0x2c8]
;;;334    
;;;335      hpcd_USB_OTG_HS.Instance = USB_OTG_HS;
000014  4815              LDR      r0,|L21.108|
000016  4914              LDR      r1,|L21.104|
000018  6008              STR      r0,[r1,#0]  ; hpcd_USB_OTG_HS
;;;336      hpcd_USB_OTG_HS.Init.dev_endpoints = 6;
00001a  2006              MOVS     r0,#6
00001c  6048              STR      r0,[r1,#4]  ; hpcd_USB_OTG_HS
;;;337      hpcd_USB_OTG_HS.Init.speed = PCD_SPEED_FULL;
00001e  2102              MOVS     r1,#2
000020  4811              LDR      r0,|L21.104|
000022  60c1              STR      r1,[r0,#0xc]
;;;338      hpcd_USB_OTG_HS.Init.dma_enable = DISABLE;
000024  2100              MOVS     r1,#0
000026  6101              STR      r1,[r0,#0x10]
;;;339      hpcd_USB_OTG_HS.Init.phy_itface = USB_OTG_EMBEDDED_PHY;
000028  2102              MOVS     r1,#2
00002a  6181              STR      r1,[r0,#0x18]
;;;340      hpcd_USB_OTG_HS.Init.Sof_enable = DISABLE;
00002c  2100              MOVS     r1,#0
00002e  61c1              STR      r1,[r0,#0x1c]
;;;341      hpcd_USB_OTG_HS.Init.low_power_enable = DISABLE;
000030  6201              STR      r1,[r0,#0x20]
;;;342      hpcd_USB_OTG_HS.Init.lpm_enable = DISABLE;
000032  6241              STR      r1,[r0,#0x24]
;;;343      hpcd_USB_OTG_HS.Init.vbus_sensing_enable = DISABLE;
000034  62c1              STR      r1,[r0,#0x2c]
;;;344      hpcd_USB_OTG_HS.Init.use_dedicated_ep1 = DISABLE;
000036  6301              STR      r1,[r0,#0x30]
;;;345      hpcd_USB_OTG_HS.Init.use_external_vbus = DISABLE;
000038  6341              STR      r1,[r0,#0x34]
;;;346      if (HAL_PCD_Init(&hpcd_USB_OTG_HS) != HAL_OK)
00003a  f7fffffe          BL       HAL_PCD_Init
00003e  b108              CBZ      r0,|L21.68|
;;;347      {
;;;348        Error_Handler( );
000040  f7fffffe          BL       Error_Handler
                  |L21.68|
;;;349      }
;;;350    
;;;351    #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
;;;352      /* Register USB PCD CallBacks */
;;;353      HAL_PCD_RegisterCallback(&hpcd_USB_OTG_HS, HAL_PCD_SOF_CB_ID, PCD_SOFCallback);
;;;354      HAL_PCD_RegisterCallback(&hpcd_USB_OTG_HS, HAL_PCD_SETUPSTAGE_CB_ID, PCD_SetupStageCallback);
;;;355      HAL_PCD_RegisterCallback(&hpcd_USB_OTG_HS, HAL_PCD_RESET_CB_ID, PCD_ResetCallback);
;;;356      HAL_PCD_RegisterCallback(&hpcd_USB_OTG_HS, HAL_PCD_SUSPEND_CB_ID, PCD_SuspendCallback);
;;;357      HAL_PCD_RegisterCallback(&hpcd_USB_OTG_HS, HAL_PCD_RESUME_CB_ID, PCD_ResumeCallback);
;;;358      HAL_PCD_RegisterCallback(&hpcd_USB_OTG_HS, HAL_PCD_CONNECT_CB_ID, PCD_ConnectCallback);
;;;359      HAL_PCD_RegisterCallback(&hpcd_USB_OTG_HS, HAL_PCD_DISCONNECT_CB_ID, PCD_DisconnectCallback);
;;;360    
;;;361      HAL_PCD_RegisterDataOutStageCallback(&hpcd_USB_OTG_HS, PCD_DataOutStageCallback);
;;;362      HAL_PCD_RegisterDataInStageCallback(&hpcd_USB_OTG_HS, PCD_DataInStageCallback);
;;;363      HAL_PCD_RegisterIsoOutIncpltCallback(&hpcd_USB_OTG_HS, PCD_ISOOUTIncompleteCallback);
;;;364      HAL_PCD_RegisterIsoInIncpltCallback(&hpcd_USB_OTG_HS, PCD_ISOINIncompleteCallback);
;;;365    #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
;;;366      HAL_PCDEx_SetRxFiFo(&hpcd_USB_OTG_HS, 0x200);
000044  f44f7100          MOV      r1,#0x200
000048  4807              LDR      r0,|L21.104|
00004a  f7fffffe          BL       HAL_PCDEx_SetRxFiFo
;;;367      HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_HS, 0, 0x80);
00004e  2280              MOVS     r2,#0x80
000050  2100              MOVS     r1,#0
000052  4805              LDR      r0,|L21.104|
000054  f7fffffe          BL       HAL_PCDEx_SetTxFiFo
;;;368      HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_HS, 1, 0x174);
000058  f44f72ba          MOV      r2,#0x174
00005c  2101              MOVS     r1,#1
00005e  4802              LDR      r0,|L21.104|
000060  f7fffffe          BL       HAL_PCDEx_SetTxFiFo
                  |L21.100|
;;;369      }
;;;370      return USBD_OK;
000064  2000              MOVS     r0,#0
;;;371    }
000066  bd10              POP      {r4,pc}
;;;372    
                          ENDP

                  |L21.104|
                          DCD      hpcd_USB_OTG_HS
                  |L21.108|
                          DCD      0x40040000

                          AREA ||i.USBD_LL_IsStallEP||, CODE, READONLY, ALIGN=1

                  USBD_LL_IsStallEP PROC
;;;521      */
;;;522    uint8_t USBD_LL_IsStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
000000  b510              PUSH     {r4,lr}
;;;523    {
000002  4602              MOV      r2,r0
;;;524      PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
000004  f8d232c8          LDR      r3,[r2,#0x2c8]
;;;525    
;;;526      if((ep_addr & 0x80) == 0x80)
000008  f0010080          AND      r0,r1,#0x80
00000c  2880              CMP      r0,#0x80
00000e  d109              BNE      |L22.36|
;;;527      {
;;;528        return hpcd->IN_ep[ep_addr & 0x7F].is_stall;
000010  f001007f          AND      r0,r1,#0x7f
000014  eb0004c0          ADD      r4,r0,r0,LSL #3
000018  f103003c          ADD      r0,r3,#0x3c
00001c  eb000084          ADD      r0,r0,r4,LSL #2
000020  7880              LDRB     r0,[r0,#2]
                  |L22.34|
;;;529      }
;;;530      else
;;;531      {
;;;532        return hpcd->OUT_ep[ep_addr & 0x7F].is_stall;
;;;533      }
;;;534    }
000022  bd10              POP      {r4,pc}
                  |L22.36|
000024  f001007f          AND      r0,r1,#0x7f           ;532
000028  eb0004c0          ADD      r4,r0,r0,LSL #3       ;532
00002c  f503701f          ADD      r0,r3,#0x27c          ;532
000030  eb000084          ADD      r0,r0,r4,LSL #2       ;532
000034  7880              LDRB     r0,[r0,#2]            ;532
000036  e7f4              B        |L22.34|
;;;535    
                          ENDP


                          AREA ||i.USBD_LL_OpenEP||, CODE, READONLY, ALIGN=1

                  USBD_LL_OpenEP PROC
;;;431      */
;;;432    USBD_StatusTypeDef USBD_LL_OpenEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t ep_type, uint16_t ep_mps)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;433    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;434      HAL_StatusTypeDef hal_status = HAL_OK;
00000c  f04f0800          MOV      r8,#0
;;;435      USBD_StatusTypeDef usb_status = USBD_OK;
000010  46c1              MOV      r9,r8
;;;436    
;;;437      hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
000012  462b              MOV      r3,r5
000014  4632              MOV      r2,r6
000016  4639              MOV      r1,r7
000018  f8d402c8          LDR      r0,[r4,#0x2c8]
00001c  f7fffffe          BL       HAL_PCD_EP_Open
000020  4680              MOV      r8,r0
;;;438    
;;;439      usb_status =  USBD_Get_USB_Status(hal_status);
000022  4640              MOV      r0,r8
000024  f7fffffe          BL       USBD_Get_USB_Status
000028  4681              MOV      r9,r0
;;;440    
;;;441      return usb_status;
00002a  4648              MOV      r0,r9
;;;442    }
00002c  e8bd87f0          POP      {r4-r10,pc}
;;;443    
                          ENDP


                          AREA ||i.USBD_LL_PrepareReceive||, CODE, READONLY, ALIGN=1

                  USBD_LL_PrepareReceive PROC
;;;581      */
;;;582    USBD_StatusTypeDef USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint32_t size)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;583    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;584      HAL_StatusTypeDef hal_status = HAL_OK;
00000c  f04f0800          MOV      r8,#0
;;;585      USBD_StatusTypeDef usb_status = USBD_OK;
000010  46c1              MOV      r9,r8
;;;586    
;;;587      hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
000012  463b              MOV      r3,r7
000014  4632              MOV      r2,r6
000016  4629              MOV      r1,r5
000018  f8d402c8          LDR      r0,[r4,#0x2c8]
00001c  f7fffffe          BL       HAL_PCD_EP_Receive
000020  4680              MOV      r8,r0
;;;588    
;;;589      usb_status =  USBD_Get_USB_Status(hal_status);
000022  4640              MOV      r0,r8
000024  f7fffffe          BL       USBD_Get_USB_Status
000028  4681              MOV      r9,r0
;;;590    
;;;591      return usb_status;
00002a  4648              MOV      r0,r9
;;;592    }
00002c  e8bd87f0          POP      {r4-r10,pc}
;;;593    
                          ENDP


                          AREA ||i.USBD_LL_SetUSBAddress||, CODE, READONLY, ALIGN=1

                  USBD_LL_SetUSBAddress PROC
;;;541      */
;;;542    USBD_StatusTypeDef USBD_LL_SetUSBAddress(USBD_HandleTypeDef *pdev, uint8_t dev_addr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;543    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;544      HAL_StatusTypeDef hal_status = HAL_OK;
000008  2600              MOVS     r6,#0
;;;545      USBD_StatusTypeDef usb_status = USBD_OK;
00000a  2700              MOVS     r7,#0
;;;546    
;;;547      hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
00000c  4629              MOV      r1,r5
00000e  f8d402c8          LDR      r0,[r4,#0x2c8]
000012  f7fffffe          BL       HAL_PCD_SetAddress
000016  4606              MOV      r6,r0
;;;548    
;;;549      usb_status =  USBD_Get_USB_Status(hal_status);
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       USBD_Get_USB_Status
00001e  4607              MOV      r7,r0
;;;550    
;;;551      return usb_status;
000020  4638              MOV      r0,r7
;;;552    }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;553    
                          ENDP


                          AREA ||i.USBD_LL_StallEP||, CODE, READONLY, ALIGN=1

                  USBD_LL_StallEP PROC
;;;485      */
;;;486    USBD_StatusTypeDef USBD_LL_StallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;487    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;488      HAL_StatusTypeDef hal_status = HAL_OK;
000008  2600              MOVS     r6,#0
;;;489      USBD_StatusTypeDef usb_status = USBD_OK;
00000a  2700              MOVS     r7,#0
;;;490    
;;;491      hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
00000c  4629              MOV      r1,r5
00000e  f8d402c8          LDR      r0,[r4,#0x2c8]
000012  f7fffffe          BL       HAL_PCD_EP_SetStall
000016  4606              MOV      r6,r0
;;;492    
;;;493      usb_status =  USBD_Get_USB_Status(hal_status);
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       USBD_Get_USB_Status
00001e  4607              MOV      r7,r0
;;;494    
;;;495      return usb_status;
000020  4638              MOV      r0,r7
;;;496    }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;497    
                          ENDP


                          AREA ||i.USBD_LL_Start||, CODE, READONLY, ALIGN=1

                  USBD_LL_Start PROC
;;;394      */
;;;395    USBD_StatusTypeDef USBD_LL_Start(USBD_HandleTypeDef *pdev)
000000  b570              PUSH     {r4-r6,lr}
;;;396    {
000002  4604              MOV      r4,r0
;;;397      HAL_StatusTypeDef hal_status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;398      USBD_StatusTypeDef usb_status = USBD_OK;
000006  2600              MOVS     r6,#0
;;;399    
;;;400      hal_status = HAL_PCD_Start(pdev->pData);
000008  f8d402c8          LDR      r0,[r4,#0x2c8]
00000c  f7fffffe          BL       HAL_PCD_Start
000010  4605              MOV      r5,r0
;;;401    
;;;402      usb_status =  USBD_Get_USB_Status(hal_status);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       USBD_Get_USB_Status
000018  4606              MOV      r6,r0
;;;403    
;;;404      return usb_status;
00001a  4630              MOV      r0,r6
;;;405    }
00001c  bd70              POP      {r4-r6,pc}
;;;406    
                          ENDP


                          AREA ||i.USBD_LL_Stop||, CODE, READONLY, ALIGN=1

                  USBD_LL_Stop PROC
;;;411      */
;;;412    USBD_StatusTypeDef USBD_LL_Stop(USBD_HandleTypeDef *pdev)
000000  b570              PUSH     {r4-r6,lr}
;;;413    {
000002  4604              MOV      r4,r0
;;;414      HAL_StatusTypeDef hal_status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;415      USBD_StatusTypeDef usb_status = USBD_OK;
000006  2600              MOVS     r6,#0
;;;416    
;;;417      hal_status = HAL_PCD_Stop(pdev->pData);
000008  f8d402c8          LDR      r0,[r4,#0x2c8]
00000c  f7fffffe          BL       HAL_PCD_Stop
000010  4605              MOV      r5,r0
;;;418    
;;;419      usb_status =  USBD_Get_USB_Status(hal_status);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       USBD_Get_USB_Status
000018  4606              MOV      r6,r0
;;;420    
;;;421      return usb_status;
00001a  4630              MOV      r0,r6
;;;422    }
00001c  bd70              POP      {r4-r6,pc}
;;;423    
                          ENDP


                          AREA ||i.USBD_LL_Transmit||, CODE, READONLY, ALIGN=1

                  USBD_LL_Transmit PROC
;;;561      */
;;;562    USBD_StatusTypeDef USBD_LL_Transmit(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint32_t size)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;563    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;564      HAL_StatusTypeDef hal_status = HAL_OK;
00000c  f04f0800          MOV      r8,#0
;;;565      USBD_StatusTypeDef usb_status = USBD_OK;
000010  46c1              MOV      r9,r8
;;;566    
;;;567      hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
000012  463b              MOV      r3,r7
000014  4632              MOV      r2,r6
000016  4629              MOV      r1,r5
000018  f8d402c8          LDR      r0,[r4,#0x2c8]
00001c  f7fffffe          BL       HAL_PCD_EP_Transmit
000020  4680              MOV      r8,r0
;;;568    
;;;569      usb_status =  USBD_Get_USB_Status(hal_status);
000022  4640              MOV      r0,r8
000024  f7fffffe          BL       USBD_Get_USB_Status
000028  4681              MOV      r9,r0
;;;570    
;;;571      return usb_status;
00002a  4648              MOV      r0,r9
;;;572    }
00002c  e8bd87f0          POP      {r4-r10,pc}
;;;573    
                          ENDP


                          AREA ||i.USBD_static_free||, CODE, READONLY, ALIGN=1

                  USBD_static_free PROC
;;;636      */
;;;637    void USBD_static_free(void *p)
000000  4770              BX       lr
;;;638    {
;;;639    
;;;640    }
;;;641    
                          ENDP


                          AREA ||i.USBD_static_malloc||, CODE, READONLY, ALIGN=2

                  USBD_static_malloc PROC
;;;625      */
;;;626    void *USBD_static_malloc(uint32_t size)
000000  4601              MOV      r1,r0
;;;627    {
;;;628      static uint32_t mem[(sizeof(USBD_CDC_HandleTypeDef)/4)+1];/* On 32-bit boundary */
;;;629      return mem;
000002  4801              LDR      r0,|L31.8|
;;;630    }
000004  4770              BX       lr
;;;631    
                          ENDP

000006  0000              DCW      0x0000
                  |L31.8|
                          DCD      mem

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  hpcd_USB_OTG_HS
                          %        1292
                  mem
                          %        544

;*** Start embedded assembler ***

#line 1 "../USB_DEVICE/Target/usbd_conf.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_usbd_conf_c_733e821e____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___11_usbd_conf_c_733e821e____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_usbd_conf_c_733e821e____REVSH|
#line 478
|__asm___11_usbd_conf_c_733e821e____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___11_usbd_conf_c_733e821e____RRX|
#line 665
|__asm___11_usbd_conf_c_733e821e____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
